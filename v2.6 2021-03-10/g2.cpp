//best viewed with tab size of 4 spaces
//g2.cpp - Grapher 2 main implementation file.
//Copyright (C) 2012-2020  Ayman Wagih Mohsen, unless source link provided.
//
//This program is free software: you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation, either version 3 of the License, or
//(at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program.  If not, see <https://www.gnu.org/licenses/>.

//dependencies:
//AVX.lib								g2_common.h/cpp, g2_avx.h/cpp					D:\C\Grapher 2 2013\Grapher 2 2013;
//boost::math							https://www.boost.org/							D:\C\boost_1_70_0;
//Agner Fog's Vectorclass version1		https://github.com/vectorclass/version1			D:\C\Grapher 2 2010\Grapher 2\vectorclass version1-master;
//MPFR & MPFR C++						http://www.holoborodko.com/pavel/mpfr/			D:\C\! Multiprecision\Library;
//FFTW									http://www.fftw.org/
//OpenCL								https://github.com/KhronosGroup/OpenCL-Headers	D:\Android\!-Lib\OpenCL-Headers-master;

#ifdef _DEBUG
#pragma warning(push)
#pragma warning(disable:4996)
#endif
#undef UNICODE
#include	"g2_common.h"
#include	"g2_error.h"
#include	"g2_graphics.h"
#include	"g2_expr.h"
#include	"g2_cl.h"
#include	"g2_mp.h"
#include	"g2_sse2.h"
#if _MSC_VER>=1700//if VS2012 or after
#include	"g2_avx.h"//comment this out on a pre-avx compiler
#endif

#include	"fftw3.h"
#include	<ctime>
#include	<Windows.h>
#ifndef		__GNUC__
#include	<ppl.h>
#endif
#include	<list>
#include	<stack>
#include	<vector>
#include	<set>
#include	<unordered_set>
#include	<map>
#include	<unordered_map>
#include	<queue>
#include	<string>
#include	<algorithm>

	#define	BUILD_1_7
	#define	PROFILER

#ifndef	__GNUC__
#ifdef _DEBUG
#pragma warning(pop)
#endif
#pragma		comment(lib, "libfftw3-3.lib")
#ifdef AVX_H
#pragma		comment(lib, "AVX.lib")
#endif
//#pragma	comment(linker, "/STACK:16777216")//doesn't fix MPIR crash
#endif
#ifdef		__GNUC__
#include	<cpuid.h>
#define		min(a, b)	((a)<(b)?(a):(b))
#define		max(a, b)	((a)>(b)?(a):(b))
void		cpuid(int *a, int b)
{
	__get_cpuid(b, (unsigned*)a, (unsigned*)(a+1), (unsigned*)(a+2), (unsigned*)(a+3));
}
void		cpuidex(int *a, int b, int c)
{
	a[0]=a[1]=a[2]=a[3]=0;
}
#else
#define		cpuid		__cpuid
#define		cpuidex		__cpuidex
#endif

double inv_sqrt(double x)//http://stackoverflow.com/questions/11513344/how-to-implement-the-fast-inverse-square-root-in-java
{
	double t0;
	(long long&)t0=0x5FE6EC85E7DE30DA-((long long&)x>>1);
	return t0*(1.5-.5*x*t0*t0);
}
//int floor_log2(unsigned n)
//{
//	int logn=0;
//	int sh=(n>=1<<16)<<4;	logn+=sh, n>>=sh;
//		sh=(n>=1<< 8)<<3;	logn+=sh, n>>=sh;
//		sh=(n>=1<< 4)<<2;	logn+=sh, n>>=sh;
//		sh=(n>=1<< 2)<<1;	logn+=sh, n>>=sh;
//		sh= n>=1<< 1;		logn+=sh;
//	//int sh=((n&0xFFFF0000)!=0)<<4;	logn+=sh, n>>=sh;
//	//	sh=((n&0x0000FF00)!=0)<<3;	logn+=sh, n>>=sh;
//	//	sh=((n&0x000000F0)!=0)<<2;	logn+=sh, n>>=sh;
//	//	sh=((n&0x0000000C)!=0)<<1;	logn+=sh, n>>=sh;
//	//	sh=((n&0x00000002)!=0);		logn+=sh;
//	return logn;
//}
int floor_log2(unsigned long long n)
{
	int logn=0;
	int sh=(n>=1ULL<<32)<<5;logn+=sh, n>>=sh;
		sh=(n>=1<<16)<<4;	logn+=sh, n>>=sh;
		sh=(n>=1<< 8)<<3;	logn+=sh, n>>=sh;
		sh=(n>=1<< 4)<<2;	logn+=sh, n>>=sh;
		sh=(n>=1<< 2)<<1;	logn+=sh, n>>=sh;
		sh= n>=1<< 1;		logn+=sh;
	return logn;
}
int floor_log10(double x)
{
	if(x<=0)
		return 0x80000000;
	static const double pmask[]=//positive powers
	{
		1, 10,		//10^2^0
		1, 100,		//10^2^1
		1, 1e4,		//10^2^2
		1, 1e8,		//10^2^3
		1, 1e16,	//10^2^4
		1, 1e32,	//10^2^5
		1, 1e64,	//10^2^6
		1, 1e128,	//10^2^7
		1, 1e256	//10^2^8
	};
	static const double nmask[]=//negative powers
	{
		1, 0.1,		//1/10^2^0
		1, 0.01,	//1/10^2^1
		1, 1e-4,	//1/10^2^2
		1, 1e-8,	//1/10^2^3
		1, 1e-16,	//1/10^2^4
		1, 1e-32,	//1/10^2^5
		1, 1e-64,	//1/10^2^6
		1, 1e-128,	//1/10^2^7
		1, 1e-256	//1/10^2^8
	};
	if(x>=1)
	{
		int logn=0;
		int sh=(x>=pmask[17])<<8;	logn+=sh, x*=nmask[16+(sh!=0)];
		sh=(x>=pmask[15])<<7;		logn+=sh, x*=nmask[14+(sh!=0)];
		sh=(x>=pmask[13])<<6;		logn+=sh, x*=nmask[12+(sh!=0)];
		sh=(x>=pmask[11])<<5;		logn+=sh, x*=nmask[10+(sh!=0)];
		sh=(x>=pmask[9])<<4;		logn+=sh, x*=nmask[8+(sh!=0)];
		sh=(x>=pmask[7])<<3;		logn+=sh, x*=nmask[6+(sh!=0)];
		sh=(x>=pmask[5])<<2;		logn+=sh, x*=nmask[4+(sh!=0)];
		sh=(x>=pmask[3])<<1;		logn+=sh, x*=nmask[2+(sh!=0)];
		sh= x>=pmask[1];			logn+=sh;
		return logn;
	}
	int logn=-1;
	int sh=(x<nmask[17])<<8;	logn-=sh;	x*=pmask[16+(sh!=0)];
	sh=(x<nmask[15])<<7;		logn-=sh;	x*=pmask[14+(sh!=0)];
	sh=(x<nmask[13])<<6;		logn-=sh;	x*=pmask[12+(sh!=0)];
	sh=(x<nmask[11])<<5;		logn-=sh;	x*=pmask[10+(sh!=0)];
	sh=(x<nmask[9])<<4;			logn-=sh;	x*=pmask[8+(sh!=0)];
	sh=(x<nmask[7])<<3;			logn-=sh;	x*=pmask[6+(sh!=0)];
	sh=(x<nmask[5])<<2;			logn-=sh;	x*=pmask[4+(sh!=0)];
	sh=(x<nmask[3])<<1;			logn-=sh;	x*=pmask[2+(sh!=0)];
	sh= x<nmask[1];				logn-=sh;
	return logn;
}
double power(double x, int y)
{
	double mask[]={1, 0}, product=1;
	if(y<0)
		mask[1]=1/x, y=-y;
	else
		mask[1]=x;
	for(;;)
	{
		product*=mask[y&1], y>>=1;	//67.7
		if(!y)
			return product;
		mask[1]*=mask[1];
	}
	return product;
}
double _10pow(int n)
{
	static double *mask=0;
	if(!mask)
	{
		const double _ln10=log(10.);
		mask=new double[616];
		for(int k=-308;k<308;++k)		//23.0
			mask[k+308]=power(10., k);
		//	mask[k+308]=exp(k*_ln10);//inaccurate
	}
	if(n<-308)
		return 0;
	if(n>307)
		return _HUGE;
	return mask[n+308];
}
inline double _10pow(double x){return exp(x*G2::_ln10);}
inline int			conditional_negate(int x, bool flag){return (x^-(int)flag)+flag;}
inline double		clamp_positive(double x){return (x+abs(x))*0.5;}
inline long long	clamp_positive_ll(double x){return (long long)((x+abs(x))*0.5);}
inline int			clamp_negative(int x){return (x-abs(x))>>1;}
inline double		minimum(double a, double b){return (a+b-abs(a-b))*0.5;}//is this really faster than single branch?
inline void			minmax8a(double *a, double *lo_hi)//{minimum, maximum} of 8 values, aligned
{
	__m128d v0=_mm_load_pd(a), v1=_mm_load_pd(a+2), v2=_mm_load_pd(a+4), v3=_mm_load_pd(a+6);
	__m128d
		min0=_mm_min_pd(v0, v1), max0=_mm_max_pd(v0, v1),			//12.06
		min1=_mm_min_pd(v2, v3), max1=_mm_max_pd(v2, v3),
		min2=_mm_min_pd(min0, min1), max2=_mm_max_pd(max0, max1);
	__m128d
		t0=_mm_shuffle_pd(min2, max2, 0),//{max[0], min[0]}	//{hiqword, loqword}
		t1=_mm_shuffle_pd(min2, max2, 3);//{max[1], min[1]}
	__m128d t_min=_mm_min_pd(t0, t1), t_max=_mm_max_pd(t0, t1),
		t_minmax=_mm_shuffle_pd(t_min, t_max, 2);
	_mm_store_pd(lo_hi, t_minmax);

/*	double lo0, lo1, lo2, lo3, hi0, hi1, hi2, hi3;
	if(a[0]<a[1])
		lo0=a[0], hi0=a[1];
	else
		lo0=a[1], hi0=a[0];
	if(a[2]<a[3])
		lo1=a[2], hi1=a[3];
	else
		lo1=a[3], hi1=a[2];
	if(a[4]<a[5])
		lo2=a[4], hi2=a[5];
	else
		lo2=a[5], hi2=a[4];
	if(a[6]<a[7])
		lo3=a[6], hi3=a[7];
	else
		lo3=a[7], hi3=a[6];
	lo=lo0;
	if(lo>lo1)
		lo=lo1;
	if(lo>lo2)
		lo=lo2;
	if(lo>lo3)
		lo=lo3;
	hi=hi0;
	if(hi>hi1)
		hi=hi1;
	if(hi>hi2)
		hi=hi2;
	if(hi>hi3)
		hi=hi3;//*/

	//double
	//	sum0=a[0]+a[1], diff0=abs(a[0]-a[1]),
	//	sum1=a[2]+a[3], diff1=abs(a[2]-a[3]),
	//	sum2=a[4]+a[5], diff2=abs(a[4]-a[5]),
	//	sum3=a[6]+a[7], diff3=abs(a[6]-a[7]);
	//double
	//	mi0=sum0-diff0, ma0=sum0+diff0,
	//	mi1=sum1-diff1, ma1=sum1+diff1,
	//	mi2=sum2-diff2, ma2=sum2+diff2,
	//	mi3=sum3-diff3, ma3=sum3+diff3;
	//double
	//	mia=mi0+mi1-abs(mi0-mi1), maa=ma0+ma1+abs(ma0-ma1),
	//	mib=mi2+mi3-abs(mi2-mi3), mab=ma2+ma3+abs(ma2-ma3);
	//lo=(mia+mib-abs(mia-mib))*0.125;
	//hi=(maa+mab+abs(maa-mab))*0.125;
}
void				minmax_naive(double *a, int size, double *result)//find {min, max} values, size>0
{
	result[0]=a[0], result[1]=a[0];		//3.055 c/v on R7 2700
	for(int k=1;k<size;++k)	//5.189, 7.425 cycles/value
	{
		if(result[0]>a[k])//min
			result[0]=a[k];
		if(result[1]<a[k])//max
			result[1]=a[k];
	}
}
void				minmax_ia32(double *a, int size, double *result)//{min, max}, even size, depreciated: use minmax_sse2
{
	auto &lo=result[0], &hi=result[1];
	if(a[0]<a[1])
		lo=a[0], hi=a[1];
	else
		lo=a[1], hi=a[0];
	for(int k=2;k+1<size;k+=2)//https://stackoverflow.com/questions/424800/what-is-the-best-way-to-get-the-minimum-or-maximum-value-from-an-array-of-number
	{
		if(a[k]<a[k+1])		//4.343	7.535 cycles/value
		{
			if(lo>a[k])
				lo=a[k];
			if(hi<a[k+1])
				hi=a[k+1];
		}
		else
		{
			if(lo>a[k+1])
				lo=a[k+1];
			if(hi<a[k])
				hi=a[k];
		}
	}
}
inline double		clamp(double lo, double x, double hi)
{
	hi+=hi;
	double temp=x+lo+abs(x-lo);
	return (temp+hi-abs(temp-hi))*0.25;
}
inline int			clamp(int lo, int x, int hi)
{
	hi<<=1;
	int temp=x+lo+abs(x-lo);
	return (temp+hi-abs(temp-hi))>>2;
}
void		render();
bool		_2d_drag_graph_not_window=false, _dangerous_code=false, _3d_stretch_move_cam=true, _3d_shift_move_cam=false, _3d_zoom_move_cam=false;
bool		commasInNumbers=false, commentIncompleteScope=true, nestedComments=false, colorComments=false, SSE4_1=false;
bool		fullscreen=false, showBenchmark=false, showLastModeOnIdle=true, function_timeout=true, contextHelp=false;
int			test_contourMethod=1;
int			oldMouse, cursorB, cursorEx, prevCursorEx=0;
double		logscale_factor=0.1;//0.1 0.2 1
enum		{ARCH_IA32, ARCH_MMX, ARCH_SSE, ARCH_SSE2, ARCH_SSE3, ARCH_SSE3S, ARCH_SSE4_1, ARCH_SSE4_2, ARCH_AVX, ARCH_AVX2};
int			supported_simd_arch=ARCH_IA32,
			max_simd_method=0, simd_method=0;//0: ia32, 1: sse2, 2: avx
std::string	CPUBrand;
RECT		oldWindowSize;
char		kb[256]={0}, caps_lock, num_lock;
tagPOINT	centerP, mouseP0;
tagRECT		R;
HWND__		*ghWnd=nullptr;
HINSTANCE	ghInstance=nullptr;
HDC__		*ghDC=nullptr;
Bitmap		gBitmap;
//int		*rgb=nullptr;
int			*modeRGB=nullptr;
void		minmax(double *a, int size, double *result)
{
#ifdef AVX_H
	if(simd_method>=2)
		minmax_avx(a, size, result);
	else
#endif
	if(simd_method>=1)
		minmax_sse2(a, size, result);
	else
		minmax_ia32(a, size, result);
}
void		user_trigered_seed()
{
	LARGE_INTEGER li;
	QueryPerformanceCounter(&li);
	srand(li.LowPart);
}

std::vector<Expression> expr(1), userFunctionDefinitions(1);

void bitmap_to_clipboard(int *rgb, int Xplaces, int Yplaces)
{
	std::stringstream LOL_1;
	LOL_1<<std::hex;
	for(int ky=0;ky<Yplaces;++ky)
	{
		for(int kx=0;kx<Xplaces;++kx)
		{
			int idx=Xplaces*ky+kx;
			auto p=(unsigned char*)(rgb+idx);
			LOL_1<<std::setfill('0')<<std::setw(2)<<(int)p[0]<<std::setfill('0')<<std::setw(2)<<(int)p[1]<<std::setfill('0')<<std::setw(2)<<(int)p[2]<<"  ";
		//	LOL_1<<(int)p[0]<<' '<<(int)p[1]<<' '<<(int)p[2]<<"   ";
		}
		LOL_1<<"\r\n";
	}
	copy_to_clipboard(LOL_1.str());
}
void ndr_to_clipboard_1d(Expression &ex, int Xplaces)
{
	std::stringstream LOL_1;
	for(int k=0;k<Xplaces;++k)
	{
		for(unsigned kn=0;kn<ex.n.size();++kn)
		{
			auto &n=ex.n[kn];
			LOL_1<<((double*)n.r.p)[k];
			if(n.i.size()==Xplaces)
				LOL_1<<'+'<<((double*)n.i.p)[k]<<'i';
			if(n.j.size()==Xplaces)
				LOL_1<<'+'<<((double*)n.j.p)[k]<<'j';
			if(n.k.size()==Xplaces)
				LOL_1<<'+'<<((double*)n.k.p)[k]<<'k';
			LOL_1<<'\t';
		}
		LOL_1<<"\r\n";
	}
	copy_to_clipboard(LOL_1.str());
}
void ndr_to_clipboard_2d(double *ndr, int Xplaces, int Yplaces)
{
	std::stringstream LOL_1;
	LOL_1<<std::fixed<<std::setprecision(2);
	for(int ky=0;ky<Yplaces;++ky)
	{
		for(int kx=0;kx<Xplaces;++kx)
			LOL_1<<ndr[Xplaces*ky+kx]<<'\t';
		LOL_1<<"\r\n";
	}
	copy_to_clipboard(LOL_1.str());
}
void ndr_to_clipboard_2d(Expression &ex, int Xplaces, int Yplaces)
{
	std::stringstream LOL_1;
	int ndrSize=Xplaces*Yplaces;
	for(int ky=0;ky<Yplaces;++ky)//printing all NDRs in one rectangle is better
	{
		for(int kx=0;kx<Xplaces;++kx)
		{
			int idx=Xplaces*ky+kx;
			for(unsigned kn=0;kn<ex.n.size();++kn)
			{
				auto &n=ex.n[kn];
				LOL_1<<((double*)n.r.p)[idx];
				if(n.i.size()==ndrSize)
					LOL_1<<'+'<<((double*)n.i.p)[idx]<<'i';
				if(n.j.size()==ndrSize)
					LOL_1<<'+'<<((double*)n.j.p)[idx]<<'j';
				if(n.k.size()==ndrSize)
					LOL_1<<'+'<<((double*)n.k.p)[idx]<<'k';
				LOL_1<<'\t';
			}
			LOL_1<<'\t';
		}
		LOL_1<<"\r\n";
	}
	//for(unsigned kn=0;kn<ex.n.size();++kn)
	//{
	//	auto &n=ex.n[kn];
	//	for(int ky=0;ky<Yplaces;++ky)
	//	{
	//		for(int kx=0;kx<Xplaces;++kx)
	//		{
	//			int idx=Xplaces*ky+kx;
	//			LOL_1<<((double*)n.r.p)[idx];
	//			if(n.i.size()==ndrSize)
	//				LOL_1<<'+'<<((double*)n.i.p)[idx]<<'i';
	//			if(n.j.size()==ndrSize)
	//				LOL_1<<'+'<<((double*)n.j.p)[idx]<<'j';
	//			if(n.k.size()==ndrSize)
	//				LOL_1<<'+'<<((double*)n.k.p)[idx]<<'k';
	//			LOL_1<<'\t';
	//		}
	//		LOL_1<<"\r\n";
	//	}
	//	LOL_1<<"\r\n";
	//}
	copy_to_clipboard(LOL_1.str());
}
void ndr_to_clipboard_1d(Term &n, int component, int Xplaces)
{
	auto ndr_r=(double*)(&n.r)[component].p;
	std::stringstream LOL_1;
	for(int k=0;k<Xplaces;++k)
		LOL_1<<ndr_r[k]<<"\r\n";
	copy_to_clipboard(LOL_1.str());
}
void ndr_to_clipboard_l2d(Term &n, int Xplaces, int nX, int Yplaces, int nY)
{
	auto ndr_r=(double*)n.r.p, ndr_i=(double*)n.i.p;
	std::stringstream LOL_1;
	for(int ky=0;ky<nX;++ky)
	{
		for(int kx=0;kx<Xplaces;++kx)
		{
			int idx=Xplaces*ky+kx;
			LOL_1<<ndr_r[idx]<<'+'<<ndr_i[idx]<<"i, ";
		}
		LOL_1<<'\n';
	}
	LOL_1<<'\n';
	int yoffset=Xplaces*nX;
	for(int ky=0;ky<Yplaces;++ky)
	{
		for(int kx=0;kx<nY;++kx)
		{
			int idx=yoffset+Yplaces*kx+ky;
			LOL_1<<ndr_r[idx]<<'+'<<ndr_i[idx]<<"i, ";
		}
		LOL_1<<'\n';
	}
	copy_to_clipboard(LOL_1.str());
}
void ndr_to_clipboard_3d(double *ndr, int Xplaces, int Yplaces, int Zplaces)
{
	std::stringstream LOL_1;
	for(int kz=0;kz<Zplaces;++kz)
	{
		for(int ky=0;ky<Yplaces;++ky)
		{
			for(int kx=0;kx<Xplaces;++kx)
			{
				int idx=Xplaces*(Yplaces*kz+ky)+kx;
				LOL_1<<ndr[idx]<<'\t';
			}
			LOL_1<<"\r\n";
		}
		LOL_1<<"\r\n";
	}
	copy_to_clipboard(LOL_1.str());
}
void vbo_to_clipboard(vec3 const *vn, int vcount, int const *indices, int icount, int ishr=1)
{
	std::stringstream LOL_1;
	LOL_1<<"vertex\t\tcoords\t\tnormal\r\n";
	for(int k=0;k<vcount;k+=2)
	{
		auto &vk=vn[k], &nk=vn[k+1];
		LOL_1<<(k>>1)<<":\t"<<vk.x<<",\t"<<vk.y<<",\t"<<vk.z<<";\t\t\t"<<nk.x<<",\t"<<nk.y<<",\t"<<nk.z<<"\r\n";
	//	LOL_1<<(k>>1)<<":\t"<<vk.x<<", "<<vk.y<<", "<<vk.z<<";\t\t\t"<<nk.x<<", "<<nk.y<<", "<<nk.z<<"\r\n";
	}
	LOL_1<<"\r\ntriangle\t\tvertex indices\r\n";
	for(int k=0;k<icount;k+=3)
		LOL_1<<k/3<<":\t"<<(indices[k]>>ishr)<<", "<<(indices[k+1]>>ishr)<<", "<<(indices[k+2]>>ishr)<<"\r\n";
	copy_to_clipboard(LOL_1.str());
}

struct NameTreeNode
{
	bool success;//subsequence support
	int name_id;
	NameTreeNode *nextChar[128];
	std::vector<char> children;
//	NameTreeNode():success(false), nextChar{}{}//warning C4351: new behavior: default initialization	inspect your code
	NameTreeNode():success(false)
	{
		for(int k=0;k<128;++k)
			nextChar[k]=nullptr;
	}
	void allocate_leaky(char c)
	{
		nextChar[c]=new NameTreeNode;
		children.push_back(c);
	}
	void allocate(char c)
	{
		if(!nextChar[c])
		{
			nextChar[c]=new NameTreeNode;
			children.push_back(c);
		}
	}
	void free(char c)
	{
		delete nextChar[c];
		nextChar[c]=nullptr;
		for(int k=0, kEnd=children.size();k<kEnd;++k)
		{
			if(children[k]==c)
			{
				children.erase(children.begin()+k);
				break;
			}
		}
	}
	~NameTreeNode()
	{
		for(unsigned k=0;k<children.size();++k)
			delete nextChar[children[k]];
	}
};
class NameTree
{
	NameTreeNode userFunctionNamesRoot;
	int name_id_counter;
public:
	NameTree():name_id_counter(0){}
//	NameTree():name_id_counter(G2::M_USER_FUNCTION_START){}
	NameTreeNode* matchName_free(char *text, int i, int kEnd, int &nameEnd)//free match		inline
	{
		auto node=userFunctionNamesRoot.nextChar[text[i]];
		for(int ch=i+1;node;++ch)
		{
			if(node->success)
			{
				nameEnd=ch;
				return node;
			}
			if(ch==kEnd)
				break;
			node=node->nextChar[text[ch]];
		}
		return nullptr;
	}
	NameTreeNode* matchName		(char *text, int i, int f, int &nameEnd)//bounded match
	{
		auto node=userFunctionNamesRoot.nextChar[text[i]];
		for(int ch=i+1;node;++ch)
		{
			if(ch==f)
			{
				if(node->success)
				{
					nameEnd=ch;
					return node;
				}
				break;
			}
			node=node->nextChar[text[ch]];
		}
		return nullptr;
	}
	NameTreeNode* addName		(char *text, int i, int f)
	{
		int len=f-i;
		const char *keywords[]={"break", "continue", "do", "else", "for", "goto", "if", "return", "switch", "while"};//exact match
		const int nkw=sizeof(keywords)/sizeof(*keywords);
		for(int k=0;k<nkw;++k)
			if(!strcmp(text+i, keywords[k]))
				return nullptr;
		//if(		text[i+0]=='b'&&text[i+1]=='r'&&text[i+2]=='e'&&text[i+3]=='a'&&text[i+4]=='k'//X  what if function mane starts with 'if'?
		//	||	text[i+0]=='c'&&text[i+1]=='o'&&text[i+2]=='n'&&text[i+3]=='t'&&text[i+4]=='i'&&text[i+5]=='n'&&text[i+6]=='u'&&text[i+7]=='e'
		//	||	text[i+0]=='d'&&text[i+1]=='o'
		//	||	text[i+0]=='e'&&text[i+1]=='l'&&text[i+2]=='s'&&text[i+3]=='e'
		//	||	text[i+0]=='f'&&text[i+1]=='o'&&text[i+2]=='r'
		//	||	text[i+0]=='g'&&text[i+1]=='o'&&text[i+2]=='t'&&text[i+3]=='o'
		//	||	text[i+0]=='i'&&text[i+1]=='f'
		//	||	text[i+0]=='r'&&text[i+1]=='e'&&text[i+2]=='t'&&text[i+3]=='u'&&text[i+4]=='r'&&text[i+5]=='n'
		//	||	text[i+0]=='s'&&text[i+1]=='w'&&text[i+2]=='i'&&text[i+3]=='t'&&text[i+4]=='c'&&text[i+5]=='h'
		//	||	text[i+0]=='w'&&text[i+1]=='h'&&text[i+2]=='i'&&text[i+3]=='l'&&text[i+4]=='e')
		//	return nullptr;

		auto node=&userFunctionNamesRoot;
		for(int k2=i;;++k2)
		{
			if(k2==f)//subsequence
			{
				if(!node->success)
					node->success=true, node->name_id=name_id_counter++;
				return node;
			}
			auto next=node->nextChar[text[k2]];
			if(next)
				node=next;
			else
			{
				for(;k2<f;++k2)
				{
					node->allocate_leaky(text[k2]);
					node=node->nextChar[text[k2]];
				}
				node->success=true, node->name_id=name_id_counter++;
				return node;
			}
		}
		return nullptr;
	}
	void removeName				(char *text, int i, int f)
	{
		auto node=userFunctionNamesRoot.nextChar[text[i]];
		std::stack<std::pair<NameTreeNode*, int>> depth;//parentNode, child char
	//	depth.push(std::pair<NameTreeNode*, int>(node, text[i]));
		for(int ch=i+1;node;++ch)//find
		{
			if(ch==f)//found, remove
			{
				if(node->children.size())//remove subsequence
					node->success=false;
				else//remove pillar sequence
				{
					for(;depth.size()&&depth.top().first->children.size()==1&&!depth.top().first->success;)//seek start of free branch
						depth.pop();
					if(depth.size())//remove child & pillar branch
						depth.top().first->free(depth.top().second);
					else//remove last entry
						userFunctionNamesRoot.free(userFunctionNamesRoot.children[0]);
				}
				break;
			}
			depth.push(std::pair<NameTreeNode*, int>(node, text[ch]));
			node=node->nextChar[text[ch]];
		}
	}
	void cleanTree()
	{
		if(userFunctionNamesRoot.children.size())
		{
			auto ufdBegin=userFunctionDefinitions.begin(), ufdEnd=userFunctionDefinitions.end();
			auto node=userFunctionNamesRoot.nextChar[userFunctionNamesRoot.children[0]];
			std::vector<std::pair<NameTreeNode*, int>> depth(1, std::pair<NameTreeNode*, int>(&userFunctionNamesRoot, 0));//stack: &pauseParentNode, pauseChildNo
			for(int br=0;;)
			{
				if(node->success&&std::find_if(ufdBegin, ufdEnd, [&](Expression const &def){return def.name_id==node->name_id;})==ufdEnd)//unused name, remove
				{
					if(node->children.size())//remove subsequence
						node->success=false;
					else//remove pillar sequence
					{
						for(;depth.size()&&depth.rbegin()->first->children.size()==1&&!depth.rbegin()->first->success;)//seek start of free branch
							depth.pop_back();
						if(depth.size())
						{
							auto parent=depth.rbegin()->first;
							parent->free(depth.rbegin()->second);//remove pillar branch
							if(depth.rbegin()->second==parent->children.size())//no next child, find from parents above
							{
								depth.pop_back();
								for(;depth.size()&&depth.rbegin()->second==depth.rbegin()->first->children.size()-1;)//if parent branches exhausted pop and repeat
									depth.pop_back();
								if(depth.size())
									br=++depth.rbegin()->second, node=parent->nextChar[parent->children[br]];
								else//scan finish
									break;
							}
							else//next child is where goner was
								br=depth.rbegin()->second, node=parent->nextChar[parent->children[br]];
						}
						else//remove last entry
						{
							userFunctionNamesRoot.free(userFunctionNamesRoot.children[0]);
							break;
						}
					}
				}
				if(br==depth.rbegin()->first->children.size())//branches exhausted
				{
					for(;depth.size()&&depth.rbegin()->second==depth.rbegin()->first->children.size()-1;)//if parent branches exhausted pop and repeat
						depth.pop_back();
					if(depth.size())//if parents left goto next child
					{
						auto parent=depth.rbegin()->first;
						br=++depth.rbegin()->second, node=parent->nextChar[parent->children[br]];
					}
					else//root exhausted
						break;
				}
				else
				{
					depth.push_back(std::pair<NameTreeNode*, int>(node, br));
					node=node->nextChar[node->children[br]];
				}
			}
		}
	}
} userFunctionNames;

int lineChangeStart=-1, lineRemoveEnd=-1, lineInsertEnd=-1, nLines=1;
int boundChangeStart=-1, boundRemoveEnd=-1, boundInsertEnd=-1;
int exprChangeStart=-1, exprRemoveEnd=-1, exprInsertEnd=-1;
int functionChangeStart=-1, functionRemoveEnd=-1, functionInsertEnd=-1;
typedef std::pair<int, char> Bound;
std::vector<Bound> bounds(1, Bound(0, 'c'));//e expression, f function, c clear/empty
//std::vector<std::pair<int, char>> bounds(1, std::pair<int, char>(0, 'e'));
typedef std::pair<int, int> CommentBound;
std::vector<CommentBound> allComments;
struct BoundCounter
{
	int idx,
		kc,//next comment
		start, end;
	BoundCounter(int idx, int kc, int textlen):idx(idx), kc(kc), start(kc?allComments[kc-1].second:0), end(kc<(int)allComments.size()?allComments[kc].first:textlen){}
	void skip_comments(int textlen)
	{
		if(idx>=end&&kc<(int)allComments.size())//jump forward over comment kc
		{
			start=idx=allComments[kc].second;//end of next comment
			++kc;
			if(kc<(int)allComments.size())
				end=allComments[kc].first;//start of after-next comment
			else
				end=textlen;
		}
	}
	void rskip_comments()
	{
		if(idx<start&&kc>0)//kc>0 implies there are comments		jump backwards over comment kc-1
		{
			--kc;
			end=allComments[kc].first;//start of next comment
			idx=end-1;
			if(kc>0)
				start=allComments[kc-1].second;//end of previous comment
			else
				start=0;
		}
	}
	void inc(int textlen)//don't use inc() or dec() when skipping identifier
	{
		++idx;
		skip_comments(textlen);
	}
	void dec()
	{
		--idx;
		rskip_comments();
	}
};
char skip_whitespace(const char *text, BoundCounter &k, int textlen)
{
	for(;k.idx<textlen&&text[k.idx]==' '||text[k.idx]=='\t'||text[k.idx]=='\r'||text[k.idx]=='\n';k.inc(textlen));
	return k.idx>=textlen;
}
char skip_char_ifmatch(const char *text, BoundCounter &k, int textlen, char c)
{
	char match=text[k.idx]==c;
	k.idx+=match;
	k.skip_comments(textlen);
	return match<<1|(k.idx>=textlen);//on match: k points after c or OOB
}
char skip_char_ifmatch(const char *text, BoundCounter &k, int textlen, const char *cs, char *c_matched_ret=nullptr)
{
	char match=false;
	for(int k2=0;cs[k2];++k2)
	{
		if(text[k.idx]==cs[k2])
		{
			match=true;
			if(c_matched_ret)
				*c_matched_ret=cs[k2];
			break;
		}
	}
	k.idx+=match;
	k.skip_comments(textlen);
	return match<<1|(k.idx>=textlen);//on match: k points after c or OOB
}
char skip_identifier_ifmatch(const char *text, BoundCounter &k, int textlen)
{
	if(text[k.idx]>='a'&&text[k.idx]<='z'||text[k.idx]>='A'&&text[k.idx]<='Z'||text[k.idx]=='_')
	{
		for(;k.idx>=0&&(text[k.idx]>='a'&&text[k.idx]<='z'||text[k.idx]>='A'&&text[k.idx]<='Z'||text[k.idx]=='_'||text[k.idx]>='0'&&text[k.idx]<='9');++k.idx);
		return 2|int(k.idx>=textlen);
	}
	return k.idx>=textlen;
}
char rskip_whitespace(const char *text, BoundCounter &k, int textlen)
{
	for(;k.idx>=0&&text[k.idx]==' '||text[k.idx]=='\t'||text[k.idx]=='\r'||text[k.idx]=='\n';k.dec());
	return k.idx<0;//k points at first non-whitespace or OOB
}
//enum{RSKIP_OOB_BIT=0, RSKIP_MATCH_BIT=1};
char rskip_char_ifmatch(const char *text, BoundCounter &k, int textlen, char c)//called after rskip_whitespace
{
	char match=text[k.idx]==c;
	k.idx-=match;
	k.rskip_comments();
	return match<<1|(k.idx<0);//on match: k points at before c or OOB
}
char rskip_char_ifmatch(const char *text, BoundCounter &k, int textlen, const char *cs, char *c_matched_ret=nullptr)
{
	char match=false;
	for(int k2=0;cs[k2];++k2)
	{
		if(text[k.idx]==cs[k2])
		{
			match=true;
			if(c_matched_ret)
				*c_matched_ret=cs[k2];
			break;
		}
	}
	k.idx-=match;
	k.rskip_comments();
	return match<<1|(k.idx<0);//on match: k points at before matched char
}
char rskip_identifier(const char *text, BoundCounter &k, int textlen)
{
	for(;k.idx>=0&&(text[k.idx]>='a'&&text[k.idx]<='z'||text[k.idx]>='A'&&text[k.idx]<='Z'||text[k.idx]>='0'&&text[k.idx]<='9'||text[k.idx]=='_');--k.idx);
	int idx2=k.idx+(k.idx+1<textlen);//idx2 points at start of identifier
	char match=text[idx2]>='a'&&text[idx2]<='z'||text[idx2]>='A'&&text[idx2]<='Z';
	k.rskip_comments();
	return match<<1|(k.idx<0);
}

struct		Performance
{
	static int nCalls, odd;
	static long long freq, nticks;
	static _LARGE_INTEGER li;
	static double best;
	Performance(){QueryPerformanceCounter(&li);}
	Performance(int x, int y)
	{
		nCalls++;
		QueryPerformanceFrequency(&li);
		freq=li.QuadPart;
		QueryPerformanceCounter(&li);
		double current=1000.*(li.QuadPart-nticks)/freq;
		if(nCalls==200)
			best=current, nCalls=0, odd=!odd;
		else if(current<best)
			best=current;
		int bkMode=getBkMode();
	//	int bkMode=GetBkMode(ghMemDC);
		setBkMode(OPAQUE);
	//	SetBkMode(ghMemDC, OPAQUE);
	//	const char *hwacc=usingOpenGL?"OpenGL":"Software";
		GUIPrint
		(
			x, y, "%s%.2fbest%s, %.2ffps, %d, %s, %s",
		//	x, y, odd?"[%.10fbest], %.10ffps, %d, %s, %s":"%.10fbest, %.10ffps, %d, %s, %s",
			odd?"[":"",
			1000/best,
			odd?"]":"",
			1000/current,
			nCalls,
			simd_method==2?"AVX":simd_method==1?"SSE2":"IA32",
			usingOpenGL==MODE_CL_GL_INTEROP?"CL-GL interop.":usingOpenGL?"OpenGL":"Software"
		//	usingOpenGL?"OpenGL":"Software"
		);
		//GUIPrint(x, y, odd?"[%.10fbest], %.10ffps, %d, %s, %s":"%.10fbest, %.10ffps, %d, %s, %s",
		//	1000/best,
		//	1000/current,
		//	nCalls,
		//	simd_method==2?"AVX":simd_method==1?"SSE2":"IA32",
		//	usingOpenGL?"OpenGL":"Software");
	//	GUIPrint(x, y-16, "hwacc = 0x%08X", (int)hwacc);//
	//	GUIPrint(x, y-16, "usingOpenGL = %d", (int)usingOpenGL);//
	//	GUIPrint(x, y, odd?"[%.10fbest], %.10ffps, %d, %s, OpenGL":"%.10fbest, %.10ffps, %d, %s, OpenGL", 1000/best, 1000/current, nCalls, simd_method==2?"AVX":simd_method==1?"SSE2":"IA32");
	//	GUIPrint(ghMemDC, x, y, odd?"[%.10fbest], %.10ffps, %d, %s":"%.10fbest, %.10ffps, %d, %s", 1000/best, 1000/current, nCalls, simd_method==2?"AVX":simd_method==1?"SSE2":"IA32");
		//GUIPrint(ghMemDC, x, y, odd?"[%.10fbest], %.10fms, %d, %s":"%.10fbest, %.10fms, %d, %s", best, current, nCalls, simd_method==2?"AVX":simd_method==1?"SSE2":"IA32");
#ifdef PROFILER
		prof_print();
#endif
		setBkMode(bkMode);
	//	SetBkMode(ghMemDC, bkMode);
		nticks=li.QuadPart;
	}
};
int				Performance::nCalls=0, Performance::odd=0;
long long		Performance::freq, Performance::nticks;
_LARGE_INTEGER	Performance::li;
double			Performance::best=_HUGE;

template<int buffer_size>void print_value(Term &n, int idx, char (&buffer)[buffer_size], int &offset, int mathSet, int base=10)
{
	switch(mathSet)
	{
	case 'R':
		if(!printValue_real(buffer, offset, ((double*)n.r.p)[idx], base))
			offset+=sprintf_s(buffer+offset, buffer_size-offset, "0");
		break;
	case 'c':
		{
			bool written=printValue_real(buffer, offset, ((double*)n.r.p)[idx], base);
			printValue_unreal(written, buffer, offset, ((double*)n.i.p)[idx], "i", base);
			if(!written)
				offset+=sprintf_s(buffer+offset, buffer_size-offset, "0");
		}
		break;
	case 'h':
		{
			bool written=printValue_real(buffer, offset, ((double*)n.r.p)[idx], base);
			printValue_unreal(written, buffer, offset, ((double*)n.i.p)[idx], "i", base);
			printValue_unreal(written, buffer, offset, ((double*)n.j.p)[idx], "j", base);
			printValue_unreal(written, buffer, offset, ((double*)n.k.p)[idx], "k", base);
			if(!written)
				offset+=sprintf_s(buffer+offset, buffer_size-offset, "0");
		}
		break;
	}
}
int			find_mode(const int *modes, int nmodes, int mode)
{
	for(int km2=0;km2<nmodes;++km2)
		if(modes[km2]==mode)
			return km2;
	return -1;
}
class		TextBox
{
protected:
	int bpx, bpy, bw, bh;
	int mouseTextSel, mouseTextScrollX, mouseTextScrollY;
	Region rgn;
	char mapChar(char c)
	{
		return
			 c>='0'&&c<='9'||c=='.'?							'0'
			:c=='\''||c>='A'&&c<='Z'||c>='a'&&c<='z'||c=='_'?	'a'
			:c==' '||c=='\t'?									' '
			:c=='\r'||c=='\n'?									'\r'
			:													c;
	}
	void cursorAtMouse(int x, int y);
	int toTeleportCursor;
	void cursorTeleport();
public:
	char *text;
	int textlen, cursor, selcur;
	bool active;
	int tpx, tpy, tw, th;
	TextBox(bool active);
	void changeFont(double A);
	void setDimensions(int x, int y, int w, int h);
	int private_clickRegion(short x, short y)//
	{
		if(tw>w)
		{
			if(th>h)//horizontal & vertical scrolling
			{
				if(y>=0)
				{
					if(y<17)
					{
						if(x>=bw-17&&x<bw)//	[^]
						{
							tpy=tpy-fontH<0?0:tpy-fontH;
							return 1;
						}
					}
					else if(y<bh-34)
					{
						if(x>=bw-17&&x<bw)//	|
						{
							mouseTextScrollY=1;
							return 0;
						}
					}
					else if(y<bh-17)
					{
						if(x>=bw-17&&x<bw)//	[v]
						{
							tpy=tpy+fontH>th-bh?th-bh:tpy+fontH;
							return 1;
						}
					}
					else if(y<bh)
					{
						if(x>=0)
						{
							if(x<17)//	[<]
							{
								tpx=tpx-fontH<0?0:tpx-fontH;
								return 1;
							}
							else if(x<bw-34)//	__
							{
								mouseTextScrollX=1;
								return 0;
							}
							else if(x<bw-17)//	[>]
							{
								tpx=tpx+fontH>tw-bw?tw-bw:tpx+fontH;
								return 1;
							}
						}
					}
				}
			}
			else//horizontal scrolling only
			{
				if(y>=bh-17&&y<bh)
				{
					if(x>=0)
					{
						if(x<17)//	[<]
						{
							tpx=tpx-fontH<0		?0		:tpx-fontH;
							return 1;
						}
						else if(x<bw-17)//	__
						{
							mouseTextScrollX=1;
							return 0;
						}
						else if(x<bw)//	[>]
						{
							tpx=tpx+fontH>tw-bw	?tw-bw	:tpx+fontH;
							return 1;
						}
					}
				}
			}
		}
		else
		{
			if(th>h)//vertical scrolling only
			{
				if(x>=bw-17&&x<bw)
				{
					if(y>=0)
					{
						if(y<17)//	[^]
						{
							tpy=tpy-fontH<0?0:tpy-fontH;
							return 1;
						}
						else if(y<bh-17)//	|
						{
							mouseTextScrollY=1;
							return 0;
						}
						else if(y<bh)//	[v]
						{
							tpx=tpx+fontH>tw-bw	?tw-bw	:tpx+fontH;
							return 1;
						}
					}
				}
			}
		}
		mouseTextSel=1;
		cursorAtMouse(x, y);
		if(!kb[VK_SHIFT])
			selcur=cursor;
		return 1;
	}
	virtual int switchToWithMouseOn(int lParam);
	virtual int inputLButtonDown(int lParam);
	int inputMouseMove(int lParam);
	void inputLButtonUp();
	int inputMouseWheel(int wParam);
	virtual int inputKeyDown(int wParam, int lParam);
	virtual void draw();
	virtual void draw_corresponding			(const int*, int, TextBox*);
	virtual void draw_corresponding_color	(const int*, int, TextBox*);
	~TextBox();

};
void			TextBox::cursorAtMouse(int x, int y)
{
	cursor=0;
	if(y>=0)
	{
		for(int k=0, l=0;k<textlen-1;++k)//find the start of line containing cursor
		{
			if(l==(tpy+y)/fontH)
				break;
			else if(text[k]=='\r')
				cursor=++k+1, ++l;//skip '\n'
		}
	}
	int lstart=cursor;
	selectFont();
//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	for(int x2=0;cursor<textlen&&text[cursor]!='\r';++cursor)
//	for(int x2=0;text[cursor]!='\r'&&cursor<textlen;++cursor)
	{
		int tx2=getTextWidth(text, lstart, cursor+1, 0);
	//	int tx2=getTextWidth(text+lstart, cursor+1-lstart);
	//	int tx2=font.getTextW(text, lstart, cursor+1);
		if(tpx+x<x2+(tx2-x2)/2)
			break;
		x2=tx2;
	}
	deselectFont();
//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
//	cursorTeleport();
}
void			TextBox::cursorTeleport()
{
//	if(tw>w||th>h)//outdated
	{
		selectFont();
	//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
		int currentLineStart=0, cursorY=0, cursorX=0;
		for(int k=0;k<cursor;++k)
		{
			if(text[k]=='\r')
			{
				cursorY+=fontH;
				if(k+1<textlen&&text[k+1]=='\n')
					++k;
				currentLineStart=k+1;
			}
		}
		if(currentLineStart<cursor)
			cursorX=getTextWidth(text, currentLineStart, cursor, 0);
		//	cursorX=getTextWidth(text+currentLineStart, cursor-currentLineStart);
		//	cursorX=font.getTextW(text, currentLineStart, cursor);
		deselectFont();
	//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			 if(cursorY<tpy			)tpy=cursorY;
		else if(cursorY>tpy+h-fontH	)tpy=cursorY-h+fontH;
			 if(cursorX<tpx			)tpx=cursorX;
		else if(cursorX>tpx+w		)tpx=cursorX-w;
	}
	if(!kb[VK_SHIFT])
		selcur=cursor;//cursorAtMouse
	toTeleportCursor=false;
}
				TextBox::TextBox(bool active=false):active(active), cursor(0), selcur(0), bpx(0), bpy(0), bw(0), bh(0), tpx(0), tpy(0), tw(0), th(0), mouseTextSel(0), mouseTextScrollX(0), mouseTextScrollY(0), toTeleportCursor(0)
{
	text=(char*)malloc(((textlen=0)+1)*sizeof(char)), text[textlen]='\0';
	rgn.create(bpx, bpy, bpx+bw, bpy+bh);
//	createRegion(bpx, bpy, bpx+bw, bpy+bh);
//	hRgn=CreateRectRgn(bpx, bpy, bpx+bw, bpy+bh);
}
void			TextBox::setDimensions(int x, int y, int w, int h)
{
	bpx=x, bpy=y, bw=w, bh=h;
	rgn.destroy();
//	deleteRegion();
	rgn.create(bpx, bpy, bpx+bw, bpy+bh);
//	createRegion(bpx, bpy, bpx+bw, bpy+bh);
//	DeleteObject(hRgn);
//	hRgn=CreateRectRgn(bpx, bpy, bpx+bw, bpy+bh);
}
void			TextBox::changeFont(double A){tpx=int(A*tpx), tpy=int(A*tpy);}
int				TextBox::switchToWithMouseOn(int lParam){return private_clickRegion(((short*)&lParam)[0]-bpx, ((short*)&lParam)[1]-bpy);}
int				TextBox::inputLButtonDown(int lParam)
{
	short x=((short*)&lParam)[0]-bpx, y=((short*)&lParam)[1]-bpy;
	if(x>=0&&x<bw&&y>=0&&y<bh)//
		return private_clickRegion(((short*)&lParam)[0]-bpx, ((short*)&lParam)[1]-bpy);
	else if(active)
	{
		active=false;
		return 1;
	}
	else
		return 0;
}
int				TextBox::inputMouseMove(int lParam)
{
	if(active)
	{
		int x=((short*)&lParam)[0], y=((short*)&lParam)[1];
			 if(mouseTextSel	){	cursorAtMouse(x-bpx, y-bpy);																					return 1;}
		else if(mouseTextScrollX){	tpx+=int(double(tw)*(x-short(oldMouse		))/(tw>bw&&th>bh?bw-41:bw-34)), tpx=tpx<0?0:tpx>tw-bw?tw-bw:tpx;	return 1;}
		else if(mouseTextScrollY){	tpy+=int(double(th)*(y-short(oldMouse>>16	))/(tw>bw&&th>bh?bh-41:bh-34)), tpy=tpy<0?0:tpy>th-bh?th-bh:tpy;	return 1;}
	}
	return 0;
}
void			TextBox::inputLButtonUp()
{
	if(active)
		mouseTextSel=mouseTextScrollX=mouseTextScrollY=0;
}
int				TextBox::inputMouseWheel(int wParam)
{
	if(active)
	{
		if(th>bh){		 if(((short*)&wParam)[1]<0)	{tpy=tpy+100>th-bh	?th-bh	:tpy+100;return 1;}
					else							{tpy=tpy-100<0		?0		:tpy-100;return 1;}}
	}
	return 0;
}
int				TextBox::inputKeyDown(int wParam, int lParam)
{
	if(kb[VK_CONTROL])
	{
		switch(wParam)
		{
		case VK_CAPITAL:				return 0;
		case VK_NUMLOCK:				return 0;
		case VK_OEM_3:					return 0;
		case '1':						return 0;
		case '2':						return 0;
		case '3':						return 0;
		case '4':						return 0;
		case '5':						return 0;
		case '6':						return 0;
		case '7':						return 0;
		case '8':						return 0;
		case '9':						return 0;
		case '0':						return 0;
		case VK_OEM_MINUS:				return 0;
		case VK_OEM_PLUS:				return 0;
		case VK_TAB:					return 0;
		case 'Q':						return 0;
		case 'W':						return 0;
		case 'E':						return 0;
		case 'R':						return 0;
		case 'T':						return 0;
		case 'Y':						return 0;
		case 'U':						return 0;
		case 'I':						return 0;
		case 'O':						return 0;
		case 'P':						return 0;
		case VK_OEM_4:					return 0;
		case VK_OEM_6:					return 0;
		case 'A':
			cursor=textlen;
			cursorTeleport();
			selcur=0;
			return 1;
		case 'S':						return 0;
		case 'D':						return 0;
		case 'F':						return 0;
		case 'G':						return 0;
		case 'H':						return 0;
		case 'J':						return 0;
		case 'K':						return 0;
		case 'L':						return 0;
		case VK_OEM_1:					return 0;
		case VK_OEM_7:					return 0;
		case VK_OEM_5:case VK_OEM_102:	return 0;
		case 'Z':						return 0;
		case 'X':						return 0;
		case 'C':
			if(cursor!=selcur)
			{
				int k=cursor<selcur?cursor:selcur, k2=cursor>selcur?cursor:selcur;
				char *clipboard=(char*)LocalAlloc(LMEM_FIXED, (k2-k+1)*sizeof(char));
				memcpy(clipboard, &text[k], (k2-k)*sizeof(char));
				clipboard[k2-k]='\0';
				OpenClipboard(ghWnd), EmptyClipboard(), SetClipboardData(CF_OEMTEXT, (void*)clipboard), CloseClipboard();
			}
			return 0;
		case 'V':						return 0;
		case 'B':						return 0;
		case 'N':						return 0;
		case 'M':						return 0;
		case VK_OEM_COMMA:				return 0;
		case VK_OEM_PERIOD:				return 0;
		case VK_OEM_2:					return 0;
		case VK_SPACE:					return 0;
		case VK_NUMPAD0:				return 0;
		case VK_NUMPAD1:				return 0;
		case VK_NUMPAD2:				return 0;
		case VK_NUMPAD3:				return 0;
		case VK_NUMPAD4:				return 0;
		case VK_NUMPAD5:				return 0;
		case VK_NUMPAD6:				return 0;
		case VK_NUMPAD7:				return 0;
		case VK_NUMPAD8:				return 0;
		case VK_NUMPAD9:				return 0;
		case VK_DECIMAL:				return 0;
		case VK_ADD:					return 0;
		case VK_SUBTRACT:				return 0;
		case VK_MULTIPLY:				return 0;
		case VK_DIVIDE:					return 0;
		case VK_DELETE:					return 0;
		case VK_BACK:					return 0;
		case VK_RETURN:					return 0;
		case VK_UP:
			if(th>bh)
			{
				tpy=tpy-fontH<0?0:tpy-fontH;
				return 1;
			}
			return 0;
		case VK_DOWN:
			if(th>bh)
			{
				tpy=tpy+fontH>th-bh?th-bh:tpy+fontH;
				return 1;
			}
			return 0;
		case VK_LEFT:
			if(cursor)
			{
				char initial=mapChar(text[--cursor]);
				for(;cursor;--cursor)
					if(mapChar(text[cursor-1])!=initial)
						break;
				cursorTeleport();
				return 1;
			}
			if(selcur!=cursor&&!kb[VK_SHIFT])
			{
				selcur=cursor;
				return 1;
			}
			return 0;
		case VK_RIGHT:
			if(cursor!=textlen)
			{
				char initial=mapChar(text[cursor++]);
				for(;cursor!=textlen;++cursor)
					if(mapChar(text[cursor])!=initial)
						break;
				cursorTeleport();
				return 1;
			}
			if(selcur!=cursor&&!kb[VK_SHIFT])
			{
				selcur=cursor;
				return 1;
			}
			return 0;
		case VK_HOME:
			if(kb[VK_SHIFT])
			{
				cursor=0;
				cursorTeleport();
				return 1;
			}
			else if(tw>bw)
			{
				tpx=0;
				return 1;
			}
			return 0;
		case VK_END:
			if(kb[VK_SHIFT])
			{
				cursor=textlen;
				cursorTeleport();
				return 1;
			}
			else if(tw>bw)
			{
				tpx=tw-bw;
				return 1;
			}
			return 0;
		case VK_ESCAPE:case VK_F1:case VK_F2:case VK_F3:case VK_F4:case VK_F5:case VK_F6:case VK_F7:case VK_F8:case VK_F9:case VK_F10:case VK_F11:case VK_F12:case VK_INSERT:	return 0;
		case VK_F13:case VK_F14:case VK_F15:case VK_F16:case VK_F17:case VK_F18:case VK_F19:case VK_F20:case VK_F21:case VK_F22:case VK_F23:case VK_F24:						return 0;
		case VK_SHIFT:					return 0;
		case VK_CONTROL:case VK_LWIN:	return 0;
		case VK_PRIOR:case VK_NEXT:		return 0;
		default:						return 0;
		}
	}
	else
	{
		switch(wParam)
		{
		case VK_CAPITAL:				return 0;
		case VK_NUMLOCK:				return 0;
		case VK_OEM_3:					return 0;
		case '0':						return 0;
		case '1':						return 0;
		case '2':						return 0;
		case '3':						return 0;
		case '4':						return 0;
		case '5':						return 0;
		case '6':						return 0;
		case '7':						return 0;
		case '8':						return 0;
		case '9':						return 0;
		case VK_OEM_MINUS:				return 0;
		case VK_OEM_PLUS:				return 0;
		case 'Q':						return 0;
		case 'W':						return 0;
		case 'E':						return 0;
		case 'R':						return 0;
		case 'T':						return 0;
		case 'Y':						return 0;
		case 'U':						return 0;
		case 'I':						return 0;
		case 'O':						return 0;
		case 'P':						return 0;
		case VK_OEM_4:					return 0;
		case VK_OEM_6:					return 0;
		case 'A':						return 0;
		case 'S':						return 0;
		case 'D':						return 0;
		case 'F':						return 0;
		case 'G':						return 0;
		case 'H':						return 0;
		case 'J':						return 0;
		case 'K':						return 0;
		case 'L':						return 0;
		case VK_OEM_1:					return 0;
		case VK_OEM_7:					return 0;
		case VK_OEM_5:case VK_OEM_102:	return 0;
		case 'Z':						return 0;
		case 'X':						return 0;
		case 'C':						return 0;
		case 'V':						return 0;
		case 'B':						return 0;
		case 'N':						return 0;
		case 'M':						return 0;
		case VK_OEM_COMMA:				return 0;
		case VK_OEM_PERIOD:				return 0;
		case VK_OEM_2:					return 0;
		case VK_SPACE:					return 0;
		case VK_NUMPAD0:				return 0;
		case VK_NUMPAD1:				return 0;
		case VK_NUMPAD2:				return 0;
		case VK_NUMPAD3:				return 0;
		case VK_NUMPAD4:				return 0;
		case VK_NUMPAD5:				return 0;
		case VK_NUMPAD6:				return 0;
		case VK_NUMPAD7:				return 0;
		case VK_NUMPAD8:				return 0;
		case VK_NUMPAD9:				return 0;
		case VK_DECIMAL:				return 0;
		case VK_ADD:					return 0;
		case VK_SUBTRACT:				return 0;
		case VK_MULTIPLY:				return 0;
		case VK_DIVIDE:					return 0;
		case VK_DELETE:					return 0;
		case VK_BACK:					return 0;
		case VK_RETURN:					return 0;
		case VK_UP:
			if(kb[VK_SHIFT])
			{
				for(int k=cursor-2;k>=0;--k)
				{
					if(text[k]=='\r')
					{
						selectFont();
					//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
						int x=getTextWidth(text, k+2, cursor, 0), x2=0;
					//	int x=font.getTextW(text, k+2, cursor), x2=0;
						for(;;--k)
							if(!k||text[k-1]=='\n')
								break;
						for(int k2=k;;++k2)
						{
							if(text[k2]=='\r')
							{
								cursor=k2;
								break;
							}
							int tx2;
							if(text[k2]=='\t')
								tx2=getTextWidth(text, k, k2+1, 0);
							//	tx2=font.getTextW(text, k, k2+1);
							else
								tx2=x2+fontW[text[k2]];
							if(tx2>x)
							{
								cursor=tx2-(tx2-x2)/2>x?k2:k2+1;
								break;
							}
							x2=tx2;
						}
						deselectFont();
					//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
						cursorTeleport();
						return 1;
					}
				}
			}
			else if(th>bh)
			{
				tpy=tpy-fontH<0?0:tpy-fontH;
				return 1;
			}
			return 0;
		case VK_DOWN:
			if(kb[VK_SHIFT])
			{
				for(int k=cursor;k<textlen;++k)
				{
					if(text[k]=='\n')
					{
						selectFont();
					//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
						int k2=cursor;
						for(;k2>0;--k2)
							if(text[k2-1]=='\n')//k2 points at start of line
								break;
						int x=getTextWidth(text, k2, cursor, 0), x2=0;
					//	int x=getTextWidth(text+k2, cursor-k2), x2=0;
					//	int x=font.getTextW(text, k2, cursor), x2=0;
						for(int k2=++k;;++k2)
						{
							if(text[k2]=='\r'||k2==textlen)
							{
								cursor=k2;
								break;
							}
							int tx2;
							if(text[k2]=='\t')
								tx2=getTextWidth(text, k, k2+1, 0);
							//	tx2=getTextWidth(text+k, k2+1-k);
							//	tx2=font.getTextW(text, k, k2+1);
							else
								tx2=x2+fontW[text[k2]];
							if(tx2>x)
							{
								cursor=tx2-(tx2-x2)/2>x?k2:k2+1;
								break;
							}
							x2=tx2;
						}
						deselectFont();
					//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
						cursorTeleport();
						return 1;
					}
				}
			}
			else if(th>bh)
			{
				tpy=tpy+fontH>th-bh?th-bh:tpy+fontH;
				return 1;
			}
			return 0;
		case VK_LEFT:
			if(kb[VK_SHIFT])
			{
				if(cursor)
				{
					cursor-=text[cursor-1]=='\n'?2:1;
					cursorTeleport();
					return 1;
				}
			}
			return 0;
		case VK_RIGHT:
			if(kb[VK_SHIFT])
			{
				if(cursor<textlen)
				{
					cursor+=text[cursor]=='\r'?2:1;
					cursorTeleport();
					return 1;
				}
			}
			return 0;
		case VK_HOME:
			if(kb[VK_SHIFT])
			{
				if(cursor&&text[cursor-1]!='\n')
				{
					for(;;--cursor)
						if(!cursor||text[cursor-1]=='\n')
							break;
					cursorTeleport();
					return 1;
				}
			}
			if(tw>bw)
			{
				tpx=0;
				return 1;
			}
			return 0;
		case VK_END:
			if(kb[VK_SHIFT])
			{
				if(text[cursor]!='\r'&&cursor<textlen)
				{
					for(;;++cursor)
						if(text[cursor]=='\r'||cursor==textlen)
							break;
					cursorTeleport();
					return 1;
				}
			}
			if(tw>bw)
			{
				tpx=tw-bw;
				return 1;
			}
			return 0;
		case VK_ESCAPE:case VK_F1:case VK_F2:case VK_F3:case VK_F4:case VK_F5:case VK_F6:case VK_F7:case VK_F8:case VK_F9:case VK_F10:case VK_F11:case VK_F12:case VK_INSERT:	return 0;
		case VK_F13:case VK_F14:case VK_F15:case VK_F16:case VK_F17:case VK_F18:case VK_F19:case VK_F20:case VK_F21:case VK_F22:case VK_F23:case VK_F24:						return 0;
		case VK_TAB:					return 0;
		case VK_SHIFT:					return 0;
		case VK_CONTROL:case VK_LWIN:	return 0;
		case VK_PRIOR:case VK_NEXT:		return 0;
		default:						return 0;
		}
	}
	return 0;
}
void			TextBox::draw()
{
	rgn.use();
//	useRegion();
//	SelectClipRgn(ghMemDC, hRgn);
	tw=th=0;
	int bkMode=setBkMode(OPAQUE), bkColor=setBkColor(0xFFFFFF);
//	int bkMode=getBkMode(), bkColor=getBkColor();
//	int bkMode=GetBkMode(ghMemDC), bkColor=GetBkColor(ghMemDC);
//	SetBkMode(ghMemDC, TRANSPARENT);
	for(int k=cursor<selcur?cursor:selcur, k2=cursor>selcur?cursor:selcur, k3=0, k4=0, x=0, y=0;k4<=textlen;++k4)
	{
		if(k4==k)
		{
			x+=(short)print(bpx+x-tpx, bpy+y-tpy, bpx-tpx, &text[k3], k4-k3);
		//	x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
			k3=k4;
			setBkMode(OPAQUE), setBkColor(active?0x00FFFF96:0x00969696);
		//	SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, active?0x00FFFF96:0x00969696);
		}
		if(k4==k2)
		{
			x+=(short)print(bpx+x-tpx, bpy+y-tpy, bpx-tpx, &text[k3], k4-k3);
		//	x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
			k3=k4;
			setBkMode(bkMode), setBkColor(bkColor);
		//	SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
		//	SetBkMode(ghMemDC, TRANSPARENT);
		}
		if(text[k4]=='\r'||k4==textlen)
		{
			x+=(short)print(bpx+x-tpx, bpy+y-tpy, bpx-tpx, &text[k3], k4-k3);
		//	x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
			if(x>tw)
				tw=x;
			k3=k4+2, x=0, th+=fontH, y+=fontH;
		}
	}
	setBkMode(bkMode), setBkColor(bkColor);
//	SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
	if(tw>bw&&th>bh)
	{
		int xi=bpx+17+int(double(bw-51)*tpx/tw), xf=bpx+17+int(double(bw-51)*(tpx+bw)/tw), yi=bpy+17+int(double(bh-51)*tpy/th), yf=bpy+17+int(double(bh-51)*(tpy+bh)/th);
		line(bpx		, bpy+bh-17	, bpx+bw	, bpy+bh-17	);
		line(bpx+17		, bpy+bh-17	, bpx+17	, bpy+bh	);
		line(xi			, bpy+bh-17	, xi		, bpy+bh	);
		line(xf			, bpy+bh-17	, xf		, bpy+bh	);
		line(bpx+bw-34	, bpy+bh-17	, bpx+bw-34	, bpy+bh	);
		line(bpx+bw-17	, bpy		, bpx+bw-17	, bpy+bh	);
		line(bpx+bw-17	, bpy+17	, bpx+bw	, bpy+17	);
		line(bpx+bw-17	, yi		, bpx+bw	, yi		);
		line(bpx+bw-17	, yf		, bpx+bw	, yf		);
		line(bpx+bw-17	, bpy+bh-34	, bpx+bw	, bpy+bh-34	);
	}
	else if(tw>bw)
	{
		tpy=0;
		int xi=bpx+17+int(double(bw-34)*tpx/tw), xf=bpx+17+int(double(bw-34)*(tpx+bw)/tw);
		line(bpx		, bpy+bh-17, bpx+bw		, bpy+bh-17	);
		line(bpx+17		, bpy+bh-17, bpx+17		, bpy+bh	);
		line(xi			, bpy+bh-17, xi			, bpy+bh	);
		line(xf			, bpy+bh-17, xf			, bpy+bh	);
		line(bpx+bw-17	, bpy+bh-17, bpx+bw-17	, bpy+bh	);
	}
	else if(th>bh)
	{	
		tpx=0;
		int yi=bpy+17+int(double(bh-34)*tpy/th), yf=bpy+17+int(double(bh-34)*(tpy+bh)/th);
		line(bpx+bw-17, bpy			, bpx+bw-17	, bpy+bh	);
		line(bpx+bw-17, bpy+17		, bpx+bw	, bpy+17	);
		line(bpx+bw-17, yi			, bpx+bw	, yi		);
		line(bpx+bw-17, yf			, bpx+bw	, yf		);
		line(bpx+bw-17, bpy+bh-17	, bpx+bw	, bpy+bh-17	);
	}
	else
		tpx=tpy=0;
	rgn.drop();
//	dropRegion();
//	SelectClipRgn(ghMemDC, 0);
}
void			TextBox::draw_corresponding(const int *modes, int nmodes, TextBox *tb)
{
	int xc, yc;//cursor position	unused
	rgn.use();
//	useRegion();
//	SelectClipRgn(ghMemDC, hRgn);
	tw=th=0;
	int bkMode=setBkMode(OPAQUE), bkColor=setBkColor(0xFFFFFF), txtColor=getTextColor(), line=0;
//	int bkMode=getBkMode(), bkColor=getBkColor(), txtColor=getTextColor(), line=0;
//	int bkMode=GetBkMode(ghMemDC), bkColor=GetBkColor(ghMemDC), txtColor=GetTextColor(ghMemDC), line=0;
	{
		int x=0, y=0;
		auto exprIT=expr.begin();
		for(;exprIT!=expr.end();++exprIT)
		{
		//	if(modes.find(exprIT->rmode[0])!=modes.end())
			int km=-1;
			for(int km2=0;km2<nmodes;++km2)
			{
				if(modes[km2]==exprIT->rmode[0])
				{
					km=km2;
					break;
				}
			}
			if(km!=-1)
			{
				th=y=fontH*exprIT->endLineNo;
			//	th=y=font.H*((exprIT+1!=expr.end()?exprIT[1].lineNo:nLines)-1);
				break;
			}
		}
		for(int k=cursor<selcur?cursor:selcur, k2=cursor>selcur?cursor:selcur, k3=0, k4=0;k4<=textlen;++k4)
		{
			if(k4==k)//selection start
			{
				if(k3<k4)
					x+=(short)print(bpx+x-tpx, bpy+y-tb->tpy, bpx-tpx, &text[k3], k4-k3);
				//	x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tb->tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
				k3=k4;
				if(k4==cursor)
					xc=x, yc=y;
				setBkMode(OPAQUE), setBkColor(active?0x00FFFF96:0x00969696);
			//	SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, active?0x00FFFF96:0x00969696);
			}
			if(k4==k2)//selection end
			{
				if(k3<k4)
					x+=(short)print(bpx+x-tpx, bpy+y-tb->tpy, bpx-tpx, &text[k3], k4-k3);
				//	x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tb->tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
				k3=k4;
				if(k4==cursor)
					xc=x, yc=y;
				setBkMode(bkMode), setBkColor(bkColor);
			//	SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
			}
			if(text[k4]=='\r')
			{
				if(k3<k4)
					x+=(short)print(bpx+x-tpx, bpy+y-tb->tpy, bpx-tpx, &text[k3], k4-k3);
				//	x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tb->tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
				if(x>tw)
					tw=x;
				k3=k4+2, x=0;
				if(k4==0||text[k4-1]!='\\')
				{
					++exprIT;
					for(;exprIT!=expr.end();++exprIT)
					{
					//	if(modes.find(exprIT->rmode[0])!=modes.end())
						if(find_mode(modes, nmodes, exprIT->rmode[0])!=-1)
						{
							th=y=fontH*exprIT->endLineNo;
						//	th=y=font.H*((exprIT+1!=expr.end()?exprIT[1].lineNo:nLines)-1);
							break;
						}
					}
				}
			}
			else if(k4==textlen)
			{
				if(k3<k4)
					x+=(short)print(bpx+x-tpx, bpy+y-tb->tpy, bpx-tpx, &text[k3], k4-k3);
				//	x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tb->tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
				if(x>tw)
					tw=x;
				k3=k4+2, x=0, th+=fontH;
			}
		}
	}
	setBkMode(bkMode), setBkColor(bkColor), setTextColor(txtColor);
//	SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor), SetTextColor(ghMemDC, txtColor);
	rgn.drop();
//	dropRegion();
//	SelectClipRgn(ghMemDC, 0);
}
void			TextBox::draw_corresponding_color(const int *modes, int nmodes, TextBox *tb)
{
	int xc, yc;//cursor position	unused
	rgn.use();
//	useRegion();
//	SelectClipRgn(ghMemDC, hRgn);
	tw=th=0;
	int bkMode=getBkMode(), bkColor=getBkColor(), txtColor=getTextColor();
//	int bkMode=GetBkMode(ghMemDC), bkColor=GetBkColor(ghMemDC), txtColor=GetTextColor(ghMemDC), line=0;
	{
		int x=0, y=0;
		auto exprIT=expr.begin();
		for(;exprIT!=expr.end();++exprIT)
		{
		//	if(modes.find(exprIT->rmode[0])!=modes.end())
			int km=find_mode(modes, nmodes, exprIT->rmode[0]);
			if(km!=-1)
			{
				th=y=fontH*exprIT->endLineNo;
				setTextColor(exprIT->winColor);
			//	SetTextColor(ghMemDC, exprIT->winColor);//
			//	SetTextColor(ghMemDC, modes.find(exprIT->rmode[0])!=modes.end()?exprIT->winColor:txtColor);
				break;
			}
		}
		for(int k=cursor<selcur?cursor:selcur, k2=cursor>selcur?cursor:selcur, k3=0, k4=0;k4<=textlen;++k4)
		{
			if(k4==k)
			{
				x+=(short)print(bpx+x-tpx, bpy+y-tb->tpy, bpx-tpx, &text[k3], k4-k3);
			//	x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tb->tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
				k3=k4;
				if(k4==cursor)
					xc=x, yc=y;
				setBkMode(OPAQUE), setBkColor(active?0x00FFFF96:0x00969696);
			//	SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, active?0x00FFFF96:0x00969696);
			}
			if(k4==k2)
			{
				x+=(short)print(bpx+x-tpx, bpy+y-tb->tpy, bpx-tpx, &text[k3], k4-k3);
			//	x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tb->tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
				k3=k4;
				if(k4==cursor)
					xc=x, yc=y;
				setBkMode(bkMode), setBkColor(bkColor);
			//	SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
			//	SetBkMode(ghMemDC, TRANSPARENT);
			}
			if(text[k4]=='\r')
			{
				x+=(short)print(bpx+x-tpx, bpy+y-tb->tpy, bpx-tpx, &text[k3], k4-k3);
			//	x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tb->tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
				if(x>tw)
					tw=x;
				k3=k4+2, x=0;
				if(k4==0||text[k4-1]!='\\')
				{
					++exprIT;
					for(;exprIT!=expr.end();++exprIT)
					{
					//	if(modes.find(exprIT->rmode[0])!=modes.end())
						int km=find_mode(modes, nmodes, exprIT->rmode[0]);
						if(km!=-1)
						{
							th=y=fontH*exprIT->endLineNo;
							setTextColor(exprIT->winColor);
						//	SetTextColor(ghMemDC, exprIT->winColor);//
						//	SetTextColor(ghMemDC, modes.find(exprIT->rmode[0])!=modes.end()?exprIT->winColor:txtColor);
							break;
						}
					}
				}
			}
			else if(k4==textlen)
			{
				x+=(short)print(bpx+x-tpx, bpy+y-tb->tpy, bpx-tpx, &text[k3], k4-k3);
			//	x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tb->tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
				if(x>tw)
					tw=x;
				k3=k4+2, x=0, th+=fontH;
			}
		}
	}
	setBkMode(bkMode), setBkColor(bkColor), setTextColor(txtColor);
//	SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor), SetTextColor(ghMemDC, txtColor);
	rgn.drop();
//	dropRegion();
//	SelectClipRgn(ghMemDC, 0);
}
				TextBox::~TextBox()
{
	free(text);
	rgn.destroy();
//	deleteRegion();
//	DeleteObject(hRgn);
}
class		InputTextBox:public TextBox
{
	int	*history, histpos, histlen, cont;
public:
	int getLineNo(int, int, int);
private:
	void closeComment(int, int);
	void replaceText_update(int, int, int);
	void replaceText(int, int, const char*, int);
	void insertText(int, const char*, int);
	void removeText(int, int);
public:
	InputTextBox(bool active):TextBox(active), history(0), histpos(0), histlen(0), cont(1){}
	virtual int switchToWithMouseOn(int lParam);
	int inputLButtonDown(int lParam);
	int inputKeyDown(int wParam, int lParam);
	void draw();
	void draw_color(const int*, int);
	friend int copy_text_with_n0d_results(int);
} itb(1);
int				InputTextBox::getLineNo(int i, int i_lineNo, int f)
{
	int lineNo=i_lineNo;
	for(int k=i;k<f;++k)
		if(text[k]=='\n'||text[k]=='\r'&&text[k+1]!='\n')
			++lineNo;
	return lineNo;
}
void			InputTextBox::closeComment(int cStart, int cEnd)
{
	int min=cStart;
	for(;allComments.size()&&allComments.rbegin()->second>cStart;)
	{
		if(min>allComments.rbegin()->first)
			min=allComments.rbegin()->first;
		allComments.pop_back();
	}
	allComments.push_back(std::pair<int, int>(min, cEnd));
}
void			InputTextBox::replaceText_update(int i, int fr, int fi)
{
	std::vector<std::pair<int, char>> oldbounds=std::move(bounds);
	{
		nLines=1;
		allComments.clear();
		for(int k=0;;)//A: comments
		{
			{//skip till comment
				for(;k+1<textlen&&(text[k]!='/'||text[k+1]!='/'&&text[k+1]!='*');++k);
				char k1_oob=k+1>=textlen;
				k+=k1_oob;//k points at comment start or OOB
				if(k1_oob)//no comments left
					break;
			}
			int start=k;//comment found
			k+=2;
			char isend=0;
			if(text[k-1]=='/')//skip line comment
			{
				for(;k<textlen&&(k>0&&text[k-1]=='\\'||text[k]!='\r');++k);
				isend=k>=textlen;
			}
			else if(text[k-1]=='*')//skip block comment
			{
				if(nestedComments)
				{
					int level=1;
					for(;k+1<textlen;++k)
					{
						char open=text[k]=='/'&&text[k+1]=='*', close=text[k]=='*'&&text[k+1]=='/';
						level+=open-close;
						if(!level)
							break;
						k+=open|close;
					}
				}
				else
					for(;k+1<textlen&&(text[k]!='*'||text[k+1]!='/');++k);
				char k1_oob=k+1>=textlen;
				k+=1+!k1_oob;//k points at end of comment or OOB
				isend=k1_oob;
			}
			allComments.push_back(CommentBound(start, k));
			if(isend)
				break;
		}
#if 0
		{
			std::stack<int> cStack;//positions of /*
			bool cFound=false, lineComment=false;
			int cFirst, lcFirst;
			for(int k=0;;++k)//A: comments					block 5
			{
				if(k>=textlen)
				{
					if(lineComment)
						closeComment(lcFirst, textlen);
					if(commentIncompleteScope)
					{
						if(nestedComments)
						{
							if(cStack.size())
							{
								for(;cStack.size()>1;)
									cStack.pop();
								closeComment(cStack.top(), textlen);
								cStack.pop();
							}
						}
						else if(cFound)
							closeComment(cFirst, textlen);
					}
					break;
				}
				switch(text[k])
				{
				case '\\':
					if(k+1<textlen&&text[k+1]=='\r')//robust
					{
						k+=1+(k+2<textlen&&text[k+2]=='\n');
						++nLines;
					}
					continue;
				case '\r':
					if(k+1<textlen&&text[k+1]=='\n')//
						++k;
				case '\n':
					if(lineComment)
					{
						closeComment(lcFirst, k-1);
						lineComment=false;
					}
					++nLines;
					continue;
				case '/':
					if(k+1<textlen)
					{
						if(text[k+1]=='*')
						{
							if(nestedComments)
								cStack.push(k);
							else if(!cFound)
								cFirst=k, cFound=true;
							++k;
						}
						else if(text[k+1]=='/')
						{
							if(!lineComment&&(nestedComments&&!cStack.size()||!cFound))
								lcFirst=k, lineComment=true;
							++k;
						}
					}
					continue;
				case '*':
					if(k+1<textlen&&text[k+1]=='/')
					{
						if(nestedComments)
						{
							if(cStack.size())
							{
								closeComment(cStack.top(), k+2);
								cStack.pop();
							}
							++k;
						}
						else if(cFound)
						{
							closeComment(cFirst, k+2);
							cFound=false;
							++k;//c c++
						}
					}
					continue;
				}
			}
		}
#endif
		for(BoundCounter k(0, 0, textlen);;)//bound extractor
		{
			for(;k.idx<textlen&&text[k.idx]!='{'&&(k.idx&&text[k.idx-1]=='\\'||text[k.idx]!='\r');k.inc(textlen));
			if(k.idx==textlen||text[k.idx]=='\r')
			{
				k.idx+=k.idx<textlen&&text[k.idx]=='\r';
				k.idx+=k.idx<textlen&&text[k.idx]=='\n';
			//	k.idx+=1+(k.idx+1<textlen&&text[k.idx+1]=='\n');
				bounds.push_back(Bound(k.idx, 'e'));
			}
			else if(text[k.idx]=='{')
			{
				//parse function header in reverse
				BoundCounter hstart=k;
				hstart.dec();
				char isfunction=!rskip_whitespace(text, hstart, textlen);
				isfunction&=rskip_char_ifmatch(text, hstart, textlen, ')')==2;//match & not OOB
				if(isfunction)
				{
					try//ID WS '(' [[WS T WS ID WS ',']^n WS T WS ID] WS ')' WS FBODY		<- header is parsed backwards
					{
						char arg_separator[]="(,";
						char match_oob=0;//{match bit, OOB bit}
#define					MATCH_BIT	(match_oob>>1)
#define					OOB_BIT		(match_oob&1)
						for(char notfirsttime=false;isfunction;notfirsttime=true)
						{
							if(rskip_whitespace(text, hstart, textlen))//OOB	//...){
								throw false;

							char c_matched=0;
							arg_separator[1]=','&-notfirsttime;
							match_oob=rskip_char_ifmatch(text, hstart, textlen, arg_separator, &c_matched);
							if(OOB_BIT)//OOB	//...){
								throw false;
							char match=MATCH_BIT;
							if(match&&c_matched=='(')//found '('
								break;
							if(notfirsttime&&!match)//comma must separate args
								throw false;

							if(rskip_whitespace(text, hstart, textlen))//OOB	//...){
								throw false;

							match_oob=rskip_identifier(text, hstart, textlen);//argname must be found
							if(OOB_BIT)//OOB	//...){
								throw false;
							isfunction&=MATCH_BIT;

							if(rskip_whitespace(text, hstart, textlen))//OOB	//...){
								throw false;

							match_oob=rskip_char_ifmatch(text, hstart, textlen, "rRcCqQhH");//optional
							if(OOB_BIT)//OOB	//...){
								throw false;
						}

						if(rskip_whitespace(text, hstart, textlen))//OOB	//(...){
							throw false;
						match_oob=rskip_identifier(text, hstart, textlen);//funcname must be found
						isfunction&=MATCH_BIT;
#undef					MATCH_BIT
#undef					OOB_BIT
					}
					catch(bool f)
					{
						isfunction=f;
					}
				}
				//match curly brace
				k.inc(textlen);//k points at '{'
				int level=1;
				for(;k.idx<textlen&&level;k.inc(textlen))
				{
					char c=text[k.idx];
					level+=(c=='{')-(c=='}');
				}
				skip_whitespace(text, k, textlen);
				isfunction&=!level;//k points at after '}'

				if(isfunction)//hstart is before the start or OOB
				{
					hstart.inc(textlen);
					for(;bounds.size()&&hstart.idx<bounds.rbegin()->first;)//pop possible thought to be expression bounds
						bounds.pop_back();
					bounds.push_back(Bound(k.idx, 'f'));
				}
				else
					bounds.push_back(Bound(k.idx, 'e'));//invalid function definitions are considered as expressions to avoid CRASH
				//	bounds.push_back(Bound(k.idx, 'c'));
			}
			if(k.idx>=textlen)
			{
				if(text[k.idx-1]=='\n')
					bounds.push_back(Bound(k.idx, 'e'));
				break;
			}
		}
#if 0
		const char *rHeaderTable[]=//C: extend functions
		{
		//allow newlines in header		args with mathset specifier
		//	          tn  r                  s!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
			"`````````ab``b``````````````````a````````e``````cccccccccc```````dddddddddddddddddddddddddd````d`dddddddddddddddddddddddddd`````",//a	[f]	[)]
			"`````````ab``b``````````````````a````````e``````cccccccccc```````dddddddddddddddddddddddddd`a``d`dddddddddddddddddddddddddd`````",//b	\\\r\n
			"````````````````````````````````````````````````cccccccccc```````dddddddddddddddddddddddddd````d`dddddddddddddddddddddddddd`````",//c	number	f{}
			"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^cccccccccc^^^^^^^dddddddddddddddddddddddddd^^^^d^dddddddddddddddddddddddddd^^^^^",//d	letter	f{}
			
			"`````````ef``f``````````````````e```````o```````iiiiiiiiii```````jjjjjjjjjjjjjjjjjjjjjjjjjj````j`jjjjjjjjjjjjjjjjjjjjjjjjjj`````",//e	(	[arg]
			"`````````ef``f``````````````````e```````````````iiiiiiiiii```````jjjjjjjjjjjjjjjjjjjjjjjjjj`e``j`jjjjjjjjjjjjjjjjjjjjjjjjjj`````",//f	\\\r\n

			"`````````eh``h``````````````````g```````````````iiiiiiiiii```````jjjjjjjjjjjjjjjjjjjjjjjjjj````j`jjjjjjjjjjjjjjjjjjjjjjjjjj`````",//g	arg
			"`````````eh``h``````````````````g```````````````iiiiiiiiii```````jjjjjjjjjjjjjjjjjjjjjjjjjj`g``j`jjjjjjjjjjjjjjjjjjjjjjjjjj`````",//h	\\\r\n
			"````````````````````````````````````````````````iiiiiiiiii```````jjjjjjjjjjjjjjjjjjjjjjjjjj````j`jjjjjjjjjjjjjjjjjjjjjjjjjj`````",//i	number	arg
			"`````````kl`````````````````````k```````o```g```iiiiiiiiii```````jjjjjjjjjjjjjjjjjjjjjjjjjj````j`jjjjjjjjjjjjjjjjjjjjjjjjjj`````",//j	letter	arg

			"`````````kl``l``````````````````k```````o```g``````````````````````m````m````````mm````````````````m````m````````mm`````````````",//k	, [mathset]
			"`````````kl``l``````````````````k```````````g``````````````````````m````m````````mm`````````k``````m````m````````mm`````````````",//l	\\\r\n

			"`````````mn``n``````````````````m```````o```g```````````````````````````````````````````````````````````````````````````````````",//m	,
			"`````````mn``n``````````````````m```````````g```````````````````````````````````````````````m```````````````````````````````````",//n	\\\r\n

			"`````````op``p``````````````````o```````````````qqqqqqqqqq```````rrrrrrrrrrrrrrrrrrrrrrrrrr````r`rrrrrrrrrrrrrrrrrrrrrrrrrr`````",//o	[f]
			"`````````op``p``````````````````o```````````````qqqqqqqqqq```````rrrrrrrrrrrrrrrrrrrrrrrrrr`o``r`rrrrrrrrrrrrrrrrrrrrrrrrrr`````",//p	\\\r\n
			"````````````````````````````````````````````````qqqqqqqqqq```````rrrrrrrrrrrrrrrrrrrrrrrrrr````r`rrrrrrrrrrrrrrrrrrrrrrrrrr`````",//q	number	f
			"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^qqqqqqqqqq^^^^^^^rrrrrrrrrrrrrrrrrrrrrrrrrr^^^^r^rrrrrrrrrrrrrrrrrrrrrrrrrr^^^^^" //r	letter	f
	/*	//allow newlines in header
		//	          tn  r                  s!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
			"`````````ab``b``````````````````a````````e``````cccccccccc```````dddddddddddddddddddddddddd````d`dddddddddddddddddddddddddd`````",//a	[f]	[)]
			"`````````ab``b``````````````````a````````e``````cccccccccc```````dddddddddddddddddddddddddd`a``d`dddddddddddddddddddddddddd`````",//b	\\\r\n
			"````````````````````````````````````````````````cccccccccc```````dddddddddddddddddddddddddd````d`dddddddddddddddddddddddddd`````",//c	number	f{}
			"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^cccccccccc^^^^^^^dddddddddddddddddddddddddd^^^^d^dddddddddddddddddddddddddd^^^^^",//d	letter	f{}
			
			"`````````ef``f``````````````````e```````m```````iiiiiiiiii```````jjjjjjjjjjjjjjjjjjjjjjjjjj````j`jjjjjjjjjjjjjjjjjjjjjjjjjj`````",//e	(	[arg]
			"`````````ef``f``````````````````e```````````````iiiiiiiiii```````jjjjjjjjjjjjjjjjjjjjjjjjjj`e``j`jjjjjjjjjjjjjjjjjjjjjjjjjj`````",//f	\\\r\n

			"`````````eh``h``````````````````g```````````````iiiiiiiiii```````jjjjjjjjjjjjjjjjjjjjjjjjjj````j`jjjjjjjjjjjjjjjjjjjjjjjjjj`````",//g	arg
			"`````````eh``h``````````````````g```````````````iiiiiiiiii```````jjjjjjjjjjjjjjjjjjjjjjjjjj`g``j`jjjjjjjjjjjjjjjjjjjjjjjjjj`````",//h	\\\r\n
			"````````````````````````````````````````````````iiiiiiiiii```````jjjjjjjjjjjjjjjjjjjjjjjjjj````j`jjjjjjjjjjjjjjjjjjjjjjjjjj`````",//i	number	arg
			"`````````kl`````````````````````k```````m```g```iiiiiiiiii```````jjjjjjjjjjjjjjjjjjjjjjjjjj````j`jjjjjjjjjjjjjjjjjjjjjjjjjj`````",//j	letter	arg

			"`````````kl``l``````````````````k```````m```g```````````````````````````````````````````````````````````````````````````````````",//k	,
			"`````````kl``l``````````````````k```````````g```````````````````````````````````````````````k```````````````````````````````````",//l	\\\r\n

			"`````````mn``n``````````````````m```````````````oooooooooo```````pppppppppppppppppppppppppp````p`pppppppppppppppppppppppppp`````",//m	[f]
			"`````````mn``n``````````````````m```````````````oooooooooo```````pppppppppppppppppppppppppp`m``p`pppppppppppppppppppppppppp`````",//n	\\\r\n
			"````````````````````````````````````````````````oooooooooo```````pppppppppppppppppppppppppp````p`pppppppppppppppppppppppppp`````",//o	number	f
			"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^oooooooooo^^^^^^^pppppppppppppppppppppppppp^^^^p^pppppppppppppppppppppppppp^^^^^" //p	letter	f//*/
		}, *tailTable[]=
		{
		//	          tn  r                  s!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
			"_````````a^``a``````````````````a```````````````````````````````````````````````````````````b```````````````````````````````````",//a	ws
			"_`````````a``b``````````````````````````````````````````````````````````````````````````````````````````````````````````````````" //b	\\\r\n
		};
		//state=table[state-'a'][text[k]]	>'`': continue;		=='`': return;		<'`': i=k+'_'-state;return;
		{
			std::stack<int> fStack;
			auto cIT=allComments.begin();
			for(int k=0, kEnd=cIT!=allComments.end()?cIT->first:textlen;;++k)//B: bounds
			{
				if(k>=kEnd)
				{
					if(cIT!=allComments.end())
					{
						k=cIT->second;
						++cIT;
						kEnd=cIT!=allComments.end()?cIT->first:textlen;
					}
					else
					{
						if(commentIncompleteScope&&fStack.size())
						{
							while(fStack.size()>1)		//find first '{', extend as header, push as comment
								fStack.pop();
							int cStart=fStack.top();//first '{'
							auto acIT=allComments.end();
							for(;acIT!=allComments.begin()&&acIT[-1].first>cStart;--acIT);
							char state='a';
							for(int rk=cStart, rkEnd=acIT!=allComments.begin()?acIT[-1].second:-1, newStart=-1;;--rk)//extend as header
							{
								if(rk<rkEnd)//check counter
								{
									if(acIT!=allComments.begin())
									{
										state=rHeaderTable[state-'a'][' '];
										rk=acIT[-1].first-1;
										--acIT;
										rkEnd=acIT!=allComments.begin()?acIT[-1].second:-1;
									}
									else break;
								}
								else state=rHeaderTable[state-'a'][rk<0?'\0':text[rk]];
								if(state<'a')//check for final state
								{
									if(state<'`'||newStart!=-1)//success final state or optional end reached earlier
									{
										if(state<'`')
											newStart=rk+'_'-state;
										cStart=newStart;
									}
									break;
								}
								if(state=='m'&&newStart==-1)
									newStart=rk;
							}
							closeComment(cStart, textlen);
							for(;bounds.size()>1&&bounds.rbegin()[1].first>cStart;)
								bounds.pop_back();
							if(bounds.size())
								bounds.rbegin()->first=cStart;
							bounds.push_back(std::pair<int, char>(textlen, 'e'));//separate empty expr
						}
						else if(!bounds.size()||bounds.rbegin()->first<textlen||text[textlen-1]=='\n'&&(textlen-3<0||text[textlen-3]!='\\'))
							bounds.push_back(std::pair<int, char>(textlen, 'e'));
						break;
					}
				}
				switch(text[k])
				{
				case '\\':
					if(k+1<textlen&&text[k+1]=='\r')//robust
						k+=1+(k+2<textlen&&text[k+2]=='\n');
					continue;
				case '\r':
					if(k+1<textlen&&text[k+1]=='\n')//
						++k;
				case '\n':
					bounds.push_back(std::pair<int, char>(k+1, 'e'));
					continue;
				case '{':
					fStack.push(k);
					continue;
				case '}':
					if(fStack.size())
					{
						for(;bounds.size()&&fStack.top()<bounds.rbegin()->first;)
							bounds.pop_back();
						int start=bounds.size()?bounds.rbegin()->first:0;
						if(start<fStack.top())
							bounds.push_back(std::pair<int, char>(fStack.top(), 'e'));
						bounds.push_back(std::pair<int, char>(k+1, 'f'));
						fStack.pop();
					}
					continue;
				}
			}
		}
		{
			auto cIT=allComments.begin(), acIT=cIT;
			for(int b=0, bEnd=bounds.size();b<bEnd;++b)
			{
				if(bounds[b].second=='f')
				{
					if(b)
					{
						for(;cIT!=allComments.end()&&cIT->first<bounds[b-1].first;++cIT);//cIT[-1]: last comment before function b start
						acIT=cIT;
						char state='a';
						for(int rk=bounds[b-1].first-1, rkEnd=acIT!=allComments.begin()?acIT[-1].second:-1, newStart=-1;;--rk)//header/whitespace before function
						{
							if(rk<rkEnd)//check counter
							{
								if(acIT!=allComments.begin())
								{
									state=rHeaderTable[state-'a'][' '];
									rk=acIT[-1].first-1;
									--acIT;
									rkEnd=acIT!=allComments.begin()?acIT[-1].second:-1;
								}
								else break;
							}
							else state=rHeaderTable[state-'a'][rk<0?'\0':text[rk]];
							if(state<'a')//check state
							{
								if(state<'`'||newStart!=-1)
								{
									if(state<'`')
										newStart=rk+'_'-state;
									if(newStart==0)
									{
										bounds.erase(bounds.begin(), bounds.begin()+b);
										bEnd-=b, b=0;
									}
									else
									{
										for(int rb2=b-1;rb2>=0;--rb2)
										{
											if(rb2==0||bounds[rb2-1].first<newStart)//prev bound rb2 start
											{
												if(rb2+1<b)
												{
													bounds.erase(bounds.begin()+rb2+1, bounds.begin()+b);
													bEnd-=b-(rb2+1), b=rb2+1;
												}
												break;
											}
										}
										bounds[b-1].first=newStart;
									}
								}
								break;
							}
							if(state=='m'&&newStart==-1)
								newStart=rk;
						}
					}
					if(b+1<bEnd)
					{
						for(;cIT!=allComments.end()&&cIT->first<bounds[b].first;++cIT);//cIT: first comment after function b end
						acIT=cIT;
						char state='a';
						for(int k=bounds[b].first, kEnd=acIT!=allComments.end()?acIT->first:textlen+1;;++k)//whitespace after function
						{
							if(k>=kEnd)
							{
								if(acIT!=allComments.end())
								{
									k=acIT->second;
									state=tailTable[state-'a'][' '];
									++acIT;
									kEnd=acIT!=allComments.end()?acIT->first:textlen+1;
								}
								else break;
							}
							else state=tailTable[state-'a'][text[k]];
							if(state<'a')
							{
								if(state<'`')
								{
									int newEnd=k+'_'-state;
									for(int b2=b+1;;++b2)
									{
										if(b2==bounds.size()||newEnd<=bounds[b2].first)//next bound end b+1
										{
											b2+=newEnd==bounds[b2].first;
											if(b+1<b2)
											{
												bounds.erase(bounds.begin()+b+1, bounds.begin()+b2);
												bEnd-=b2-(b+1);
											}
											bounds[b].first=newEnd;
											break;
										}
									}
								}
								break;
							}
						}
					}
				}
			}
		}
#endif
	}
	for(int b=0, bEnd=bounds.size(), e=0, func=0;b<bEnd;++b)//D: find change extent
	{
		if(bounds[b].first>i||bounds[b].first!=oldbounds[b].first)
		{
			boundChangeStart=b;
			exprChangeStart=e, functionChangeStart=func;
			if(b==bounds.size()||b==oldbounds.size()||bounds[b].second=='f')//recompile everything below when changing a function
		//	if(bounds[b].second=='f')
			{
				boundRemoveEnd=oldbounds.size(), boundInsertEnd=bounds.size();
				break;
			}
			int dk=fi-fr;
			bool diff_enc=bounds[b].first!=oldbounds[b].first+dk*(bounds[b].first>i), end_unas=true;
			if(!diff_enc)
				++b;
			for(int ob=b, oldBoundEnd=oldbounds.size();;)
			{
				if(b>=bEnd||ob>=oldBoundEnd)
				{
					if(diff_enc||end_unas)
						boundRemoveEnd=oldbounds.size(), boundInsertEnd=bEnd;
					else if(boundRemoveEnd==oldbounds.size())
						boundInsertEnd=bEnd;
					else if(boundInsertEnd==bEnd)
						boundRemoveEnd=oldbounds.size();
					break;
				}
				if(oldbounds[ob].second=='f'||bounds[b].second=='f')//recompile everything below when changing a function
				{
					boundRemoveEnd=oldbounds.size(), boundInsertEnd=bounds.size();
					break;
				}
				int obf=oldbounds[ob].first+dk*(oldbounds[ob].first>i);
				if(bounds[b].first<obf)
				{
					diff_enc=true;
					++b;
				}
				else if(bounds[b].first>obf)
				{
					diff_enc=true;
					++ob;
				}
				else
				{
					if(bounds[b].second!=oldbounds[ob].second)
					{
						if(b+1<bEnd&&ob+1<oldBoundEnd&&bounds[b+1].first==oldbounds[ob+1].first+dk&&bounds[b+1].second==oldbounds[ob+1].second&&fr<oldbounds[ob+1].first&&fi<bounds[b+1].first)//diff typ~, same>f
							boundRemoveEnd=ob+1, boundInsertEnd=b+1, diff_enc=false, end_unas=false;
						else
							diff_enc=true;//diff typ~
					}
					else if(diff_enc)//diff~, diff start~
						boundRemoveEnd=ob+1, boundInsertEnd=b+1, diff_enc=false, end_unas=false;
					else if(ob>0&&b>0&&oldbounds[ob-1].first>=fr&&bounds[b-1].first>=fi&&(ob==1||b==1||oldbounds[ob-2].first<fr||bounds[b-2].first<fi))
						boundRemoveEnd=ob, boundInsertEnd=b, diff_enc=false, end_unas=false;
					++b, ++ob;
				}
			}
			break;
		}
		if(bounds[b].second=='e')
			++e;
		else
			++func;
	}
	int b=boundChangeStart, e=exprChangeStart, func=functionChangeStart;//E: change in expr and functions
	for(;b<boundRemoveEnd;++b)
		e+=oldbounds[b].second&1, func+=(oldbounds[b].second&2)!=0;
/*	{
		if(oldbounds[b].second=='e')
			++e;
		else
			++func;
	}//*/
	exprRemoveEnd=e, functionRemoveEnd=func;
	b=boundChangeStart, e=exprChangeStart, func=functionChangeStart;
	for(;b<boundInsertEnd;++b)
	{
		if(bounds[b].second=='e')
			++e;
		else
			++func;
	}
	exprInsertEnd=e, functionInsertEnd=func;
}
void			InputTextBox::replaceText(int i, int f, const char *a, int len)
{
	lineChangeStart=getLineNo(0, 0, i);
	lineRemoveEnd=getLineNo(i, lineChangeStart, f)+1;

	//remove
	if(i<f)
	{
		histlen=histpos+f-i, history=(int*)realloc(history, histlen*sizeof(int));
		for(int k=0;k<f-i;++k)				history[histpos+k]=(f-1-k)<<10|cont<<9|1<<8|text[f-1-k	], cont=1;
		for(int k=f;k<=textlen;++k)			text[k-f+i]=text[k];
		textlen-=f-i, histpos=histlen, cursor=selcur=i;
	}
	//insert
	text=(char*)realloc(text, (textlen+1+len)*sizeof(char));
	histlen=histpos+len, history=(int*)realloc(history, histlen*sizeof(int));
	for(int k=0;k<len;++k)				history[histpos+k]=(i+k	)<<10|cont<<9|0<<8|a	[k		], cont=1;
	for(int k=textlen;k>=cursor;--k)	text[k+len]=text[k];
	memcpy(&text[cursor], a, len*sizeof(char));
	textlen+=len, histpos=histlen, cursor=selcur=cursor+len;
	replaceText_update(i, f, i+len);

	lineInsertEnd=getLineNo(0, 0, i+len)+1;
}
void			InputTextBox::insertText(int o, const char *a, int len)
{
	lineChangeStart=getLineNo(0, 0, o);
	lineRemoveEnd=lineChangeStart+1;

	text=(char*)realloc(text, (textlen+1+len)*sizeof(char));
	histlen=histpos+len, history=(int*)realloc(history, histlen*sizeof(int));
	for(int k=0;k<len;++k)				history[histpos+k]=(o+k	)<<10|cont<<9|0<<8|a	[k		], cont=1;//position, action continuity, insert, character
	for(int k=textlen;k>=cursor;--k)	text[k+len]=text[k];
	memcpy(&text[cursor], a, len*sizeof(char));
	textlen+=len, histpos=histlen, cursor=selcur=cursor+len;
	replaceText_update(o, o, o+len);

	lineInsertEnd=getLineNo(0, 0, o+len)+1;
}
void			InputTextBox::removeText(int i, int f)
{
	lineChangeStart=getLineNo(0, 0, i);
	lineRemoveEnd=getLineNo(i, lineChangeStart, f)+1;

	histlen=histpos+f-i, history=(int*)realloc(history, histlen*sizeof(int));
	for(int k=0;k<f-i;++k)				history[histpos+k]=(f-1-k)<<10|cont<<9|1<<8|text[f-1-k	], cont=1;//position, action continuity, remove, character
	for(int k=f;k<=textlen;++k)			text[k-f+i]=text[k];
	textlen-=f-i, histpos=histlen, cursor=selcur=i;
	text=(char*)realloc(text, (textlen+1)*sizeof(char));
	replaceText_update(i, f, i);

	lineInsertEnd=lineChangeStart+1;

}
int				InputTextBox::switchToWithMouseOn	(int lParam){cont=0;return TextBox::switchToWithMouseOn(lParam);}
int				InputTextBox::inputLButtonDown		(int lParam){cont=0;return TextBox::inputLButtonDown(lParam);}
int				InputTextBox::inputKeyDown(int wParam, int lParam)
{
	if(kb[VK_CONTROL])
	{
		switch(wParam)
		{
		case VK_CAPITAL:				return 0;
		case VK_NUMLOCK:				return 0;
		case VK_OEM_3:					return 0;
		case '1':						return 0;
		case '2':						return 0;
		case '3':						return 0;
		case '4':						return 0;
		case '5':						return 0;
		case '6':						return 0;
		case '7':						return 0;
		case '8':						return 0;
		case '9':						return 0;
		case '0':						return 0;
		case VK_OEM_MINUS:				return 0;
		case VK_OEM_PLUS:				return 0;
		case 'Q':						return 0;
		case 'W':						return 0;
		case 'E':						return 0;
		case 'R':						return 0;
		case 'T':						return 0;
		case 'Y':
			if(histpos<histlen)
			{
				int rStart, rEnd;
				int iStart, iEnd;
				bool remove, insert;
				{
					int ph=histpos;
					bool allowInsert=true;
					if(remove=(history[ph]&0x00000100)!=0)
					{
						rStart=history[ph]>>10&0x003FFFFF, rEnd=rStart+1;
						++ph;
						for(;ph<histlen&&history[ph]&0x00000200&&history[ph]&0x00000100;++ph)
						{
						//	int LOL_1=history[ph]>>10&0x003FFFFF;
							if((history[ph]>>10&0x003FFFFF)<rStart)
								--rStart;//backspace
							else
								++rEnd;//delete
						//	if((history[ph]>>10&0x003FFFFF)==rStart)
						//		++rEnd;//delete
						//	else
						//		--rStart;//backspace
						//	if(rStart<(history[ph]>>10&0x003FFFFF))//what?
						//		--rStart;//backspace
						//	else
						//		++rEnd;//delete
						}
						allowInsert=(history[ph]&0x00000200)!=0;
					}
					if(insert=allowInsert&&!(history[ph]&0x00000100))
					{
						iStart=history[ph]>>10&0x003FFFFF, iEnd=iStart+1;
						++ph;
						for(;ph<histlen&&history[ph]&0x00000200;++ph)
					//	for(;ph<histlen&&history[ph]&0x00000200&&!(history[ph]&0x00000100);++ph)
							++iEnd;
						if(!remove)
							rStart=rEnd=iStart;
					}
					else
						iStart=iEnd=rStart;
				}
				lineChangeStart=getLineNo(0, 0, iStart);
				if(remove)
				{
					lineRemoveEnd=getLineNo(iStart, lineChangeStart, rEnd)+1;
					for(int k=rStart, k2=rEnd;k2<=textlen;++k, ++k2)
						text[k]=text[k2];
					histpos+=rEnd-rStart;
					cursor=selcur=rStart;
				}
				else
					lineRemoveEnd=lineChangeStart+1;
				if(iEnd!=rEnd)
					textlen+=iEnd-rEnd, text=(char*)realloc(text, (textlen+1)*sizeof(char));
				if(insert)
				{
					for(int k=textlen-(iEnd-iStart), k2=textlen;k>=iStart;--k, --k2)
						text[k2]=text[k];
					for(int k=iStart;k<iEnd;++k, ++histpos)
						text[k]=char(history[histpos]);
					lineInsertEnd=getLineNo(0, 0, iEnd)+1;
					cursor=selcur=iEnd;
				}
				else
					lineInsertEnd=lineChangeStart+1;
				replaceText_update(iStart, rEnd, iEnd);
				cursorTeleport();
				cont=0;//
			}
		/*	removedExEnd=insertedExEnd=-1;
			removeText_update(0, textlen);
			for(;histpos<histlen;)
			{
				int k=history[histpos]>>10&0x003FFFFF;
				if(!(history[histpos]&0x00000100))
				{
					++textlen, text=(char*)realloc(text, (textlen+1)*sizeof(char)), cursor=selcur=k+1;
					for(int k2=textlen;k2>k;--k2)text[k2]=text[k2-1];
					text[k]=history[histpos]&0x000000FF;
				}
				else
				{
					for(int k2=k;k2<textlen;++k2)text[k2]=text[k2+1];
					--textlen, text=(char*)realloc(text, (textlen+1)*sizeof(char)), cursor=selcur=k;
				}
				++histpos;
				if(histpos<histlen)if(!(history[histpos]&0x00000200))break;
			}
			insertText_update(0, textlen);//*/
			return 2;
		case 'U':						return 0;
		case 'I':						return 0;
		case 'O':						return 0;
		case 'P':						return 0;
		case VK_OEM_4:					return 0;
		case VK_OEM_6:					return 0;
		case 'A':
			cursor=textlen;
			cursorTeleport();
			cont=0, selcur=0;
			return 1;
		case 'S':						return 0;
		case 'D':
			histpos=0, histlen=0, history=(int*)realloc(history, histlen*sizeof(int));
			return 0;
		case 'F':						return 0;
		case 'G':						return 0;
		case 'H':						return 0;
		case 'J':						return 0;
		case 'K':						return 0;
		case 'L':						return 0;
		case VK_OEM_1:					return 0;
		case VK_OEM_7:					return 0;
		case VK_OEM_5:case VK_OEM_102:	return 0;
		case 'Z':
			if(histpos>0)
			{
				int urStart, urEnd;
				int uiStart, uiEnd;
				bool undoInsert, undoRemove, backspace=true;
				{
					int ph=histpos-1;
					bool allowUndoRemove=true;
					if(undoInsert=!(history[ph]&0x00000100))//undo insert?
					{
						uiStart=history[ph]>>10&0x003FFFFF, uiEnd=uiStart+1;
						if(history[ph]&0x00000200)//continue?
						{
							for(;ph;)
							{
								--ph;
								if(history[ph]&0x00000100)//next undo remove?
									break;
								--uiStart;
								if(!(history[ph]&0x00000200))//stop?
								{
									allowUndoRemove=false;
									break;
								}
							}
						}
						else
							allowUndoRemove=false;
					}
					if(undoRemove=allowUndoRemove&&(history[ph]&0x00000100)!=0)//undo remove?
					{
						urStart=history[ph]>>10&0x003FFFFF, urEnd=urStart+1;
						for(;ph&&history[ph]&0x00000200;)//continue?
						{
							--ph;
							backspace=(history[ph]>>10&0x003FFFFF)>urStart;//undo moves to the right?
							++urEnd;
						}
						if(!undoInsert)
							uiStart=uiEnd=urStart;
					}
					else
						urStart=urEnd=uiStart;
				}
				lineChangeStart=getLineNo(0, 0, urStart);
				if(undoInsert)
				{
					lineRemoveEnd=getLineNo(urStart, lineChangeStart, uiEnd)+1;
					for(int k=uiStart, k2=uiEnd;k2<=textlen;++k, ++k2)
						text[k]=text[k2];
					histpos-=uiEnd-uiStart;
					cursor=selcur=uiStart;
				}
				else
					lineRemoveEnd=lineChangeStart+1;
				if(urEnd!=uiEnd)
					textlen+=urEnd-uiEnd, text=(char*)realloc(text, (textlen+1)*sizeof(char));
				if(undoRemove)
				{
					for(int k=textlen-(urEnd-urStart), k2=textlen;k>=urStart;--k, --k2)
						text[k2]=text[k];
					if(backspace)
					{
						for(int k=urStart;k<urEnd;++k)
						{
							--histpos;
							text[k]=char(history[histpos]);
						}
					}
					else
					{
						for(int k=urEnd-1;k>=urStart;--k)
						{
							--histpos;
							text[k]=char(history[histpos]);
						}
					}
					cursor=selcur=urEnd;
					lineInsertEnd=getLineNo(0, 0, urEnd)+1;
				}
				else
					lineInsertEnd=lineChangeStart+1;
				replaceText_update(urStart, uiEnd, urEnd);
				cursorTeleport();
				cont=0;//
			}
			return 2;
		case 'X':
		case 'C':
			if(cursor!=selcur)
			{
				int k=cursor<selcur?cursor:selcur, k2=cursor>selcur?cursor:selcur;
				char *clipboard=(char*)LocalAlloc(LMEM_FIXED, (k2-k+1)*sizeof(char));
				memcpy(clipboard, &text[k], (k2-k)*sizeof(char));
				clipboard[k2-k]='\0';
				OpenClipboard(ghWnd), EmptyClipboard(), SetClipboardData(CF_OEMTEXT, (void*)clipboard), CloseClipboard();
				if(wParam=='X')
				{
					removeText(k, k2);
					return 2;
				}
				if(wParam=='X')
					cursorTeleport();
			}
			return 0;
		case 'V':
			{
				OpenClipboard(ghWnd);
				char *clipboard=(char*)GetClipboardData(CF_OEMTEXT);	if(!clipboard				){CloseClipboard();break;}
				int size=strlen(clipboard);								if(size<=0||size>0x003FFFFF	){CloseClipboard();break;}
				char *a=(char*)malloc((size+1)*sizeof(char));
				memcpy(a, clipboard, (size+1)*sizeof(char)), CloseClipboard();
				for(int k=0;k<size;++k)
				{
					if(a[k]=='\r'&&a[k+1]!='\n')
					{
						++k, ++size, a=(char*)realloc(a, (size+1)*sizeof(char));
						for(int k2=size-1;k2>k;++k2)a[k2]=a[k2-1];	a[k]='\n';
					}
					else if(a[k]&0x80)//UNICODE UTF-8
					{
						free(a);
						return 0;
					}
					//	a[k]=' ';
					//	a[k]&=0x7F;
				}
				cont=0;
				replaceText(cursor<selcur?cursor:selcur, cursor>selcur?cursor:selcur, a, size);
				cursorTeleport();
				free(a);
				cont=0;//
			}
			return 2;
		case 'B':						return 0;
		case 'N':						return 0;
		case 'M':						return 0;
		case VK_OEM_COMMA:				return 0;
		case VK_OEM_PERIOD:				return 0;
		case VK_OEM_2:					return 0;
		case VK_SPACE:					return 0;
		case VK_NUMPAD0:				return 0;
		case VK_NUMPAD1:				return 0;
		case VK_NUMPAD2:				return 0;
		case VK_NUMPAD3:				return 0;
		case VK_NUMPAD4:				return 0;
		case VK_NUMPAD5:				return 0;
		case VK_NUMPAD6:				return 0;
		case VK_NUMPAD7:				return 0;
		case VK_NUMPAD8:				return 0;
		case VK_NUMPAD9:				return 0;
		case VK_DECIMAL:				return 0;
		case VK_ADD:					return 0;
		case VK_SUBTRACT:				return 0;
		case VK_MULTIPLY:				return 0;
		case VK_DIVIDE:					return 0;
		case VK_DELETE:					return 0;
		case VK_BACK:					return 0;
		case VK_RETURN:					return 0;
		case VK_UP:
			if(th>bh)
			{
				tpy=tpy-fontH<0?0:tpy-fontH;
				return 1;
			}
			return 0;
		case VK_DOWN:
			if(th>bh)
			{
				tpy=tpy+fontH>th-bh?th-bh:tpy+fontH;
				return 1;
			}
			return 0;
		case VK_LEFT:
			if(cursor)
			{
				char initial=mapChar(text[--cursor]);
				for(;cursor;--cursor)
					if(mapChar(text[cursor-1])!=initial)
						break;
				cont=0;
				cursorTeleport();
				return 1;
			}
			if(selcur!=cursor&&!kb[VK_SHIFT])
			{
				selcur=cursor;
				return 1;
			}
			return 0;
		case VK_RIGHT:
			if(cursor!=textlen)
			{
				char initial=mapChar(text[cursor++]);
				for(;cursor!=textlen;++cursor)
					if(mapChar(text[cursor])!=initial)
						break;
				cont=0;
				cursorTeleport();
				return 1;
			}
			if(selcur!=cursor&&!kb[VK_SHIFT])
			{
				selcur=cursor;
				return 1;
			}
			return 0;
		case VK_HOME:
			if(cursor)
			{
				cursor=0, cont=0;
				cursorTeleport();
				return 1;
			}
			if(selcur!=cursor&&!kb[VK_SHIFT])
			{
				selcur=cursor;
				return 1;
			}
			return 0;
		case VK_END:
			if(cursor!=textlen)
			{
				cursor=textlen, cont=0;
				cursorTeleport();
				return 1;
			}
			if(selcur!=cursor&&!kb[VK_SHIFT])
			{
				selcur=cursor;
				return 1;
			}
			return 0;
		case VK_ESCAPE:case VK_F1:case VK_F2:case VK_F3:case VK_F4:case VK_F5:case VK_F6:case VK_F7:case VK_F8:case VK_F9:case VK_F10:case VK_F11:case VK_F12:case VK_INSERT:	return 0;
		case VK_F13:case VK_F14:case VK_F15:case VK_F16:case VK_F17:case VK_F18:case VK_F19:case VK_F20:case VK_F21:case VK_F22:case VK_F23:case VK_F24:						return 0;
		case VK_TAB:					return 0;
		case VK_SHIFT:					return 0;
		case VK_CONTROL:case VK_LWIN:	return 0;
		case VK_PRIOR:case VK_NEXT:		return 0;
		default:						return 0;
		}
	}
	else//ctrl is up
	{
		char character=caps_lock!=kb[VK_SHIFT];
	//	char character=-(caps_lock!=kb[VK_SHIFT]);
	//	char character=caps_lock&&!kb[VK_SHIFT]||!caps_lock&&kb[VK_SHIFT]?-1:0;
		switch(wParam)
		{
		case VK_CAPITAL:				return 0;
		case VK_NUMLOCK:				return 0;
		case VK_OEM_3:					character=kb[VK_SHIFT]	?'~':	'`'	;	break;
		case '0':						character=kb[VK_SHIFT]	?')':	'0'	;	break;
		case '1':						character=kb[VK_SHIFT]	?'!':	'1'	;	break;
		case '2':						character=kb[VK_SHIFT]	?'@':	'2'	;	break;
		case '3':						character=kb[VK_SHIFT]	?'#':	'3'	;	break;
		case '4':						character=kb[VK_SHIFT]	?'$':	'4'	;	break;
		case '5':						character=kb[VK_SHIFT]	?'%':	'5'	;	break;
		case '6':						character=kb[VK_SHIFT]	?'^':	'6'	;	break;
		case '7':						character=kb[VK_SHIFT]	?'&':	'7'	;	break;
		case '8':						character=kb[VK_SHIFT]	?'*':	'8'	;	break;
		case '9':						character=kb[VK_SHIFT]	?'(':	'9'	;	break;
		case VK_OEM_MINUS:				character=kb[VK_SHIFT]	?'_':	'-'	;	break;
		case VK_OEM_PLUS:				character=kb[VK_SHIFT]	?'+':	'='	;	break;
		case VK_TAB:					character=						'\t';	break;
		case 'Q':						character=character		?'Q':	'q'	;	break;
		case 'W':						character=character		?'W':	'w'	;	break;
		case 'E':						character=character		?'E':	'e'	;	break;
		case 'R':						character=character		?'R':	'r'	;	break;
		case 'T':						character=character		?'T':	't'	;	break;
		case 'Y':						character=character		?'Y':	'y'	;	break;
		case 'U':						character=character		?'U':	'u'	;	break;
		case 'I':						character=character		?'I':	'i'	;	break;
		case 'O':						character=character		?'O':	'o'	;	break;
		case 'P':						character=character		?'P':	'p'	;	break;
		case VK_OEM_4:					character=kb[VK_SHIFT]	?'{':	'['	;	break;
		case VK_OEM_6:					character=kb[VK_SHIFT]	?'}':	']'	;	break;
		case 'A':						character=character		?'A':	'a'	;	break;
		case 'S':						character=character		?'S':	's'	;	break;
		case 'D':						character=character		?'D':	'd'	;	break;
		case 'F':						character=character		?'F':	'f'	;	break;
		case 'G':						character=character		?'G':	'g'	;	break;
		case 'H':						character=character		?'H':	'h'	;	break;
		case 'J':						character=character		?'J':	'j'	;	break;
		case 'K':						character=character		?'K':	'k'	;	break;
		case 'L':						character=character		?'L':	'l'	;	break;
		case VK_OEM_1:					character=kb[VK_SHIFT]	?':':	';'	;	break;
		case VK_OEM_7:					character=kb[VK_SHIFT]	?'"':	'\'';	break;
		case VK_OEM_5:case VK_OEM_102:	character=kb[VK_SHIFT]	?'|':	'\\';	break;
		case 'Z':						character=character		?'Z':	'z'	;	break;
		case 'X':						character=character		?'X':	'x'	;	break;
		case 'C':						character=character		?'C':	'c'	;	break;
		case 'V':						character=character		?'V':	'v'	;	break;
		case 'B':						character=character		?'B':	'b'	;	break;
		case 'N':						character=character		?'N':	'n'	;	break;
		case 'M':						character=character		?'M':	'm'	;	break;
		case VK_OEM_COMMA:				character=kb[VK_SHIFT]	?'<':	','	;	break;
		case VK_OEM_PERIOD:				character=kb[VK_SHIFT]	?'>':	'.'	;	break;
		case VK_OEM_2:					character=kb[VK_SHIFT]	?'?':	'/'	;	break;
		case VK_SPACE:					character=						' '	;	break;
		case VK_NUMPAD0:				character=						'0'	;	break;
		case VK_NUMPAD1:				character=						'1'	;	break;
		case VK_NUMPAD2:				character=						'2'	;	break;
		case VK_NUMPAD3:				character=						'3'	;	break;
		case VK_NUMPAD4:				character=						'4'	;	break;
		case VK_NUMPAD5:				character=						'5'	;	break;
		case VK_NUMPAD6:				character=						'6'	;	break;
		case VK_NUMPAD7:				character=						'7'	;	break;
		case VK_NUMPAD8:				character=						'8'	;	break;
		case VK_NUMPAD9:				character=						'9'	;	break;
		case VK_DECIMAL:				character=						'.'	;	break;
		case VK_ADD:					character=						'+'	;	break;
		case VK_SUBTRACT:				character=						'-'	;	break;
		case VK_MULTIPLY:				character=						'*'	;	break;
		case VK_DIVIDE:					character=						'/'	;	break;
		case VK_DELETE:
			if(cursor!=selcur)
			{
				cont=0;
				removeText(cursor<selcur?cursor:selcur, cursor>selcur?cursor:selcur);
				cursorTeleport();
				return 2;
			}
			else if(text[cursor])
			{
				cont=0;
				removeText(cursor, cursor+1+(text[cursor]=='\r'));
				cursorTeleport();
				return 2;
			}
			return 0;
		case VK_BACK:
			if(cursor!=selcur)
			{
				cont=0;
				removeText(cursor<selcur?cursor:selcur, cursor>selcur?cursor:selcur);
				cursorTeleport();
				return 2;
			}
			else if(cursor)
			{
				cont=0;
				removeText(cursor-(text[cursor-1]=='\n'?2:1), cursor);
				cursorTeleport();
				return 2;
			}
			return 0;
		case VK_RETURN:					character=						'\r';	break;
		case VK_UP:
			for(int k=cursor-2;k>=0;--k)
			{
				if(text[k]=='\r')
				{
					selectFont();
				//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
					int x=getTextWidth(text, k+2, cursor, 0), x2=0;
				//	int x=font.getTextW(text, k+2, cursor), x2=0;
					for(;;--k)
						if(!k||text[k-1]=='\n')
							break;
					for(int k2=k;;++k2)
					{
						if(text[k2]=='\r')
						{
							cursor=k2;
							break;
						}
						int tx2;
						if(text[k2]=='\t')
							tx2=getTextWidth(text, k, k2+1, 0);
						//	tx2=font.getTextW(text, k, k2+1);
						else
							tx2=x2+fontW[text[k2]];
						if(tx2>x)
						{
							cursor=tx2-(tx2-x2)/2>x?k2:k2+1;
							break;
						}
						x2=tx2;
					}
					deselectFont();
				//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
					cursorTeleport();
					cont=0;
					return 1;
				}
			}
			if(selcur!=cursor&&!kb[VK_SHIFT])
			{
				selcur=cursor;
				return 1;
			}
			return 0;
		case VK_DOWN:
			for(int k=cursor;k<textlen;++k)//find next newline
			{
				if(text[k]=='\n')
				{
					selectFont();
				//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
					int k2=cursor;
					for(;k2>0;--k2)//find start of current line
						if(text[k2-1]=='\n')
							break;
					int x=getTextWidth(text, k2, cursor, 0), x2=0;//start of line till cursor
				//	int x=font.getTextW(text, k2, cursor), x2=0;
					for(int k2=++k;;++k2)
					{
						if(text[k2]=='\r'||k2==textlen)
						{
							cursor=k2;
							break;
						}
						int tx2;
						if(text[k2]=='\t')
							tx2=getTextWidth(text, k, k2+1, 0);
						//	tx2=font.getTextW(text, k, k2+1);
						else
							tx2=x2+fontW[text[k2]];
						if(tx2>x)
						{
							cursor=tx2-(tx2-x2)/2>x?k2:k2+1;
							break;
						}
						x2=tx2;
					}
					deselectFont();
				//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
					cursorTeleport();
					cont=0;
					return 1;
				}
			}
			if(selcur!=cursor&&!kb[VK_SHIFT])
			{
				selcur=cursor;
				return 1;
			}
			return 0;
		case VK_LEFT:
			if(cursor)
			{
				cursor-=text[cursor-1]=='\n'?2:1, cont=0;
				cursorTeleport();
				return 1;
			}
			if(selcur!=cursor&&!kb[VK_SHIFT])
			{
				selcur=cursor;
				return 1;
			}
			return 0;
		case VK_RIGHT:
			if(text[cursor])
			{
				cursor+=text[cursor]=='\r'?2:1, cont=0;
				cursorTeleport();
				return 1;
			}
			if(selcur!=cursor&&!kb[VK_SHIFT])
			{
				selcur=cursor;
				return 1;
			}
			return 0;
		case VK_HOME:
			if(cursor&&text[cursor-1]!='\n')
			{
				for(;;--cursor)
					if(!cursor||text[cursor-1]=='\n')
					{
						cont=0;
						break;
					}
				cursorTeleport();
				return 1;
			}
			if(selcur!=cursor&&!kb[VK_SHIFT])
			{
				selcur=cursor;
				return 1;
			}
			return 0;
		case VK_END:
			if(text[cursor]!='\r'&&text[cursor])
			{
				for(;;++cursor)
					if(text[cursor]=='\r'||!text[cursor])
					{
						cont=0;
						break;
					}
				cursorTeleport();
				return 1;
			}
			if(selcur!=cursor&&!kb[VK_SHIFT])
			{
				selcur=cursor;
				return 1;
			}
			return 0;
		case VK_ESCAPE:case VK_F1:case VK_F2:case VK_F3:case VK_F4:case VK_F5:case VK_F6:case VK_F7:case VK_F8:case VK_F9:case VK_F10:case VK_F11:case VK_F12:case VK_INSERT:	return 0;
		case VK_F13:case VK_F14:case VK_F15:case VK_F16:case VK_F17:case VK_F18:case VK_F19:case VK_F20:case VK_F21:case VK_F22:case VK_F23:case VK_F24:						return 0;
		case VK_SHIFT:					return 0;
		case VK_CONTROL:case VK_LWIN:	return 0;
		case VK_PRIOR:case VK_NEXT:		return 0;
		default:						return 0;
		}
		if(character>0)
		{
			int start, end;
			if(cursor<selcur)
				start=cursor, end=selcur;
			else
				start=selcur, end=cursor;
			if(character!='\r')
				replaceText(start, end, &character, 1), cont=1;
			else
			{
				static const char newline[]="\r\n";
				replaceText(start, end, newline, 2), cont=0;
			}
		//	toTeleportCursor=true;
			cursorTeleport();
			return 2;
		}
	}
	return 0;
}
void			InputTextBox::draw()
{
	int xc, yc;
	rgn.use();
//	useRegion();
//	SelectClipRgn(ghMemDC, hRgn);
	tw=th=0;
	int bkMode=setBkMode(OPAQUE), bkColor=setBkColor(0xFFFFFF);
//	int bkMode=getBkMode(), bkColor=getBkColor();
//	int bkMode=GetBkMode(ghMemDC), bkColor=GetBkColor(ghMemDC);
//	SetBkMode(ghMemDC, TRANSPARENT);
	int const selectColor=active?0xFFFF96:0x969696, errorColor=0x0000FF, selectErrorColor=active?0x7F7FCA:0x4B4BCA;
//	int const selectColor=active?0xFFFF96:0x969696, errorColor=0x7F7FFF, selectErrorColor=active?0xBFBFCA:0x8A8ACA;
/*	unsigned char errorBkR=0xFF, errorBkG=0x7F, errorBkB=0x7F;
//	unsigned char errorBkR=0xFF, errorBkG=0, errorBkB=0;
	unsigned char selectionBkR, selectionBkG, selectionBkB;
	if(active)
		selectionBkR=0x96, selectionBkG=0xFF, selectionBkB=0xFF;
	else
		selectionBkR=0x96, selectionBkG=0x96, selectionBkB=0x96;//*/
	{
		bool firstBoundFunction=bounds.size()&&bounds[0].second=='f';
		Expression *it=firstBoundFunction?&userFunctionDefinitions[0]:&expr[0];
	//	Expression *it=bounds.size()?bounds[0].second=='f'?&userFunctionDefinitions[0]:&expr[0]:nullptr;
		unsigned kSE=0;
		int k, k2;
		if(cursor<selcur)
			k=cursor, k2=selcur;
		else
			k=selcur, k2=cursor;
		bool inError=false;
		for(int k3=0, k4=0, x=0, y=0, b=0, bEnd=bounds.size(), e=-int(firstBoundFunction), func=int(firstBoundFunction)-1;k4<=textlen;++k4)
		{
			if(k4==bounds[b].first)
			{
				++b;
				if(b<bEnd)
				{
					if(bounds[b].second=='e')
					{
						++e;
						it=&expr[e];
					}
					else
					{
						++func;
						it=&userFunctionDefinitions[func];
					}
					kSE=0;
				}
			}
			if(kSE<it->syntaxErrors.size())
			{
				if(k4==it->syntaxErrors[kSE].first)//red text
				{
				//	if(k3<k4)
				//	{
						x+=(short)print(bpx+x-tpx, bpy+y-tpy, bpx-tpx, &text[k3], k4-k3);
					//	x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
						k3=k4;
				//	}//*/
				//	if(k4==cursor)
				//		xc=x, yc=y;
					if(k4>k&&k4<k2)//has been in selection: average color
						setBkColor(selectErrorColor);
					//	SetBkColor(ghMemDC, selectErrorColor);
					else
						setBkMode(OPAQUE), setBkColor(errorColor);
					//	SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, errorColor);
				//	SetBkMode(ghMemDC, OPAQUE);
				//	SetBkColor(ghMemDC, k4>k&&k4<k2?selectErrorColor:errorColor);
				/*	int bg=GetBkColor(ghMemDC);
					auto pbg=(unsigned char*)&bg;
					SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, (pbg[2]+errorBkB)/2<<16|(pbg[1]+errorBkG)/2<<8|(pbg[0]+errorBkR)/2);//*/
				//	SetBkColor(ghMemDC, ((bg>>16)+0)/2<<16|(unsigned char(bg>>8)+0)/2<<8|(unsigned char(bg)+0)/2<<16);
				//	SetTextColor(ghMemDC, 0x0000FF);
					inError=true;
				}
				if(k4==it->syntaxErrors[kSE].second)//black text
				{
				//	k4+=it->syntaxErrors[kSE].first==it->syntaxErrors[kSE].second&&text[it->syntaxErrors[kSE].second]!='\r';
					x+=(short)print(bpx+x-tpx, bpy+y-tpy, bpx-tpx, &text[k3], k4-k3);
				//	x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
					k3=k4;
					++kSE;
					if(kSE>=it->syntaxErrors.size()||k4!=it->syntaxErrors[kSE].first)
					{
						if(k4>k&&k4<k2)//has been in selection
							setBkColor(selectColor);
						//	SetBkColor(ghMemDC, selectColor);
						else
							setBkMode(bkMode), setBkColor(bkColor);
						//	SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
					/*	int bg=GetBkColor(ghMemDC);
						auto pbg=(unsigned char*)&bg;
						SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, (2*pbg[2]-errorBkB)<<16|(2*pbg[1]-errorBkG)<<8|(2*pbg[0]-errorBkR));//*/
					//	SetTextColor(ghMemDC, 0);
						inError=false;
					}
				}
			}
			if(k4==k)
			{
				if(k3<k4)
				{
					x+=(short)print(bpx+x-tpx, bpy+y-tpy, bpx-tpx, &text[k3], k4-k3);
				//	x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
					k3=k4;
				}
				if(k4==cursor)
					xc=x, yc=y;
				if(inError)
					setBkColor(selectErrorColor);
				//	SetBkColor(ghMemDC, selectErrorColor);
				else
					setBkMode(OPAQUE), setBkColor(selectColor);
				//	SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, selectColor);
			/*	int bg=GetBkColor(ghMemDC);
				auto pbg=(unsigned char*)&bg;
				SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, (pbg[2]+selectionBkB)/2<<16|(pbg[1]+selectionBkG)/2<<8|(pbg[0]+selectionBkR)/2);//*/
			//	SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, active?0x00FFFF96:0x00969696);
			}
			if(k4==k2)
			{
				if(k3<k4)
				{
					x+=(short)print(bpx+x-tpx, bpy+y-tpy, bpx-tpx, &text[k3], k4-k3);
				//	x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
					k3=k4;
				}
				if(k4==cursor)
					xc=x, yc=y;
				if(inError)
					setBkColor(errorColor);
				//	SetBkColor(ghMemDC, errorColor);
				else
					setBkMode(bkMode), setBkColor(bkColor);
				//	SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
			/*	int bg=GetBkColor(ghMemDC);
				auto pbg=(unsigned char*)&bg;
				SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, (2*pbg[2]-selectionBkB)<<16|(2*pbg[1]-selectionBkG)<<8|(2*pbg[0]-selectionBkR));//*/
			//	SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
			//	SetBkMode(ghMemDC, TRANSPARENT);
			}
			if(text[k4]=='\r'||k4==textlen)
			{
			/*	if(bounds[b].second=='e'&&inError)//expr: new line stops error (bad fix)
				{
					if(k4>k&&k4<k2)//has been in selection
						SetBkColor(ghMemDC, selectColor);
					else
						SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
					inError=false;
				}//*/
				if(k3<k4)
					x+=(short)print(bpx+x-tpx, bpy+y-tpy, bpx-tpx, &text[k3], k4-k3);
				//	x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[k3], k4-k3, 0, 0, bpx-tpx));
				if(x>tw)
					tw=x;
				k3=k4+2, x=0, th+=fontH, y+=fontH;
			}
		}
	}//*/
/*	{
		int x=0, y=0;
		int selStart, selEnd;
		if(cursor<selcur)
			selStart=cursor, selEnd=selcur;
		else
			selStart=selcur, selEnd=cursor;
		bool selection=selStart<selEnd;
		for(int bound=0, kStart=0, e=0, lineStart=0, k=0, nBounds=bounds.size();bound<nBounds;++bound)
		{
			bool exprBound=bounds[bound].second=='e';
			k=kStart;
			for(int kEnd=bounds[bound].first;;++k)
			{
				if(k==selStart)
				{
					if(lineStart<k)
					{
						x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[lineStart], k-lineStart, 0, 0, bpx-tpx));
						lineStart=k;
					}
					if(k==cursor)
						xc=x, yc=y;
					SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, active?0x00FFFF96:0x00969696);
				}
				if(k==selEnd)
				{
					if(lineStart<k)
					{
						x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[lineStart], k-lineStart, 0, 0, bpx-tpx));
						lineStart=k;
					}
					if(k==cursor)
						xc=x, yc=y;
					SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
				}
				if(text[k]=='\r')
				{
					if(lineStart<k)
					{
						x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[lineStart], k-lineStart, 0, 0, bpx-tpx));
						lineStart=k;
					}
					if(x>tw)
						tw=x;
				//	lineStart=k+(text[k+1]=='\n')+1, x=0;
				}
				if(k==kEnd)
				{
					if(lineStart<k)
						x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[lineStart], k-lineStart, 0, 0, bpx-tpx));
					lineStart=k+(text[k+1]=='\n')+1, x=0;
					break;
				}
			}
		}
	}//*/
	setBkMode(bkMode), setBkColor(bkColor);
//	SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
//	if(toTeleportCursor)
//		cursorTeleport();
	if(active)
		line(bpx+xc-tpx, bpy+yc-tpy, bpx+xc-tpx, bpy+yc-tpy+fontH);
	if(tw>bw&&th>bh)
	{
		int xi=bpx+17+int(double(bw-51)*tpx/tw), xf=bpx+17+int(double(bw-51)*(tpx+bw)/tw), yi=bpy+17+int(double(bh-51)*tpy/th), yf=bpy+17+int(double(bh-51)*(tpy+bh)/th);
		line(bpx		, bpy+bh-17	, bpx+bw	, bpy+bh-17	);
		line(bpx+17		, bpy+bh-17	, bpx+17	, bpy+bh	);
		line(xi			, bpy+bh-17	, xi		, bpy+bh	);
		line(xf			, bpy+bh-17	, xf		, bpy+bh	);
		line(bpx+bw-34	, bpy+bh-17	, bpx+bw-34	, bpy+bh	);
		line(bpx+bw-17	, bpy		, bpx+bw-17	, bpy+bh	);
		line(bpx+bw-17	, bpy+17	, bpx+bw	, bpy+17	);
		line(bpx+bw-17	, yi		, bpx+bw	, yi		);
		line(bpx+bw-17	, yf		, bpx+bw	, yf		);
		line(bpx+bw-17	, bpy+bh-34	, bpx+bw	, bpy+bh-34	);
	}
	else if(tw>bw)
	{
		tpy=0;
		int xi=bpx+17+int(double(bw-34)*tpx/tw), xf=bpx+17+int(double(bw-34)*(tpx+bw)/tw);
		line(bpx		, bpy+bh-17, bpx+bw		, bpy+bh-17	);
		line(bpx+17		, bpy+bh-17, bpx+17		, bpy+bh	);
		line(xi			, bpy+bh-17, xi			, bpy+bh	);
		line(xf			, bpy+bh-17, xf			, bpy+bh	);
		line(bpx+bw-17	, bpy+bh-17, bpx+bw-17	, bpy+bh	);
	}
	else if(th>bh)
	{	
		tpx=0;
		int yi=bpy+17+int(double(bh-34)*tpy/th), yf=bpy+17+int(double(bh-34)*(tpy+bh)/th);
		line(bpx+bw-17, bpy			, bpx+bw-17	, bpy+bh	);
		line(bpx+bw-17, bpy+17		, bpx+bw	, bpy+17	);
		line(bpx+bw-17, yi			, bpx+bw	, yi		);
		line(bpx+bw-17, yf			, bpx+bw	, yf		);
		line(bpx+bw-17, bpy+bh-17	, bpx+bw	, bpy+bh-17	);
	}
	else
		tpx=tpy=0;
	rgn.drop();
//	dropRegion();
//	SelectClipRgn(ghMemDC, 0);
}
void			InputTextBox::draw_color(const int *modes, int nmodes)
{
	int xc=0xCCCCCCCC, yc=0xCCCCCCCC;
	//int xc, yc;
	rgn.use();
//	useRegion();
//	SelectClipRgn(ghMemDC, hRgn);
	tw=th=0;
	int bkMode=getBkMode(), bkColor=getBkColor(), txtColor=getTextColor(), line=0;
//	int bkMode=GetBkMode(ghMemDC), bkColor=GetBkColor(ghMemDC), txtColor=GetTextColor(ghMemDC), line=0;
//	SetBkMode(ghMemDC, TRANSPARENT);
	int const selectColor=active?0xFFFF96:0x969696, errorColor=0x0000FF, selectErrorColor=active?0x7F7FCA:0x4B4BCA;
//	int const selectColor=active?0xFFFF96:0x969696, errorColor=0x7F7FFF, selectErrorColor=active?0xBFBFCA:0x8A8ACA;
/*	unsigned char errorBkR=0xFF, errorBkG=0x7F, errorBkB=0x7F;
//	unsigned char errorBkR=0xFF, errorBkG=0, errorBkB=0;
	unsigned char selectionBkR, selectionBkG, selectionBkB;
	if(active)
		selectionBkR=0x96, selectionBkG=0xFF, selectionBkB=0xFF;
	else
		selectionBkR=0x96, selectionBkG=0x96, selectionBkB=0x96;//*/
	{
		int x=0, y=0;
		int selStart, selEnd;
		if(cursor<selcur)
			selStart=cursor, selEnd=selcur;
		else
			selStart=selcur, selEnd=cursor;
		bool selection=selStart<selEnd;
		bool inError=false;
		for(int bound=0, nBounds=bounds.size(), e=0, func=0, textoutStart=0, k=0;bound<nBounds;++bound)
	//	for(int bound=0, nBounds=bounds.size(), e=0, textoutStart=0, k=0;bound<nBounds;++bound)
		{
			bool exprBound=bounds[bound].second=='e';
			Expression *it=exprBound?&expr[e]:&userFunctionDefinitions[func];
			unsigned kSE=0;
		//	SetTextColor(ghMemDC, exprBound&&modes.find(expr[e].rmode[0])!=modes.end()?expr[e].winColor:txtColor);
			setTextColor(exprBound&&find_mode(modes, nmodes, expr[e].rmode[0])!=-1?expr[e].winColor:txtColor);
		//	SetTextColor(ghMemDC, exprBound&&find_mode(modes, nmodes, expr[e].rmode[0])!=-1?expr[e].winColor:txtColor);
			for(int kEnd=bounds[bound].first;;++k)
			{
				if(kSE<it->syntaxErrors.size())
				{
					if(k==it->syntaxErrors[kSE].first)//red text
					{
						if(textoutStart<k)
						{
							x+=(short)print(bpx+x-tpx, bpy+y-tpy, bpx-tpx, &text[textoutStart], k-textoutStart);
						//	x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[textoutStart], k-textoutStart, 0, 0, bpx-tpx));
							textoutStart=k;
							if(x>tw)
								tw=x;
						}
						if(k>selStart&&k<selEnd)//has been in selection: average color
							setBkColor(selectErrorColor);
						//	SetBkColor(ghMemDC, selectErrorColor);
						else
							setBkMode(OPAQUE), setBkColor(errorColor);
						//	SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, errorColor);
					/*	int bg=GetBkColor(ghMemDC);
						auto pbg=(unsigned char*)&bg;
						SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, (pbg[2]+errorBkB)/2<<16|(pbg[1]+errorBkG)/2<<8|(pbg[0]+errorBkR)/2);//*/
					//	SetBkColor(ghMemDC, ((bg>>16)+0)/2<<16|(unsigned char(bg>>8)+0)/2<<8|(unsigned char(bg)+0)/2<<16);
					//	SetTextColor(ghMemDC, 0x0000FF);
						inError=true;
					}
					else if(k==it->syntaxErrors[kSE].second)//black text
					{
						if(textoutStart<k)
						{
							x+=(short)print(bpx+x-tpx, bpy+y-tpy, bpx-tpx, &text[textoutStart], k-textoutStart);
						//	x+=short(TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[textoutStart], k-textoutStart, 0, 0, bpx-tpx));
							textoutStart=k;
							if(x>tw)
								tw=x;
						}
						++kSE;
						if(kSE>=it->syntaxErrors.size()||k!=it->syntaxErrors[kSE].first)
						{
							if(k>selStart&&k<selEnd)//has been in selection
								setBkColor(selectColor);
							//	SetBkColor(ghMemDC, selectColor);
							else
								setBkMode(bkMode), setBkColor(bkColor);
							//	SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
						/*	int bg=GetBkColor(ghMemDC);
							auto pbg=(unsigned char*)&bg;
							SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, (2*pbg[2]-errorBkB)<<16|(2*pbg[1]-errorBkG)<<8|(2*pbg[0]-errorBkR));//*/
						//	SetTextColor(ghMemDC, 0);
							inError=false;
						}
					}
				}
				if(k==selStart)
				{
					if(textoutStart<k)
					{
						x+=(short)print(bpx+x-tpx, bpy+y-tpy, bpx-tpx, &text[textoutStart], k-textoutStart);
					//	x+=(short)TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, &text[textoutStart], k-textoutStart, 0, 0, bpx-tpx);
						textoutStart=k;
						if(x>tw)
							tw=x;
					}
					if(k==cursor)
						xc=x, yc=y;
					if(inError)
						setBkColor(selectErrorColor);
					//	SetBkColor(ghMemDC, selectErrorColor);
					else
						setBkMode(OPAQUE), setBkColor(selectColor);
					//	SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, selectColor);
				/*	int bg=GetBkColor(ghMemDC);
					auto pbg=(unsigned char*)&bg;
					SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, (pbg[2]+selectionBkB)/2<<16|(pbg[1]+selectionBkG)/2<<8|(pbg[0]+selectionBkR)/2);//*/
				//	SetBkMode(ghMemDC, OPAQUE), SetBkColor(ghMemDC, active?0x00FFFF96:0x00969696);
				}
				if(k==selEnd)
				{
					if(textoutStart<k)
					{
						x+=(short)print(bpx+x-tpx, bpy+y-tpy, bpx-tpx, text+textoutStart, k-textoutStart);
					//	x+=(short)TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, text+textoutStart, k-textoutStart, 0, 0, bpx-tpx);
						textoutStart=k;
						if(x>tw)
							tw=x;
					}
					if(k==cursor)
						xc=x, yc=y;
					if(inError)
						setBkColor(errorColor);
					//	SetBkColor(ghMemDC, errorColor);
					else
						setBkMode(bkMode), setBkColor(bkColor);
					//	SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
				/*	int bg=GetBkColor(ghMemDC);
					auto pbg=(unsigned char*)&bg;
					SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, (2*pbg[2]-selectionBkB)<<16|(2*pbg[1]-selectionBkG)<<8|(2*pbg[0]-selectionBkR));//*/
				//	SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor);
				}
				if(text[k]=='\r')
				{
					if(textoutStart<k)
					{
						x+=(short)print(bpx+x-tpx, bpy+y-tpy, bpx-tpx, text+textoutStart, k-textoutStart);
					//	x+=(short)TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, text+textoutStart, k-textoutStart, 0, 0, bpx-tpx);
						textoutStart=k;
						if(x>tw)
							tw=x;
					}
					k+=text[k+1]=='\n';
					x=0, th+=fontH, y+=fontH;
					if(k+1==kEnd)
					{
						++k;
						textoutStart=k;
						break;
					}
				//	textoutStart=k+(text[k+1]=='\n')+1, x=0, th+=font.H, y+=font.H;
				}
				if(k==kEnd)
				{
					if(textoutStart<k)
					{
						x+=(short)print(bpx+x-tpx, bpy+y-tpy, bpx-tpx, text+textoutStart, k-textoutStart);
					//	x+=(short)TabbedTextOutA(ghMemDC, bpx+x-tpx, bpy+y-tpy, text+textoutStart, k-textoutStart, 0, 0, bpx-tpx);
						textoutStart=k;
						if(x>tw)
							tw=x;
					}
				//	textoutStart=k+(text[k+1]=='\n')+1;//, x=0;
					break;
				}
			}
			e+=exprBound;
		}
	}//*/
	setBkMode(bkMode), setBkColor(bkColor), setTextColor(txtColor);
//	SetBkMode(ghMemDC, bkMode), SetBkColor(ghMemDC, bkColor), SetTextColor(ghMemDC, txtColor);
	//if(xc==0xCCCCCCCC)
	//	return;
	if(active)
		::line(bpx+xc-tpx, bpy+yc-tpy, bpx+xc-tpx, bpy+yc-tpy+fontH);
	if(tw>bw&&th>bh)
	{
		int xi=bpx+17+int(double(bw-51)*tpx/tw), xf=bpx+17+int(double(bw-51)*(tpx+bw)/tw), yi=bpy+17+int(double(bh-51)*tpy/th), yf=bpy+17+int(double(bh-51)*(tpy+bh)/th);
		::line(bpx		, bpy+bh-17	, bpx+bw	, bpy+bh-17	);
		::line(bpx+17	, bpy+bh-17	, bpx+17	, bpy+bh	);
		::line(xi		, bpy+bh-17	, xi		, bpy+bh	);
		::line(xf		, bpy+bh-17	, xf		, bpy+bh	);
		::line(bpx+bw-34, bpy+bh-17	, bpx+bw-34	, bpy+bh	);
		::line(bpx+bw-17, bpy		, bpx+bw-17	, bpy+bh	);
		::line(bpx+bw-17, bpy+17	, bpx+bw	, bpy+17	);
		::line(bpx+bw-17, yi		, bpx+bw	, yi		);
		::line(bpx+bw-17, yf		, bpx+bw	, yf		);
		::line(bpx+bw-17, bpy+bh-34	, bpx+bw	, bpy+bh-34	);
	}
	else if(tw>bw)
	{
		tpy=0;
		int xi=bpx+17+int(double(bw-34)*tpx/tw), xf=bpx+17+int(double(bw-34)*(tpx+bw)/tw);
		::line(bpx		, bpy+bh-17, bpx+bw		, bpy+bh-17	);
		::line(bpx+17	, bpy+bh-17, bpx+17		, bpy+bh	);
		::line(xi		, bpy+bh-17, xi			, bpy+bh	);
		::line(xf		, bpy+bh-17, xf			, bpy+bh	);
		::line(bpx+bw-17, bpy+bh-17, bpx+bw-17	, bpy+bh	);
	}
	else if(th>bh)
	{	
		tpx=0;
		int yi=bpy+17+int(double(bh-34)*tpy/th), yf=bpy+17+int(double(bh-34)*(tpy+bh)/th);
		::line(bpx+bw-17, bpy		, bpx+bw-17	, bpy+bh	);
		::line(bpx+bw-17, bpy+17	, bpx+bw	, bpy+17	);
		::line(bpx+bw-17, yi		, bpx+bw	, yi		);
		::line(bpx+bw-17, yf		, bpx+bw	, yf		);
		::line(bpx+bw-17, bpy+bh-17	, bpx+bw	, bpy+bh-17	);
	}
	else
		tpx=tpy=0;
	rgn.drop();
//	dropRegion();
//	SelectClipRgn(ghMemDC, 0);
}
namespace	G2
{
	char  returns_rcq		(char optype){return optype;}
	char  returns_rrr		(char optype){return 'R';}
	char  returns_ccc		(char optype){return 'c';}
	char  returns_ccq		(char optype)
	{
		switch(optype)
		{
		case 'R':return 'c';
		case 'c':return 'c';
		case 'h':return 'h';
		}
		return 0;
	}
	char  returns_rXX		(char optype)
	{
		switch(optype)
		{
		case 'R':return 'R';


		}
		return 0;
	}
	char  returns_cXX		(char optype)
	{
		switch(optype)
		{
		case 'R':return 'c';


		}
		return 0;
	}
	char  returns_ccq_ccq_qqq(char op1type, char op2type)
	{
		switch(op1type)
		{
		case 'R':switch(op2type){case 'R':return 'c';	case 'c':return 'c';	case 'h':return 'h';}break;
		case 'c':switch(op2type){case 'R':return 'c';	case 'c':return 'c';	case 'h':return 'h';}break;
		case 'h':switch(op2type){case 'R':return 'h';	case 'c':return 'h';	case 'h':return 'h';}break;
		}
		return 0;
	}
	char  returns_rrr_rrr_rrr(char op1type, char op2type){return 'R';}
	char  returns_ccX_ccX_qXX(char op1type, char op2type)
	{
		switch(op1type)
		{
		case 'R':switch(op2type){case 'R':return 'c';	case 'c':return 'c';						}break;
		case 'c':switch(op2type){case 'R':return 'c';	case 'c':return 'c';						}break;
		case 'h':switch(op2type){case 'R':return 'h';												}break;
		}
		return 0;
	}
	char  returns_rXX_rXX_XXX(char op1type, char op2type)
	{
		switch(op1type)
		{
		case 'R':switch(op2type){case 'R':return 'R';												}break;
		case 'c':switch(op2type){case 'R':return 'R';												}break;
		case 'h':																					break;
		}
		return 0;
	}
	char  returns_rXX_XXX_XXX(char op1type, char op2type)
	{
		switch(op1type)
		{
		case 'R':switch(op2type){case 'R':return 'R';												}break;
		case 'c':																					break;
		case 'h':																					break;
		}
		return 0;
	}
	char  returns_cXX_XXX_XXX(char op1type, char op2type)
	{
		switch(op1type)
		{
		case 'R':switch(op2type){case 'R':return 'c';												}break;
		case 'c':																					break;
		case 'h':																					break;
		}
		return 0;
	}
	char  returns_rcq_ccq_qqq(char op1type, char op2type){return maximum((int)op1type, (int)op2type);}
	char  returns_rrr_ccc_qqq(char op1type, char op2type){return op1type;}
	char  returns_rcq_rcq_rcq(char op1type, char op2type){return op2type;}
	char  returns_rXX_cXX_qXX(char op1type, char op2type){return op2type;}
	char  returns_conditional(char op1type, char op2type, char op3type)
	{
		switch(op1type)
		{
		case 'R':
			switch(op2type)
			{
			case 'R':switch(op3type){case 'R':return 'R';	case 'c':return 'c';	case 'h':return 'h';}break;
			case 'c':switch(op3type){case 'R':return 'c';	case 'c':return 'c';	case 'h':return 'h';}break;
			case 'h':switch(op3type){case 'R':return 'h';	case 'c':return 'h';	case 'h':return 'h';}break;
			}
			break;
		case 'c':
			switch(op2type)
			{
			case 'R':switch(op3type){case 'R':return 'c';	case 'c':return 'c';	case 'h':return 'h';}break;
			case 'c':switch(op3type){case 'R':return 'c';	case 'c':return 'c';	case 'h':return 'h';}break;
			case 'h':switch(op3type){case 'R':return 'h';	case 'c':return 'h';	case 'h':return 'h';}break;
			}
			break;
		case 'h':
			switch(op2type)
			{
			case 'R':switch(op3type){case 'R':return 'h';	case 'c':return 'h';	case 'h':return 'h';}break;
			case 'c':switch(op3type){case 'R':return 'h';	case 'c':return 'h';	case 'h':return 'h';}break;
			case 'h':switch(op3type){case 'R':return 'h';	case 'c':return 'h';	case 'h':return 'h';}break;
			}
			break;
		}
		return 0;
	}

	void  r_r_setzero				(VectP &r, VectP const&)					{*r.r=0;}
	void  c_c_setzero				(CompP &r, CompP const&)					{*r.r=*r.i=0;}
	void  q_q_setzero				(QuatP &r, QuatP const&)					{*r.r=*r.i=*r.j=*r.k=0;}
	
	void  r_r_ceil					(VectP &r, VectP const &x)					{r=x.ceil();}
	void  c_c_ceil					(CompP &r, CompP const &x)					{r=ceil((Comp1d)x);}
	void  q_q_ceil					(QuatP &r, QuatP const &x)					{r=ceil((Quat1d)x);}
	bool disc_r_ceil_o				(Value const &o0, Value const &o1){return o0.r!=o1.r;}
	bool disc_c_ceil_o				(Value const &o0, Value const &o1){return o0.r!=o1.r||o0.i!=o1.i;}
	bool disc_q_ceil_o				(Value const &o0, Value const &o1){return o0.r!=o1.r||o0.i!=o1.i||o0.j!=o1.j||o0.k!=o1.k;}

	void  r_r_floor					(VectP &r, VectP const &x)					{r=x.floor();}
	void  c_c_floor					(CompP &r, CompP const &x)					{r=floor((Comp1d)x);}
	void  q_q_floor					(QuatP &r, QuatP const &x)					{r=floor((Quat1d)x);}
	auto disc_r_floor_o				=disc_r_ceil_o;
	auto disc_c_floor_o				=disc_c_ceil_o;
	auto disc_q_floor_o				=disc_q_ceil_o;

	void  r_r_round					(VectP &r, VectP const &x)					{r=x.round();}
	void  c_c_round					(CompP &r, CompP const &x)					{r=round((Comp1d)x);}
	void  q_q_round					(QuatP &r, QuatP const &x)					{r=round((Quat1d)x);}
	auto  disc_r_round_o			=disc_r_ceil_o;
	auto  disc_c_round_o			=disc_c_ceil_o;
	auto  disc_q_round_o			=disc_q_ceil_o;

	void  r_r_int					(VectP &r, VectP const &x)					{r=(int)(double)x;}
	void  c_c_int					(CompP &r, CompP const &x)					{r=Comp1d((int)*x.r, (int)*x.i);}
	void  q_q_int					(QuatP &r, QuatP const &x)					{r=Quat1d((int)*x.r, (int)*x.i, (int)*x.j, (int)*x.k);}
	auto  disc_r_int_o				=disc_r_ceil_o;
	auto  disc_c_int_o				=disc_c_ceil_o;
	auto  disc_q_int_o				=disc_q_ceil_o;

	void  r_r_frac					(VectP &r, VectP const &x)					{r=x-std::floor((double)x);}
	void  c_c_frac					(CompP &r, CompP const &x)					{r=Comp1d(*x.r-std::floor(*x.r), *x.i-std::floor(*x.i));}
	void  q_q_frac					(QuatP &r, QuatP const &x)					{r=Quat1d(*x.r-std::floor(*x.r), *x.i-std::floor(*x.i), *x.j-std::floor(*x.j), *x.k-std::floor(*x.k));}
	bool  disc_r_frac_i				(Value const &o0, Value const &o1){return std::floor(o0.r)!=std::floor(o1.r);}
	bool  disc_c_frac_i				(Value const &o0, Value const &o1){return std::floor(o0.r)!=std::floor(o1.r)||std::floor(o0.i)!=std::floor(o1.i);}
	bool  disc_q_frac_i				(Value const &o0, Value const &o1){return std::floor(o0.r)!=std::floor(o1.r)||std::floor(o0.i)!=std::floor(o1.i)||std::floor(o0.j)!=std::floor(o1.j)||std::floor(o0.k)!=std::floor(o1.k);}

	void  r_r_abs					(VectP &r, VectP const &x)					{r=x.abs();}
	void  r_c_abs					(VectP &r, CompP const &x)					{r=abs((Comp1d)x);}
	void  r_q_abs					(VectP &r, QuatP const &x)					{r=abs((Quat1d)x);}

	void  r_r_arg					(VectP &r, VectP const &x)					{r=x<0?_pi:x==0?_qnan:0;}
	void  r_c_arg					(VectP &r, CompP const &x)
	{
		Comp1d cx=x;
		r=(cx.real()==0)&(cx.imag()==0)?_qnan: ::atan2(cx.imag(), cx.real());
	}
	void  r_q_arg					(VectP &r, QuatP const &x)
	{
		Quat1d qx=x;
		r=::acos(qx.R_component_1()/abs(qx));
	}
	bool  disc_r_arg_i				(Value const &x0, Value const &x1){return x0.r<0?x1.r>=0:x0.r>0?x1.r<=0:x1.r!=0;}//return std::signbit(x0.r)!=std::signbit(x1.r);
	bool  disc_c_arg_i				(Value const &x0, Value const &x1)
	{
		if(x0.r<0)
		{
			if(x0.i<0)
			{
				if(x1.r<0)	return x1.i>=0;
				if(x1.r>0)	return x1.i>0&&x0.r+(0-x0.i)*(x1.r-x0.r)/(x1.i-x0.i)<=0;
							return x1.i>=0;
			}
			else if(x0.i>0)
			{
				if(x1.r<0)	return x1.i<0;
				if(x1.r>0)	return x1.i<0&&x0.r+(0-x0.r)*(x1.r-x0.r)/(x1.i-x1.i)<=0;
							return x1.i<=0;
			}
			else
			{
				if(x1.r<0)	return x1.i<0;
				if(x1.r>0)	return x1.i<=0;
							return x1.i<=0;
			}
		}
		else if(x0.r>0)
		{
			if(x0.i<0)
			{
				if(x1.r<0)	return x1.i>=0&&(x1.i==0||x0.r+(0-x0.r)*(x1.r-x0.r)/(x1.i-x1.i)<=0);
				if(x1.r>0)	return false;
							return x1.i==0;
			}
			else if(x0.i>0)
			{
				if(x1.r<0)	return x1.i<0&&x0.r+(0-x0.r)*(x1.r-x0.r)/(x1.i-x1.i)<=0;
				if(x1.r>0)	return false;
							return x1.i==0;
			}
			else
			{
				if(x1.r<0)	return x1.i==0;
				if(x1.r>0)	return false;
							return x1.i==0;
			}
		}
		else
		{
			if(x0.i<0)
			{
				if(x1.r<0)	return x1.i>=0;
				if(x1.r>0)	return false;
							return x1.i>=0;
			}
			else if(x0.i>0)
			{
				if(x1.r<0)	return x1.i<0;
				if(x1.r>0)	return false;
							return x1.i<=0;
			}
							return true;
		}
	}
	bool  disc_q_arg_i				(Value const &x0, Value const &x1){return false;}//

	void  r_c_real					(VectP &r, CompP const &x)					{r=*x.r;}

	void  r_c_imag					(VectP &r, CompP const &x)					{r=*x.i;}

	//r_conjugate: assign
	void c_c_conjugate				(CompP &r, CompP const &x)					{r=Comp1d(*x.r, -*x.i);}
	void q_q_conjugate				(QuatP &r, QuatP const &x)					{r=Quat1d(*x.r, -*x.i, -*x.j, -*x.k);}

	void  c_r_polar					(CompP &r, VectP const &x)					{r=Comp1d(abs(*x.r), *x.r<0?_pi:*x.r==0?_qnan:0);}
	void  c_c_polar					(CompP &r, CompP const &x)
	{
		Comp1d cx=x;
		double mag=abs(cx);
		r=Comp1d(mag, mag==0?_qnan: ::atan2(cx.imag(), cx.real()));
	}
	void  c_q_polar					(CompP &r, QuatP const &x)
	{
		Quat1d qx=x;
		double mag=abs(qx);
		r=Comp1d(mag, ::acos(qx.R_component_1()/mag));
	}
	auto disc_r_polar_i				=disc_r_arg_i;
	auto disc_c_polar_i				=disc_c_arg_i;
	auto disc_q_polar_i				=disc_q_arg_i;

	//r_cartesian	assign
	void  c_c_cartesian				(CompP &r, CompP const &x)			{r=Comp1d(*x.r*cos(*x.i), *x.r*sin(*x.i));}
	void  q_q_cartesian				(QuatP &r, QuatP const &x)
	{
		double cos_j=cos(*x.j), xr_cos_k=*x.r*cos(*x.k);
		r=Quat1d(
			cos(*x.i)*cos_j*xr_cos_k,
			sin(*x.i)*cos_j*xr_cos_k,
			sin(*x.j)*xr_cos_k,
			*x.r*sin(*x.k));
	}

	void r_rr_plus					(VectP &r, VectP const &x, VectP const &y)	{r=x+y;}
	void c_rc_plus					(CompP &r, VectP const &x, CompP const &y)	{r=(double)x+(Comp1d)y;}
	void q_rq_plus					(QuatP &r, VectP const &x, QuatP const &y)	{r=(double)x+(Quat1d)y;}
	void c_cr_plus					(CompP &r, CompP const &x, VectP const &y)	{r=(Comp1d)x+(double)y;}
	void c_cc_plus					(CompP &r, CompP const &x, CompP const &y)	{r=(Comp1d)x+(Comp1d)y;}
	void q_cq_plus					(QuatP &r, CompP const &x, QuatP const &y)	{r=(Comp1d)x+(Quat1d)y;}
	void q_qr_plus					(QuatP &r, QuatP const &x, VectP const &y)	{r=(Quat1d)x+(double)y;}
	void q_qc_plus					(QuatP &r, QuatP const &x, CompP const &y)	{r=(Quat1d)x+(Comp1d)y;}
	void q_qq_plus					(QuatP &r, QuatP const &x, QuatP const &y)	{r=(Quat1d)x+(Quat1d)y;}

	void  r_r_minus					(VectP &r, VectP const &x)					{r=-x;}
	void  c_c_minus					(CompP &r, CompP const &x)					{r=-(Comp1d)x;}
	void  q_q_minus					(QuatP &r, QuatP const &x)					{r=-(Quat1d)x;}
	void r_rr_minus					(VectP &r, VectP const &x, VectP const &y)	{r=x-y;}
	void c_rc_minus					(CompP &r, VectP const &x, CompP const &y)	{r=(double)x-(Comp1d)y;}
	void q_rq_minus					(QuatP &r, VectP const &x, QuatP const &y)	{r=(double)x-(Quat1d)y;}
	void c_cr_minus					(CompP &r, CompP const &x, VectP const &y)	{r=(Comp1d)x-(double)y;}
	void c_cc_minus					(CompP &r, CompP const &x, CompP const &y)	{r=(Comp1d)x-(Comp1d)y;}
	void q_cq_minus					(QuatP &r, CompP const &x, QuatP const &y)	{r=(Comp1d)x-(Quat1d)y;}
	void q_qr_minus					(QuatP &r, QuatP const &x, VectP const &y)	{r=(Quat1d)x-(double)y;}
	void q_qc_minus					(QuatP &r, QuatP const &x, CompP const &y)	{r=(Quat1d)x-(Comp1d)y;}
	void q_qq_minus					(QuatP &r, QuatP const &x, QuatP const &y)	{r=(Quat1d)x-(Quat1d)y;}

	void r_rr_multiply				(VectP &r, VectP const &x, VectP const &y)	{r=x*y;}
	void c_rc_multiply				(CompP &r, VectP const &x, CompP const &y)	{r=(double)x*(Comp1d)y;}
	void q_rq_multiply				(QuatP &r, VectP const &x, QuatP const &y)	{r=(double)x*(Quat1d)y;}
	void c_cr_multiply				(CompP &r, CompP const &x, VectP const &y)	{r=(Comp1d)x*(double)y;}
	void c_cc_multiply				(CompP &r, CompP const &x, CompP const &y)	{r=(Comp1d)x*(Comp1d)y;}
	void q_cq_multiply				(QuatP &r, CompP const &x, QuatP const &y)	{r=(Comp1d)x*(Quat1d)y;}
	void q_qr_multiply				(QuatP &r, QuatP const &x, VectP const &y)	{r=(Quat1d)x*(double)y;}
	void q_qc_multiply				(QuatP &r, QuatP const &x, CompP const &y)	{r=(Quat1d)x*(Comp1d)y;}
	void q_qq_multiply				(QuatP &r, QuatP const &x, QuatP const &y)	{r=(Quat1d)x*(Quat1d)y;}
	
	inline Comp1d inv(Comp1d const &x)
	{
		double inv_abs2=1/(x.real()*x.real()+x.imag()*x.imag());
		return Comp1d(x.real()*inv_abs2, -x.imag()*inv_abs2);
	}
	inline Quat1d inv(Quat1d const &x)
	{
		double inv_abs2=1/(x.R_component_1()*x.R_component_1()+x.R_component_2()*x.R_component_2()+x.R_component_3()*x.R_component_3()+x.R_component_4()*x.R_component_4());
		return Quat1d(x.R_component_1()*inv_abs2, -x.R_component_2()*inv_abs2, -x.R_component_3()*inv_abs2, -x.R_component_4()*inv_abs2);
	}
	void  r_r_divide				(VectP &r, VectP const &y)					{r=1/y;}
	void  c_c_divide				(CompP &r, CompP const &y)					{r=inv((Comp1d)y);}
	void  q_q_divide				(QuatP &r, QuatP const &y)					{r=inv((Quat1d)y);}
	void r_rr_divide				(VectP &r, VectP const &x, VectP const &y)	{r=x/y;}
	void c_rc_divide				(CompP &r, VectP const &x, CompP const &y)	{r=(double)x/(Comp1d)y;}
	void q_rq_divide				(QuatP &r, VectP const &x, QuatP const &y)	{r=(double)x/(Quat1d)y;}
	void c_cr_divide				(CompP &r, CompP const &x, VectP const &y)	{r=(Comp1d)x/(double)y;}
	void c_cc_divide				(CompP &r, CompP const &x, CompP const &y)	{r=(Comp1d)x/(Comp1d)y;}
	void q_cq_divide				(QuatP &r, CompP const &x, QuatP const &y)	{r=(Comp1d)x/(Quat1d)y;}
	void q_qr_divide				(QuatP &r, QuatP const &x, VectP const &y)	{r=(Quat1d)x/(double)y;}
	void q_qc_divide				(QuatP &r, QuatP const &x, CompP const &y)	{r=(Quat1d)x/(Comp1d)y;}
	void q_qq_divide				(QuatP &r, QuatP const &x, QuatP const &y)	{r=(Quat1d)x/(Quat1d)y;}
	auto disc_r_divide_i			=disc_r_arg_i;
	bool disc_c_divide_i			(Value const &x0, Value const &x1)
	{
		double const pole[2]={0, 0};
		if(x0.r<0)
		{
			if(x0.i<0)
			{
				if(x1.r<0)	return false;
				if(x1.r>0)	return _2d_between(x0.r, x0.i, pole[0], pole[1], x1.r, x1.i);
							return x1.i==0;
			}
			if(x0.i>0)
			{
				if(x1.r<0)	return false;
				if(x1.r>0)	return _2d_between(x0.r, x0.i, pole[0], pole[1], x1.r, x1.i);
							return x1.i==0;
			}
			{
				if(x1.r<0)	return false;
				if(x1.r>0)	return x1.i==0;
							return true;
			}
		}
		if(x0.r>0)
		{
			if(x0.i<0)
			{
				if(x1.r<0)	return _2d_between(x0.r, x0.i, pole[0], pole[1], x1.r, x1.i);
				if(x1.r>0)	return false;
							return x1.i==0;
			}
			if(x0.i>0)
			{
				if(x1.r<0)	return _2d_between(x0.r, x0.i, pole[0], pole[1], x1.r, x1.i);
				if(x1.r>0)	return false;
							return x1.i==0;
			}
			{
				if(x1.r<0)	return x1.i==0;
				if(x1.r>0)	return false;
							return true;
			}
		}
		{
			if(x0.i<0)
			{
				if(x1.r<0)	return false;
				if(x1.r>0)	return false;
							return x1.i>=0;
			}
			if(x0.i>0)
			{
				if(x1.r<0)	return false;
				if(x1.r>0)	return false;
							return x1.i<=0;
			}
			{
							return true;
			}
		}
	}
	bool disc_q_divide_i			(Value const &x0, Value const &x1){return false;}//
	bool disc_rr_divide_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_r_divide_i(y0, y1);}
	bool disc_rc_divide_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_c_divide_i(y0, y1);}
	bool disc_rq_divide_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_q_divide_i(y0, y1);}
	bool disc_cr_divide_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_r_divide_i(y0, y1);}
	bool disc_cc_divide_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_c_divide_i(y0, y1);}
	bool disc_cq_divide_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_q_divide_i(y0, y1);}
	bool disc_qr_divide_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_r_divide_i(y0, y1);}
	bool disc_qc_divide_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_c_divide_i(y0, y1);}
	bool disc_qq_divide_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return disc_q_divide_i(y0, y1);}

	void r_rr_logic_divides			(VectP &r, VectP const &y, VectP const &x)	{auto t=x/y; r=t==::floor(t);}//note: this is a boolean (logic) operator
	void r_rc_logic_divides			(VectP &r, VectP const &y, CompP const &x)	{auto t=(Comp1d)x/(double)y; r=t==floor(t);}
	void r_rq_logic_divides			(VectP &r, VectP const &y, QuatP const &x)	{auto t=(Quat1d)x/(double)y; r=t==floor(t);}
	void r_cr_logic_divides			(VectP &r, CompP const &y, VectP const &x)	{auto t=(double)x/(Comp1d)y; r=t==floor(t);}
	void r_cc_logic_divides			(VectP &r, CompP const &y, CompP const &x)	{auto t=(Comp1d)x/(Comp1d)y; r=t==floor(t);}
	void r_cq_logic_divides			(VectP &r, CompP const &y, QuatP const &x)	{auto t=(Quat1d)x/(Comp1d)y; r=t==floor(t);}
	void r_qr_logic_divides			(VectP &r, QuatP const &y, VectP const &x)	{auto t=(double)x/(Quat1d)y; r=t==floor(t);}
	void r_qc_logic_divides			(VectP &r, QuatP const &y, CompP const &x)	{auto t=(Comp1d)x/(Quat1d)y; r=t==floor(t);}
	void r_qq_logic_divides			(VectP &r, QuatP const &y, QuatP const &x)	{auto t=(Quat1d)x/(Quat1d)y; r=t==floor(t);}
	bool disc_r_logic_divides_o		(Value const &x0, Value const &x1){return x0.r!=x1.r;}//for all logic functions

	inline double power_real(double const &x, int y)
	{
		double m[]={1, 0}, r=1;
		if(y<0)
			m[1]=1/x, y=-y;
		else
			m[1]=x;
		for(;;)
		{
			r*=m[y&1], y>>=1;
			if(!y)
				return r;
			m[1]*=m[1];
		}
		return r;
	}
	inline Quat1d power_real(Quat1d const &x, int y)
	{
		Quat1d t=x, r(1.);
		int p=abs(y);
		for(;;)
		{
			if(p&1)
				r*=t;
			p>>=1;
			if(!p)
				return y<0?inv(r):r;
			t*=t;
		}
		return y<0?inv(r):r;
	}
	void r_rr_power_real			(VectP &r, VectP const &x, VectP const &y)	{r=power_real((double)x, (int)std::floor((double)y));}//long long y
	void c_cr_power_real			(CompP &r, CompP const &x, VectP const &y)	{r=std::pow((Comp1d)x, (int)std::floor((double)y));}
	void q_qr_power_real			(QuatP &r, QuatP const &x, VectP const &y)	{r=power_real((Quat1d)x, (int)std::floor((double)y));}//boost::math::pow is recursive
	bool disc_rr_power_real_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return std::floor(y0.r)!=std::floor(y1.r);}//truncation vs floor
	auto disc_cr_power_real_i		=disc_rr_power_real_i;
	auto disc_qr_power_real_i		=disc_rr_power_real_i;

	void c_cr_pow					(CompP &r, CompP const &x, VectP const &y)
	{
		if(!*x.r&&!*x.i&&!*y.r)
			r=1;
		else
			r=exp((double)y*log((Comp1d)x));
	}
	void c_cc_pow					(CompP &r, CompP const &x, CompP const &y)
	{
		if(!*x.r&&!*x.i&&!*y.r&&!*y.i)
			r=1;
		else
			r=exp((Comp1d)y*log((Comp1d)x));
	}
	void q_cq_pow					(QuatP &r, CompP const &x, QuatP const &y)
	{
		if(!*x.r&&!*x.i&&!*y.r&&!*y.i&&!*y.j&&!*y.k)
			r=Quat1d(1.);
		else
			r=exp((Quat1d)y*log((Comp1d)x));
	}
	void q_qr_pow					(QuatP &r, QuatP const &x, VectP const &y)
	{
		if(!*x.r&&!*x.i&&!*x.j&&!*x.k&&!*y.r)
			r=Quat1d(1.);
		else
			r=exp((double)y*log((Quat1d)x));
	}
	void q_qc_pow					(QuatP &r, QuatP const &x, CompP const &y)
	{
		if(!*x.r&&!*x.i&&!*x.j&&!*x.k&&!*y.r&&!*y.i)
			r=Quat1d(1.);
		else
			r=exp((Comp1d)y*log((Quat1d)x));
	}
	void q_qq_pow					(QuatP &r, QuatP const &x, QuatP const &y)
	{
		if(!*x.r&&!*x.i&&!*x.j&&!*x.k&&!*y.r&&!*y.i&&!*y.j&&!*y.k)
			r=Quat1d(1.);
		else
			r=exp((Quat1d)y*log((Quat1d)x));
	}
	bool disc_cr_pow_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1)
	{//pole: y<0: x.r<=0, x.i=0;	y>0: x.r<0, x.i=0
		if(y0.r==y1.r)
		{
		}
		else
		{
		}
	//	if(x0.i==0&&x1.i==0&&std::signbit(x0.r)!=std::signbit(x1.r))
	//	{
	//	}
		return false;
	}
	bool disc_cc_pow_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cq_pow_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qr_pow_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qc_pow_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qq_pow_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	void  c_c_ln					(CompP &r, CompP const &x)					{r=log((Comp1d)x);}
	void  q_q_ln					(QuatP &r, QuatP const &x)					{r=log((Quat1d)x);}
	auto disc_c_ln_i				=disc_c_arg_i;
	bool disc_q_ln_i				(Value const &x0, Value const &x1){return false;}//
	
	void  c_c_log					(CompP &r, CompP const &x)					{r=log((Comp1d)x)*inv_ln10;}
	void  q_q_log					(QuatP &r, QuatP const &x)					{r=log((Quat1d)x)*inv_ln10;}
	void c_cr_log					(CompP &r, CompP const &x, VectP const &y)	{r=log((Comp1d)x)/log(Comp1d(y, 0));}
	void c_cc_log					(CompP &r, CompP const &x, CompP const &y)	{r=log((Comp1d)x)/log((Comp1d)y);}
	void q_cq_log					(QuatP &r, CompP const &x, QuatP const &y)	{r=log((Comp1d)x)/log((Quat1d)y);}
	void q_qc_log					(QuatP &r, QuatP const &x, CompP const &y)	{r=log((Quat1d)x)/log((Comp1d)y);}
	void q_qq_log					(QuatP &r, QuatP const &x, QuatP const &y)	{r=log((Quat1d)x)/log((Quat1d)y);}
	auto disc_c_log_i				=disc_c_arg_i;
	bool disc_q_log_i				(Value const &x0, Value const &x1){return false;}//
	bool disc_cr_log_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cc_log_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cq_log_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qc_log_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qq_log_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	
	Comp1d tetrate(double x, double y)
	{
		double log_x=std::log((double)x), ry=y;
		int h=int(::floor(ry-.5)+1);//rounded real part
		Comp1d t(ry-(double)h);//real-round(real)+i*imag
		{
			auto q=std::sqrt(log_x);
			t=(t+1.)*(
				(
					log_x>_ln2?
						(q*(0.137467+q*(4.94969+q*0.0474179))/(1.+q*(3.23171+q*0.471222))+(-.5+_ln2)/log_x-1.)
						+t*	(
								(q*(-0.424278+q*(1.75166+q*(-1.46524+q*0.93347)))/(0.0312142+q*(-0.267478+q))+(-.625+_ln2)/log_x-1.)
								+t*	(
										(q*(3.39255+q*(16.1046+q*(-19.5216+q*10.7458)))/(1.+q*(4.1274+q*5.25449))+(-2./3+_ln2)/log_x-1.)
										+t*(0.16*q*(1.+q*(27.7934+q*(358.688+q*(-259.233+log_x*61.6566))))/(1.-8.1192*q+37.087*log_x)+(-131./192.+_ln2)/log_x-1.)
									)
							)
					:
						(-1.0018+(0.15128484821526975*(1.+33.04715298851381*q-3.51771875598067*log_x)*q)/(1.+3.2255053261256337*q)+(-0.5+_ln2)/log_x)
						+t*	(
								(1.1-2.608785958462561*(1.-0.6663562294911147*q)*q-(-0.625+_ln2)/log_x)
								+t*	(
										(-0.96+3.0912038297987596*(1.+0.6021398048785328*log_x)*q/(1.+ 4.240467556480155*log_x)+(-2./3+_ln2)/log_x)
										+t*(1.2-10.44604984418533*(1.+0.2137568928431227*q+0.3693275254470449*log_x)*q/(1.+4.95715636660691*q + 7.70233216637738*log_x)-(-131./192.+_ln2)/log_x)
									)
							)
				)*t+1.)+std::log(t+2.)/log_x-_ln2/log_x*(1.+t);
		}
		for(;h>0;--h)
			t=std::exp(log_x*t);
		for(;h<0;++h)
			t=std::log(t)/log_x;
		return t;
	}
	Comp1d tetrate(Comp1d const &x, double y)
	{
		Comp1d log_x=std::log((Comp1d)x);
		double ry=y;
		int h=int(::floor(ry-.5)+1);//rounded real part
		Comp1d t(ry-(double)h);//real-round(real)+i*imag
		{
			auto q=std::sqrt(log_x);
			t=(t+1.)*(
				(
					log_x.real()>_ln2?
						(q*(0.137467+q*(4.94969+q*0.0474179))/(1.+q*(3.23171+q*0.471222))+(-.5+_ln2)/log_x-1.)
						+t*	(
								(q*(-0.424278+q*(1.75166+q*(-1.46524+q*0.93347)))/(0.0312142+q*(-0.267478+q))+(-.625+_ln2)/log_x-1.)
								+t*	(
										(q*(3.39255+q*(16.1046+q*(-19.5216+q*10.7458)))/(1.+q*(4.1274+q*5.25449))+(-2./3+_ln2)/log_x-1.)
										+t*(0.16*q*(1.+q*(27.7934+q*(358.688+q*(-259.233+log_x*61.6566))))/(1.-8.1192*q+37.087*log_x)+(-131./192.+_ln2)/log_x-1.)
									)
							)
					:
						(-1.0018+(0.15128484821526975*(1.+33.04715298851381*q-3.51771875598067*log_x)*q)/(1.+3.2255053261256337*q)+(-0.5+_ln2)/log_x)
						+t*	(
								(1.1-2.608785958462561*(1.-0.6663562294911147*q)*q-(-0.625+_ln2)/log_x)
								+t*	(
										(-0.96+3.0912038297987596*(1.+0.6021398048785328*log_x)*q/(1.+ 4.240467556480155*log_x)+(-2./3+_ln2)/log_x)
										+t*(1.2-10.44604984418533*(1.+0.2137568928431227*q+0.3693275254470449*log_x)*q/(1.+4.95715636660691*q + 7.70233216637738*log_x)-(-131./192.+_ln2)/log_x)
									)
							)
				)*t+1.)+std::log(t+2.)/log_x-_ln2/log_x*(1.+t);
		}
		for(;h>0;--h)
			t=std::exp(log_x*t);
		for(;h<0;++h)
			t=std::log(t)/log_x;
		return t;
	}
	Quat1d tetrate(Quat1d const &x, double y)
	{
		Quat1d qx=x;
		double ry=y;
		if(ry<-1)
		{
			int steps=int(abs(ry));
			Quat1d t(ry-::floor(ry)), lrx=log(qx);
			for(int k=0;k<steps;++k)
				t=log(t)/lrx;
			return t;
		}
		else if(ry<=0)
			return Quat1d(1+ry);
		else
		{
			int h=int(ry)+1;
			Quat1d t(ry-::floor(ry));
			for(int k=0;k<h;++k)
				t=pow(qx, t);
			return t;
		}
	}
	Comp1d tetrate(double x, Comp1d const &y)
	{
		double log_x=std::log((double)x);
		std::complex<double> cy=y;
		int h=int(::floor(cy.real()-.5)+1);//rounded real part
		std::complex<double> t(cy-(double)h);//real-round(real)+i*imag
		{
			auto q=std::sqrt(log_x);
			t=(t+1.)*(
				(
					log_x>_ln2?
						(q*(0.137467+q*(4.94969+q*0.0474179))/(1.+q*(3.23171+q*0.471222))+(-.5+_ln2)/log_x-1.)
						+t*	(
								(q*(-0.424278+q*(1.75166+q*(-1.46524+q*0.93347)))/(0.0312142+q*(-0.267478+q))+(-.625+_ln2)/log_x-1.)
								+t*	(
										(q*(3.39255+q*(16.1046+q*(-19.5216+q*10.7458)))/(1.+q*(4.1274+q*5.25449))+(-2./3+_ln2)/log_x-1.)
										+t*(0.16*q*(1.+q*(27.7934+q*(358.688+q*(-259.233+log_x*61.6566))))/(1.-8.1192*q+37.087*log_x)+(-131./192.+_ln2)/log_x-1.)
									)
							)
					:
						(-1.0018+(0.15128484821526975*(1.+33.04715298851381*q-3.51771875598067*log_x)*q)/(1.+3.2255053261256337*q)+(-0.5+_ln2)/log_x)
						+t*	(
								(1.1-2.608785958462561*(1.-0.6663562294911147*q)*q-(-0.625+_ln2)/log_x)
								+t*	(
										(-0.96+3.0912038297987596*(1.+0.6021398048785328*log_x)*q/(1.+ 4.240467556480155*log_x)+(-2./3+_ln2)/log_x)
										+t*(1.2-10.44604984418533*(1.+0.2137568928431227*q+0.3693275254470449*log_x)*q/(1.+4.95715636660691*q + 7.70233216637738*log_x)-(-131./192.+_ln2)/log_x)
									)
							)
				)*t+1.)+std::log(t+2.)/log_x-_ln2/log_x*(1.+t);
		}
		for(;h>0;--h)
			t=std::exp(log_x*t);
		for(;h<0;++h)
			t=std::log(t)/log_x;
		return t;
	}
	Comp1d tetrate(Comp1d const &x, Comp1d const &y)
	{
		std::complex<double> log_x=std::log((std::complex<double>)x), cy=y;
	//	if(log_x.real()<.03)//abs(log_x)<1.03045453395352
	//	{
	//		if(cy.real()<-1.)
	//			return -30.;
	//		return 1.;
	//	}
		int h=int(::floor(cy.real()-.5)+1);
		std::complex<double> t(cy-(double)h);//real-round(real)+i*imag
		{
		//	bool unassigned=true;
		//	if(log_x.real()<.001)//abs(log_x)<1.00100050016671
		//	{
		//		if(t.real()>-1)//real-round(real)>-1
		//			unassigned=false, t=1.;
		//		else if(t.real()<-1)
		//			unassigned=false, t=-990.;
		//	}
		//	if(unassigned)
		//	{
				std::complex<double> q=std::sqrt(log_x);
				t=(t+1.)*(
					(
						log_x.real()>_ln2?
							(q*(0.137467+q*(4.94969+q*0.0474179))/(1.+q*(3.23171+q*0.471222))+(-.5+_ln2)/log_x-1.)
							+t*	(
									(q*(-0.424278+q*(1.75166+q*(-1.46524+q*0.93347)))/(0.0312142+q*(-0.267478+q))+(-.625+_ln2)/log_x-1.)
									+t*	(
											(q*(3.39255+q*(16.1046+q*(-19.5216+q*10.7458)))/(1.+q*(4.1274+q*5.25449))+(-2./3+_ln2)/log_x-1.)
											+t*(0.16*q*(1.+q*(27.7934+q*(358.688+q*(-259.233+log_x*61.6566))))/(1.-8.1192*q+37.087*log_x)+(-131./192.+_ln2)/log_x-1.)
										)
								)
						:
							(-1.0018+(0.15128484821526975*(1.+33.04715298851381*q-3.51771875598067*log_x)*q)/(1.+3.2255053261256337*q)+(-0.5+_ln2)/log_x)
							+t*	(
									(1.1-2.608785958462561*(1.-0.6663562294911147*sqrt(log_x))*sqrt(log_x)-(-0.625+_ln2)/log_x)
									+t*	(
											(-0.96+3.0912038297987596*(1.+0.6021398048785328*log_x)*q/(1.+ 4.240467556480155*log_x)+(-2./3+_ln2)/log_x)
											+t*(1.2-10.44604984418533*(1.+0.2137568928431227*q+0.3693275254470449*log_x)*q/(1.+4.95715636660691*q + 7.70233216637738*log_x)-(-131./192.+_ln2)/log_x)
										)
								)
					)*t+1.)+log(t+2.)/log_x-_ln2/log_x*(1.+t);
		//	}
		}
		for(;h>0;--h)
			t=exp(log_x*t);
		for(;h<0;++h)
			t=std::log(t)/log_x;
		return t;
	}
	void c_rr_tetrate				(CompP &r, VectP const &x, VectP const &y)	{r=tetrate(x, y);}
	void c_rc_tetrate				(CompP &r, VectP const &x, CompP const &y)	{r=tetrate(x, y);}
	void c_cr_tetrate				(CompP &r, CompP const &x, VectP const &y)	{r=tetrate((Comp1d)x, (double)y);}
	void c_cc_tetrate				(CompP &r, CompP const &x, CompP const &y)	{r=tetrate(x, y);}
	void q_qr_tetrate				(QuatP &r, QuatP const &x, VectP const &y)	{r=tetrate((Quat1d)x, (double)y);}
	bool disc_rr_tetrate_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cr_tetrate_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qr_tetrate_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_rc_tetrate_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cc_tetrate_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	
	class Tetrate//http://en.citizendium.org/wiki/Fit1.cin
	{
		static std::complex<double> _fit1(std::complex<double> x, std::complex<double> y)
		{
			if(x.real()<.001)
			{
				if(y.real()>-1)
					return 1.;
				if(y.real()<-1)
					return -990.;
			}
			std::complex<double> q=std::sqrt(x);
			return (y+1.)*(
				(
					x.real()>_ln2?
						(q*(0.137467+q*(4.94969+q*0.0474179))/(1.+q*(3.23171+q*0.471222))+(-.5+_ln2)/x-1.)
						+y*	(
								(q*(-0.424278+q*(1.75166+q*(-1.46524+q*0.93347)))/(0.0312142+q*(-0.267478+q))+(-.625+_ln2)/x-1.)
								+y*	(
										(q*(3.39255+q*(16.1046+q*(-19.5216+q*10.7458)))/(1.+q*(4.1274+q*5.25449))+(-2./3+_ln2)/x-1.)
										+y*(0.16*q*(1.+q*(27.7934+q*(358.688+q*(-259.233+x*61.6566))))/(1.-8.1192*q+37.087*x)+(-131./192.+_ln2)/x-1.)
									)
							)
					:
						(-1.0018+(0.15128484821526975*(1.+33.04715298851381*q-3.51771875598067*x)*q)/(1.+3.2255053261256337*q)+(-0.5+_ln2)/x)
						+y*	(
								(1.1-2.608785958462561*(1.-0.6663562294911147*sqrt(x))*sqrt(x)-(-0.625+_ln2)/x)
								+y*	(
										(-0.96+3.0912038297987596*(1.+0.6021398048785328*x)*q/(1.+ 4.240467556480155*x)+(-2./3+_ln2)/x)
										+y*(1.2-10.44604984418533*(1.+0.2137568928431227*q+0.3693275254470449*x)*q/(1.+4.95715636660691*q + 7.70233216637738*x)-(-131./192.+_ln2)/x)
									)
							)
				)*y+1.)+log(y+2.)/x-_ln2/x*(1.+y);
		}
	public:
		static std::complex<double> fit1(std::complex<double> x, std::complex<double> y)
		{
			x=std::log(x);
			if(x.real()<.03)
			{
				if(y.real()<-1.)
					return -30.;
				return 1.;
			}
			int h=int(::floor(y.real()-.5)+1);
			std::complex<double> result=_fit1(x, y-(double)h);
			for(;h>0;--h)
				result=exp(x*result);
			for(;h<0;++h)
				result=std::log(result)/x;
			return result;
		}
	};
	Comp1d pentate(double x, double y)
	{
		long long h=convert_d2ll_zero(y);
	//	long long h=y.r!=y.r||y.r<-ll_max||y.r>ll_max?0:long long(y);
	//	long long h=std::isnan(y.r)||std::isinf(y.r)?0:long long(y);
		if(h<-2)	return _HUGE;//1/::sin(0);
		if(h==-2)	return -1;
		if(h==-1)	return 0;
		if(h==0)	return 1;
		if(h==1)	return x;
		double rx=x;
		Comp1d result(rx);
		for(int k=0;k<h;++k)
			result=Tetrate::fit1(rx, result);
		return result;
	}
	Comp1d pentate(Comp1d const &x, double y)
	{
		long long h=convert_d2ll_zero(y);
		if(h<-2)	return _HUGE;//1/::sin(0);
		if(h==-2)	return -1;
		if(h==-1)	return 0;
		if(h==0)	return 1;
		if(h==1)	return x;
		Comp1d cx=x, result(cx);
		for(int k=0;k<h;++k)
			result=Tetrate::fit1(cx, result);
		return result;
	}
	void c_rr_pentate				(CompP &r, VectP const &x, VectP const &y)	{r=pentate(x, y);}
	void c_cr_pentate				(CompP &r, CompP const &x, VectP const &y)	{r=pentate(x, y);}
	bool disc_rr_pentate_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cr_pentate_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	void  r_r_bitwise_shift_left_l	(VectP &r, VectP const &x)					{r=::exp(x.floor()*_ln2);}	//<<x = 2^floor(x)		//is floor necessary?	floor: granular shift
	void  c_c_bitwise_shift_left_l	(CompP &r, CompP const &x)					{r=exp(floor(x)*_ln2);}
	void  q_q_bitwise_shift_left_l	(QuatP &r, QuatP const &x)					{r=exp(floor(x)*_ln2);}
	void  r_r_bitwise_shift_left_r	(VectP &r, VectP const &x)					{r=x+x;}					//x<< = 2x
	void  c_c_bitwise_shift_left_r	(CompP &r, CompP const &x)					{Comp1d cx=x; r=cx+cx;}
	void  q_q_bitwise_shift_left_r	(QuatP &r, QuatP const &x)					{Quat1d qx=x; r=qx+qx;}
	void r_rr_bitwise_shift_left	(VectP &r, VectP const &x, VectP const &y)	{r=x*::exp(y.floor()*_ln2);}//x<<y = x*2^floor(y)
	void c_rc_bitwise_shift_left	(CompP &r, VectP const &x, CompP const &y)	{r=(double)x*exp(floor(y)*_ln2);}
	void q_rq_bitwise_shift_left	(QuatP &r, VectP const &x, QuatP const &y)	{r=(double)x*exp(floor(y)*_ln2);}
	void c_cr_bitwise_shift_left	(CompP &r, CompP const &x, VectP const &y)	{r=(Comp1d)x*::exp(y.floor()*_ln2);}
	void c_cc_bitwise_shift_left	(CompP &r, CompP const &x, CompP const &y)	{r=(Comp1d)x*exp(floor(y)*_ln2);}
	void q_cq_bitwise_shift_left	(QuatP &r, CompP const &x, QuatP const &y)	{r=(Comp1d)x*exp(floor(y)*_ln2);}
	void q_qr_bitwise_shift_left	(QuatP &r, QuatP const &x, VectP const &y)	{r=(Quat1d)x*::exp(y.floor()*_ln2);}
	void q_qc_bitwise_shift_left	(QuatP &r, QuatP const &x, CompP const &y)	{r=(Quat1d)x*exp(floor(y)*_ln2);}
	void q_qq_bitwise_shift_left	(QuatP &r, QuatP const &x, QuatP const &y)	{r=(Quat1d)x*exp(floor(y)*_ln2);}
	auto disc_r_bitwise_shift_left_l_o	=disc_r_ceil_o;
	auto disc_c_bitwise_shift_left_l_o	=disc_c_ceil_o;
	auto disc_q_bitwise_shift_left_l_o	=disc_q_ceil_o;
	bool disc_rr_bitwise_shift_left_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return std::floor(x1.r)-std::floor(x0.r)!=0;}
	bool disc_rc_bitwise_shift_left_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return std::floor(x1.r)-std::floor(x0.r)!=0;}
	bool disc_rq_bitwise_shift_left_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return std::floor(x1.r)-std::floor(x0.r)!=0;}
	bool disc_cr_bitwise_shift_left_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return std::floor(x1.r)-std::floor(x0.r)!=0||std::floor(x1.i)-std::floor(x0.i)!=0;}
	bool disc_cc_bitwise_shift_left_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return std::floor(x1.r)-std::floor(x0.r)!=0||std::floor(x1.i)-std::floor(x0.i)!=0;}
	bool disc_cq_bitwise_shift_left_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return std::floor(x1.r)-std::floor(x0.r)!=0||std::floor(x1.i)-std::floor(x0.i)!=0;}
	bool disc_qr_bitwise_shift_left_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return std::floor(x1.r)-std::floor(x0.r)!=0||std::floor(x1.i)-std::floor(x0.i)!=0||std::floor(x1.j)-std::floor(x0.j)!=0||std::floor(x1.k)-std::floor(x0.k)!=0;}
	bool disc_qc_bitwise_shift_left_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return std::floor(x1.r)-std::floor(x0.r)!=0||std::floor(x1.i)-std::floor(x0.i)!=0||std::floor(x1.j)-std::floor(x0.j)!=0||std::floor(x1.k)-std::floor(x0.k)!=0;}
	bool disc_qq_bitwise_shift_left_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return std::floor(x1.r)-std::floor(x0.r)!=0||std::floor(x1.i)-std::floor(x0.i)!=0||std::floor(x1.j)-std::floor(x0.j)!=0||std::floor(x1.k)-std::floor(x0.k)!=0;}

	void  r_r_bitwise_shift_right_l	(VectP &r, VectP const &x)					{r=::exp(-x.floor()*_ln2);}	//>>x = 2^-floor(x)
	void  c_c_bitwise_shift_right_l	(CompP &r, CompP const &x)					{r=exp(-floor(x)*_ln2);}
	void  q_q_bitwise_shift_right_l	(QuatP &r, QuatP const &x)					{r=exp(-floor(x)*_ln2);}
	void  r_r_bitwise_shift_right_r	(VectP &r, VectP const &x)					{r=x*0.5;}					//x>> = x/2
	void  c_c_bitwise_shift_right_r	(CompP &r, CompP const &x)					{r=(Comp1d)x*0.5;}
	void  q_q_bitwise_shift_right_r	(QuatP &r, QuatP const &x)					{r=(Quat1d)x*0.5;}
	void r_rr_bitwise_shift_right	(VectP &r, VectP const &x, VectP const &y)	{r=x*::exp(-y.floor()*_ln2);}//x>>y = x*2^-floor(y)
	void c_rc_bitwise_shift_right	(CompP &r, VectP const &x, CompP const &y)	{r=(double)x*exp(-floor(y)*_ln2);}
	void q_rq_bitwise_shift_right	(QuatP &r, VectP const &x, QuatP const &y)	{r=(double)x*exp(-floor(y)*_ln2);}
	void c_cr_bitwise_shift_right	(CompP &r, CompP const &x, VectP const &y)	{r=(Comp1d)x*::exp(-y.floor()*_ln2);}
	void c_cc_bitwise_shift_right	(CompP &r, CompP const &x, CompP const &y)	{r=(Comp1d)x*exp(-floor(y)*_ln2);}
	void q_cq_bitwise_shift_right	(QuatP &r, CompP const &x, QuatP const &y)	{r=(Comp1d)x*exp(-floor(y)*_ln2);}
	void q_qr_bitwise_shift_right	(QuatP &r, QuatP const &x, VectP const &y)	{r=(Quat1d)x*::exp(-y.floor()*_ln2);}
	void q_qc_bitwise_shift_right	(QuatP &r, QuatP const &x, CompP const &y)	{r=(Quat1d)x*exp(-floor(y)*_ln2);}
	void q_qq_bitwise_shift_right	(QuatP &r, QuatP const &x, QuatP const &y)	{r=(Quat1d)x*exp(-floor(y)*_ln2);}
	auto disc_r_bitwise_shift_right_l_o	=disc_r_ceil_o;
	auto disc_c_bitwise_shift_right_l_o	=disc_c_ceil_o;
	auto disc_q_bitwise_shift_right_l_o	=disc_q_ceil_o;
	auto disc_rr_bitwise_shift_right_i	=disc_rr_bitwise_shift_left_i;
	auto disc_rc_bitwise_shift_right_i	=disc_rc_bitwise_shift_left_i;
	auto disc_rq_bitwise_shift_right_i	=disc_rq_bitwise_shift_left_i;
	auto disc_cr_bitwise_shift_right_i	=disc_cr_bitwise_shift_left_i;
	auto disc_cc_bitwise_shift_right_i	=disc_cc_bitwise_shift_left_i;
	auto disc_cq_bitwise_shift_right_i	=disc_cq_bitwise_shift_left_i;
	auto disc_qr_bitwise_shift_right_i	=disc_qr_bitwise_shift_left_i;
	auto disc_qc_bitwise_shift_right_i	=disc_qc_bitwise_shift_left_i;
	auto disc_qq_bitwise_shift_right_i	=disc_qq_bitwise_shift_left_i;

	inline double bitwise_not(double const &x){return std::isnan(x)|std::isinf(x)?0:(double)~convert_d2ll(x);}
	void  r_r_bitwise_not			(VectP &r, VectP const &x)					{r=bitwise_not(x);}
	void  c_c_bitwise_not			(CompP &r, CompP const &x)					{r=Comp1d(bitwise_not(*x.r), bitwise_not(*x.i));}
	void  q_q_bitwise_not			(QuatP &r, QuatP const &x)					{r=Quat1d(bitwise_not(*x.r), bitwise_not(*x.i), bitwise_not(*x.j), bitwise_not(*x.k));}
	auto disc_r_bitwise_not_i		=disc_r_arg_i;
	bool disc_c_bitwise_not_i		(Value const &x0, Value const &x1){return std::signbit(x0.r)!=std::signbit(x1.r)||std::signbit(x0.i)!=std::signbit(x1.i);}
	bool disc_q_bitwise_not_i		(Value const &x0, Value const &x1){return std::signbit(x0.r)!=std::signbit(x1.r)||std::signbit(x0.i)!=std::signbit(x1.i)||std::signbit(x0.j)!=std::signbit(x1.j)||std::signbit(x0.k)!=std::signbit(x1.k);}

	inline double bitwise_and(double const &x){return std::isnan(x)|std::isinf(x)?0:!~convert_d2ll(x);}
	inline double bitwise_and(double const &x, double const &y){return std::isnan(x)|std::isinf(x)|std::isnan(y)|std::isinf(y)?0:double(convert_d2ll(x)&convert_d2ll(y));}
	inline long long bitwise_and_ll(double const &x, double const &y){return std::isnan(x)|std::isinf(x)|std::isnan(y)|std::isinf(y)?0:convert_d2ll(x)&convert_d2ll(y);}
	void  r_r_bitwise_and			(VectP &r, VectP const &x)					{r=bitwise_and(x);}
	void  c_c_bitwise_and			(CompP &r, CompP const &x)					{r=Comp1d(bitwise_and(*x.r), bitwise_and(*x.i));}
	void  q_q_bitwise_and			(QuatP &r, QuatP const &x)					{r=Quat1d(bitwise_and(*x.r), bitwise_and(*x.i), bitwise_and(*x.j), bitwise_and(*x.k));}
	void r_rr_bitwise_and			(VectP &r, VectP const &x, VectP const &y)	{r=bitwise_and(x, y);}
	void c_rc_bitwise_and			(CompP &r, VectP const &x, CompP const &y)	{r=Comp1d(bitwise_and(x, *y.r), bitwise_and(x, *y.i));}
	void q_rq_bitwise_and			(QuatP &r, VectP const &x, QuatP const &y)	{r=Quat1d(bitwise_and(x, *y.r), bitwise_and(x, *y.i), bitwise_and(x, *y.j), bitwise_and(x, *y.k));}
	void c_cr_bitwise_and			(CompP &r, CompP const &x, VectP const &y)	{r=Comp1d(bitwise_and(*x.r, y), bitwise_and(*x.i, y));}
	void c_cc_bitwise_and			(CompP &r, CompP const &x, CompP const &y)
	{
		long long
			xr_yr=bitwise_and_ll(*x.r, *y.r), xi_yr=bitwise_and_ll(*x.i, *y.r),
			xr_yi=bitwise_and_ll(*x.r, *y.i), xi_yi=bitwise_and_ll(*x.i, *y.i);
		r=Comp1d(double(xr_yr-xi_yi), double(xr_yi+xi_yr));
	}
	void q_cq_bitwise_and			(QuatP &r, CompP const &x, QuatP const &y)
	{
		long long
			xr_yr=bitwise_and_ll(*x.r, *y.r), xi_yr=bitwise_and_ll(*x.i, *y.r),
			xr_yi=bitwise_and_ll(*x.r, *y.i), xi_yi=bitwise_and_ll(*x.i, *y.i),
			xr_yj=bitwise_and_ll(*x.r, *y.j), xi_yj=bitwise_and_ll(*x.i, *y.j),
			xr_yk=bitwise_and_ll(*x.r, *y.k), xi_yk=bitwise_and_ll(*x.i, *y.k);
		r=Quat1d(double(xr_yr-xi_yi), double(xr_yi+xi_yr), double(xr_yj-xi_yk), double(xr_yk+xi_yj));
	}
	void q_qr_bitwise_and			(QuatP &r, QuatP const &x, VectP const &y)	{r=Quat1d(bitwise_and(*x.r, y), bitwise_and(*x.i, y), bitwise_and(*x.j, y), bitwise_and(*x.k, y));}
	void q_qc_bitwise_and			(QuatP &r, QuatP const &x, CompP const &y)
	{
		long long
			xr_yr=bitwise_and_ll(*x.r, *y.r), xi_yr=bitwise_and_ll(*x.i, *y.r), xj_yr=bitwise_and_ll(*x.j, *y.r), xk_yr=bitwise_and_ll(*x.k, *y.r),
			xr_yi=bitwise_and_ll(*x.r, *y.i), xi_yi=bitwise_and_ll(*x.i, *y.i), xj_yi=bitwise_and_ll(*x.j, *y.i), xk_yi=bitwise_and_ll(*x.k, *y.i);
		r=Quat1d(double(xr_yr-xi_yi), double(xr_yi+xi_yr), double(xj_yr+xk_yi), double(-xj_yi+xk_yr));
	}
	void q_qq_bitwise_and			(QuatP &r, QuatP const &x, QuatP const &y)
	{
		long long
			xr_yr=bitwise_and_ll(*x.r, *y.r), xi_yr=bitwise_and_ll(*x.i, *y.r), xj_yr=bitwise_and_ll(*x.j, *y.r), xk_yr=bitwise_and_ll(*x.k, *y.r),
			xr_yi=bitwise_and_ll(*x.r, *y.i), xi_yi=bitwise_and_ll(*x.i, *y.i), xj_yi=bitwise_and_ll(*x.j, *y.i), xk_yi=bitwise_and_ll(*x.k, *y.i),
			xr_yj=bitwise_and_ll(*x.r, *y.j), xi_yj=bitwise_and_ll(*x.i, *y.j), xj_yj=bitwise_and_ll(*x.j, *y.j), xk_yj=bitwise_and_ll(*x.k, *y.j),
			xr_yk=bitwise_and_ll(*x.r, *y.k), xi_yk=bitwise_and_ll(*x.i, *y.k), xj_yk=bitwise_and_ll(*x.j, *y.k), xk_yk=bitwise_and_ll(*x.k, *y.k);
		r=Quat1d(double(xr_yr-xi_yi-xj_yj-xk_yk), double(xr_yi+xi_yr+xj_yk-xk_yj), double(xj_yj-xi_yk+xj_yr+xk_yi), double(xr_yk+xi_yj-xj_yi+xk_yr));
	}
	auto disc_r_bitwise_and_o		=disc_r_ceil_o;
	auto disc_c_bitwise_and_o		=disc_c_ceil_o;
	auto disc_q_bitwise_and_o		=disc_q_ceil_o;

	inline double bitwise_nand(double const &x){return std::isnan(x)|std::isinf(x)?0:!x;}
	inline double bitwise_nand(double const &x, double const &y){return std::isnan(x)|std::isinf(x)|std::isnan(y)|std::isinf(y)?0:(double)~(convert_d2ll(x)&convert_d2ll(y));}
	inline long long bitwise_nand_ll(double const &x, double const &y){return std::isnan(x)|std::isinf(x)|std::isnan(y)|std::isinf(y)?0:~(convert_d2ll(x)&convert_d2ll(y));}
	void  r_r_bitwise_nand			(VectP &r, VectP const &x)					{r=bitwise_nand(x);}
	void  c_c_bitwise_nand			(CompP &r, CompP const &x)					{r=Comp1d(bitwise_nand(*x.r), bitwise_nand(*x.i));}
	void  q_q_bitwise_nand			(QuatP &r, QuatP const &x)					{r=Quat1d(bitwise_nand(*x.r), bitwise_nand(*x.i), bitwise_nand(*x.j), bitwise_nand(*x.k));}
	void r_rr_bitwise_nand			(VectP &r, VectP const &x, VectP const &y)	{r=bitwise_nand(x, y);}
	void c_rc_bitwise_nand			(CompP &r, VectP const &x, CompP const &y)	{r=Comp1d(bitwise_nand(x, *y.r), bitwise_nand(x, *y.i));}
	void q_rq_bitwise_nand			(QuatP &r, VectP const &x, QuatP const &y)	{r=Quat1d(bitwise_nand(x, *y.r), bitwise_nand(x, *y.i), bitwise_nand(x, *y.j), bitwise_nand(x, *y.k));}
	void c_cr_bitwise_nand			(CompP &r, CompP const &x, VectP const &y)	{r=Comp1d(bitwise_nand(*x.r, y), bitwise_nand(*x.i, y));}
	void c_cc_bitwise_nand			(CompP &r, CompP const &x, CompP const &y)
	{
		long long
			xr_yr=bitwise_nand_ll(*x.r, *y.r), xi_yr=bitwise_nand_ll(*x.i, *y.r),
			xr_yi=bitwise_nand_ll(*x.r, *y.i), xi_yi=bitwise_nand_ll(*x.i, *y.i);
		r=Comp1d(double(xr_yr-xi_yi), double(xr_yi+xi_yr));
	}
	void q_cq_bitwise_nand			(QuatP &r, CompP const &x, QuatP const &y)
	{
		long long
			xr_yr=bitwise_nand_ll(*x.r, *y.r), xi_yr=bitwise_nand_ll(*x.i, *y.r),
			xr_yi=bitwise_nand_ll(*x.r, *y.i), xi_yi=bitwise_nand_ll(*x.i, *y.i),
			xr_yj=bitwise_nand_ll(*x.r, *y.j), xi_yj=bitwise_nand_ll(*x.i, *y.j),
			xr_yk=bitwise_nand_ll(*x.r, *y.k), xi_yk=bitwise_nand_ll(*x.i, *y.k);
		r=Quat1d(double(xr_yr-xi_yi), double(xr_yi+xi_yr), double(xr_yj-xi_yk), double(xr_yk+xi_yj));
	}
	void q_qr_bitwise_nand			(QuatP &r, QuatP const &x, VectP const &y)	{r=Quat1d(bitwise_nand(*x.r, y), bitwise_nand(*x.i, y), bitwise_nand(*x.j, y), bitwise_nand(*x.k, y));}
	void q_qc_bitwise_nand			(QuatP &r, QuatP const &x, CompP const &y)
	{
		long long
			xr_yr=bitwise_nand_ll(*x.r, *y.r), xi_yr=bitwise_nand_ll(*x.i, *y.r), xj_yr=bitwise_nand_ll(*x.j, *y.r), xk_yr=bitwise_nand_ll(*x.k, *y.r),
			xr_yi=bitwise_nand_ll(*x.r, *y.i), xi_yi=bitwise_nand_ll(*x.i, *y.i), xj_yi=bitwise_nand_ll(*x.j, *y.i), xk_yi=bitwise_nand_ll(*x.k, *y.i);
		r=Quat1d(double(xr_yr-xi_yi), double(xr_yi+xi_yr), double(xj_yr+xk_yi), double(-xj_yi+xk_yr));
	}
	void q_qq_bitwise_nand			(QuatP &r, QuatP const &x, QuatP const &y)
	{
		long long
			xr_yr=bitwise_nand_ll(*x.r, *y.r), xi_yr=bitwise_nand_ll(*x.i, *y.r), xj_yr=bitwise_nand_ll(*x.j, *y.r), xk_yr=bitwise_nand_ll(*x.k, *y.r),
			xr_yi=bitwise_nand_ll(*x.r, *y.i), xi_yi=bitwise_nand_ll(*x.i, *y.i), xj_yi=bitwise_nand_ll(*x.j, *y.i), xk_yi=bitwise_nand_ll(*x.k, *y.i),
			xr_yj=bitwise_nand_ll(*x.r, *y.j), xi_yj=bitwise_nand_ll(*x.i, *y.j), xj_yj=bitwise_nand_ll(*x.j, *y.j), xk_yj=bitwise_nand_ll(*x.k, *y.j),
			xr_yk=bitwise_nand_ll(*x.r, *y.k), xi_yk=bitwise_nand_ll(*x.i, *y.k), xj_yk=bitwise_nand_ll(*x.j, *y.k), xk_yk=bitwise_nand_ll(*x.k, *y.k);
		r=Quat1d(double(xr_yr-xi_yi-xj_yj-xk_yk), double(xr_yi+xi_yr+xj_yk-xk_yj), double(xj_yj-xi_yk+xj_yr+xk_yi), double(xr_yk+xi_yj-xj_yi+xk_yr));
	}
	auto disc_r_bitwise_nand_o		=disc_r_bitwise_and_o;
	auto disc_c_bitwise_nand_o		=disc_c_bitwise_and_o;
	auto disc_q_bitwise_nand_o		=disc_q_bitwise_and_o;
	
	inline double bitwise_or(double const &x){return std::isnan(x)|std::isinf(x)?0:convert_d2ll(x)!=0;}
	inline double bitwise_or(double const &x, double const &y){return std::isnan(x)|std::isinf(x)|std::isnan(y)|std::isinf(y)?0:double(convert_d2ll(x)|convert_d2ll(y));}
	inline long long bitwise_or_ll_c(double const &x, double const &y){return std::isnan(x)|std::isinf(x)|std::isnan(y)|std::isinf(y)?0:~convert_d2ll(x)&~convert_d2ll(y);}
	void  r_r_bitwise_or			(VectP &r, VectP const &x)					{r=bitwise_or(x);}
	void  c_c_bitwise_or			(CompP &r, CompP const &x)					{r=Comp1d(bitwise_or(*x.r), bitwise_or(*x.i));}
	void  q_q_bitwise_or			(QuatP &r, QuatP const &x)					{r=Quat1d(bitwise_or(*x.r), bitwise_or(*x.i), bitwise_or(*x.j), bitwise_or(*x.k));}
	void r_rr_bitwise_or			(VectP &r, VectP const &x, VectP const &y)	{r=bitwise_or(x, y);}
	void c_rc_bitwise_or			(CompP &r, VectP const &x, CompP const &y)	{r=Comp1d(bitwise_or(x, *y.r), bitwise_or(x, *y.i));}
	void q_rq_bitwise_or			(QuatP &r, VectP const &x, QuatP const &y)	{r=Quat1d(bitwise_or(x, *y.r), bitwise_or(x, *y.i), bitwise_or(x, *y.j), bitwise_or(x, *y.k));}
	void c_cr_bitwise_or			(CompP &r, CompP const &x, VectP const &y)	{r=Comp1d(bitwise_or(*x.r, y), bitwise_or(*x.i, y));}
	void c_cc_bitwise_or			(CompP &r, CompP const &x, CompP const &y)
	{
		long long
			xr_yr=bitwise_or_ll_c(*x.r, *y.r), xi_yr=bitwise_or_ll_c(*x.i, *y.r),
			xr_yi=bitwise_or_ll_c(*x.r, *y.i), xi_yi=bitwise_or_ll_c(*x.i, *y.i);
		r=Comp1d((double)~(xr_yr-xi_yi), (double)~(xr_yi+xi_yr));
	}
	void q_cq_bitwise_or			(QuatP &r, CompP const &x, QuatP const &y)
	{
		long long
			xr_yr=bitwise_or_ll_c(*x.r, *y.r), xi_yr=bitwise_or_ll_c(*x.i, *y.r),
			xr_yi=bitwise_or_ll_c(*x.r, *y.i), xi_yi=bitwise_or_ll_c(*x.i, *y.i),
			xr_yj=bitwise_or_ll_c(*x.r, *y.j), xi_yj=bitwise_or_ll_c(*x.i, *y.j),
			xr_yk=bitwise_or_ll_c(*x.r, *y.k), xi_yk=bitwise_or_ll_c(*x.i, *y.k);
		r=Quat1d((double)~(xr_yr-xi_yi), (double)~(xr_yi+xi_yr), (double)~(xr_yj-xi_yk), (double)~(xr_yk+xi_yj));
	}
	void q_qr_bitwise_or			(QuatP &r, QuatP const &x, VectP const &y)	{r=Quat1d(bitwise_or(*x.r, y), bitwise_or(*x.i, y), bitwise_or(*x.j, y), bitwise_or(*x.k, y));}
	void q_qc_bitwise_or			(QuatP &r, QuatP const &x, CompP const &y)
	{
		long long
			xr_yr=bitwise_or_ll_c(*x.r, *y.r), xi_yr=bitwise_or_ll_c(*x.i, *y.r), xj_yr=bitwise_or_ll_c(*x.j, *y.r), xk_yr=bitwise_or_ll_c(*x.k, *y.r),
			xr_yi=bitwise_or_ll_c(*x.r, *y.i), xi_yi=bitwise_or_ll_c(*x.i, *y.i), xj_yi=bitwise_or_ll_c(*x.j, *y.i), xk_yi=bitwise_or_ll_c(*x.k, *y.i);
		r=Quat1d((double)~(xr_yr-xi_yi), (double)~(xr_yi+xi_yr), (double)~(xj_yr+xk_yi), (double)~(-xj_yi+xk_yr));
	}
	void q_qq_bitwise_or			(QuatP &r, QuatP const &x, QuatP const &y)
	{
		long long
			xr_yr=bitwise_or_ll_c(*x.r, *y.r), xi_yr=bitwise_or_ll_c(*x.i, *y.r), xj_yr=bitwise_or_ll_c(*x.j, *y.r), xk_yr=bitwise_or_ll_c(*x.k, *y.r),
			xr_yi=bitwise_or_ll_c(*x.r, *y.i), xi_yi=bitwise_or_ll_c(*x.i, *y.i), xj_yi=bitwise_or_ll_c(*x.j, *y.i), xk_yi=bitwise_or_ll_c(*x.k, *y.i),
			xr_yj=bitwise_or_ll_c(*x.r, *y.j), xi_yj=bitwise_or_ll_c(*x.i, *y.j), xj_yj=bitwise_or_ll_c(*x.j, *y.j), xk_yj=bitwise_or_ll_c(*x.k, *y.j),
			xr_yk=bitwise_or_ll_c(*x.r, *y.k), xi_yk=bitwise_or_ll_c(*x.i, *y.k), xj_yk=bitwise_or_ll_c(*x.j, *y.k), xk_yk=bitwise_or_ll_c(*x.k, *y.k);
		r=Quat1d((double)~(xr_yr-xi_yi-xj_yj-xk_yk), (double)~(xr_yi+xi_yr+xj_yk-xk_yj), (double)~(xj_yj-xi_yk+xj_yr+xk_yi), (double)~(xr_yk+xi_yj-xj_yi+xk_yr));
	}
	auto disc_r_bitwise_or_o		=disc_r_bitwise_and_o;
	auto disc_c_bitwise_or_o		=disc_c_bitwise_and_o;
	auto disc_q_bitwise_or_o		=disc_q_bitwise_and_o;
	
	inline double bitwise_nor(double const &x){return std::isnan(x)|std::isinf(x)?0:!convert_d2ll(x);}
	inline double bitwise_nor(double const &x, double const &y){return std::isnan(x)|std::isinf(x)|std::isnan(x)|std::isinf(x)?0:(double)~(convert_d2ll(x)|convert_d2ll(y));}
	inline long long bitwise_nor_ll_c(double const &x, double const &y){return std::isnan(x)|std::isinf(x)|std::isnan(x)|std::isinf(x)?0:~convert_d2ll(x)|~convert_d2ll(y);}
	void  r_r_bitwise_nor			(VectP &r, VectP const &x)					{r=bitwise_nor(x);}
	void  c_c_bitwise_nor			(CompP &r, CompP const &x)					{r=Comp1d(bitwise_nor(*x.r), bitwise_nor(*x.i));}
	void  q_q_bitwise_nor			(QuatP &r, QuatP const &x)					{r=Quat1d(bitwise_nor(*x.r), bitwise_nor(*x.i), bitwise_nor(*x.j), bitwise_nor(*x.k));}
	void r_rr_bitwise_nor			(VectP &r, VectP const &x, VectP const &y)	{r=bitwise_nor(x, y);}
	void c_rc_bitwise_nor			(CompP &r, VectP const &x, CompP const &y)	{r=Comp1d(bitwise_nor(x, *y.r), bitwise_nor(x, *y.i));}
	void q_rq_bitwise_nor			(QuatP &r, VectP const &x, QuatP const &y)	{r=Quat1d(bitwise_nor(x, *y.r), bitwise_nor(x, *y.i), bitwise_nor(x, *y.j), bitwise_nor(x, *y.k));}
	void c_cr_bitwise_nor			(CompP &r, CompP const &x, VectP const &y)	{r=Comp1d(bitwise_nor(*x.r, y), bitwise_nor(*x.i, y));}
	void c_cc_bitwise_nor			(CompP &r, CompP const &x, CompP const &y)
	{
		long long
			xr_yr=bitwise_nor_ll_c(*x.r, *y.r), xi_yr=bitwise_nor_ll_c(*x.i, *y.r),
			xr_yi=bitwise_nor_ll_c(*x.r, *y.i), xi_yi=bitwise_nor_ll_c(*x.i, *y.i);
		r=Comp1d((double)~(xr_yr-xi_yi), (double)~(xr_yi+xi_yr));
	}
	void q_cq_bitwise_nor			(QuatP &r, CompP const &x, QuatP const &y)
	{
		long long
			xr_yr=bitwise_nor_ll_c(*x.r, *y.r), xi_yr=bitwise_nor_ll_c(*x.i, *y.r),
			xr_yi=bitwise_nor_ll_c(*x.r, *y.i), xi_yi=bitwise_nor_ll_c(*x.i, *y.i),
			xr_yj=bitwise_nor_ll_c(*x.r, *y.j), xi_yj=bitwise_nor_ll_c(*x.i, *y.j),
			xr_yk=bitwise_nor_ll_c(*x.r, *y.k), xi_yk=bitwise_nor_ll_c(*x.i, *y.k);
		r=Quat1d((double)~(xr_yr-xi_yi), (double)~(xr_yi+xi_yr), (double)~(xr_yj-xi_yk), (double)~(xr_yk+xi_yj));
	}
	void q_qr_bitwise_nor			(QuatP &r, QuatP const &x, VectP const &y)	{r=Quat1d(bitwise_nor(*x.r, y), bitwise_nor(*x.i, y), bitwise_nor(*x.j, y), bitwise_nor(*x.k, y));}
	void q_qc_bitwise_nor			(QuatP &r, QuatP const &x, CompP const &y)
	{
		long long
			xr_yr=bitwise_nor_ll_c(*x.r, *y.r), xi_yr=bitwise_nor_ll_c(*x.i, *y.r), xj_yr=bitwise_nor_ll_c(*x.j, *y.r), xk_yr=bitwise_nor_ll_c(*x.k, *y.r),
			xr_yi=bitwise_nor_ll_c(*x.r, *y.i), xi_yi=bitwise_nor_ll_c(*x.i, *y.i), xj_yi=bitwise_nor_ll_c(*x.j, *y.i), xk_yi=bitwise_nor_ll_c(*x.k, *y.i);
		r=Quat1d((double)~(xr_yr-xi_yi), (double)~(xr_yi+xi_yr), (double)~(xj_yr+xk_yi), (double)~(-xj_yi+xk_yr));
	}
	void q_qq_bitwise_nor			(QuatP &r, QuatP const &x, QuatP const &y)
	{
		long long
			xr_yr=bitwise_nor_ll_c(*x.r, *y.r), xi_yr=bitwise_nor_ll_c(*x.i, *y.r), xj_yr=bitwise_nor_ll_c(*x.j, *y.r), xk_yr=bitwise_nor_ll_c(*x.k, *y.r),
			xr_yi=bitwise_nor_ll_c(*x.r, *y.i), xi_yi=bitwise_nor_ll_c(*x.i, *y.i), xj_yi=bitwise_nor_ll_c(*x.j, *y.i), xk_yi=bitwise_nor_ll_c(*x.k, *y.i),
			xr_yj=bitwise_nor_ll_c(*x.r, *y.j), xi_yj=bitwise_nor_ll_c(*x.i, *y.j), xj_yj=bitwise_nor_ll_c(*x.j, *y.j), xk_yj=bitwise_nor_ll_c(*x.k, *y.j),
			xr_yk=bitwise_nor_ll_c(*x.r, *y.k), xi_yk=bitwise_nor_ll_c(*x.i, *y.k), xj_yk=bitwise_nor_ll_c(*x.j, *y.k), xk_yk=bitwise_nor_ll_c(*x.k, *y.k);
		r=Quat1d((double)~(xr_yr-xi_yi-xj_yj-xk_yk), (double)~(xr_yi+xi_yr+xj_yk-xk_yj), (double)~(xj_yj-xi_yk+xj_yr+xk_yi), (double)~(xr_yk+xi_yj-xj_yi+xk_yr));
	}
	auto disc_r_bitwise_nor_o		=disc_r_bitwise_and_o;
	auto disc_c_bitwise_nor_o		=disc_c_bitwise_and_o;
	auto disc_q_bitwise_nor_o		=disc_q_bitwise_and_o;
	
	//inline double bitwise_xor(double const &x){return std::isnan(x)|std::isinf(x)?0:bitwise_xor(x);}
	inline double bitwise_xor(double const &x, double const &y){return std::isnan(x)|std::isinf(x)|std::isnan(y)|std::isinf(y)?0:double(convert_d2ll(x)^convert_d2ll(y));}
	void  r_r_bitwise_xor			(VectP &r, VectP const &x)					{r=bitwise_xor(x);}
	void  c_c_bitwise_xor			(CompP &r, CompP const &x)					{r=Comp1d(bitwise_xor(*x.r), bitwise_xor(*x.i));}
	void  q_q_bitwise_xor			(QuatP &r, QuatP const &x)					{r=Quat1d(bitwise_xor(*x.r), bitwise_xor(*x.i), bitwise_xor(*x.j), bitwise_xor(*x.k));}
	void r_rr_bitwise_xor			(VectP &r, VectP const &x, VectP const &y)	{r=bitwise_xor(x, y);}
	void c_rc_bitwise_xor			(CompP &r, VectP const &x, CompP const &y)	{r=Comp1d(bitwise_xor(x, *y.r), *y.i);}
	void q_rq_bitwise_xor			(QuatP &r, VectP const &x, QuatP const &y)	{r=Quat1d(bitwise_xor(x, *y.r), *y.i, *y.j, *y.k);}
	void c_cr_bitwise_xor			(CompP &r, CompP const &x, VectP const &y)	{r=Comp1d(bitwise_xor(*x.r, y), *x.i);}
	void c_cc_bitwise_xor			(CompP &r, CompP const &x, CompP const &y)	{r=Comp1d(bitwise_xor(*x.r, *y.r), bitwise_xor(*x.i, *y.i));}
	void q_cq_bitwise_xor			(QuatP &r, CompP const &x, QuatP const &y)	{r=Quat1d(bitwise_xor(*x.r, *y.r), bitwise_xor(*x.i, *y.i), *y.j, *y.k);}
	void q_qr_bitwise_xor			(QuatP &r, QuatP const &x, VectP const &y)	{r=Quat1d(bitwise_xor(*x.r, y), *x.i, *x.j, *x.k);}
	void q_qc_bitwise_xor			(QuatP &r, QuatP const &x, CompP const &y)	{r=Quat1d(bitwise_xor(*x.r, *y.r), bitwise_xor(*x.i, *y.i), *x.j, *x.k);}
	void q_qq_bitwise_xor			(QuatP &r, QuatP const &x, QuatP const &y)	{r=Quat1d(bitwise_xor(*x.r, *y.r), bitwise_xor(*x.i, *y.i), bitwise_xor(*x.j, *y.j), bitwise_xor(*x.k, *y.k));}
	auto disc_r_bitwise_xor_o		=disc_r_bitwise_and_o;
	auto disc_c_bitwise_xor_o		=disc_c_bitwise_and_o;
	auto disc_q_bitwise_xor_o		=disc_q_bitwise_and_o;
	
	//inline double bitwise_xnor(double const &x){return std::isnan(x)|std::isinf(x)?0:(double)!bitwise_xor(x);}
	inline double bitwise_xnor(double const &x, double const &y){return std::isnan(x)|std::isinf(x)|std::isnan(y)|std::isinf(y)?0:(double)~(convert_d2ll(x)^convert_d2ll(y));}
	void  r_r_bitwise_xnor			(VectP &r, VectP const &x)					{r=bitwise_xnor(x);}
	void  c_c_bitwise_xnor			(CompP &r, CompP const &x)					{r=Comp1d(bitwise_xnor(*x.r), bitwise_xnor(*x.i));}
	void  q_q_bitwise_xnor			(QuatP &r, QuatP const &x)					{r=Quat1d(bitwise_xnor(*x.r), bitwise_xnor(*x.i), bitwise_xnor(*x.j), bitwise_xnor(*x.k));}
	void r_rr_bitwise_xnor			(VectP &r, VectP const &x, VectP const &y)	{r=bitwise_xnor(x, y);}
	void c_rc_bitwise_xnor			(CompP &r, VectP const &x, CompP const &y)	{r=Comp1d(bitwise_xnor(x, *y.r), *y.i);}
	void q_rq_bitwise_xnor			(QuatP &r, VectP const &x, QuatP const &y)	{r=Quat1d(bitwise_xnor(x, *y.r), *y.i, *y.j, *y.k);}
	void c_cr_bitwise_xnor			(CompP &r, CompP const &x, VectP const &y)	{r=Comp1d(bitwise_xnor(*x.r, y), *x.i);}
	void c_cc_bitwise_xnor			(CompP &r, CompP const &x, CompP const &y)	{r=Comp1d(bitwise_xnor(*x.r, *y.r), bitwise_xnor(*x.i, *y.i));}
	void q_cq_bitwise_xnor			(QuatP &r, CompP const &x, QuatP const &y)	{r=Quat1d(bitwise_xnor(*x.r, *y.r), bitwise_xnor(*x.i, *y.i), *y.j, *y.k);}
	void q_qr_bitwise_xnor			(QuatP &r, QuatP const &x, VectP const &y)	{r=Quat1d(bitwise_xnor(*x.r, y), *x.i, *x.j, *x.k);}
	void q_qc_bitwise_xnor			(QuatP &r, QuatP const &x, CompP const &y)	{r=Quat1d(bitwise_xnor(*x.r, *y.r), bitwise_xnor(*x.i, *y.i), *x.j, *x.k);}
	void q_qq_bitwise_xnor			(QuatP &r, QuatP const &x, QuatP const &y)	{r=Quat1d(bitwise_xnor(*x.r, *y.r), bitwise_xnor(*x.i, *y.i), bitwise_xnor(*x.j, *y.j), bitwise_xnor(*x.k, *y.k));}
	auto disc_r_bitwise_xnor_o		=disc_r_bitwise_and_o;
	auto disc_c_bitwise_xnor_o		=disc_c_bitwise_and_o;
	auto disc_q_bitwise_xnor_o		=disc_q_bitwise_and_o;
	
	void  r_r_logic_equal			(VectP &r, VectP const &x)					{r=x==0;}
	void  r_c_logic_equal			(VectP &r, CompP const &x)					{r=!x.c_is_true();}
	void  r_q_logic_equal			(VectP &r, QuatP const &x)					{r=!x.q_is_true();}
	void r_rr_logic_equal			(VectP &r, VectP const &x, VectP const &y)	{r=x==y;}
	void r_rc_logic_equal			(VectP &r, VectP const &x, CompP const &y)	{r=(double)x==(Comp1d)y;}
	void r_rq_logic_equal			(VectP &r, VectP const &x, QuatP const &y)	{r=(double)x==(Quat1d)y;}
	void r_cr_logic_equal			(VectP &r, CompP const &x, VectP const &y)	{r=(Comp1d)x==(double)y;}
	void r_cc_logic_equal			(VectP &r, CompP const &x, CompP const &y)	{r=(Comp1d)x==(Comp1d)y;}
	void r_cq_logic_equal			(VectP &r, CompP const &x, QuatP const &y)	{r=(Comp1d)x==(Quat1d)y;}
	void r_qr_logic_equal			(VectP &r, QuatP const &x, VectP const &y)	{r=(Quat1d)x==(double)y;}
	void r_qc_logic_equal			(VectP &r, QuatP const &x, CompP const &y)	{r=(Quat1d)x==(Comp1d)y;}
	void r_qq_logic_equal			(VectP &r, QuatP const &x, QuatP const &y)	{r=(Quat1d)x==(Quat1d)y;}
	auto disc_r_logic_equal_o		=disc_r_logic_divides_o;
	
	void  r_r_logic_not_equal		(VectP &r, VectP const &x)					{r=x.r_is_true();}
	void  r_c_logic_not_equal		(VectP &r, CompP const &x)					{r=x.c_is_true();}
	void  r_q_logic_not_equal		(VectP &r, QuatP const &x)					{r=x.q_is_true();}
	void r_rr_logic_not_equal		(VectP &r, VectP const &x, VectP const &y)	{r=x!=y;}
	void r_rc_logic_not_equal		(VectP &r, VectP const &x, CompP const &y)	{r=(double)x!=(Comp1d)y;}
	void r_rq_logic_not_equal		(VectP &r, VectP const &x, QuatP const &y)	{r=(double)x!=(Quat1d)y;}
	void r_cr_logic_not_equal		(VectP &r, CompP const &x, VectP const &y)	{r=(Comp1d)x!=(double)y;}
	void r_cc_logic_not_equal		(VectP &r, CompP const &x, CompP const &y)	{r=(Comp1d)x!=(Comp1d)y;}
	void r_cq_logic_not_equal		(VectP &r, CompP const &x, QuatP const &y)	{r=(Comp1d)x!=(Quat1d)y;}
	void r_qr_logic_not_equal		(VectP &r, QuatP const &x, VectP const &y)	{r=(Quat1d)x!=(double)y;}
	void r_qc_logic_not_equal		(VectP &r, QuatP const &x, CompP const &y)	{r=(Quat1d)x!=(Comp1d)y;}
	void r_qq_logic_not_equal		(VectP &r, QuatP const &x, QuatP const &y)	{r=(Quat1d)x!=(Quat1d)y;}
	auto disc_r_logic_not_equal_o	=disc_r_logic_divides_o;
	
	void  r_r_logic_less_l			(VectP &r, VectP const &x)					{r=0<x;}
	void  r_c_logic_less_l			(VectP &r, CompP const &x)					{r=0<*x.r;}
	void  r_q_logic_less_l			(VectP &r, QuatP const &x)					{r=0<*x.r;}
	void  r_r_logic_less_r			(VectP &r, VectP const &x)					{r=x<0;}
	void  r_c_logic_less_r			(VectP &r, CompP const &x)					{r=*x.r<0;}
	void  r_q_logic_less_r			(VectP &r, QuatP const &x)					{r=*x.r<0;}
	void r_rr_logic_less			(VectP &r, VectP const &x, VectP const &y)	{r=x<y;}
	void r_rc_logic_less			(VectP &r, VectP const &x, CompP const &y)	{r=x<*y.r;}
	void r_rq_logic_less			(VectP &r, VectP const &x, QuatP const &y)	{r=x<*y.r;}
	void r_cr_logic_less			(VectP &r, CompP const &x, VectP const &y)	{r=*x.r<y;}
	void r_cc_logic_less			(VectP &r, CompP const &x, CompP const &y)	{r=*x.r<*y.r;}
	void r_cq_logic_less			(VectP &r, CompP const &x, QuatP const &y)	{r=*x.r<*y.r;}
	void r_qr_logic_less			(VectP &r, QuatP const &x, VectP const &y)	{r=*x.r<y;}
	void r_qc_logic_less			(VectP &r, QuatP const &x, CompP const &y)	{r=*x.r<*y.r;}
	void r_qq_logic_less			(VectP &r, QuatP const &x, QuatP const &y)	{r=*x.r<*y.r;}
	auto disc_r_logic_less_l_o		=disc_r_logic_divides_o;
	auto disc_r_logic_less_r_o		=disc_r_logic_divides_o;
	auto disc_r_logic_less_o		=disc_r_logic_divides_o;
	
	void  r_r_logic_less_equal_l	(VectP &r, VectP const &x)					{r=0<=x;}
	void  r_c_logic_less_equal_l	(VectP &r, CompP const &x)					{r=0<=*x.r;}
	void  r_q_logic_less_equal_l	(VectP &r, QuatP const &x)					{r=0<=*x.r;}
	void  r_r_logic_less_equal_r	(VectP &r, VectP const &x)					{r=x<=0;}
	void  r_c_logic_less_equal_r	(VectP &r, CompP const &x)					{r=*x.r<=0;}
	void  r_q_logic_less_equal_r	(VectP &r, QuatP const &x)					{r=*x.r<=0;}
	void r_rr_logic_less_equal		(VectP &r, VectP const &x, VectP const &y)	{r=x<=y;}
	void r_rc_logic_less_equal		(VectP &r, VectP const &x, CompP const &y)	{r=x<=*y.r;}
	void r_rq_logic_less_equal		(VectP &r, VectP const &x, QuatP const &y)	{r=x<=*y.r;}
	void r_cr_logic_less_equal		(VectP &r, CompP const &x, VectP const &y)	{r=*x.r<=y;}
	void r_cc_logic_less_equal		(VectP &r, CompP const &x, CompP const &y)	{r=*x.r<=*y.r;}
	void r_cq_logic_less_equal		(VectP &r, CompP const &x, QuatP const &y)	{r=*x.r<=*y.r;}
	void r_qr_logic_less_equal		(VectP &r, QuatP const &x, VectP const &y)	{r=*x.r<=y;}
	void r_qc_logic_less_equal		(VectP &r, QuatP const &x, CompP const &y)	{r=*x.r<=*y.r;}
	void r_qq_logic_less_equal		(VectP &r, QuatP const &x, QuatP const &y)	{r=*x.r<=*y.r;}
	auto disc_r_logic_less_equal_l_o=disc_r_logic_divides_o;
	auto disc_r_logic_less_equal_r_o=disc_r_logic_divides_o;
	auto disc_r_logic_less_equal_o	=disc_r_logic_divides_o;
	
	void  r_r_logic_greater_l		(VectP &r, VectP const &x)					{r=0>x;}
	void  r_c_logic_greater_l		(VectP &r, CompP const &x)					{r=0>*x.r;}
	void  r_q_logic_greater_l		(VectP &r, QuatP const &x)					{r=0>*x.r;}
	void  r_r_logic_greater_r		(VectP &r, VectP const &x)					{r=x>0;}
	void  r_c_logic_greater_r		(VectP &r, CompP const &x)					{r=*x.r>0;}
	void  r_q_logic_greater_r		(VectP &r, QuatP const &x)					{r=*x.r>0;}
	void r_rr_logic_greater			(VectP &r, VectP const &x, VectP const &y)	{r=x>y;}
	void r_rc_logic_greater			(VectP &r, VectP const &x, CompP const &y)	{r=x>*y.r;}
	void r_rq_logic_greater			(VectP &r, VectP const &x, QuatP const &y)	{r=x>*y.r;}
	void r_cr_logic_greater			(VectP &r, CompP const &x, VectP const &y)	{r=*x.r>y;}
	void r_cc_logic_greater			(VectP &r, CompP const &x, CompP const &y)	{r=*x.r>*y.r;}
	void r_cq_logic_greater			(VectP &r, CompP const &x, QuatP const &y)	{r=*x.r>*y.r;}
	void r_qr_logic_greater			(VectP &r, QuatP const &x, VectP const &y)	{r=*x.r>y;}
	void r_qc_logic_greater			(VectP &r, QuatP const &x, CompP const &y)	{r=*x.r>*y.r;}
	void r_qq_logic_greater			(VectP &r, QuatP const &x, QuatP const &y)	{r=*x.r>*y.r;}
	auto disc_r_logic_greater_l_o	=disc_r_logic_divides_o;
	auto disc_r_logic_greater_r_o	=disc_r_logic_divides_o;
	auto disc_r_logic_greater_o		=disc_r_logic_divides_o;
	
	void  r_r_logic_greater_equal_l	(VectP &r, VectP const &x)					{r=0>=x;}
	void  r_c_logic_greater_equal_l	(VectP &r, CompP const &x)					{r=0>=*x.r;}
	void  r_q_logic_greater_equal_l	(VectP &r, QuatP const &x)					{r=0>=*x.r;}
	void  r_r_logic_greater_equal_r	(VectP &r, VectP const &x)					{r=x>=0;}
	void  r_c_logic_greater_equal_r	(VectP &r, CompP const &x)					{r=*x.r>=0;}
	void  r_q_logic_greater_equal_r	(VectP &r, QuatP const &x)					{r=*x.r>=0;}
	void r_rr_logic_greater_equal	(VectP &r, VectP const &x, VectP const &y)	{r=x>=y;}
	void r_rc_logic_greater_equal	(VectP &r, VectP const &x, CompP const &y)	{r=x>=*y.r;}
	void r_rq_logic_greater_equal	(VectP &r, VectP const &x, QuatP const &y)	{r=x>=*y.r;}
	void r_cr_logic_greater_equal	(VectP &r, CompP const &x, VectP const &y)	{r=*x.r>=y;}
	void r_cc_logic_greater_equal	(VectP &r, CompP const &x, CompP const &y)	{r=*x.r>=*y.r;}
	void r_cq_logic_greater_equal	(VectP &r, CompP const &x, QuatP const &y)	{r=*x.r>=*y.r;}
	void r_qr_logic_greater_equal	(VectP &r, QuatP const &x, VectP const &y)	{r=*x.r>=y;}
	void r_qc_logic_greater_equal	(VectP &r, QuatP const &x, CompP const &y)	{r=*x.r>=*y.r;}
	void r_qq_logic_greater_equal	(VectP &r, QuatP const &x, QuatP const &y)	{r=*x.r>=*y.r;}
	auto disc_r_logic_greater_equal_l_o	=disc_r_logic_divides_o;
	auto disc_r_logic_greater_equal_r_o	=disc_r_logic_divides_o;
	auto disc_r_logic_greater_equal_o	=disc_r_logic_divides_o;
	
	void  r_r_logic_not				(VectP &r, VectP const &x)					{r=x==0;}
	void  r_c_logic_not				(VectP &r, CompP const &x)					{r=(*x.r==0)&(*x.i==0);}
	void  r_q_logic_not				(VectP &r, QuatP const &x)					{r=(*x.r==0)&(*x.i==0)&(*x.j==0)&(*x.k==0);}
	auto disc_r_logic_not_o			=disc_r_logic_divides_o;
	
	void r_rr_logic_and				(VectP &r, VectP const &x, VectP const &y)	{r=x.r_is_true()&y.r_is_true();}
	void r_rc_logic_and				(VectP &r, VectP const &x, CompP const &y)	{r=x.r_is_true()&y.c_is_true();}
	void r_rq_logic_and				(VectP &r, VectP const &x, QuatP const &y)	{r=x.r_is_true()&y.q_is_true();}
	void r_cr_logic_and				(VectP &r, CompP const &x, VectP const &y)	{r=x.c_is_true()&y.r_is_true();}
	void r_cc_logic_and				(VectP &r, CompP const &x, CompP const &y)	{r=x.c_is_true()&y.c_is_true();}
	void r_cq_logic_and				(VectP &r, CompP const &x, QuatP const &y)	{r=x.c_is_true()&y.q_is_true();}
	void r_qr_logic_and				(VectP &r, QuatP const &x, VectP const &y)	{r=x.q_is_true()&y.r_is_true();}
	void r_qc_logic_and				(VectP &r, QuatP const &x, CompP const &y)	{r=x.q_is_true()&y.c_is_true();}
	void r_qq_logic_and				(VectP &r, QuatP const &x, QuatP const &y)	{r=x.q_is_true()&y.q_is_true();}
	auto disc_r_logic_and_o			=disc_r_logic_divides_o;
	
	void r_rr_logic_or				(VectP &r, VectP const &x, VectP const &y)	{r=x.r_is_true()|y.r_is_true();}
	void r_rc_logic_or				(VectP &r, VectP const &x, CompP const &y)	{r=x.r_is_true()|y.c_is_true();}
	void r_rq_logic_or				(VectP &r, VectP const &x, QuatP const &y)	{r=x.r_is_true()|y.q_is_true();}
	void r_cr_logic_or				(VectP &r, CompP const &x, VectP const &y)	{r=x.c_is_true()|y.r_is_true();}
	void r_cc_logic_or				(VectP &r, CompP const &x, CompP const &y)	{r=x.c_is_true()|y.c_is_true();}
	void r_cq_logic_or				(VectP &r, CompP const &x, QuatP const &y)	{r=x.c_is_true()|y.q_is_true();}
	void r_qr_logic_or				(VectP &r, QuatP const &x, VectP const &y)	{r=x.q_is_true()|y.r_is_true();}
	void r_qc_logic_or				(VectP &r, QuatP const &x, CompP const &y)	{r=x.q_is_true()|y.c_is_true();}
	void r_qq_logic_or				(VectP &r, QuatP const &x, QuatP const &y)	{r=x.q_is_true()|y.q_is_true();}
	auto disc_r_logic_or_o			=disc_r_logic_divides_o;
	
	void r_rr_logic_xor				(VectP &r, VectP const &x, VectP const &y)	{r=x.r_is_true()^y.r_is_true();}
	void r_rc_logic_xor				(VectP &r, VectP const &x, CompP const &y)	{r=x.r_is_true()^y.c_is_true();}
	void r_rq_logic_xor				(VectP &r, VectP const &x, QuatP const &y)	{r=x.r_is_true()^y.q_is_true();}
	void r_cr_logic_xor				(VectP &r, CompP const &x, VectP const &y)	{r=x.c_is_true()^y.r_is_true();}
	void r_cc_logic_xor				(VectP &r, CompP const &x, CompP const &y)	{r=x.c_is_true()^y.c_is_true();}
	void r_cq_logic_xor				(VectP &r, CompP const &x, QuatP const &y)	{r=x.c_is_true()^y.q_is_true();}
	void r_qr_logic_xor				(VectP &r, QuatP const &x, VectP const &y)	{r=x.q_is_true()^y.r_is_true();}
	void r_qc_logic_xor				(VectP &r, QuatP const &x, CompP const &y)	{r=x.q_is_true()^y.c_is_true();}
	void r_qq_logic_xor				(VectP &r, QuatP const &x, QuatP const &y)	{r=x.q_is_true()^y.q_is_true();}
	auto disc_r_logic_xor_o			=disc_r_logic_divides_o;
	
	void r_rr_condition_zero		(VectP &r, VectP const &x, VectP const &y)	{r=x.r_is_true()?x:y;}
	void c_rc_condition_zero		(CompP &r, VectP const &x, CompP const &y)	{r=x.r_is_true()?Comp1d(*x.r):y;}
	void q_rq_condition_zero		(QuatP &r, VectP const &x, QuatP const &y)	{r=x.r_is_true()?Quat1d(*x.r):y;}
	void c_cr_condition_zero		(CompP &r, CompP const &x, VectP const &y)	{r=x.c_is_true()?x:Comp1d(*y.r);}
	void c_cc_condition_zero		(CompP &r, CompP const &x, CompP const &y)	{r=x.c_is_true()?x:y;}
	void q_cq_condition_zero		(QuatP &r, CompP const &x, QuatP const &y)	{r=x.c_is_true()?Quat1d(x):y;}
	void q_qr_condition_zero		(QuatP &r, QuatP const &x, VectP const &y)	{r=x.q_is_true()?x:Quat1d(*y.r);}
	void q_qc_condition_zero		(QuatP &r, QuatP const &x, CompP const &y)	{r=x.q_is_true()?x:Quat1d(y);}
	void q_qq_condition_zero		(QuatP &r, QuatP const &x, QuatP const &y)	{r=x.q_is_true()?x:y;}
	bool disc_rr_condition_zero_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return _1d_zero_in_range(x0.r, x1.r);}
	bool disc_rc_condition_zero_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return _1d_zero_in_range(x0.r, x1.r);}
	bool disc_rq_condition_zero_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return _1d_zero_in_range(x0.r, x1.r);}
	bool disc_cr_condition_zero_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return _1d_zero_in_range(x0.r, x1.r)&&_1d_zero_in_range(x0.i, x1.i);}
	bool disc_cc_condition_zero_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return _1d_zero_in_range(x0.r, x1.r)&&_1d_zero_in_range(x0.i, x1.i);}
	bool disc_cq_condition_zero_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return _1d_zero_in_range(x0.r, x1.r)&&_1d_zero_in_range(x0.i, x1.i);}
	bool disc_qr_condition_zero_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return _1d_zero_in_range(x0.r, x1.r)&&_1d_zero_in_range(x0.i, x1.i)&&_1d_zero_in_range(x0.j, x1.j)&&_1d_zero_in_range(x0.k, x1.k);}
	bool disc_qc_condition_zero_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return _1d_zero_in_range(x0.r, x1.r)&&_1d_zero_in_range(x0.i, x1.i)&&_1d_zero_in_range(x0.j, x1.j)&&_1d_zero_in_range(x0.k, x1.k);}
	bool disc_qq_condition_zero_i	(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return _1d_zero_in_range(x0.r, x1.r)&&_1d_zero_in_range(x0.i, x1.i)&&_1d_zero_in_range(x0.j, x1.j)&&_1d_zero_in_range(x0.k, x1.k);}

	void  r_r_percent				(VectP &r, VectP const &x)					{r=x*0.01;}
	void  c_c_percent				(CompP &r, CompP const &x)					{r=(Comp1d)x*0.01;}
	void  q_q_percent				(QuatP &r, QuatP const &x)					{r=(Quat1d)x*0.01;}
	
	void r_rr_modulo				(VectP &r, VectP const &x, VectP const &y)	{r=x%y;}
	void c_rc_modulo				(CompP &r, VectP const &x, CompP const &y)	{r=x%y;}
	void q_rq_modulo				(QuatP &r, VectP const &x, QuatP const &y)	{r=x%y;}
	void c_cr_modulo				(CompP &r, CompP const &x, VectP const &y)	{r=x%y;}
	void c_cc_modulo				(CompP &r, CompP const &x, CompP const &y)	{r=x%y;}
	void q_cq_modulo				(QuatP &r, CompP const &x, QuatP const &y)	{r=x%y;}
	void q_qr_modulo				(QuatP &r, QuatP const &x, VectP const &y)	{r=x%y;}
	void q_qc_modulo				(QuatP &r, QuatP const &x, CompP const &y)	{r=x%y;}
	void q_qq_modulo				(QuatP &r, QuatP const &x, QuatP const &y)	{r=x%y;}
	bool disc_rr_modulo_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return std::floor(x0.r/y0.r)!=std::floor(x1.r/y1.r);}
	bool disc_rc_modulo_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_rq_modulo_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cr_modulo_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cc_modulo_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cq_modulo_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qr_modulo_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qc_modulo_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qq_modulo_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	void  r_r_sgn					(VectP &r, VectP const &x)					{r=(x>0)-(x<0);}
	void  c_c_sgn					(CompP &r, CompP const &x)					{Comp1d cx=x; double mag=abs(cx); r=mag?cx/mag:0;}//sign function gives a unit vector
	void  q_q_sgn					(QuatP &r, QuatP const &x)					{Quat1d qx=x; double mag=abs(qx); r=mag?qx/mag:Quat1d();}
	auto disc_r_sgn_i				=disc_r_divide_i;
	auto disc_c_sgn_i				=disc_c_divide_i;
	auto disc_q_sgn_i				=disc_q_divide_i;

	void  r_r_sq					(VectP &r, VectP const &x)					{r=x*x;}
	void  c_c_sq					(CompP &r, CompP const &x)					{r=sq(x);}
	void  q_q_sq					(QuatP &r, QuatP const &x)					{r=sq(x);}

	void  c_c_sqrt					(CompP &r, CompP const &x)					{r=sqrt((Comp1d)x);}
	void  q_q_sqrt					(QuatP &r, QuatP const &x)					{r=sqrt((Quat1d)x);}

	void  r_r_invsqrt				(VectP &r, VectP const &x)
	{
		double t0;
		(long long&)t0=0x5FE6EC85E7DE30DA-(*(long long*)x.r>>1);
		r=t0*(1.5-.5**x.r*t0*t0);
	}

	void  r_r_cbrt					(VectP &r, VectP const &x)					{r=boost::math::cbrt((double)x);}//VC2010: _MSC_VER<1700
	void  c_c_cbrt					(CompP &r, CompP const &x)					{r=std::exp(1./3*std::log((Comp1d)x));}//optimize
	void  q_q_cbrt					(QuatP &r, QuatP const &x)
	{
		Quat1d qx=x;
		double t=qx.R_component_2()*qx.R_component_2()+qx.R_component_3()*qx.R_component_3()+qx.R_component_4()*qx.R_component_4();
		if(t)
		{
			double absx=::sqrt(qx.R_component_1()*qx.R_component_1()+t);
			t=::acos(qx.R_component_1()/absx)/(::sqrt(t)*3);
			Quat1d logx_3(1./3*boost::math::log1p(absx-1), t*qx.R_component_2(), t*qx.R_component_3(), t*qx.R_component_4());
			r=boost::math::exp(logx_3);
		}
		else
			r=Quat1d(boost::math::cbrt(qx.R_component_1()));

		//Quat1d t=log((Quat1d)x);
		//if(t.R_component_1()!=-_HUGE)
		//	r=exp(1./3*t);
		//else
		//	r=Quat1d();
	}

	void  r_r_gauss					(VectP &r, VectP const &x)					{double rx=x; r=::exp(-rx*rx);}
	void  c_c_gauss					(CompP &r, CompP const &x)					{r=exp(-sq(x));}
	void  q_q_gauss					(QuatP &r, QuatP const &x)					{r=exp(-sq(x));}

	void  r_r_erf					(VectP &r, VectP const &x)					{r=boost::math::erf((double)x);}

	inline double zeta(double x)
	{
		try
		{
			return boost::math::zeta(x);
		}
		catch(...)
		{
			return _qnan;
		}
	}
	void  r_r_zeta					(VectP &r, VectP const &x)					{r=zeta(x);}
	bool disc_r_zeta_i				(Value const &x0, Value const &x1){return x0.r<1?x1.r>=1:x0.r>1&&x1.r<=1;}

	double tgamma(double x, double y)//upper incomplete gamma, G(x, 0) = G(x)
	{
		try
		{
			if(x>0)
			{
				if(y>=0)
					return boost::math::tgamma((double)x, (double)y);
			}
			else if(x==0)
				return _HUGE;
			long long cInf=0x7FF8000000000010;//x.r>0&&y.r<0||x.r<0
			return (double&)cInf;
			//if(x.r<0)
			//{
			//	long long cInf=0x7FF8000000000010;
			//	return (double&)cInf;
			//}
			//else if(x.r==0)
			//	return _HUGE;
			//else if(y.r<0)
			//{
			//	long long cInf=0x7FF8000000000010;
			//	return (double&)cInf;
			//}
			//return boost::math::tgamma((double)x, (double)y);
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return _HUGE;
			if(valueBits==0x8000000000000000)
				return -_HUGE;
			long long divergentBits=0x7FF8000000000010;
			return (double&)divergentBits;
		}
		catch(std::overflow_error&)
		{
			return _HUGE;
		}
	}
	void  r_r_tgamma				(VectP &r, VectP const &x)					{r=tgamma((double)x);}
	void  c_c_tgamma				(CompP &r, CompP const &x)					{r=tgamma(x);}
	void  q_q_tgamma				(QuatP &r, QuatP const &x)					{r=tgamma(x);}
	void r_rr_tgamma				(VectP &r, VectP const &x, VectP const &y)	{r=tgamma(x, y);}
	bool disc_r_tgamma_i			(Value const &x0, Value const &x1){return (x0.r<=0||x1.r<=0)&&_1d_int_in_range(x0.r, x1.r);}
	bool disc_c_tgamma_i			(Value const &x0, Value const &x1)
	{
		if(x0.r==x1.r)	return false;
		if(x0.i==x1.i)	return x0.i==0&&_1d_int_in_range(x0.r, x1.r);
		if(std::signbit(x0.i)!=std::signbit(x1.i))
		{
			double t=_1d_zero_crossing(x0.r, x0.i, x1.r, x1.i);
			return t<=0&&t==std::floor(t);
		}
		return false;
	}
	bool disc_q_tgamma_i			(Value const &x0, Value const &x1){return false;}//
	bool disc_rr_tgamma_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	void  r_r_loggamma				(VectP &r, VectP const &x)					{r=std::lgamma(x);}
	auto disc_r_loggamma_i			=disc_r_tgamma_i;
//	bool disc_r_loggamma_i			(Value const &x0, Value const &x1){return (x0.r<=0||x1.r<=0)&&_1d_int_in_range(x0.r, x1.r);}

	void  r_r_factorial				(VectP &r, VectP const &x)					{r=tgamma(x+1);}
	void  c_c_factorial				(CompP &r, CompP const &x)					{r=tgamma((Comp1d)x+1.);}
	void  q_q_factorial				(QuatP &r, QuatP const &x)					{r=tgamma((Quat1d)x+1.);}
	bool disc_r_factorial_i			(Value const &x0, Value const &x1)
	{
		Value _x0=x0.r+1, _x1=x1.r+1;
		return disc_r_tgamma_i(_x0, _x1);
	}
	bool disc_c_factorial_i			(Value const &x0, Value const &x1)
	{
		Value _x0=x0, _x1=x1.r;
		_x0.r+=1, _x1.r+=1;
		return disc_c_tgamma_i(_x0, _x1);
	}
	bool disc_q_factorial_i			(Value const &x0, Value const &x1)
	{
		Value _x0=x0, _x1=x1.r;
		_x0.r+=1, _x1.r+=1;
		return disc_q_tgamma_i(_x0, _x1);
	}

	inline double permutation(double x, double y)
	{
		try
		{
			double rx=x, ry=y;
			return boost::math::tgamma(rx+1)/boost::math::tgamma(rx-ry+1);
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return _HUGE;
			if(valueBits==0x8000000000000000)
				return -_HUGE;
			long long divergentBits=0x7FF8000000000010;
			return *(double*)&divergentBits;
		}
		catch(std::overflow_error&)
		{
			return _HUGE;
		}
	}
	Comp1d permutation(Comp1d const &x, Comp1d const &y)
	{
		try
		{
			std::complex<double> cx=x, cy=y;
			return tgamma(cx+1.)/tgamma(cx-cy+1.);
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return _HUGE;
			if(valueBits==0x8000000000000000)
				return -_HUGE;
			long long divergentBits=0x7FF8000000000010;
			return *(double*)&divergentBits;
		}
		catch(std::overflow_error&)
		{
			return _HUGE;
		}
	}
	Quat1d permutation(Quat1d const &x, Quat1d const &y)
	{
		try
		{
			boost::math::quaternion<double> qx=x, qy=y;
			return tgamma(qx+1.)/tgamma(qx-qy+1.);
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return Quat1d(_HUGE);
			if(valueBits==0x8000000000000000)
				return Quat1d(-_HUGE);
			long long divergentBits=0x7FF8000000000010;
			return Quat1d((double&)divergentBits);
		}
		catch(std::overflow_error&)
		{
			return Quat1d(_HUGE);
		}
	}
	void  r_r_permutation			(VectP &r, VectP const &x)					{r=1;}
	void  c_c_permutation			(CompP &r, CompP const &x)					{r=Comp1d(1, 0);}
	void  q_q_permutation			(QuatP &r, QuatP const &x)					{r=Quat1d(1, 0, 0, 0);}
	void r_rr_permutation			(VectP &r, VectP const &x, VectP const &y)	{r=permutation(x, y);}
	void c_cr_permutation			(CompP &r, CompP const &x, VectP const &y)	{r=permutation(x, Comp1d(*y.r, 0));}
	void c_cc_permutation			(CompP &r, CompP const &x, CompP const &y)	{r=permutation(x, y);}
	void q_qq_permutation			(QuatP &r, QuatP const &x, QuatP const &y)	{r=permutation(x, y);}
	bool disc_rr_permutation_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_rc_permutation_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_rq_permutation_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cr_permutation_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cc_permutation_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cq_permutation_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qr_permutation_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qc_permutation_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qq_permutation_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	
	double combination(double x, double y)
	{
		try
		{
			double rx=x, ry=y;
			double r=boost::math::tgamma(rx+1)/(boost::math::tgamma(rx-ry+1)*boost::math::tgamma(ry+1));
			return r;
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return _HUGE;
			if(valueBits==0x8000000000000000)
				return -_HUGE;
			long long divergentBits=0x7FF8000000000010;
			return *(double*)&divergentBits;
		}
		catch(std::overflow_error&)
		{
			return _HUGE;
		}
	}
	Comp1d combination(Comp1d const &x, Comp1d const &y)
	{
		try
		{
			std::complex<double> cx=x, cy=y;
			return tgamma(cx+1.)/(tgamma(cx-cy+1.)*tgamma(cy+1.));
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return _HUGE;
			if(valueBits==0x8000000000000000)
				return -_HUGE;
			long long divergentBits=0x7FF8000000000010;
			return *(double*)&divergentBits;
		}
		catch(std::overflow_error&)
		{
			return _HUGE;
		}
	}
	Quat1d combination(Quat1d const &x, Quat1d const &y)
	{
		try
		{
			boost::math::quaternion<double> qx=x, qy=y;
			return tgamma(qx+1.)/(tgamma(qx-qy+1.)*tgamma(qy+1.));
		}
		catch(std::domain_error&)
		{
			long long valueBits=(long long&)x;
			if(!valueBits)
				return Quat1d(_HUGE);
			if(valueBits==0x8000000000000000)
				return Quat1d(-_HUGE);
			long long divergentBits=0x7FF8000000000010;
			return Quat1d((double&)divergentBits);
		}
		catch(std::overflow_error&)
		{
			return Quat1d(_HUGE);
		}
	}
	void  r_r_combination			(VectP &r, VectP const &x)					{r=1;}
	void  c_c_combination			(CompP &r, CompP const &x)					{r=Comp1d(1, 0);}
	void  q_q_combination			(QuatP &r, QuatP const &x)					{r=Quat1d(1, 0, 0, 0);}
	void r_rr_combination			(VectP &r, VectP const &x, VectP const &y)	{r=combination(x, y);}
	void c_cr_combination			(CompP &r, CompP const &x, VectP const &y)	{r=combination(x, Comp1d(*y.r, 0));}
	void c_cc_combination			(CompP &r, CompP const &x, CompP const &y)	{r=combination(x, y);}
	void q_qq_combination			(QuatP &r, QuatP const &x, QuatP const &y)	{r=combination(x, y);}
	bool disc_rr_combination_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_rc_combination_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_rq_combination_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cr_combination_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cc_combination_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cq_combination_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qr_combination_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qc_combination_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qq_combination_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	const Comp1d _i(0, 1);
	inline Comp1d asinh(Comp1d const &x){return log(x+sqrt(sq(x)+1.));}
	inline double sinhc(double const &x){return ::sinh(x)/x;}
	void  r_r_cos					(VectP &r, VectP const &x)					{r=::cos(x);}
	void  c_c_cos					(CompP &r, CompP const &x)					{r=cos((Comp1d)x);}
	void  q_q_cos					(QuatP &r, QuatP const &x)					{r=cos((Quat1d)x);}

	inline Comp1d acos(Comp1d const &x){return -_i*log(x+sqrt(sq(x)-1.));}
	void  c_c_acos					(CompP &r, CompP const &x)					{r=acos(x);}
	void  q_q_acos					(QuatP &r, QuatP const &x)					{r=acos(x);}
	bool disc_c_acos_i				(Value const &x0, Value const &x1)
	{
		if(x0.i==x1.i)	return false;//x0.i is not nan vs. x0.i==x1.i ?
		if(x0.r==x1.r)	return (x0.i<=0?x1.i>0:x1.i<=0)&&(x0.r<-1||x0.r>1);
		//if(x0.i==x0.i)	return false;
		//if(x0.r==x0.r)	return (x0.i<=0?x1.i>0:x1.i<=0)&&(x0.r<-1||x0.r>1);
		if(x0.i<=0&&x1.i>0||x1.i<=0&&x0.i>0)
		{
			double t=_1d_zero_crossing(x0.r, x0.i, x1.r, x1.i);
			return t<-1||t>1;
		}
		return false;
	}
	bool disc_q_acos_i				(Value const &x0, Value const &x1){return false;}//
	
	const double d_inv180=1./180, d_torad=_pi*d_inv180, d_todeg=180/_pi;
	void  r_r_cosd					(VectP &r, VectP const &x)					{r=::cos(x*d_torad);}
	void  c_c_cosd					(CompP &r, CompP const &x)					{Comp1d x2(*x.r*d_torad, *x.i); r=cos(x2);}//TODO: investigate: is there a c_c_cosd?
	void  q_q_cosd					(QuatP &r, QuatP const &x)					{Quat1d x2(*x.r*d_torad, *x.i, *x.j, *x.k); r=cos(x2);}

	void  c_c_acosd					(CompP &r, CompP const &x)					{Comp1d r2=acos(x); r=Comp1d(r2.real()*d_todeg, r2.imag());}
	void  q_q_acosd					(QuatP &r, QuatP const &x)					{Quat1d r2=acos(x); r=Quat1d(r2.real()*d_todeg, r2.R_component_2(), r2.R_component_3(), r2.R_component_4());}
	auto disc_c_acosd_i				=disc_c_acos_i;
	auto disc_q_acosd_i				=disc_q_acos_i;

	inline Comp1d cosh(Comp1d const &x){return (exp(x)+exp(-x))*0.5;}
	inline Quat1d cosh(Quat1d const &x){return (exp(x)+exp(-x))*0.5;}
	void  r_r_cosh					(VectP &r, VectP const &x)					{r=::cosh(x);}
	void  c_c_cosh					(CompP &r, CompP const &x)					{r=cosh(x);}
	void  q_q_cosh					(QuatP &r, QuatP const &x)					{r=cosh(x);}

	inline Comp1d acosh(Comp1d const &x){return log(x+sqrt(sq(x)-1.));}
	void  c_c_acosh					(CompP &r, CompP const &x)					{r=acosh(x);}
	void  q_q_acosh					(QuatP &r, QuatP const &x)					{r=acosh(x);}

	void  r_r_cosc					(VectP &r, VectP const &x)					{r=::cos(x)/x;}
	void  c_c_cosc					(CompP &r, CompP const &x)					{Comp1d cx=x; r=cos(cx)/cx;}
	void  q_q_cosc					(QuatP &r, QuatP const &x)					{Quat1d qx=x; r=cos(qx)/qx;}
	auto disc_r_cosc_i				=disc_r_divide_i;
	auto disc_c_cosc_i				=disc_c_divide_i;
	auto disc_q_cosc_i				=disc_q_divide_i;

	void  r_r_sec					(VectP &r, VectP const &x)					{r=1/::cos(x);}
	void  c_c_sec					(CompP &r, CompP const &x)					{r=inv(cos((Comp1d)x));}
	void  q_q_sec					(QuatP &r, QuatP const &x)					{r=inv(cos((Quat1d)x));}
	bool disc_r_sec_i				(Value const &x0, Value const &x1)
	{
		if(std::abs(x1.r-x0.r)>3.2)
			return true;
		return _1d_int_in_range(x0.r/_pi-.5, x1.r/_pi-.5);
	}
	bool disc_c_sec_i				(Value const &x0, Value const &x1)
	{
		if(x0.r==x1.r)
		{
			if(x0.i==x1.i)	return false;
			double t=x0.r/_pi-.5;
			return t==std::floor(t);
		}
		if(x0.i==x1.i)	return x0.i==0&&_1d_int_in_range(x0.r/_pi-.5, x1.r/_pi-.5);
		if(std::signbit(x0.i)!=std::signbit(x1.i))
		{
			double t=_1d_zero_crossing(x0.r, x0.i, x1.r, x0.i)/_pi-.5;
			return t==std::floor(t);
		}
		return false;
	}
	bool disc_q_sec_i				(Value const &x0, Value const &x1){return false;}//

	void  c_c_asec					(CompP &r, CompP const &x)					{r=std::acos(inv((Comp1d)x));}
	void  q_q_asec					(QuatP &r, QuatP const &x)					{r=acos(inv((Quat1d)x));}
	auto disc_c_asec_i				=disc_c_divide_i;
	auto disc_q_asec_i				=disc_q_divide_i;

	void  r_r_secd					(VectP &r, VectP const &x)					{r=1/::cos(x*d_torad);}
	void  c_c_secd					(CompP &r, CompP const &x)					{Comp1d x2(*x.r*d_torad, *x.i); r=inv(cos(x2));}
	void  q_q_secd					(QuatP &r, QuatP const &x)					{Quat1d x2(*x.r*d_torad, *x.i, *x.j, *x.k); r=inv(cos(x2));}
	bool disc_r_secd_i				(Value const &x0, Value const &x1)
	{
		if(std::abs(x1.r-x0.r)>180)
			return true;
		return _1d_int_in_range(x0.r*d_inv180-.5, x1.r*d_inv180-.5);
	}
	bool disc_c_secd_i				(Value const &x0, Value const &x1)
	{
		if(x0.r==x1.r)
		{
			if(x0.i==x1.i)	return false;
			double t=x0.r*d_inv180-.5;
			return t==std::floor(t);
		}
		if(x0.i==x1.i)	return x0.i==0&&_1d_int_in_range(x0.r*d_inv180-.5, x1.r*d_inv180-.5);
		if(std::signbit(x0.i)!=std::signbit(x1.i))
		{
			double t=_1d_zero_crossing(x0.r*d_inv180, x0.i, x1.r*d_inv180, x0.i)-.5;
			return t==std::floor(t);
		}
		return false;
	}
	bool disc_q_secd_i				(Value const &x0, Value const &x1){return false;}//

	void  c_c_asecd					(CompP &r, CompP const &x)					{Comp1d x2=std::acos(inv((Comp1d)x)); r=Comp1d(x2.real()*d_todeg, x2.imag());}
	void  q_q_asecd					(QuatP &r, QuatP const &x)					{Quat1d x2=acos(inv((Quat1d)x)); r=Quat1d(x2.R_component_1()*d_todeg, x2.R_component_2(), x2.R_component_3(), x2.R_component_4());}
	auto disc_c_asecd_i				=disc_c_divide_i;
	auto disc_q_asecd_i				=disc_q_divide_i;

	void  r_r_sech					(VectP &r, VectP const &x)					{r=1/::cosh(x);}
	void  c_c_sech					(CompP &r, CompP const &x)					{r=inv(cosh((Comp1d)x));}
	void  q_q_sech					(QuatP &r, QuatP const &x)					{r=inv(cosh((Quat1d)x));}
	bool disc_c_sech_i				(Value const &x0, Value const &x1)
	{
		if(x0.i==x1.i)
		{
			if(x0.r==x1.r)
				return false;
			double i=x0.i/_pi+.5;
			return i==std::floor(i)&&(x0.r<0?x1.r>=0:x0.r>0?x1.r<=0:x1.r!=0);
		}
		if(x0.r==x1.r)
			return x0.r==0&&_1d_int_in_range(x0.i/_pi-.5, x1.i/_pi-.5);
		return false;
		//if(x0.i==x1.i)	return true;
		//if(x0.r==x1.r)	return x0.r==0&&_1d_int_in_range(x0.i/_pi-.5, x1.i/_pi-.5);
		//if(std::signbit(x0.r)!=std::signbit(x1.r))
		//{
		//	double t=_1d_zero_crossing(x0.i, x0.r, x1.i, x1.r)/_pi-.5;
		//	return t==std::floor(t);
		//}
		//return false;
	}
	bool disc_q_sech_i				(Value const &x0, Value const &x1){return false;}//

	void  c_c_asech					(CompP &r, CompP const &x)					{r=std::acosh(inv((Comp1d)x));}
	void  q_q_asech					(QuatP &r, QuatP const &x)					{r=acosh(inv((Quat1d)x));}
	bool disc_c_asech_i				(Value const &x0, Value const &x1)
	{
		if(x0.i==x0.i)	return x0.i==0&&x0.r!=x0.r&&std::signbit(x0.r)!=std::signbit(x1.r);
		if(x0.r==x0.r)	return (x0.i<=0?x1.i>0:x1.i<=0)&&(x0.r<=0||x0.r>1);
		if(x0.i<=0&&x1.i>0||x0.i<=0&&x1.i>0)
		{
			double t=_1d_zero_crossing(x0.r, x0.i, x1.r, x1.i);
			return t<=0||t>1;
		}
		return false;
	}
	bool disc_q_asech_i				(Value const &x0, Value const &x1){return false;}//

	void  r_r_sin					(VectP &r, VectP const &x)					{r=::sin(x);}
	void  c_c_sin					(CompP &r, CompP const &x)					{r=sin((Comp1d)x);}
	void  q_q_sin					(QuatP &r, QuatP const &x)					{r=sin((Quat1d)x);}

	inline Comp1d asin(Comp1d const &x){return -_i*log(_i*x+sqrt(1.-sq(x)));}
	void  c_c_asin					(CompP &r, CompP const &x)					{r=std::asin((Comp1d)x);}
	void  q_q_asin					(QuatP &r, QuatP const &x)					{r=asin((Quat1d)x);}
	auto disc_c_asin_i				=disc_c_acos_i;
	auto disc_q_asin_i				=disc_q_acos_i;

	void  r_r_sind					(VectP &r, VectP const &x)					{r=::sin(x*d_torad);}
	void  c_c_sind					(CompP &r, CompP const &x)					{Comp1d x2(*x.r*d_torad, *x.i); r=sin(x2);}
	void  q_q_sind					(QuatP &r, QuatP const &x)					{Quat1d x2(*x.r*d_torad, *x.i, *x.j, *x.k); r=sin(x2);}

	void  c_c_asind					(CompP &r, CompP const &x)					{Comp1d r2=std::asin((Comp1d)x); r=Comp1d(r2.real()*d_todeg, r2.imag());}
	void  q_q_asind					(QuatP &r, QuatP const &x)					{Quat1d r2=asin((Quat1d)x); r=Quat1d(r2.R_component_1()*d_todeg, r2.R_component_2(), r2.R_component_3(), r2.R_component_4());}
	auto disc_c_asind_i				=disc_c_acos_i;
	auto disc_q_asind_i				=disc_q_acos_i;

	inline Comp1d sinh(Comp1d const &x){return (exp(x)-exp(-x))*0.5;}
	inline Quat1d sinh(Quat1d const &x){return (exp(x)-exp(-x))*0.5;}
	void  r_r_sinh					(VectP &r, VectP const &x)					{r=::sinh((double)x);}
	void  c_c_sinh					(CompP &r, CompP const &x)					{r=sinh((Comp1d)x);}
	void  q_q_sinh					(QuatP &r, QuatP const &x)					{r=sinh((Quat1d)x);}

	void  r_r_asinh					(VectP &r, VectP const &x)					{r=std::asinh((double)x);}
	void  c_c_asinh					(CompP &r, CompP const &x)					{r=std::asinh((Comp1d)x);}
	void  q_q_asinh					(QuatP &r, QuatP const &x)					{r=asinh((Quat1d)x);}
	bool disc_c_asinh_i				(Value const &x0, Value const &x1)
	{
		Value _x0(x0.i, x0.r), _x1(x1.i, x0.r);
		return disc_c_acos_i(_x0, _x1);
	}
	bool disc_q_asinh_i				(Value const &x0, Value const &x1){return false;}//

	void  r_r_sinc					(VectP &r, VectP const &x)					{double rx=x; r=rx?::sin(rx)/rx:1;}
	void  c_c_sinc					(CompP &r, CompP const &x)					{Comp1d cx=x; r=x.c_is_true()?sin(cx)/cx:1;}
	void  q_q_sinc					(QuatP &r, QuatP const &x)					{Quat1d qx=x; r=x.c_is_true()?sin(qx)/qx:Quat1d(1);}

	void  r_r_sinhc					(VectP &r, VectP const &x)					{double rx=x; r=rx?::sinh(rx)/rx:1;}
	void  c_c_sinhc					(CompP &r, CompP const &x)					{Comp1d cx=x; r=x.c_is_true()?sinh(cx)/cx:1;}
	void  q_q_sinhc					(QuatP &r, QuatP const &x)					{Quat1d qx=x; r=x.c_is_true()?sinh(qx)/qx:Quat1d(1);}

	void  r_r_csc					(VectP &r, VectP const &x)					{r=1/::sin(x);}
	void  c_c_csc					(CompP &r, CompP const &x)					{r=inv(sin((Comp1d)x));}
	void  q_q_csc					(QuatP &r, QuatP const &x)					{r=inv(sin((Quat1d)x));}
	bool disc_r_csc_i				(Value const &x0, Value const &x1)
	{
		if(std::abs(x1.r-x0.r)>3.2)	return true;
		return _1d_int_in_range(x0.r/_pi, x1.r/_pi);
	}
	bool disc_c_csc_i				(Value const &x0, Value const &x1)
	{
		if(x0.r==x1.r)	return true;
		if(x0.i==x1.i)	return x0.i==0&&_1d_int_in_range(x0.r/_pi, x1.r/_pi);
		if(std::signbit(x0.i)!=std::signbit(x1.i))
		{
			double t=_1d_zero_crossing(x0.r, x0.i, x1.r, x0.i)/_pi;
			return t==std::floor(t);
		}
		return false;
	}
	bool disc_q_csc_i				(Value const &x0, Value const &x1){return false;}

	void  c_c_acsc					(CompP &r, CompP const &x)					{r=std::asin(inv((Comp1d)x));}
	void  q_q_acsc					(QuatP &r, QuatP const &x)					{r=asin(inv((Quat1d)x));}
	bool disc_c_acsc_i				(Value const &x0, Value const &x1)
	{
		if(x0.i==x1.i)	return x0.i==0&&(x0.r<0?x1.r>=0:x0.r>0?x1.r<=0:x1.r!=0);//x1.r<0||x1.r>0);
		if(x0.r==x1.r)
		{
			if(x0.r<0)	return x0.r>-1&&(x0.i<=0?x1.i>0:x1.i<=0);
			if(x0.r==0)	return x0.i<0?x1.i>=0:x0.i==0?x1.i<0||x1.i>0:x1.i<=0;
						return x0.r<1&&(x0.i<0?x1.i>=0:x1.i<0);
		}
		return false;
	}
	bool disc_q_acsc_i				(Value const &x0, Value const &x1){return false;}//

	void  r_r_cscd					(VectP &r, VectP const &x)					{r=1/::sin(x*d_torad);}
	void  c_c_cscd					(CompP &r, CompP const &x)					{Comp1d x2(*x.r*d_torad, *x.i); r=inv(sin(x2));}
	void  q_q_cscd					(QuatP &r, QuatP const &x)					{Quat1d x2(*x.r*d_torad, *x.i, *x.j, *x.k); r=inv(sin(x2));}
	bool disc_r_cscd_i				(Value const &x0, Value const &x1)
	{
		if(std::abs(x1.r-x0.r)>180)	return true;
		return _1d_int_in_range(x0.r*d_inv180, x1.r*d_inv180);
	}
	bool disc_c_cscd_i				(Value const &x0, Value const &x1)
	{
		if(x0.r==x1.r)	return true;
		if(x0.i==x1.i)	return x0.i==0&&_1d_int_in_range(x0.r*d_inv180, x1.r*d_inv180);
		if(std::signbit(x0.i)!=std::signbit(x1.i))
		{
			double t=_1d_zero_crossing(x0.r, x0.i, x1.r, x0.i)*d_inv180;
			return t==std::floor(t);
		}
		return false;
	}
	bool disc_q_cscd_i				(Value const &x0, Value const &x1){return false;}

	void  c_c_acscd					(CompP &r, CompP const &x)					{Comp1d r2=std::asin(inv((Comp1d)x)); r=Comp1d(r2.real()*d_todeg, r2.imag());}
	void  q_q_acscd					(QuatP &r, QuatP const &x)					{Quat1d r2=asin(inv((Quat1d)x)); r=Quat1d(r2.R_component_1()*d_todeg, r2.R_component_2(), r2.R_component_3(), r2.R_component_4());}
	bool disc_c_acscd_i				(Value const &x0, Value const &x1)
	{
		if(x0.i==x1.i)	return x0.i==0&&(x0.r<0?x1.r>=0:x0.r>0?x1.r<=0:x1.r!=0);//x1.r<0||x1.r>0);
		if(x0.r==x1.r)
		{
			if(x0.r<0)	return x0.r>-1&&(x0.i<=0?x1.i>0:x1.i<=0);
			if(x0.r==0)	return x0.i<0?x1.i>=0:x0.i==0?x1.i<0||x1.i>0:x1.i<=0;
						return x0.r<1&&(x0.i<0?x1.i>=0:x1.i<0);
		}
		return false;
	}
	bool disc_q_acscd_i				(Value const &x0, Value const &x1){return false;}//

	void  r_r_csch					(VectP &r, VectP const &x)					{r=1/::sinh(x);}
	void  c_c_csch					(CompP &r, CompP const &x)					{r=inv(sinh((Comp1d)x));}
	void  q_q_csch					(QuatP &r, QuatP const &x)					{r=inv(sinh((Quat1d)x));}
	auto disc_r_csch_i				=disc_r_divide_i;
	bool disc_c_csch_i				(Value const &x0, Value const &x1)
	{
		Value _x0(x0.i, x0.r), _x1(x1.i, x1.r);
		return disc_c_csc_i(_x0, _x1);
	}
	bool disc_q_csch_i				(Value const &x0, Value const &x1){return false;}//

	void  r_r_acsch					(VectP &r, VectP const &x)					{r=std::asinh(1/(double)x);}
	void  c_c_acsch					(CompP &r, CompP const &x)					{r=std::asinh(inv((Comp1d)x));}
	void  q_q_acsch					(QuatP &r, QuatP const &x)					{r=asinh(inv((Quat1d)x));}
	auto disc_r_acsch_i				=disc_r_divide_i;
	bool disc_c_acsch_i				(Value const &x0, Value const &x1)
	{
		Value _x0(x0.i, x0.r), _x1(x1.i, x1.r);
		return disc_c_acsc_i(_x0, _x1);
	}
	bool disc_q_acsch_i				(Value const &x0, Value const &x1){return false;}//

	inline Comp1d tan(Comp1d const &x)
	{
		const Comp1d two_i(0, 2);
		Comp1d exp_2ix=exp(two_i*x);
		return (exp_2ix-1.)/((exp_2ix+1.)*_i);
	}
	inline Quat1d tan(Quat1d const &x)
	{
		const Comp1d two_i(0, 2);
		Quat1d exp_2ix=exp(two_i*x);
		return (exp_2ix-1.)/((exp_2ix+1.)*_i);
	}
	void  r_r_tan					(VectP &r, VectP const &x)					{r=::tan(x);}
	void  c_c_tan					(CompP &r, CompP const &x)					{r=tan(x);}
	void  q_q_tan					(QuatP &r, QuatP const &x)					{r=tan(x);}
	auto disc_r_tan_i				=disc_r_sec_i;
	auto disc_c_tan_i				=disc_c_sec_i;
	auto disc_q_tan_i				=disc_q_sec_i;

	inline Comp1d atan(Comp1d const &x){return (_i*0.5)*log((_i+x)/(_i-x));}
	inline double atan_addition(double x, double y){return x<0?y<0?-_pi:_pi:0;}
	void  r_r_atan					(VectP &r, VectP const &x)					{r=::atan(x);}
	void  c_c_atan					(CompP &r, CompP const &x)					{r=atan(x);}
	void  q_q_atan					(QuatP &r, QuatP const &x)					{r=atan(x);}
	void r_rr_atan					(VectP &r, VectP const &x, VectP const &y)	{r=::atan2(x, y);}		//TODO: fix atan addition		what?
	void c_rc_atan					(CompP &r, VectP const &x, CompP const &y)
	{
		double rx=x;
		Comp1d t=std::atan(rx/(Comp1d)y);
		r=rx<0?*y.r<0?t-_pi:t+_pi:t;
	}
	void q_rq_atan					(QuatP &r, VectP const &x, QuatP const &y)
	{
		double rx=x;
		Quat1d t=atan(rx/(Quat1d)y);
		r=rx<0?*y.r<0?t-_pi:t+_pi:t;
	}
	void c_cr_atan					(CompP &r, CompP const &x, VectP const &y)
	{
		double ry=y;
		Comp1d t=std::atan((Comp1d)x/ry);
		r=*x.r<0?ry<0?t-_pi:t+_pi:t;
	}
	void c_cc_atan					(CompP &r, CompP const &x, CompP const &y)
	{
		Comp1d t=std::atan((Comp1d)x/(Comp1d)y);
		r=*x.r<0?*y.r<0?t-_pi:t+_pi:t;
	}
	void q_cq_atan					(QuatP &r, CompP const &x, QuatP const &y)
	{
		Quat1d t=atan((Comp1d)x/(Quat1d)y);
		r=*x.r<0?*y.r<0?t-_pi:t+_pi:t;
	}
	void q_qr_atan					(QuatP &r, QuatP const &x, VectP const &y)
	{
		double ry=y;
		Quat1d t=atan((Quat1d)x/ry);
		r=*x.r<0?ry<0?t-_pi:t+_pi:t;
	}
	void q_qc_atan					(QuatP &r, QuatP const &x, CompP const &y)
	{
		Quat1d t=atan((Quat1d)x/(Comp1d)y);
		r=*x.r<0?*y.r<0?t-_pi:t+_pi:t;
	}
	void q_qq_atan					(QuatP &r, QuatP const &y, QuatP const &x)
	{
		Quat1d t=atan((Quat1d)x/(Quat1d)y);
		r=*x.r<0?*y.r<0?t-_pi:t+_pi:t;
	}
	bool disc_c_atan_i				(Value const &x0, Value const &x1)
	{
		Value _x0(x0.i, x0.r), _x1(x1.i, x1.r);
		return disc_c_acos_i(_x0, _x1);
	}
	bool disc_q_atan_i				(Value const &x0, Value const &x1){return false;}//
	bool disc_rr_atan_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1)
	{
		if(y0.r<0)
		{
			if(x0.r<0)
			{
				if(y1.r<0)	return x1.r>=0;
				if(y1.r>0)	return x1.r>0&&y0.r+(0-x0.r)*(y1.r-y0.r)/(x1.r-x0.r)<=0;
							return x1.r>=0;
			}
			else if(x0.r>0)
			{
				if(y1.r<0)	return x1.r<0;
				if(y1.r>0)	return x1.r<0&&y0.r+(0-y0.r)*(y1.r-y0.r)/(x1.r-x1.r)<=0;
							return x1.r<=0;
			}
			else
			{
				if(y1.r<0)	return x1.r<0;
				if(y1.r>0)	return x1.r<=0;
							return x1.r<=0;
			}
		}
		else if(y0.r>0)
		{
			if(x0.r<0)
			{
				if(y1.r<0)	return x1.r>=0&&(x1.r==0||y0.r+(0-y0.r)*(y1.r-y0.r)/(x1.r-x1.r)<=0);
				if(y1.r>0)	return false;
							return x1.r==0;
			}
			else if(x0.r>0)
			{
				if(y1.r<0)	return x1.r<0&&y0.r+(0-y0.r)*(y1.r-y0.r)/(x1.r-x1.r)<=0;
				if(y1.r>0)	return false;
							return x1.r==0;
			}
			else
			{
				if(y1.r<0)	return x1.r==0;
				if(y1.r>0)	return false;
							return x1.r==0;
			}
		}
		else
		{
			if(x0.r<0)
			{
				if(y1.r<0)	return x1.r>=0;
				if(y1.r>0)	return false;
							return x1.r>=0;
			}
			else if(x0.r>0)
			{
				if(y1.r<0)	return x1.r<0;
				if(y1.r>0)	return false;
							return x1.r<=0;
			}
							return true;
		}
	}
	bool disc_rc_atan_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_rq_atan_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cr_atan_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cc_atan_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cq_atan_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qr_atan_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qc_atan_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qq_atan_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	void  r_r_tand					(VectP &r, VectP const &x)					{r=::tan(x*d_torad);}
	void  c_c_tand					(CompP &r, CompP const &x)					{Comp1d x2(*x.r*d_torad, *x.i); r=tan(x2);}
	void  q_q_tand					(QuatP &r, QuatP const &x)					{Quat1d x2(*x.r*d_torad, *x.i, *x.j, *x.k); r=tan(x2);}
	auto disc_r_tand_i				=disc_r_sec_i;
	auto disc_c_tand_i				=disc_c_sec_i;
	auto disc_q_tand_i				=disc_q_sec_i;

	void  r_r_atand					(VectP &r, VectP const &x)					{r=::atan(x)*d_todeg;}
	void  c_c_atand					(CompP &r, CompP const &x)					{Comp1d r2=atan(x); r=Comp1d(r2.real()*d_todeg, r2.imag());}
	void  q_q_atand					(QuatP &r, QuatP const &x)					{Quat1d r2=atan(x); r=Quat1d(r2.real()*d_todeg, r2.R_component_2(), r2.R_component_3(), r2.R_component_4());}
	void r_rr_atand					(VectP &r, VectP const &x, VectP const &y)	{r=::atan2(x, y)*d_todeg;}
	void c_rc_atand					(CompP &r, VectP const &x, CompP const &y)
	{
		double rx=x;
		Comp1d t=std::atan(rx/(Comp1d)y);
		t.real(t.real()*d_todeg);
		r=rx<0?*y.r<0?t-180.:t+180.:t;
	}
	void q_rq_atand					(QuatP &r, VectP const &x, QuatP const &y)
	{
		double rx=x;
		Quat1d t=atan(rx/(Quat1d)y);
		t=Quat1d(t.R_component_1()*d_todeg, t.R_component_2(), t.R_component_3(), t.R_component_4());
		r=rx<0?*y.r<0?t-180.:t+180.:t;
	}
	void c_cr_atand					(CompP &r, CompP const &x, VectP const &y)
	{
		double ry=y;
		Comp1d t=std::atan((Comp1d)x/ry);
		t.real(t.real()*d_todeg);
		r=*x.r<0?ry<0?t-180.:t+180.:t;
	}
	void c_cc_atand					(CompP &r, CompP const &x, CompP const &y)
	{
		Comp1d t=std::atan((Comp1d)x/(Comp1d)y);
		t.real(t.real()*d_todeg);
		r=*x.r<0?*y.r<0?t-180.:t+180.:t;
	}
	void q_cq_atand					(QuatP &r, CompP const &x, QuatP const &y)
	{
		Quat1d t=atan((Comp1d)x/(Quat1d)y);
		t=Quat1d(t.R_component_1()*d_todeg, t.R_component_2(), t.R_component_3(), t.R_component_4());
		r=*x.r<0?*y.r<0?t-180.:t+180.:t;
	}
	void q_qr_atand					(QuatP &r, QuatP const &x, VectP const &y)
	{
		double ry=y;
		Quat1d t=atan((Quat1d)x/ry);
		t=Quat1d(t.R_component_1()*d_todeg, t.R_component_2(), t.R_component_3(), t.R_component_4());
		r=*x.r<0?ry<0?t-180.:t+180.:t;
	}
	void q_qc_atand					(QuatP &r, QuatP const &x, CompP const &y)
	{
		Quat1d t=atan((Quat1d)x/(Comp1d)y);
		t=Quat1d(t.R_component_1()*d_todeg, t.R_component_2(), t.R_component_3(), t.R_component_4());
		r=*x.r<0?*y.r<0?t-180.:t+180.:t;
	}
	void q_qq_atand					(QuatP &r, QuatP const &y, QuatP const &x)
	{
		Quat1d t=atan((Quat1d)x/(Quat1d)y);
		t=Quat1d(t.R_component_1()*d_todeg, t.R_component_2(), t.R_component_3(), t.R_component_4());
		r=*x.r<0?*y.r<0?t-180.:t+180.:t;
	}
	bool disc_c_atand_i				(Value const &x0, Value const &x1)
	{
		Value _x0(x0.i, x0.r), _x1(x1.i, x1.r);
		return disc_c_acosd_i(_x0, _x1);
	}
	bool disc_q_atand_i				(Value const &x0, Value const &x1){return false;}//
	bool disc_rr_atand_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1)
	{
		if(y0.r<0)
		{
			if(x0.r<0)
			{
				if(y1.r<0)	return x1.r>=0;
				if(y1.r>0)	return x1.r>0&&y0.r+(0-x0.r)*(y1.r-y0.r)/(x1.r-x0.r)<=0;
							return x1.r>=0;
			}
			else if(x0.r>0)
			{
				if(y1.r<0)	return x1.r<0;
				if(y1.r>0)	return x1.r<0&&y0.r+(0-y0.r)*(y1.r-y0.r)/(x1.r-x1.r)<=0;
							return x1.r<=0;
			}
			else
			{
				if(y1.r<0)	return x1.r<0;
				if(y1.r>0)	return x1.r<=0;
							return x1.r<=0;
			}
		}
		else if(y0.r>0)
		{
			if(x0.r<0)
			{
				if(y1.r<0)	return x1.r>=0&&(x1.r==0||y0.r+(0-y0.r)*(y1.r-y0.r)/(x1.r-x1.r)<=0);
				if(y1.r>0)	return false;
							return x1.r==0;
			}
			else if(x0.r>0)
			{
				if(y1.r<0)	return x1.r<0&&y0.r+(0-y0.r)*(y1.r-y0.r)/(x1.r-x1.r)<=0;
				if(y1.r>0)	return false;
							return x1.r==0;
			}
			else
			{
				if(y1.r<0)	return x1.r==0;
				if(y1.r>0)	return false;
							return x1.r==0;
			}
		}
		else
		{
			if(x0.r<0)
			{
				if(y1.r<0)	return x1.r>=0;
				if(y1.r>0)	return false;
							return x1.r>=0;
			}
			else if(x0.r>0)
			{
				if(y1.r<0)	return x1.r<0;
				if(y1.r>0)	return false;
							return x1.r<=0;
			}
							return true;
		}
	}
	bool disc_rc_atand_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_rq_atand_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cr_atand_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cc_atand_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_cq_atand_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qr_atand_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qc_atand_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	bool disc_qq_atand_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	inline Comp1d tanh(Comp1d const &x){Comp1d e2x=exp(x+x); return (e2x-1.)/(e2x+1.);}
	inline Quat1d tanh(Quat1d const &x){Quat1d e2x=exp(x+x); return (e2x-1.)/(e2x+1.);}
	void  r_r_tanh					(VectP &r, VectP const &x)					{r=::tanh(x);}
	void  c_c_tanh					(CompP &r, CompP const &x)					{r=tanh(x);}
	void  q_q_tanh					(QuatP &r, QuatP const &x)					{r=tanh(x);}

	inline Comp1d atanh(Comp1d const &x){return 0.5*log((1.+x)/(1.-x));}
	void  c_c_atanh					(CompP &r, CompP const &x)					{r=atanh(x);}
	void  q_q_atanh					(QuatP &r, QuatP const &x)					{r=atanh(x);}
	bool disc_c_atanh_i				(Value const &x0, Value const &x1)
	{
		Value _x0(x0.r, -x0.i), _x1(x1.r, -x1.i);
		return disc_c_acos_i(_x0, _x1);
	}
	bool disc_q_atanh_i				(Value const &x0, Value const &x1){return false;}//

	void  r_r_tanc					(VectP &r, VectP const &x)					{double rx=x; r=rx?::tan(rx)/rx:0;}
	void  c_c_tanc					(CompP &r, CompP const &x)					{Comp1d cx=x; r=x.c_is_true()?tan(cx)/cx:0;}
	void  q_q_tanc					(QuatP &r, QuatP const &x)					{Quat1d qx=x; r=x.q_is_true()?tan(qx)/qx:Quat1d();}
	auto disc_r_tanc_i				=disc_r_sec_i;
	auto disc_c_tanc_i				=disc_c_sec_i;
	auto disc_q_tanc_i				=disc_q_sec_i;

	void  r_r_cot					(VectP &r, VectP const &x)					{r=1/::tan(x);}
	void  c_c_cot					(CompP &r, CompP const &x)					{r=inv(tan((Comp1d)x));}
	void  q_q_cot					(QuatP &r, QuatP const &x)					{r=inv(tan((Quat1d)x));}
	auto disc_r_cot_i				=disc_r_csc_i;
	auto disc_c_cot_i				=disc_c_csc_i;
	auto disc_q_cot_i				=disc_q_csc_i;

	void  r_r_acot					(VectP &r, VectP const &x)					{r=*x.r?::atan(1/ *x.r):_pi/2;}
	void  c_c_acot					(CompP &r, CompP const &x)					{r=std::atan(inv((Comp1d)x));}
	void  q_q_acot					(QuatP &r, QuatP const &x)					{r=atan(inv((Quat1d)x));}
	bool disc_r_acot_i				(Value const &x0, Value const &x1){return x0.r<0?x1.r>=0:x1.r<0;}
	auto disc_c_acot_i				=disc_c_acsch_i;
	auto disc_q_acot_i				=disc_q_acsch_i;

	void  r_r_cotd					(VectP &r, VectP const &x)					{r=1/::tan(x*d_torad);}
	void  c_c_cotd					(CompP &r, CompP const &x)					{Comp1d x2(*x.r*d_torad, *x.i); r=inv(tan(x2));}
	void  q_q_cotd					(QuatP &r, QuatP const &x)					{Quat1d x2(*x.r*d_torad, *x.i, *x.j, *x.k); r=inv(tan(x2));}
	auto disc_r_cotd_i				=disc_r_cscd_i;
	auto disc_c_cotd_i				=disc_c_cscd_i;
	auto disc_q_cotd_i				=disc_q_cscd_i;

	void  r_r_acotd					(VectP &r, VectP const &x)					{r=*x.r?::atan(1/ *x.r)*d_todeg:90;}
	void  c_c_acotd					(CompP &r, CompP const &x)					{Comp1d r2=std::atan(inv((Comp1d)x)); r=Comp1d(r2.real()*d_todeg, r2.imag());}
	void  q_q_acotd					(QuatP &r, QuatP const &x)					{Quat1d r2=atan(inv((Quat1d)x)); r=Quat1d(r2.real()*d_todeg, r2.R_component_2(), r2.R_component_3(), r2.R_component_4());}
	bool disc_r_acotd_i				(Value const &x0, Value const &x1){return x0.r<0?x1.r>=0:x1.r<0;}
	auto disc_c_acotd_i				=disc_c_acsch_i;
	auto disc_q_acotd_i				=disc_q_acsch_i;

	void  r_r_coth					(VectP &r, VectP const &x)					{r=1/::tanh(x);}
	void  c_c_coth					(CompP &r, CompP const &x)					{r=inv(tanh(x));}
	void  q_q_coth					(QuatP &r, QuatP const &x)					{r=inv(tanh(x));}
	auto disc_r_coth_i				=disc_r_csch_i;
	auto disc_c_coth_i				=disc_c_csch_i;
	bool disc_q_coth_i				(Value const &x0, Value const &x1){return false;}//

	void  c_c_acoth					(CompP &r, CompP const &x)					{r=std::atanh(inv((Comp1d)x));}
	void  q_q_acoth					(QuatP &r, QuatP const &x)					{r=atanh(inv((Quat1d)x));}
	bool disc_c_acoth_i				(Value const &x0, Value const &x1)
	{
		Value _x0(x0.r, -x0.i), _x1(x1.r, -x1.i);
		return disc_c_acsc_i(_x0, _x1);
	}
	bool disc_q_acoth_i				(Value const &x0, Value const &x1){return false;}//

	void  r_r_exp					(VectP &r, VectP const &x)					{r=::exp(x);}
	void  c_c_exp					(CompP &r, CompP const &x)					{r=exp((Comp1d)x);}
	void  q_q_exp					(QuatP &r, QuatP const &x)					{r=exp((Quat1d)x);}
	
	inline double pow(double const &x, double const &y){return ::exp(y*::log(x));}
	void  r_r_fib					(VectP &r, VectP const &x)					{double phi_p_x=::exp(x*_ln_phi); r=(phi_p_x-::cos(_pi*x)/phi_p_x)*inv_sqrt5;}
	void  c_c_fib					(CompP &r, CompP const &x)					{Comp1d cx=x, phi_p_x=exp(cx*_ln_phi); r=(phi_p_x-cos(_pi*cx)/phi_p_x)*inv_sqrt5;}
	void  q_q_fib					(QuatP &r, QuatP const &x)					{Quat1d qx=x, phi_p_x=exp(qx*_ln_phi); r=(phi_p_x-cos(_pi*qx)/phi_p_x)*inv_sqrt5;}
	
	const double rand_norm=9.31322574615479e-010;
	inline double my_rand(){return (rand()<<15|rand())*rand_norm;}
	void  r_r_random				(VectP &r, VectP const &x)					{r=my_rand();}
	void  c_c_random				(CompP &r, CompP const &x)					{r=Comp1d(my_rand(), my_rand());}
	void  q_q_random				(QuatP &r, QuatP const &x)					{r=Quat1d(my_rand(), my_rand(), my_rand(), my_rand());}
	void r_rr_random				(VectP &r, VectP const &x, VectP const &y)	{r=my_rand();}
	void c_cr_random				(CompP &r, CompP const &x, VectP const &y)	{r=Comp1d(my_rand(), my_rand());}
	void c_cc_random				(CompP &r, CompP const &x, CompP const &y)	{r=Comp1d(my_rand(), my_rand());}
	void q_qq_random				(QuatP &r, QuatP const &x, QuatP const &y)	{r=Quat1d(my_rand(), my_rand(), my_rand(), my_rand());}
	bool disc_r_random_o			(Value const &o0, Value const &o1){return true;}
	auto disc_c_random_o			=disc_r_random_o;
	auto disc_q_random_o			=disc_r_random_o;
	//auto disc_rr_random_o			=disc_r_random_o;
	//auto disc_rc_random_o			=disc_r_random_o;
	//auto disc_rq_random_o			=disc_r_random_o;
	//auto disc_cr_random_o			=disc_r_random_o;
	//auto disc_cc_random_o			=disc_r_random_o;
	//auto disc_cq_random_o			=disc_r_random_o;
	//auto disc_qr_random_o			=disc_r_random_o;
	//auto disc_qc_random_o			=disc_r_random_o;
	//auto disc_qq_random_o			=disc_r_random_o;

	inline double beta(double x, double y)
	{
		try
		{
			return boost::math::beta(x, y);
		}
		catch(...){return _qnan;}
	}
	void  r_r_beta					(VectP &r, VectP const &x)					{r=beta(x, x);}
	void r_rr_beta					(VectP &r, VectP const &x, VectP const &y)	{r=beta(x, y);}
	bool disc_r_beta_i				(Value const &x0, Value const &x1){return false;}//
	bool disc_rr_beta_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	inline double bessel_j(double x, double y)
	{
		try
		{
			return boost::math::cyl_bessel_j(x, y);
		}
		catch(...){return _qnan;}
	}
	void  r_r_bessel_j				(VectP &r, VectP const &x)					{r=bessel_j(0, x);}
	void r_rr_bessel_j				(VectP &r, VectP const &x, VectP const &y)	{r=bessel_j(x, y);}
	bool disc_r_bessel_j_i			(Value const &x0, Value const &x1){return false;}
	bool disc_rr_bessel_j_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	inline double cyl_neumann(double x, double y)
	{
		if(x>0)
			int LOL_1=0;
		if(y!=y||y<0)
			return _qnan;
		try
		{
			return boost::math::cyl_neumann(x, y);
		}
		catch(std::domain_error&){return _qnan;}
		catch(std::overflow_error&){return -_HUGE;}
		catch(...){return _qnan;}
	}
	void  r_r_bessel_y				(VectP &r, VectP const &x)					{r=cyl_neumann(0, x);}
	void r_rr_bessel_y				(VectP &r, VectP const &x, VectP const &y)	{r=cyl_neumann(x, y);}
	bool disc_r_bessel_y_i			(Value const &x0, Value const &x1){return false;}//
	bool disc_rr_bessel_y_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	inline Comp1d r_hankel1(double x, double y)
	{
		try
		{
			return boost::math::cyl_bessel_j(x, y)+Comp1d(0, 1)*boost::math::cyl_neumann(x, y);
		}
		catch(std::domain_error&){return _qnan;}
		catch(std::overflow_error&){return -_HUGE;}
		catch(...){return _qnan;}
	}
	void  c_r_hankel1				(CompP &r, VectP const &x)					{r=r_hankel1(x, x);}
	void  c_c_hankel1				(CompP &r, CompP const &x)					{r=r_hankel1(*x.r, *x.i);}
	void c_rr_hankel1				(CompP &r, VectP const &x, VectP const &y)	{r=r_hankel1(x, y);}
	bool disc_r_hankel1_i			(Value const &x0, Value const &x1){return false;}//
	bool disc_rr_hankel1_i			(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	void  r_r_step					(VectP &r, VectP const &x)					{r=step(x);}
	void  c_c_step					(CompP &r, CompP const &x)					{r=step(x);}
	void  q_q_step					(QuatP &r, QuatP const &x)					{r=step(x);}
	auto disc_r_step_i				=disc_r_divide_i;
	auto disc_c_step_i				=disc_c_divide_i;
	auto disc_q_step_i				=disc_q_divide_i;

	void  r_r_rect					(VectP &r, VectP const &x)					{r=step(x+0.5)-step(x-0.5);}
	void  c_c_rect					(CompP &r, CompP const &x)					{Comp1d cx=x; r=step(cx+0.5)-step(cx-0.5);}
	void  q_q_rect					(QuatP &r, QuatP const &x)					{Quat1d qx=x; r=step(qx+0.5)-step(qx-0.5);}
	bool disc_rect(double x0, double x1)
	{
		double const d[2]={-0.5, 0.5};
		if(x0<d[0])		return x1>=d[0];
		if(x0==d[0])	return x1<d[0]||x1>d[0];
		if(x0<d[1])		return x1>=d[1];
		if(x0==d[1])	return x1<d[1]||x1>d[1];
						return x1<=d[1];
	}
	bool disc_r_rect_i				(Value const &x0, Value const &x1){return disc_rect(x0.r, x1.r);}
	bool disc_c_rect_i				(Value const &x0, Value const &x1)
	{
		if(x0.i==x1.i)	return x0.i==0&&disc_rect(x0.r, x1.r);
		if(x0.r==x1.r)	return (x0.r==-.5||x0.r==.5)&&(x0.i<0?x1.i>=0:x0.i==0?x1.i<0||x1.i>0:x1.i<=0);
		double x=_1d_zero_crossing(x0.r, x0.i, x1.r, x1.i);
		return x==-.5||x==.5;
	}
	bool disc_q_rect_i				(Value const &x0, Value const &x1){return false;}//

	void  r_r_trgl					(VectP &r, VectP const &x)					{double t=::abs(x);						r=t<1?1-t:0;}
	void  r_c_trgl					(VectP &r, CompP const &x)					{double t=std::abs((Comp1d)x);			r=t<1?1-t:0;}
	void  r_q_trgl					(VectP &r, QuatP const &x)					{double t=boost::math::abs((Quat1d)x);	r=t<1?1-t:0;}

	void  r_r_sqwv					(VectP &r, VectP const &x)					{r=*x.r-::floor(*x.r)<0.5;}
	void  r_c_sqwv					(VectP &r, CompP const &x)					{r=*x.r-::floor(*x.r)<0.5;}
	void  r_q_sqwv					(VectP &r, QuatP const &x)					{r=*x.r-::floor(*x.r)<0.5;}
	void r_rr_sqwv					(VectP &r, VectP const &x, VectP const &y)	{r=*x.r-::floor(*x.r)<*y.r;}
	void r_rc_sqwv					(VectP &r, VectP const &x, CompP const &y)	{r=*x.r-::floor(*x.r)<*y.r;}
	void r_rq_sqwv					(VectP &r, VectP const &x, QuatP const &y)	{r=*x.r-::floor(*x.r)<*y.r;}
	void r_cr_sqwv					(VectP &r, CompP const &x, VectP const &y)	{r=*x.r-::floor(*x.r)<*y.r;}
	void r_cc_sqwv					(VectP &r, CompP const &x, CompP const &y)	{r=*x.r-::floor(*x.r)<*y.r;}
	void r_cq_sqwv					(VectP &r, CompP const &x, QuatP const &y)	{r=*x.r-::floor(*x.r)<*y.r;}
	void r_qr_sqwv					(VectP &r, QuatP const &x, VectP const &y)	{r=*x.r-::floor(*x.r)<*y.r;}
	void r_qc_sqwv					(VectP &r, QuatP const &x, CompP const &y)	{r=*x.r-::floor(*x.r)<*y.r;}
	void r_qq_sqwv					(VectP &r, QuatP const &x, QuatP const &y)	{r=*x.r-::floor(*x.r)<*y.r;}
	bool disc_r_sqwv_o				(Value const &o0, Value const &o1)			{return o0.r!=o0.r;}
	//bool disc_r_sqwv_i				(Value const &x0, Value const &x1)
	//{
	//	if(x0.r==x1.r)	return false;
	//	double t0=x0.r+x0.r, t1=x1.r+x1.r;
	//	if(t0==std::floor(t0)||t1==std::floor(t1))
	//		return true;
	//	return std::floor(t0)!=std::floor(t1);
	//}
	//bool disc_c_sqwv_i				(Value const &x0, Value const &x1)
	//{
	//	if(std::floor(x0.r)!=std::floor(x1.r)||std::floor(x0.i)!=std::floor(x1.i))
	//		return true;
	//	if(x0.r==x1.r&&x0.i==x1.i)
	//		return true;
	//	{
	//		double r0=2*x0.r;
	//		if(r0==std::floor(r0)&&x0.i==std::floor(x0.i))
	//			return true;
	//	}
	//	{
	//		double r1=2*x1.r;
	//		if(r1==std::floor(r1)&&x1.i==std::floor(x1.i))
	//			return true;
	//	}
	//	return false;
	//}
	//bool disc_q_sqwv_i				(Value const &x0, Value const &x1){return false;}//
	//bool disc_rr_sqwv_o				(Value const &o0, Value const &o1){return o0.r!=o1.r;}
	//bool disc_rc_sqwv_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	//bool disc_rq_sqwv_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	//bool disc_cr_sqwv_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	//bool disc_cc_sqwv_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	//bool disc_cq_sqwv_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	//bool disc_qr_sqwv_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	//bool disc_qc_sqwv_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//
	//bool disc_qq_sqwv_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return false;}//

	inline double clamp01(double x)
	{
		double temp=x+abs(x);//max(0, x)
		return (temp+2-abs(temp-2))*0.25;//min(x, 1)
	}
	inline double trwv_dc(double x, double y)
	{
		double t=x-::floor(x), t2=1-x;
		t2-=::floor(t2);
		double dc=clamp01(y);
		double dc2=1-dc, t_d=t/dc, t2_d2=t2/dc2;
		return (t_d<1?t_d:0)+(t2_d2<1?t2_d2:0);
	}
	void  r_r_trwv					(VectP &r, VectP const &x)					{double t=abs(x-::floor(x)-0.5); r=t+t;}
	void  r_c_trwv					(VectP &r, CompP const &x)					{Comp1d cx=x; double t=abs(cx-floor(cx)-0.5); r=t+t;}
	void  r_q_trwv					(VectP &r, QuatP const &x)					{Quat1d qx=x; double t=abs(qx-floor(qx)-0.5); r=t+t;}
	void r_rr_trwv					(VectP &r, VectP const &x, VectP const &y)	{r=trwv_dc(*x.r, *y.r);}
	void r_rc_trwv					(VectP &r, VectP const &x, CompP const &y)	{r=trwv_dc(*x.r, *y.r);}
	void r_rq_trwv					(VectP &r, VectP const &x, QuatP const &y)	{r=trwv_dc(*x.r, *y.r);}
	void r_cr_trwv					(VectP &r, CompP const &x, VectP const &y)	{r=trwv_dc(*x.r, *y.r);}
	void r_cc_trwv					(VectP &r, CompP const &x, CompP const &y)	{r=trwv_dc(*x.r, *y.r);}
	void r_cq_trwv					(VectP &r, CompP const &x, QuatP const &y)	{r=trwv_dc(*x.r, *y.r);}
	void r_qr_trwv					(VectP &r, QuatP const &x, VectP const &y)	{r=trwv_dc(*x.r, *y.r);}
	void r_qc_trwv					(VectP &r, QuatP const &x, CompP const &y)	{r=trwv_dc(*x.r, *y.r);}
	void r_qq_trwv					(VectP &r, QuatP const &x, QuatP const &y)	{r=trwv_dc(*x.r, *y.r);}

	inline double sawtooth(double x)
	{
		double t=x-::floor(x), t2=::floor(1-t);//dc=1
		return (t2+1)*(t2*0.5+t);
	}
	inline double sawtooth_dc(double x, double y)
	{
		if(!y)
			return 0;
		auto t=x-::floor(x), t2=::floor(y-t);
		return (t2+1)*(t2*0.5+t)/y;
	}
	inline bool sawtooth_dc_disc(double t0, double t1){return std::floor(t0)!=std::floor(t1);}
	void  r_r_saw					(VectP &r, VectP const &x)					{r=sawtooth(*x.r);}
	void  r_c_saw					(VectP &r, CompP const &x)					{r=sawtooth(*x.r);}
	void  r_q_saw					(VectP &r, QuatP const &x)					{r=sawtooth(*x.r);}
	void r_rr_saw					(VectP &r, VectP const &x, VectP const &y)	{r=sawtooth_dc(*x.r, *y.r);}
	void r_rc_saw					(VectP &r, VectP const &x, CompP const &y)	{r=sawtooth_dc(*x.r, *y.r);}
	void r_rq_saw					(VectP &r, VectP const &x, QuatP const &y)	{r=sawtooth_dc(*x.r, *y.r);}
	void r_cr_saw					(VectP &r, CompP const &x, VectP const &y)	{r=sawtooth_dc(*x.r, *y.r);}
	void r_cc_saw					(VectP &r, CompP const &x, CompP const &y)	{r=sawtooth_dc(*x.r, *y.r);}
	void r_cq_saw					(VectP &r, CompP const &x, QuatP const &y)	{r=sawtooth_dc(*x.r, *y.r);}
	void r_qr_saw					(VectP &r, QuatP const &x, VectP const &y)	{r=sawtooth_dc(*x.r, *y.r);}
	void r_qc_saw					(VectP &r, QuatP const &x, CompP const &y)	{r=sawtooth_dc(*x.r, *y.r);}
	void r_qq_saw					(VectP &r, QuatP const &x, QuatP const &y)	{r=sawtooth_dc(*x.r, *y.r);}
	bool disc_r_saw_i				(Value const &x0, Value const &x1){return std::ceil(x0.r)!=std::ceil(x1.r);}
	bool disc_c_saw_i				(Value const &x0, Value const &x1){return std::ceil(x0.r)!=std::ceil(x1.r);}
	bool disc_q_saw_i				(Value const &x0, Value const &x1){return std::ceil(x0.r)!=std::ceil(x1.r);}
	bool disc_rr_saw_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return sawtooth_dc_disc(x0.r-y0.r, x1.r-y1.r);}
	bool disc_rc_saw_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return sawtooth_dc_disc(x0.r-y0.r, x1.r-y1.r);}
	bool disc_rq_saw_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return sawtooth_dc_disc(x0.r-y0.r, x1.r-y1.r);}
	bool disc_cr_saw_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return sawtooth_dc_disc(x0.r-y0.r, x1.r-y1.r);}
	bool disc_cc_saw_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return sawtooth_dc_disc(x0.r-y0.r, x1.r-y1.r);}
	bool disc_cq_saw_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return sawtooth_dc_disc(x0.r-y0.r, x1.r-y1.r);}
	bool disc_qr_saw_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return sawtooth_dc_disc(x0.r-y0.r, x1.r-y1.r);}
	bool disc_qc_saw_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return sawtooth_dc_disc(x0.r-y0.r, x1.r-y1.r);}
	bool disc_qq_saw_i				(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return sawtooth_dc_disc(x0.r-y0.r, x1.r-y1.r);}

	void r_rr_hypot					(VectP &r, VectP const &x, VectP const &y)	{r=::sqrt(x*x+y*y);}
	//void c_cc_hypot					(CompP const &x, CompP const &y)	{return sqrt(sq(x)+sq(y));}
	//void q_qq_hypot					(QuatP const &x, QuatP const &y)	{return sqrt(sq(x)+sq(y));}

	inline int mandelbrot(Comp1d const &x, int n_iterations)
	{
		double rez=0, imz=0, sq_rez=0, sq_imz=0;
		int k=0;
		for(;k<n_iterations&&sq_rez+sq_imz<16;++k)
		{
			imz=rez*imz;//calculate sq(z)
			imz+=imz;
			rez=sq_rez-sq_imz;

			rez+=x.real(), imz+=x.imag();//add x

			sq_rez=rez*rez, sq_imz=imz*imz;
		}
		return k;

		//Comp1d z;
		//int k=0;
		//for(;k<n_iterations&&z.real()*z.real()+z.imag()*z.imag()<16;++k)
		//	z=sq(z)+x;
		//return k;
	}
	void r_r_mandelbrot				(VectP &r, VectP const &x)					{r=mandelbrot((Comp1d)(double)x, 200);}
	void r_c_mandelbrot				(VectP &r, CompP const &x)					{r=mandelbrot(x, 200);}
	void r_rr_mandelbrot			(VectP &r, VectP const &x, VectP const &y)	{r=mandelbrot((Comp1d)(double)x, (int)(double)y);}
	void r_cr_mandelbrot			(VectP &r, CompP const &x, VectP const &y)	{r=mandelbrot(x, (int)(double)y);}
	bool disc_r_mandelbrot_o		(Value const &x0, Value const &x1){return x0.r!=x1.r;}

	typedef unsigned long long u64;
	inline double mod(double x, double n)
	{
		return x-::floor(x/n)*n;
	}
	double gcd(double a, double b)
	{
		for(double c=mod(a, b);c;)
			a=b, b=c, c=mod(a, b);
		return b;
	}
	double pow_mod(double x, double e, double n)
	{
		double product=1;
		for(;;)
		{
			if(mod(e, 2))
				product=mod(product*x, n);
			e=::floor(e*0.5);
			if(!e)
				break;
			x=mod(x*x, n);
		}
		return product;
	}
	int isprime(double n)//no casting
	{
		if(n!=floor(n))
			return false;
		n=abs(n);//include negative primes
		if(n<2)//0, 1
			return false;
		const unsigned char primes[]=
		{
			 2,  3,  5,  7,
			11, 13, 17, 19,
			23, 29, 31, 37,
			41, 43, 47, 53,
		};
		const int nprimes=sizeof(primes);
		for(int i=0;i<nprimes;++i)
			if(n==primes[i])
				return true;
		for(int i=0;i<nprimes&&primes[i]*primes[i]<=n;++i)
			if(!mod(n, primes[i]))
				return false;
		const int ntrials=20;//Miller-Rabin test: P[error] = 0.25^20 = 1e-14
		char inconclusive=true;
		double q=n-1;//n-1 = q<<k
		int k=0;
		for(;!mod(q, 2);q*=0.5, ++k);
		for(int i=0;inconclusive&&i<ntrials;++i)
		{
			u64 a=rand();//pick a
			for(int k2=0;k2<3;++k2)//full uniform u64 overflows double
				a=a<<15|rand();
			a=2+(u64)mod((double)a, n-3);//1<a<n-1 or 2<=a<=n-2

			double test=pow_mod((double)a, q, n);
			if(test==1)
				continue;//inconclusive
			inconclusive=false;
			for(int j=0;j<k;++j)
			{
				if(test==n-1)
				{
					inconclusive=true;
					break;
				}
				test=mod(test*test, n);
			}
		}
		return inconclusive;
	}
/*	u64 pow_mod(u64 x, u64 e, u64 n)//x^e mod n
	{
		u64 product=1;
		for(;;)
		{
			if(e&1)
				product*=x, product%=n;
			e>>=1;
			if(!e)
				break;
			x*=x, x%=n;
		}
		return product;
	}
	int isprime(long long n)
	{
		n=abs(n);//include negative primes
		if(n<2)//0, 1
			return false;
		if(n<4)//2, 3
			return true;
		if(!(n&1))//even numbers
			return false;
	//	int logn=floor_log2(n);
	//	const int ntrials=20;//Miller-Rabin test: P[error] = 0.25^20 = 1e-14
		char inconclusive=1;
		u64 q=n-1;//n-1 = q<<k
		int k=0;
		for(;!(q&1);q>>=1, ++k);
		const unsigned char aa[]=//https://math.stackexchange.com/questions/2481148/primality-testing-for-64-bit-numbers
		{
			 2,  3,  5,  7,
			11, 13, 17, 19,
			23, 29, 31, 37,
		};
		const int ntrials=sizeof(aa);
		for(int i=0;inconclusive&&i<ntrials;++i)
		{
			long long a=aa[i];//pick a
			//long long a=rand();//pick a
			//for(int k2=0;k2<4;++k2)
			//	a=a<<15|rand();
			//a=2+a%(n-3);//1<a<n-1 or 2<=a<=n-2

			u64 test=pow_mod(a, q, n);
			if(test==1)
				continue;//inconclusive
			for(int j=0;j<k;++j)
			{
				test*=test, test
			}
		}
		return inconclusive;
	}//*/
	double totient32(double n)
	{
		n=abs(n);
		double fn=::floor(n);
		if(n!=fn||isprime(n))
			return fn-1;
		if(n<2)//0, 1
			return 0;
		if(n>0xFFFFFFFF)//too large
			return G2::_qnan;
		double res=n;
		for(double i=2, sqrtn=::sqrt(n);i<=sqrtn;++i)//upto 65536
		{
			if(mod(n, i))
				continue;
			res*=(1-1/i);
			do
				n/=i;
			while(!mod(n, i));
		}
		if(n>1.5)
			res*=(1-1/n);
		return res;
	}
	double inv_mod(double x, double n)
	{
		double q, r[3]={n, x}, t[3]={0, 1};
		for(;;)//Extended Euclidean Algorithm
		{
			q=::floor(r[0]/r[1]);//quotient
			r[2]=r[0]-q*r[1];//new remainder
			if(!r[2])
				break;
			t[2]=t[0]-q*t[1];//new t

			r[0]=r[1], r[1]=r[2];//shift table
			t[0]=t[1], t[1]=t[2];
		}
		if(r[1]!=1)//gcd
			return G2::_qnan;
		if(t[1]<0)
			t[1]+=n;
		return t[1];
	}
	void r_r_isprime				(VectP &r, VectP const &x)					{r=isprime(x);}

	void r_r_totient				(VectP &r, VectP const &x)					{r=totient32(x);}

	void r_rr_invmod				(VectP &r, VectP const &x, VectP const &y)	{r=inv_mod(x, y);}

	void r_rr_min					(VectP &r, VectP const &x, VectP const &y)	{r=(x+y-abs(x-y))*0.5;}
	void c_cr_min					(CompP &r, CompP const &x, VectP const &y)	{Comp1d cx=x; double ry=y;	r=(cx+ry-abs(cx-ry))*0.5;}//TODO: compare real parts and assign appropriate components
	void c_cc_min					(CompP &r, CompP const &x, CompP const &y)	{Comp1d cx=x, cy=y;			r=(cx+cy-abs(cx-cy))*0.5;}
	void q_qq_min					(QuatP &r, QuatP const &x, QuatP const &y)	{Quat1d qx=x, qy=y;			r=(qx+qy-abs(qx-qy))*0.5;}

	void r_rr_max					(VectP &r, VectP const &x, VectP const &y)	{r=(x+y+abs(x-y))*0.5;}
	void c_cr_max					(CompP &r, CompP const &x, VectP const &y)	{Comp1d cx=x; double ry=y;	r=(cx+ry+abs(cx-ry))*0.5;}
	void c_cc_max					(CompP &r, CompP const &x, CompP const &y)	{Comp1d cx=x, cy=y;			r=(cx+cy+abs(cx-cy))*0.5;}
	void q_qq_max					(QuatP &r, QuatP const &x, QuatP const &y)	{Quat1d qx=x, qy=y;			r=(qx+qy+abs(qx-qy))*0.5;}

	void r_rr_conditional_110		(VectP &r, VectP const &x, VectP const &y)	{r=x?*y.r:0;}
	void c_rc_conditional_110		(CompP &r, VectP const &x, CompP const &y)	{r=x?y:Comp1d();}
	void q_rq_conditional_110		(QuatP &r, VectP const &x, QuatP const &y)	{r=x?y:Quat1d();}
	void r_cr_conditional_110		(VectP &r, CompP const &x, VectP const &y)	{r=x.c_is_true()?*y.r:0;}
	void c_cc_conditional_110		(CompP &r, CompP const &x, CompP const &y)	{r=x.c_is_true()?y:Comp1d();}
	void q_cq_conditional_110		(QuatP &r, CompP const &x, QuatP const &y)	{r=x.c_is_true()?y:Quat1d();}
	void r_qr_conditional_110		(VectP &r, QuatP const &x, VectP const &y)	{r=x.q_is_true()?*y.r:0;}
	void c_qc_conditional_110		(CompP &r, QuatP const &x, CompP const &y)	{r=x.q_is_true()?y:Comp1d();}
	void q_qq_conditional_110		(QuatP &r, QuatP const &x, QuatP const &y)	{r=x.q_is_true()?y:Quat1d();}
	bool disc_conditional_110_i		(Value const &x0, Value const &y0, Value const &x1, Value const &y1){return _1d_zero_in_range(x0.r, x1.r)&&_1d_zero_in_range(x0.i, x1.i)&&_1d_zero_in_range(x0.j, x1.j)&&_1d_zero_in_range(x0.k, x1.k);}
	
	void r_rr_conditional_101		(VectP &r, VectP const &x, VectP const &y)	{r=x?0:*y.r;}
	void c_rc_conditional_101		(CompP &r, VectP const &x, CompP const &y)	{r=x?Comp1d():y;}
	void q_rq_conditional_101		(QuatP &r, VectP const &x, QuatP const &y)	{r=x?Quat1d():y;}
	void r_cr_conditional_101		(VectP &r, CompP const &x, VectP const &y)	{r=x.c_is_true()?0:*y.r;}
	void c_cc_conditional_101		(CompP &r, CompP const &x, CompP const &y)	{r=x.c_is_true()?Comp1d():y;}
	void q_cq_conditional_101		(QuatP &r, CompP const &x, QuatP const &y)	{r=x.c_is_true()?Quat1d():y;}
	void r_qr_conditional_101		(VectP &r, QuatP const &x, VectP const &y)	{r=x.q_is_true()?0:*y.r;}
	void c_qc_conditional_101		(CompP &r, QuatP const &x, CompP const &y)	{r=x.q_is_true()?Comp1d():y;}
	void q_qq_conditional_101		(QuatP &r, QuatP const &x, QuatP const &y)	{r=x.q_is_true()?Quat1d():y;}
	auto disc_conditional_101_i		=disc_conditional_110_i;

	bool disc_conditional_111_i		(Value const &x0, Value const &y0, Value const &z0, Value const &x1, Value const &y1, Value const &z1){return _1d_zero_in_range(x0.r, x1.r)&&_1d_zero_in_range(x0.i, x1.i)&&_1d_zero_in_range(x0.j, x1.j)&&_1d_zero_in_range(x0.k, x1.k);}

	void  r_r_increment				(VectP &r, VectP const &x)					{r=x+1;}
	void  c_c_increment				(CompP &r, CompP const &x)					{r=(Comp1d)x+1.;}
	void  q_q_increment				(QuatP &r, QuatP const &x)					{r=(Quat1d)x+1.;}

	void  r_r_decrement				(VectP &r, VectP const &x)					{r=x-1;}
	void  c_c_decrement				(CompP &r, CompP const &x)					{r=(Comp1d)x-1.;}
	void  q_q_decrement				(QuatP &r, QuatP const &x)					{r=(Quat1d)x-1.;}

	void  r_r_assign				(VectP &r, VectP const &x)					{r=x;}
	void  c_c_assign				(CompP &r, CompP const &x)					{r=(Comp1d)x;}
	void  q_q_assign				(QuatP &r, QuatP const &x)					{r=(Quat1d)x;}

	//variadic functions
	inline Quat1d load1(Term &n, int idx, char ms)
	{
		double r, i, j, k;
		r=n.r[idx];
		//i=n.i.p?n.i.p[idx]:0;
		//j=n.j.p?n.j.p[idx]:0;
		//k=n.k.p?n.k.p[idx]:0;
		i=ms>='c'?n.i[idx]:0;
		if(ms=='h')
		{
			j=n.j[idx];
			k=n.k[idx];
		}
		else
		{
			j=0;
			k=0;
		}
		return Quat1d(r, i, j, k);
	}
	inline void store1(Term &n, int idx, char ms, Quat1d const &v)
	{
		n.r[idx]=v.R_component_1();
		if(ms>='c')
			n.i[idx]=v.R_component_2();
		if(ms=='h')
		{
			n.j[idx]=v.R_component_3();
			n.k[idx]=v.R_component_4();
		}
	}
	inline double clampd(double const &lo, double const &x, double const &hi)
	{
		if(x<lo)
			return lo;
		if(x>hi)
			return hi;
		return x;
	}
	inline void clamp(Quat1d const &lo, Quat1d &x, Quat1d const &hi)
	{
		x=Quat1d
		(
			clampd(lo.R_component_1(), x.R_component_1(), hi.R_component_1()),
			clampd(lo.R_component_2(), x.R_component_2(), hi.R_component_2()),
			clampd(lo.R_component_3(), x.R_component_3(), hi.R_component_3()),
			clampd(lo.R_component_4(), x.R_component_4(), hi.R_component_4())
		);
	}
	void va_clamp					(void *pn, void *pdata, ArgIdx result, std::vector<ArgIdx> const &args, int idx)
	{
		if(pdata)
		{
			auto &data=*(std::vector<Value>*)pdata;
			switch(args.size())
			{
			case 1:
				{
					Quat1d
						lo,
						x =data[args[0].idx],
						hi(1, 1, 1, 1);
					clamp(lo, x, hi);
					data[result.idx]=x;
				}
				break;
			case 2:
				{
					Quat1d
						lo,
						x =data[args[0].idx],
						hi=data[args[1].idx];
					clamp(lo, x, hi);
					data[result.idx]=x;
				}
				break;
			case 3:
				{
					Quat1d
						lo=data[args[0].idx],
						x =data[args[1].idx],
						hi=data[args[2].idx];
					clamp(lo, x, hi);
					data[result.idx]=x;
				}
				break;
			}
		}
		else if(pn)
		{
			auto &n=*(std::vector<Term>*)pn;
			switch(args.size())
			{
			case 1:
				{
					Quat1d
						lo,
						x =load1(n[args[0].idx], idx, args[0].mathSet),
						hi(1, 1, 1, 1);
					clamp(lo, x, hi);
					store1(n[result.idx], idx, result.mathSet, x);
				}
				break;
			case 2:
				{
					Quat1d
						lo,
						x =load1(n[args[0].idx], idx, args[0].mathSet),
						hi=load1(n[args[1].idx], idx, args[1].mathSet);
					clamp(lo, x, hi);
					store1(n[result.idx], idx, result.mathSet, x);
				}
				break;
			case 3:
				{
					Quat1d
						lo=load1(n[args[0].idx], idx, (char)args[0].mathSet),
						x =load1(n[args[1].idx], idx, (char)args[1].mathSet),
						hi=load1(n[args[2].idx], idx, (char)args[2].mathSet);
					clamp(lo, x, hi);
					store1(n[result.idx], idx, result.mathSet, x);
				}
				break;
			}
		}
	}
	void va_min						(void *pn, void *pdata, ArgIdx result, std::vector<ArgIdx> const &args, int idx)
	{
		if(pdata)
		{
			auto &data=*(std::vector<Value>*)pdata;
			int kn=args[0].idx;
			Quat1d ret=data[kn];
			for(int k=1;k<(int)args.size();++k)
			{
				kn=args[k].idx;
				Quat1d vk=data[kn];
				ret=Quat1d
				(
					min(ret.R_component_1(), vk.R_component_1()),
					min(ret.R_component_2(), vk.R_component_2()),
					min(ret.R_component_3(), vk.R_component_3()),
					min(ret.R_component_4(), vk.R_component_4())
				);
			}
			int res=result.idx;
			data[res]=ret;
		}
		else if(pn)
		{
			auto &n=*(std::vector<Term>*)pn;
			int kn=args[0].idx;
			Quat1d ret=load1(n[kn], idx, args[0].mathSet);
			for(int k=1;k<(int)args.size();++k)
			{
				kn=args[k].idx;
				Quat1d vk=load1(n[kn], idx, args[k].mathSet);
				ret=Quat1d
				(
					min(ret.R_component_1(), vk.R_component_1()),
					min(ret.R_component_2(), vk.R_component_2()),
					min(ret.R_component_3(), vk.R_component_3()),
					min(ret.R_component_4(), vk.R_component_4())
				);
			}
			int res=result.idx;
			auto &nr=n[res];
			store1(nr, idx, result.mathSet, ret);
		}
	}
	void va_max						(void *pn, void *pdata, ArgIdx result, std::vector<ArgIdx> const &args, int idx)
	{
		if(pdata)
		{
			auto &data=*(std::vector<Value>*)pdata;
			int kn=args[0].idx;
			Quat1d ret=data[kn];
			for(int k=1;k<(int)args.size();++k)
			{
				kn=args[k].idx;
				Quat1d vk=data[kn];
				ret=Quat1d
				(
					max(ret.R_component_1(), vk.R_component_1()),
					max(ret.R_component_2(), vk.R_component_2()),
					max(ret.R_component_3(), vk.R_component_3()),
					max(ret.R_component_4(), vk.R_component_4())
				);
			}
			int res=result.idx;
			data[res]=ret;
		}
		else if(pn)
		{
			auto &n=*(std::vector<Term>*)pn;
			int kn=args[0].idx;
			Quat1d ret=load1(n[kn], idx, args[0].mathSet);
			for(int k=1;k<(int)args.size();++k)
			{
				kn=args[k].idx;
				Quat1d vk=load1(n[kn], idx, args[k].mathSet);
				ret=Quat1d
				(
					max(ret.R_component_1(), vk.R_component_1()),
					max(ret.R_component_2(), vk.R_component_2()),
					max(ret.R_component_3(), vk.R_component_3()),
					max(ret.R_component_4(), vk.R_component_4())
				);
			}
			int res=result.idx;
			auto &nr=n[res];
			store1(nr, idx, result.mathSet, ret);
		}
	}
	void va_average					(void *pn, void *pdata, ArgIdx result, std::vector<ArgIdx> const &args, int idx)
	{
		if(pdata)
		{
			auto &data=*(std::vector<Value>*)pdata;
			Quat1d ret;
			for(int k=0;k<(int)args.size();++k)
				ret+=data[args[k].idx].quat1d();
			ret*=1./args.size();
			data[result.idx]=ret;
		}
		else if(pn)
		{
			auto &n=*(std::vector<Term>*)pn;
			Quat1d ret;
			for(int k=0;k<(int)args.size();++k)
				ret+=load1(n[args[k].idx], idx, args[k].mathSet);
			ret*=1./args.size();
			store1(n[result.idx], idx, result.mathSet, ret);
		}
	}
	void va_hypot					(void *pn, void *pdata, ArgIdx result, std::vector<ArgIdx> const &args, int idx)
	{
		if(pdata)
		{
			auto &data=*(std::vector<Value>*)pdata;
			Quat1d ret;
			for(int k=0;k<(int)args.size();++k)
			{
				char ms=args[k].mathSet;
				Quat1d term=data[args[k].idx];
				switch(ms)
				{
				case 'R':
					ret+=Quat1d(term.R_component_1()*term.R_component_1());
					break;
				case 'c':
					{
						Comp1d temp(term.R_component_1(), term.R_component_1());
						ret+=temp*temp;
					}
					break;
				case 'h':
					ret+=term*term;
					break;
				}
			}
			char rms=result.mathSet;
			switch(rms)
			{
			case 'R':
				ret=Quat1d(::sqrt(ret.R_component_1()));
				break;
			case 'c':
				ret=sqrt(Comp1d(ret.R_component_1(), ret.R_component_2()));
				break;
			case 'h':
				ret=sqrt(ret);
				break;
			}
			data[result.idx]=ret;
		}
		else if(pn)
		{
			auto &n=*(std::vector<Term>*)pn;
			Quat1d ret;
			for(int k=0;k<(int)args.size();++k)
			{
				char ms=args[k].mathSet;
				Quat1d term=load1(n[args[k].idx], idx, ms);
				switch(ms)
				{
				case 'R':
					ret+=Quat1d(term.R_component_1()*term.R_component_1());
					break;
				case 'c':
					{
						Comp1d temp(term.R_component_1(), term.R_component_1());
						ret+=temp*temp;
					}
					break;
				case 'h':
					ret+=term*term;
					break;
				}
			}
			char rms=result.mathSet;
			switch(rms)
			{
			case 'R':
				ret=Quat1d(::sqrt(ret.R_component_1()));
				break;
			case 'c':
				ret=sqrt(Comp1d(ret.R_component_1(), ret.R_component_2()));
				break;
			case 'h':
				ret=sqrt(ret);
				break;
			}
			store1(n[result.idx], idx, rms, ret);
		}
	}
	inline Quat1d pow(Quat1d const &x, double const &y){return exp(y*log(x));}//boost::math::pow(Quat1d, double->int)
	inline Quat1d pow(Quat1d const &x, Comp1d const &y){return exp(y*log(x));}//std::pow(Quat1d, Comp1d->double)
	inline Quat1d pow(Comp1d const &x, Quat1d const &y){return exp(y*log(x));}
	inline void pow_ms(Quat1d &base, char base_ms, Quat1d const &p)
	{
		switch(base_ms)
		{
		case 'R':
		case 'c':
			base=Quat1d(std::log(base.C_component_1()));
			break;
		case 'h':
			base=log(base);
			break;
		}
		base*=p;
		switch(base_ms)
		{
		case 'R':
		case 'c':
			base=Quat1d(std::exp(base.C_component_1()));
			break;
		case 'h':
			base=exp(base);
			break;
		}
	}
	void va_norm					(void *pn, void *pdata, ArgIdx result, std::vector<ArgIdx> const &args, int idx)
	{
		if(pdata)
		{
			auto &data=*(std::vector<Value>*)pdata;
			char pms=(char)args[0].mathSet;
			int kp=args[0].idx;
			Quat1d p=data[kp], ret;
			switch(pms)
			{
			case 'R':
				{
					for(int k=1;k<(int)args.size();++k)
					{
						char ms=(char)args[k].mathSet;
						Quat1d term=data[args[k].idx];
						switch(ms)
						{
						case 'R':
							ret+=pow(term.R_component_1(), p.R_component_1());
							break;
						case 'c':
							{
								Comp1d temp(term.R_component_1(), term.R_component_2());
								ret+=pow(temp, p.R_component_1());
							}
							break;
						case 'h':
							ret+=pow(term, p.R_component_1());
							break;
						}
					}
					p=Quat1d(1/p.R_component_1());
				}
				break;
			case 'c':
				{
					Comp1d cp=p.C_component_1();
					for(int k=1;k<(int)args.size();++k)
					{
						char ms=args[k].mathSet;
						Quat1d term=data[args[k].idx];
						switch(ms)
						{
						case 'R':
							ret+=pow(term.R_component_1(), cp);
							break;
						case 'c':
							ret+=pow(term.C_component_1(), cp);
							break;
						case 'h':
							ret+=G2::pow(term, cp);
							break;
						}
					}
					p=inv(cp);
				}
				break;
			case 'h':
				{
					for(int k=1;k<(int)args.size();++k)
					{
						char ms=args[k].mathSet;
						Quat1d term=data[args[k].idx];
						switch(ms)
						{
						case 'R':
							ret+=pow(term.R_component_1(), p);
							break;
						case 'c':
							{
								auto temp=log(term.C_component_1());
								auto temp2=temp*p;
							//	ret+=G2::exp(temp*p);
							}
						//	ret+=pow(term.C_component_1(), p);
							break;
						case 'h':
							ret+=pow(term, p);
							break;
						}
					}
					p=inv(p);
				}
				break;
			}
			char rms=result.mathSet;
			pow_ms(ret, rms, p);
			data[result.idx]=ret;
		}
		else if(pn)
		{
			auto &n=*(std::vector<Term>*)pn;
			char pms=args[0].mathSet;
			int kp=args[0].idx;
			Quat1d p=load1(n[kp], idx, pms), ret;
			switch(pms)
			{
			case 'R':
				{
					for(int k=1;k<(int)args.size();++k)
					{
						char ms=args[k].mathSet;
						Quat1d term=load1(n[args[k].idx], idx, ms);
						switch(ms)
						{
						case 'R':
							ret+=pow(term.R_component_1(), p.R_component_1());
							break;
						case 'c':
							{
								Comp1d temp(term.R_component_1(), term.R_component_2());
								ret+=pow(temp, p.R_component_1());
							}
							break;
						case 'h':
							ret+=pow(term, p.R_component_1());
							break;
						}
					}
					p=Quat1d(1/p.R_component_1());
				}
				break;
			case 'c':
				{
					auto &np=n[kp];
					Comp1d cp=p.C_component_1();
					for(int k=1;k<(int)args.size();++k)
					{
						char ms=args[k].mathSet;
						Quat1d term=load1(n[args[k].idx], idx, ms);
						switch(ms)
						{
						case 'R':
							ret+=pow(term.R_component_1(), cp);
							break;
						case 'c':
							ret+=pow(term.C_component_1(), cp);
							break;
						case 'h':
							ret+=G2::pow(term, cp);
							break;
						}
					}
					p=inv(cp);
				}
				break;
			case 'h':
				{
					for(int k=1;k<(int)args.size();++k)
					{
						char ms=args[k].mathSet;
						Quat1d term=load1(n[args[k].idx], idx, ms);
						switch(ms)
						{
						case 'R':
							ret+=pow(term.R_component_1(), p);
							break;
						case 'c':
							ret+=G2::pow(term.C_component_1(), p);
							break;
						case 'h':
							ret+=pow(term, p);
							break;
						}
					}
					p=inv(p);
				}
				break;
			}
			char rms=result.mathSet;
			pow_ms(ret, rms, p);
			store1(n[result.idx], idx, rms, ret);
		}
	}
	void va_gcd						(void *pn, void *pdata, ArgIdx result, std::vector<ArgIdx> const &args, int idx)
	{
		int nargs=args.size();
		if(pdata)
		{
			auto &data=*(std::vector<Value>*)pdata;
			if(nargs)
			{
				double divisor=data[args[0].idx].r;
				for(int k=1;k<nargs;++k)
					divisor=gcd(divisor, data[args[k].idx].r);
				data[result.idx].set(divisor);
				//long long divisor=(long long)data[args[0].idx].r;
				//for(int k=1;k<nargs;++k)
				//	divisor=gcd(divisor, (long long)data[args[k].idx].r);
				//data[result.idx].set((double)divisor);
			}
			else
				data[result.idx].setnan();
		}
		else if(pn)
		{
			auto &n=*(std::vector<Term>*)pn;
			if(nargs)
			{
				double divisor=n[args[0].idx].r[idx];
				for(int k=1;k<nargs;++k)
					divisor=gcd(divisor, n[args[k].idx].r[idx]);
				store1(n[result.idx], idx, result.mathSet, Quat1d(divisor));
			}
			else
				store1(n[result.idx], idx, result.mathSet, Quat1d(G2::_qnan));
		}
	}
}

bool UserFunctionsDefaultReturnZero=false;
bool markFunctionsStuck=false;//true: stuck once return nan regardless of input, false: stuck every time, return nan where stuck only
int userFunctionTimeLimit=400;//ms		4000
//typedef aligned_vector<PseudoQuaternion, 16> AVector_pq;
enum FORMAT
{
	FORMAT_INSTRUCTION,
	FORMAT_UNARY_OPERATOR_LEFT, FORMAT_UNARY_OPERATOR_RIGHT, FORMAT_BINARY_OPERATOR,
	FORMAT_UNARY_FUNCTION, FORMAT_BINARY_FUNCTION
};
#if 1
typedef		void (*VF)();
struct		UnaryFunctionNameMap
{
	VF func[3];
	const char *name;
	int format;
};
struct		BinaryFunctionNameMap
{
	VF func[9];
	const char *name;
	int format;
};
#define		UFNAMES(name)		{(VF)r_r_##name, (VF)c_c_##name, (VF)q_q_##name}
#define		UFNAMES_R(name)		{(VF)r_r_##name, (VF)r_c_##name, (VF)r_q_##name}
#define		UFMAP(name)			{UFNAMES(name), #name, FORMAT_UNARY_FUNCTION}
#define		BFNAMES(name)		{(VF)r_rr_##name, (VF)c_rc_##name, (VF)q_rq_##name, (VF)c_cr_##name, (VF)c_cc_##name, (VF)q_cq_##name, (VF)q_qr_##name, (VF)q_qc_##name, (VF)q_qq_##name}
#define		BFNAMES_R(name)		{(VF)r_rr_##name, (VF)r_rc_##name, (VF)r_rq_##name, (VF)r_cr_##name, (VF)r_cc_##name, (VF)r_cq_##name, (VF)r_qr_##name, (VF)r_qc_##name, (VF)r_qq_##name}
#define		BFMAP(name)			{BFNAMES(name), #name, FORMAT_UNARY_FUNCTION}
#define		UMAP_DECLARATION	static const UnaryFunctionNameMap umap[]=\
{\
	UFMAP(setzero), UFMAP(ceil), UFMAP(floor),\
	{{(VF)r_r_abs, (VF)r_c_abs, (VF)r_q_abs}, "abs", FORMAT_UNARY_FUNCTION},\
	{{(VF)r_r_arg, (VF)r_c_arg, (VF)r_q_arg}, "arg", FORMAT_UNARY_FUNCTION},\
	{{(VF)r_c_real, (VF)r_c_real, (VF)r_c_real}, "re", FORMAT_UNARY_FUNCTION},\
	{{(VF)r_c_imag, (VF)r_c_imag, (VF)r_c_imag}, "im", FORMAT_UNARY_FUNCTION},\
	{{(VF)c_c_conjugate,  (VF)c_c_conjugate, (VF)q_q_conjugate}, "conjugate", FORMAT_UNARY_FUNCTION},\
	{{(VF)c_c_polar,  (VF)c_c_polar, (VF)c_q_polar}, "polar", FORMAT_UNARY_FUNCTION},\
	{{(VF)c_c_cartesian,  (VF)c_c_cartesian, (VF)q_q_cartesian}, "cartesian", FORMAT_UNARY_FUNCTION},\
	{UFNAMES(minus), "-", FORMAT_UNARY_OPERATOR_LEFT},\
	{UFNAMES(divide), "reciprocal", FORMAT_UNARY_FUNCTION},\
	{{(VF)c_c_ln,  (VF)c_c_ln, (VF)q_q_ln}, "ln", FORMAT_UNARY_FUNCTION},\
	{{(VF)c_c_log,  (VF)c_c_log, (VF)q_q_log}, "log10", FORMAT_UNARY_FUNCTION},\
	{UFNAMES(bitwise_shift_left_l), "<<", FORMAT_UNARY_OPERATOR_LEFT},\
	{UFNAMES(bitwise_shift_left_r), "<<", FORMAT_UNARY_OPERATOR_RIGHT},\
	{UFNAMES(bitwise_shift_right_l), ">>", FORMAT_UNARY_OPERATOR_LEFT},\
	{UFNAMES(bitwise_shift_right_r), ">>", FORMAT_UNARY_OPERATOR_RIGHT},\
	{UFNAMES(bitwise_not), "~", FORMAT_UNARY_OPERATOR_LEFT},\
	{UFNAMES(bitwise_and), "&", FORMAT_UNARY_OPERATOR_LEFT},\
	{UFNAMES(bitwise_nand), "~&", FORMAT_UNARY_OPERATOR_LEFT},\
	{UFNAMES(bitwise_or), "|", FORMAT_UNARY_OPERATOR_LEFT},\
	{UFNAMES(bitwise_nor), "~|", FORMAT_UNARY_OPERATOR_LEFT},\
	{UFNAMES(bitwise_xor), "xor", FORMAT_UNARY_OPERATOR_LEFT},\
	{UFNAMES(bitwise_xnor), "xnor", FORMAT_UNARY_OPERATOR_LEFT},\
	{UFNAMES_R(logic_equal), "==0", FORMAT_UNARY_OPERATOR_RIGHT},\
	{UFNAMES_R(logic_not_equal), "!=0", FORMAT_UNARY_OPERATOR_RIGHT},\
	{UFNAMES_R(logic_less_l), "0<", FORMAT_UNARY_OPERATOR_LEFT},\
	{UFNAMES_R(logic_less_r), "<0", FORMAT_UNARY_OPERATOR_RIGHT},\
	{UFNAMES_R(logic_less_equal_l), "0<=", FORMAT_UNARY_OPERATOR_LEFT},\
	{UFNAMES_R(logic_less_equal_r), "<=0", FORMAT_UNARY_OPERATOR_RIGHT},\
	{UFNAMES_R(logic_greater_l), "0>", FORMAT_UNARY_OPERATOR_LEFT},\
	{UFNAMES_R(logic_greater_r), ">0", FORMAT_UNARY_OPERATOR_RIGHT},\
	{UFNAMES_R(logic_greater_equal_l), "0>=", FORMAT_UNARY_OPERATOR_LEFT},\
	{UFNAMES_R(logic_greater_equal_r), ">=0", FORMAT_UNARY_OPERATOR_RIGHT},\
	{UFNAMES_R(logic_not), "!", FORMAT_UNARY_OPERATOR_LEFT},\
	{UFNAMES(percent), "percent", FORMAT_UNARY_OPERATOR_RIGHT},\
	UFMAP(sgn), UFMAP(sq),\
	{{(VF)c_c_sqrt,  (VF)c_c_sqrt, (VF)q_q_sqrt}, "sqrt", FORMAT_UNARY_FUNCTION},\
	{{(VF)r_r_invsqrt,  (VF)r_r_invsqrt, (VF)r_r_invsqrt}, "invsqrt", FORMAT_UNARY_FUNCTION},\
	UFMAP(cbrt), UFMAP(gauss),\
	{{(VF)r_r_erf,  (VF)r_r_erf, (VF)r_r_erf}, "erf", FORMAT_UNARY_FUNCTION},\
	{{(VF)r_r_zeta,  (VF)r_r_zeta, (VF)r_r_zeta}, "zeta", FORMAT_UNARY_FUNCTION},\
	UFMAP(tgamma),\
	{{(VF)r_r_loggamma,  (VF)r_r_loggamma, (VF)r_r_loggamma}, "loggamma", FORMAT_UNARY_FUNCTION},\
	UFMAP(permutation), UFMAP(combination),\
	UFMAP(cos),\
	{{(VF)c_c_acos,  (VF)c_c_acos, (VF)q_q_acos}, "acos", FORMAT_UNARY_FUNCTION},\
	UFMAP(cosh),\
	{{(VF)c_c_acosh,  (VF)c_c_acosh, (VF)q_q_acosh}, "acosh", FORMAT_UNARY_FUNCTION},\
	UFMAP(cosc), UFMAP(sec),\
	{{(VF)c_c_asec,  (VF)c_c_asec, (VF)q_q_asec}, "asec", FORMAT_UNARY_FUNCTION},\
	{{(VF)c_c_asech,  (VF)c_c_asech, (VF)q_q_asech}, "asech", FORMAT_UNARY_FUNCTION},\
	UFMAP(sin),\
	{{(VF)c_c_asin,  (VF)c_c_asin, (VF)q_q_asin}, "asin", FORMAT_UNARY_FUNCTION},\
	UFMAP(sinh), UFMAP(asinh), UFMAP(sinc), UFMAP(sinhc), UFMAP(csc),\
	{{(VF)c_c_acsc,  (VF)c_c_acsc, (VF)q_q_acsc}, "acsc", FORMAT_UNARY_FUNCTION},\
	UFMAP(csch), UFMAP(acsch), UFMAP(tan), UFMAP(atan), UFMAP(tanh),\
	{{(VF)c_c_atanh,  (VF)c_c_atanh, (VF)q_q_atanh}, "atanh", FORMAT_UNARY_FUNCTION},\
	UFMAP(tanc), UFMAP(cot), UFMAP(acot), UFMAP(coth),\
	{{(VF)c_c_acoth,  (VF)c_c_acoth, (VF)c_c_acoth}, "acoth", FORMAT_UNARY_FUNCTION},\
	UFMAP(exp), UFMAP(fib),\
	{UFNAMES(random), "rand", FORMAT_UNARY_FUNCTION},\
	{{(VF)r_r_beta, (VF)r_r_beta, (VF)r_r_beta}, "beta", FORMAT_UNARY_FUNCTION},\
	{{(VF)r_r_bessel_j, (VF)r_r_bessel_j, (VF)r_r_bessel_j}, "bessel_j", FORMAT_UNARY_FUNCTION},\
	{{(VF)r_r_bessel_y, (VF)r_r_bessel_y, (VF)r_r_bessel_y}, "bessel_y", FORMAT_UNARY_FUNCTION},\
	{{(VF)c_r_hankel1, (VF)c_c_hankel1,  (VF)c_c_hankel1}, "hankel1", FORMAT_UNARY_FUNCTION},\
	UFMAP(step), UFMAP(rect),\
	{UFNAMES_R(trgl), "trgl", FORMAT_UNARY_FUNCTION},\
	{UFNAMES_R(sqwv), "sqwv", FORMAT_UNARY_FUNCTION},\
	{UFNAMES_R(trwv), "trwv", FORMAT_UNARY_FUNCTION},\
	{UFNAMES_R(saw), "saw", FORMAT_UNARY_FUNCTION},\
	{{(VF)r_r_mandelbrot, (VF)r_c_mandelbrot,  (VF)r_c_mandelbrot}, "mandelbrot", FORMAT_UNARY_FUNCTION},\
	{UFNAMES(increment), "++", FORMAT_UNARY_OPERATOR_LEFT},\
	{UFNAMES(decrement), "--", FORMAT_UNARY_OPERATOR_LEFT},\
	{UFNAMES(assign), "", FORMAT_UNARY_OPERATOR_LEFT},\
}//=	an operator that does nothing
#define		BMAP_DECLARATION	static const BinaryFunctionNameMap bmap[]=\
{\
	{BFNAMES(plus), "+", FORMAT_BINARY_OPERATOR},\
	{BFNAMES(minus), "-", FORMAT_BINARY_OPERATOR},\
	{BFNAMES(multiply), "*", FORMAT_BINARY_OPERATOR},\
	{BFNAMES(divide), "/", FORMAT_BINARY_OPERATOR},\
	{BFNAMES_R(logic_divides), "@", FORMAT_BINARY_OPERATOR},\
	{{(VF)r_rr_power_real, (VF)c_cr_power_real, (VF)q_qr_power_real,  (VF)r_rr_power_real, (VF)c_cr_power_real, (VF)q_qr_power_real,  (VF)r_rr_power_real, (VF)c_cr_power_real, (VF)q_qr_power_real}, "**", FORMAT_BINARY_OPERATOR},\
	{{(VF)c_cr_pow, (VF)c_cc_pow, (VF)q_cq_pow, (VF)q_qr_pow, (VF)q_qc_pow, (VF)q_qq_pow,  (VF)q_qr_pow, (VF)q_qc_pow, (VF)q_qq_pow}, "^", FORMAT_BINARY_OPERATOR},\
	{{(VF)c_cr_log, (VF)c_cc_log, (VF)q_cq_log, (VF)q_qc_log, (VF)q_qq_log,  (VF)c_cc_log, (VF)q_cq_log, (VF)q_qc_log, (VF)q_qq_log}, "log", FORMAT_BINARY_FUNCTION},\
	{{(VF)c_rr_tetrate, (VF)c_rc_tetrate, (VF)c_cr_tetrate, (VF)c_cc_tetrate, (VF)q_qr_tetrate,  (VF)c_rc_tetrate, (VF)c_cr_tetrate, (VF)c_cc_tetrate, (VF)q_qr_tetrate}, "^^", FORMAT_BINARY_OPERATOR},\
	{{(VF)c_rr_pentate, (VF)c_cr_pentate,  (VF)c_rr_pentate, (VF)c_cr_pentate,  (VF)c_rr_pentate, (VF)c_cr_pentate,  (VF)c_rr_pentate, (VF)c_cr_pentate,  (VF)c_cr_pentate}, "^^^", FORMAT_BINARY_OPERATOR},\
	{BFNAMES(bitwise_shift_left), "<<", FORMAT_BINARY_OPERATOR},\
	{BFNAMES(bitwise_shift_right), ">>", FORMAT_BINARY_OPERATOR},\
	{BFNAMES(bitwise_and), "&", FORMAT_BINARY_OPERATOR},\
	{BFNAMES(bitwise_nand), "~&", FORMAT_BINARY_OPERATOR},\
	{BFNAMES(bitwise_or), "|", FORMAT_BINARY_OPERATOR},\
	{BFNAMES(bitwise_nor), "~|", FORMAT_BINARY_OPERATOR},\
	{BFNAMES(bitwise_xor), "xor", FORMAT_BINARY_OPERATOR},\
	{BFNAMES(bitwise_xnor), "xnor", FORMAT_BINARY_OPERATOR},\
	{BFNAMES_R(logic_equal), "==", FORMAT_BINARY_OPERATOR},\
	{BFNAMES_R(logic_not_equal), "!=", FORMAT_BINARY_OPERATOR},\
	{BFNAMES_R(logic_less), "<", FORMAT_BINARY_OPERATOR},\
	{BFNAMES_R(logic_less_equal), "<=", FORMAT_BINARY_OPERATOR},\
	{BFNAMES_R(logic_greater), ">", FORMAT_BINARY_OPERATOR},\
	{BFNAMES_R(logic_greater_equal), ">=", FORMAT_BINARY_OPERATOR},\
	{BFNAMES_R(logic_and), "&&", FORMAT_BINARY_OPERATOR},\
	{BFNAMES_R(logic_or), "||", FORMAT_BINARY_OPERATOR},\
	{BFNAMES_R(logic_xor), "##", FORMAT_BINARY_OPERATOR},\
	{BFNAMES(condition_zero), "??", FORMAT_BINARY_OPERATOR},\
	{BFNAMES(modulo), "mod", FORMAT_BINARY_OPERATOR},\
	{{(VF)r_rr_permutation, (VF)c_cr_permutation, (VF)c_cc_permutation, (VF)q_qq_permutation,  (VF)q_qq_permutation, (VF)q_qq_permutation, (VF)q_qq_permutation, (VF)q_qq_permutation, (VF)q_qq_permutation}, "permutation", FORMAT_BINARY_FUNCTION},\
	{{(VF)r_rr_combination, (VF)c_cr_combination, (VF)c_cc_combination, (VF)q_qq_combination,  (VF)q_qq_combination, (VF)q_qq_combination, (VF)q_qq_combination, (VF)q_qq_combination, (VF)q_qq_combination}, "permutation", FORMAT_BINARY_FUNCTION},\
	BFMAP(atan),\
	{{(VF)r_rr_random, (VF)c_cr_random, (VF)c_cc_random, (VF)q_qq_random,  (VF)q_qq_random, (VF)q_qq_random, (VF)q_qq_random, (VF)q_qq_random, (VF)q_qq_random}, "rand", FORMAT_BINARY_FUNCTION},\
	{{(VF)c_rr_hankel1,  (VF)c_rr_hankel1, (VF)c_rr_hankel1, (VF)c_rr_hankel1, (VF)c_rr_hankel1, (VF)c_rr_hankel1, (VF)c_rr_hankel1, (VF)c_rr_hankel1, (VF)c_rr_hankel1}, "hankel1", FORMAT_BINARY_FUNCTION},\
	{BFNAMES_R(sqwv), "sqwv", FORMAT_BINARY_FUNCTION},\
	{{(VF)r_rr_trwv, (VF)r_rc_trwv, (VF)r_rq_trwv, (VF)r_cr_trwv, (VF)r_cc_trwv, (VF)r_cq_trwv, (VF)r_qr_trwv, (VF)r_qc_trwv, (VF)r_qq_trwv}, "trwv", FORMAT_BINARY_FUNCTION},\
	{{(VF)r_rr_saw, (VF)r_rc_saw, (VF)r_rq_saw, (VF)r_cr_saw, (VF)r_cc_saw, (VF)r_cq_saw, (VF)r_qr_saw, (VF)r_qc_saw, (VF)r_qq_saw}, "saw", FORMAT_BINARY_FUNCTION},\
	{{(VF)r_rr_hypot,  (VF)r_rr_hypot, (VF)r_rr_hypot, (VF)r_rr_hypot, (VF)r_rr_hypot, (VF)r_rr_hypot, (VF)r_rr_hypot, (VF)r_rr_hypot, (VF)r_rr_hypot}, "hypot", FORMAT_BINARY_FUNCTION},\
	{{(VF)r_rr_mandelbrot, (VF)r_cr_mandelbrot,   (VF)r_cr_mandelbrot, (VF)r_cr_mandelbrot, (VF)r_cr_mandelbrot, (VF)r_cr_mandelbrot, (VF)r_cr_mandelbrot, (VF)r_cr_mandelbrot, (VF)r_cr_mandelbrot}, "mandelbrot", FORMAT_BINARY_FUNCTION},\
	{{(VF)r_rr_min, (VF)c_cc_min, (VF)q_qq_min,   (VF)q_qq_min, (VF)q_qq_min, (VF)q_qq_min, (VF)q_qq_min, (VF)q_qq_min, (VF)q_qq_min}, "min", FORMAT_BINARY_FUNCTION},\
	{{(VF)r_rr_max, (VF)c_cc_max, (VF)q_qq_max,   (VF)q_qq_max, (VF)q_qq_max, (VF)q_qq_max, (VF)q_qq_max, (VF)q_qq_max, (VF)q_qq_max}, "max", FORMAT_BINARY_FUNCTION},\
	{{(VF)r_rr_conditional_110, (VF)c_rc_conditional_110, (VF)q_rq_conditional_110, (VF)r_cr_conditional_110, (VF)c_cc_conditional_110, (VF)q_cq_conditional_110, (VF)r_qr_conditional_110, (VF)c_qc_conditional_110, (VF)q_qq_conditional_110}, "x?y:0", FORMAT_BINARY_FUNCTION},\
	{{(VF)r_rr_conditional_101, (VF)c_rc_conditional_101, (VF)q_rq_conditional_101, (VF)r_cr_conditional_101, (VF)c_cc_conditional_101, (VF)q_cq_conditional_101, (VF)r_qr_conditional_101, (VF)c_qc_conditional_101, (VF)q_qq_conditional_101}, "x?0:y", FORMAT_BINARY_FUNCTION},\
}
#define		FP2STR_BODY		\
const int\
	nuOps=sizeof(umap)/sizeof(UnaryFunctionNameMap),\
	nbOps=sizeof(bmap)/sizeof(BinaryFunctionNameMap);\
if(is_binary)\
{\
	for(int k=0;k<nbOps;++k)\
	{\
		auto &row=bmap[k];\
		for(int k2=0;k2<9;++k2)\
		{\
			if((VF)fp==row.func[k2])\
			{\
				fmt=row.format;\
				return row.name;\
			}\
		}\
	}\
}\
else\
{\
	for(int k=0;k<nuOps;++k)\
	{\
		auto &row=umap[k];\
		for(int k2=0;k2<3;++k2)\
		{\
			if((VF)fp==row.func[k2])\
			{\
				fmt=row.format;\
				return row.name;\
			}\
		}\
	}\
}\
fmt=FORMAT_INSTRUCTION;\
return "???";
const char*	fp2str(void (*fp)(), bool is_binary, int &fmt)
{
	using namespace G2;
	UMAP_DECLARATION;
	BMAP_DECLARATION;
	FP2STR_BODY;//how to debug this?
	//const int
	//	nuOps=sizeof(umap)/sizeof(UnaryFunctionNameMap),//number of unary operations
	//	nbOps=sizeof(bmap)/sizeof(BinaryFunctionNameMap);//number of binary operations
	//if(is_binary)
	//{
	//	for(int k=0;k<nbOps;++k)
	//	{
	//		auto &row=bmap[k];
	//		for(int k2=0;k2<9;++k2)
	//		{
	//			if((void*)fp==row.func[k2])
	//			{
	//				fmt=row.format;
	//				return row.name;
	//			}
	//		}
	//	}
	//}
	//else
	//{
	//	for(int k=0;k<nuOps;++k)
	//	{
	//		auto &row=umap[k];
	//		for(int k2=0;k2<3;++k2)
	//		{
	//			if((void*)fp==row.func[k2])
	//			{
	//				fmt=row.format;
	//				return row.name;
	//			}
	//		}
	//	}
	//}
	//fmt=FORMAT_INSTRUCTION;
	//return "???";
}
const char*	mp_fp2str(void (*fp)(), bool is_binary, int &fmt)
{
	using namespace MP;
	UMAP_DECLARATION;
	BMAP_DECLARATION;
	FP2STR_BODY;
}
#undef		UFNAMES
#undef		UFNAMES_R
#undef		UFMAP
#undef		BFNAMES
#undef		BFNAMES_R
#undef		BFMAP
#undef		UMAP_DECLARATION
#undef		BMAP_DECLARATION
typedef		const char* (*FP2STR_FN)(void (*fp)(), bool is_binary, int &fmt);
#endif
void print_term(std::stringstream &LOL_1, Expression const &ex, int idx)
{
	if(idx>=(int)ex.n.size())
	{
	//	LOL_1<<'['<<idx<<"]>>OOB<<";
		LOL_1<<'['<<idx<<"]OOB";
		return;
	}
	auto &n=ex.n[idx];
	if(n.constant)
	{
		LOL_1<<'['<<idx<<']';
		int offset=0;
		auto &val=ex.data[idx];
		LOL_1<<'(';
		val.print(g_buf, offset, n.mathSet);
		g_buf[offset]='\0';
		LOL_1<<g_buf<<')';
	}
	else if(n.varNo>=0&&n.varNo<(int)ex.variables.size())
	{
		LOL_1<<'['<<idx<<']';
		auto &var=ex.variables[n.varNo];
		LOL_1<<var.name;
	}
	else//temp var
		LOL_1<<'['<<idx<<n.mathSet<<']';
}
template<typename In>inline void instr2str(Expression const &ex, int i, In const &in, void (*fp)(), std::stringstream &LOL_1, FP2STR_FN fp2str_fn)
{
	const char space=' ';
	using namespace G2;
	LOL_1<<i<<'\t';
	switch(in.type)
	{
	case 'c':
		LOL_1<<"call "<<in.op1<<" -> ";
		print_term(LOL_1, ex, in.result);
	//	LOL_1<<"call "<<in.op1<<" -> "<<in.result;
		break;
	case 'b':
		LOL_1<<"bif ";
		print_term(LOL_1, ex, in.op1);
		LOL_1<<" to "<<in.result;
	//	LOL_1<<"bif "<<in.op1<<" to "<<in.result;
		break;
	case 'B':
		LOL_1<<"bin ";
		print_term(LOL_1, ex, in.op1);
		LOL_1<<" to "<<in.result;
	//	LOL_1<<"bin "<<in.op1<<" to "<<in.result;
		break;
	case 'j':LOL_1<<"j "<<in.result;break;
	case 'r':
		LOL_1<<"r ";
		print_term(LOL_1, ex, in.result);
	//	LOL_1<<"r "<<in.result;
		break;
	case 1:case 2:case 3:case 13:case 14:case 15:case 16://unary operator/function
	case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 17:case 18:case 19:case 20:case 21:case 22:case 23:case 24:case 25:case 26://binary operator/function
		{
			int fmt=FORMAT_INSTRUCTION;
			const char *oplabel=fp2str_fn(fp, in.is_binary(), fmt);
			switch(fmt)
			{
			case FORMAT_INSTRUCTION:
				print_term(LOL_1, ex, in.result);
				LOL_1<<" = "<<oplabel<<space;
				print_term(LOL_1, ex, in.op1);
				if(in.is_binary())
				{
					LOL_1<<space;
					print_term(LOL_1, ex, in.op2);
				}
				break;
			case FORMAT_UNARY_OPERATOR_LEFT:
				print_term(LOL_1, ex, in.result);
				LOL_1<<" = "<<oplabel<<space;
				print_term(LOL_1, ex, in.op1);
				break;
			case FORMAT_UNARY_OPERATOR_RIGHT:
				print_term(LOL_1, ex, in.result);
				LOL_1<<" = ";
				print_term(LOL_1, ex, in.op1);
				LOL_1<<space<<oplabel;
				break;
			case FORMAT_BINARY_OPERATOR:
				print_term(LOL_1, ex, in.result);
				LOL_1<<" = ";
				print_term(LOL_1, ex, in.op1);
				LOL_1<<space<<oplabel<<space;
				print_term(LOL_1, ex, in.op2);
				break;
			case FORMAT_UNARY_FUNCTION:
				print_term(LOL_1, ex, in.result);
				LOL_1<<" = "<<oplabel<<'(';
				print_term(LOL_1, ex, in.op1);
				LOL_1<<')';
				break;
			case FORMAT_BINARY_FUNCTION:
				print_term(LOL_1, ex, in.result);
				LOL_1<<" = "<<oplabel<<'(';
				print_term(LOL_1, ex, in.op1);
				LOL_1<<", ";
				print_term(LOL_1, ex, in.op2);
				LOL_1<<')';
				break;
			}
		}
		break;
	case 27:
		LOL_1<<in.result<<in.r_ms<<' '<<in.op1<<in.op1_ms<<' '<<in.op2<<in.op2_ms<<' '<<in.op3<<in.op3_ms;
		break;
	}
	LOL_1<<"\r\n";
}
void expr2str(Expression const &ex, std::string &str, bool mp_instructions=false)
{
	const char space=' ';
	std::stringstream LOL_1;
	LOL_1<<"LINE "<<ex.lineNo<<":\r\n";
	for(int kn=0, knEnd=ex.n.size();kn<knEnd;++kn)//print initial memory
	{
		auto &n=ex.n[kn];
		auto &val=ex.data[kn];
		LOL_1<<kn<<'\t'<<n.mathSet<<'\t';
		if(kn<ex.nArgs)
			LOL_1<<"arg ";
		if(n.constant)
			LOL_1<<"const\t\t";
		else if(n.varNo>=0&&n.varNo<(int)ex.variables.size())
			LOL_1<<"var "<<n.varNo<<space<<ex.variables[n.varNo].name<<'\t';
		else
			LOL_1<<"temp\t\t";
		int offset=0;
		val.print(g_buf, offset, n.mathSet);
		LOL_1<<g_buf<<"\r\n";
	//	LOL_1<<val.r<<'+'<<val.i<<"i+"<<val.j<<"j+"<<val.k<<"k\r\n";
	}
	LOL_1<<"\topcode result operand1 [operand2]\r\n";
//	LOL_1<<"\r\n";
	if(mp_instructions)
	{
		for(int i=0, nInstr=ex.ni.size();i<nInstr;++i)
		{
			auto &in=ex.ni[i];
			instr2str(ex, i, in, (void(*)())in.fp.uf, LOL_1, mp_fp2str);
		}
	}
	else
	{
		for(int i=0, nInstr=ex.i.size();i<nInstr;++i)//print instructions
		{
			auto &in=ex.i[i];
			instr2str(ex, i, in, (void(*)())in.ia32.r_r, LOL_1, fp2str);
		}
	}
	str+=LOL_1.str();
}
void all_to_clipboard(bool mp_instructions=false)
{
	std::string str;
	if(userFunctionDefinitions.size())
	{
		str+="FUNCTIONS:\r\n";
		for(int k=0, kEnd=userFunctionDefinitions.size();k<kEnd;++k)
			expr2str(userFunctionDefinitions[k], str);
	}
	if(expr.size())
	{
		if(str.size())
			str+="EXPRESSIONS:\r\n";
		for(int k=0, kEnd=expr.size();k<kEnd;++k)
			expr2str(expr[k], str);
	}
	if(str.size())
		copy_to_clipboard(str.c_str(), str.size());
}
void expression_to_clipboard(Expression const &ex, bool mp_instructions=false)
{
	std::string str;
	expr2str(ex, str, mp_instructions);
	copy_to_clipboard(str);
}
void func_data_to_clipboard(std::vector<Value> &fData)
{
	std::stringstream LOL_1;
	for(unsigned k=0;k<fData.size();++k)
	{
		auto &v=fData[k];
		LOL_1<<k<<'\t'<<v.r<<'+'<<v.i<<"i+"<<v.j<<"j+"<<v.k<<"k\r\n";
	}
	copy_to_clipboard(LOL_1.str());
}
void map_to_clipboard(std::vector<Map> const &m)
{
	std::stringstream LOL_1;
	LOL_1<<"Map:\r\n";
	for(int k=0;k<(int)m.size();++k)
	{
		using namespace G2;
		const char *a=nullptr;
		switch(m[k]._0)
		{
		//label case
#define	LC(name)	case name:a=#name;break;
		LC(M_IGNORED)
		LC(M_N)
		LC(M_LPR) LC(M_RPR)
		LC(M_COMMA)
		LC(M_QUESTION_MARK) LC(M_COLON)

			LC(M_PROCEDURAL_START)
		LC(M_IF) LC(M_ELSE) LC(M_FOR) LC(M_DO) LC(M_WHILE)
		LC(M_CONTINUE) LC(M_BREAK) LC(M_RETURN)
		LC(M_LBRACE) LC(M_RBRACE)
		LC(M_SEMICOLON)

			LC(M_PROCEDURAL_ASSIGN_START)
		LC(M_ASSIGN) LC(M_ASSIGN_MULTIPLY) LC(M_ASSIGN_DIVIDE) LC(M_ASSIGN_MOD)
		LC(M_ASSIGN_PLUS) LC(M_ASSIGN_MINUS) LC(M_ASSIGN_LEFT) LC(M_ASSIGN_RIGHT)
		LC(M_ASSIGN_AND) LC(M_ASSIGN_XOR) LC(M_ASSIGN_OR)
			LC(M_PROCEDURAL_ASSIGN_END)

			LC(M_PROCEDURAL_END)

		LC(M_INCREMENT) LC(M_DECREMENT)
		LC(M_FACTORIAL_LOGIC_NOT)
		LC(M_MODULO_PERCENT)
		LC(M_BITWISE_NOT)
		LC(M_PENTATE)
		LC(M_TETRATE)
		LC(M_POWER) LC(M_POWER_REAL)
		LC(M_MULTIPLY) LC(M_DIVIDE) LC(M_LOGIC_DIVIDES)
		LC(M_PLUS) LC(M_MINUS)
		LC(M_BITWISE_SHIFT_LEFT) LC(M_BITWISE_SHIFT_RIGHT)
		LC(M_LOGIC_LESS) LC(M_LOGIC_LESS_EQUAL) LC(M_LOGIC_GREATER) LC(M_LOGIC_GREATER_EQUAL)
		LC(M_LOGIC_EQUAL) LC(M_LOGIC_NOT_EQUAL)
		LC(M_BITWISE_AND) LC(M_BITWISE_NAND)
		LC(M_BITWISE_XOR) LC(M_BITWISE_XNOR)
		LC(M_VERTICAL_BAR) LC(M_BITWISE_NOR)
		LC(M_LOGIC_AND)
		LC(M_LOGIC_XOR)
		LC(M_LOGIC_OR)
		LC(M_CONDITION_ZERO)

		LC(M_S_EQUAL_ASSIGN) LC(M_S_NOT_EQUAL)
		LC(M_S_LESS) LC(M_S_LESS_EQUAL) LC(M_S_GREATER) LC(M_S_GREATER_EQUAL)

			LC(M_FSTART)

		LC(M_COS) LC(M_ACOS) LC(M_COSD) LC(M_ACOSD) LC(M_COSH) LC(M_ACOSH) LC(M_COSC)
		LC(M_SEC) LC(M_ASEC) LC(M_SECD) LC(M_ASECD) LC(M_SECH) LC(M_ASECH)
		LC(M_SIN) LC(M_ASIN) LC(M_SIND) LC(M_ASIND) LC(M_SINH) LC(M_ASINH) LC(M_SINC) LC(M_SINHC)
		LC(M_CSC) LC(M_ACSC) LC(M_CSCD) LC(M_ACSCD) LC(M_CSCH) LC(M_ACSCH)
		LC(M_TAN)			 LC(M_TAND)				LC(M_TANH) LC(M_ATANH) LC(M_TANC)
		LC(M_COT) LC(M_ACOT) LC(M_COTD) LC(M_ACOTD) LC(M_COTH) LC(M_ACOTH)
		LC(M_EXP) LC(M_LN) LC(M_SQRT) LC(M_CBRT) LC(M_INVSQRT) LC(M_SQ)
		LC(M_GAUSS) LC(M_ERF) LC(M_FIB) LC(M_ZETA) LC(M_LNGAMMA)
		LC(M_STEP) LC(M_SGN) LC(M_RECT) LC(M_TENT)
		LC(M_CEIL) LC(M_FLOOR) LC(M_ROUND) LC(M_INT) LC(M_FRAC)
		LC(M_ABS) LC(M_ARG) LC(M_REAL) LC(M_IMAG) LC(M_CONJUGATE) LC(M_POLAR) LC(M_CARTESIAN)
		
			LC(M_BFSTART)

		LC(M_RAND)
		LC(M_ATAN) LC(M_ATAND)
		LC(M_LOG)
		LC(M_BETA) LC(M_GAMMA) LC(M_PERMUTATION) LC(M_COMBINATION)
		LC(M_BESSEL_J) LC(M_BESSEL_Y) LC(M_HANKEL1)
		LC(M_SQWV) LC(M_TRWV) LC(M_SAW) LC(M_MANDELBROT)

			LC(M_VFSTART)

		LC(M_CLAMP)
		LC(M_MIN) LC(M_MAX) LC(M_AV) LC(M_HYPOT) LC(M_NORM)

		LC(M_USER_FUNCTION)
#undef	EC
		default:a="???";break;
		}
		LOL_1<<a<<'\t'<<m[k]._1<<"\r\n";
	}
	copy_to_clipboard(LOL_1.str());
}
struct CallInfo
{
	int i;//call address		index in instructions vector
	Expression *func;

	std::vector<Value> fData;
	CallInfo(Expression *func, int i):func(func), i(i){}
};
struct Solve_UserFunction
{
	Expression &expr;
	Instruction &in;
	bool operate_on_const;
	Solve_UserFunction(Expression &expr, Instruction &in, bool operate_on_const):expr(expr), in(in), operate_on_const(operate_on_const){}
	void operator()(int v)const
	{
		auto func=&userFunctionDefinitions[in.op1];
		std::vector<Value> fData(func->data.size());
		{
			int k=0;
			if(operate_on_const)
			{
				for(int kEnd=in.args.size();k<kEnd;++k)//copy args
					fData[k]=expr.data[in.args[k].idx];
			}
			else
			{
				for(int kEnd=in.args.size();k<kEnd;++k)//copy args
				{
					auto &n=expr.n[in.args[k].idx];
					//if(v>=n.r.size()<<1||n.mathSet=='c'&&v>=n.i.size()<<1)//
					//	int LOL_1=0;
					auto &dk=fData[k];
					dk.r=n.r[v];
					if(n.mathSet>='c')
					{
						dk.i=n.i[v];
						if(n.mathSet=='h')
						{
							dk.j=n.j[v];
							dk.k=n.k[v];
						}
					}
				}
			}
			for(int kEnd=func->data.size();k<kEnd;++k)//initialize const data
				fData[k]=func->data[k];
		}
		int startTime=clock(), expiryTime=startTime+userFunctionTimeLimit, offset=(startTime>0&&expiryTime<0)*userFunctionTimeLimit;
		std::stack<CallInfo> callStack;
		for(int i2=0, nInstr=func->i.size();;)
		{
			if(i2>=nInstr)//return nothing	unreachable
			{
				if(callStack.size())
				{
					auto &cst=callStack.top();
					func=cst.func;
					i2=cst.i, nInstr=func->i.size();
					cst.fData[func->i[i2].result].setzero();
				//	cst.fData[func->i[i2].result]=fData[0];//
					std::swap(cst.fData, fData);
					callStack.pop();
					continue;
				}
				if(operate_on_const)
					expr.data[in.result].setzero();
				else
					expr.n[in.result].assign(v, Value());
				break;
			}
			if(clock()+offset>expiryTime)
			{
				func->functionStuck=true;//mark function
			
				//return nan
				if(callStack.size())
				{
					auto &cst=callStack.top();
					func=cst.func;
					i2=cst.i, nInstr=func->i.size();
					cst.fData[func->i[i2].result]=G2::_qnan;
					std::swap(cst.fData, fData);
					callStack.pop();
					++i2;
					continue;
				}
				if(operate_on_const)
					expr.data[in.result].setnan();
				//	expr.data[in.result]=G2::_qnan;
				else
					expr.n[in.result].assign(v, G2::_qnan);
				break;
			}
			auto &in2=func->i[i2];
		//	func_data_to_clipboard(fData);
			VectP rr;
			CompP cr;
			QuatP qr;
			switch(in2.r_ms)//call, jump, branch & return don't initialize result pointers
			{
			case 'R':
				rr.set(&fData[in2.result].r);
				break;
			case 'c':
				{
					auto &res=fData[in2.result];
					cr.set(&res.r, &res.i);
				}
				break;
			case 'h':
				{
					auto &res=fData[in2.result];
					qr.set(&res.r, &res.i, &res.j, &res.k);
				}
				break;
			}
			switch(in2.type)
			{
			case SIG_CALL://call user function
				if(markFunctionsStuck&&userFunctionDefinitions[in2.op1].functionStuck)//return nan without call
				{
					fData[in2.result]=G2::_qnan;
					++i2;
				}
				else
				{
					callStack.push(CallInfo(func, i2));
					auto &cst=callStack.top();
					cst.fData=std::move(fData);
				//	func=in2.function;
					func=&userFunctionDefinitions[in2.op1], i2=0, nInstr=func->i.size();
					fData.resize(func->data.size());
					{
						int k=0;
						for(int kEnd=in2.args.size();k<kEnd;++k)//copy args
							fData[k]=cst.fData[in2.args[k].idx];
						for(int kEnd=func->data.size();k<kEnd;++k)//initialize const data
							fData[k]=func->data[k];
					}
				}
				continue;
			case SIG_BIF://branch if
				if(fData[in2.op1].q_isTrue())
					i2=in2.result;
				else
					++i2;
				continue;
			case SIG_BIN://branch if not
				if(!fData[in2.op1].q_isTrue())
					i2=in2.result;
				else
					++i2;
				continue;
			case SIG_JUMP://jump
				i2=in2.result;
				continue;
			case SIG_RETURN://return
				if(callStack.size())
				{
					auto &cst=callStack.top();
					func=cst.func;
					i2=cst.i, nInstr=func->i.size();
					cst.fData[func->i[i2].result]=fData[in2.result];
					std::swap(cst.fData, fData);
					callStack.pop();
					++i2;
					continue;
				}
				if(operate_on_const)
					expr.data[in.result]=fData[in2.result];
				else
					expr.n[in.result].assign(v, fData[in2.result], func->resultMathSet);
				break;
			//case -1://unused
			//	fData[in2.result].setzero();
			//	++i2;
			//	continue;
			case SIG_R_R://r_r
				{
				//	VectP r(&fData[in2.result].r);
					in2.ia32.r_r(rr, VectP(&fData[in2.op1].r));
					++i2;
				}
				continue;
			case SIG_C_C://c_c
				{
					auto &res=fData[in2.result], &op1=fData[in2.op1];
				//	CompP r(&res.r, &res.i);
					in2.ia32.c_c(cr, CompP(&op1.r, &op1.i));
					++i2;
				}
				continue;
			case SIG_Q_Q://q_q
				{
					auto &res=fData[in2.result], &op1=fData[in2.op1];
				//	QuatP r(&res.r, &res.i, &res.j, &res.k);
					in2.ia32.q_q(qr, QuatP(&op1.r, &op1.i, &op1.j, &op1.k));
					++i2;
				}
				continue;
			case SIG_R_RR://r_rr
				{
					auto &res=fData[in2.result], &op1=fData[in2.op1], &op2=fData[in2.op2];
				//	VectP r(&res.r);
					in2.ia32.r_rr(rr, VectP(&op1.r), VectP(&op2.r));
					++i2;
				}
				continue;
			case SIG_C_RC://c_rc
				{
					auto &res=fData[in2.result], &op1=fData[in2.op1], &op2=fData[in2.op2];
				//	CompP r(&res.r, &res.i);
					in2.ia32.c_rc(cr, VectP(&op1.r), CompP(&op2.r, &op2.i));
					++i2;
				}
				continue;
			case SIG_Q_RQ://q_rq
				{
					auto &res=fData[in2.result], &op1=fData[in2.op1], &op2=fData[in2.op2];
				//	QuatP r(&res.r, &res.i, &res.j, &res.k);
					in2.ia32.q_rq(qr, VectP(&op1.r), QuatP(&op2.r, &op2.i, &op2.j, &op2.k));
					++i2;
				}
				continue;
			case SIG_C_CR://c_cr
				{
					auto &res=fData[in2.result], &op1=fData[in2.op1], &op2=fData[in2.op2];
				//	CompP r(&res.r, &res.i);
					in2.ia32.c_cr(cr, CompP(&op1.r, &op1.i), VectP(&op2.r));
					++i2;
				}
				continue;
			case SIG_C_CC://c_cc
				{
					auto &res=fData[in2.result], &op1=fData[in2.op1], &op2=fData[in2.op2];
				//	CompP r(&res.r, &res.i)
					in2.ia32.c_cc(cr, CompP(&op1.r, &op1.i), CompP(&op2.r, &op2.i));
					++i2;
				}
				continue;
			case SIG_Q_CQ://q_cq
				{
					auto &res=fData[in2.result], &op1=fData[in2.op1], &op2=fData[in2.op2];
				//	QuatP r(&res.r, &res.i, &res.j, &res.k);
					in2.ia32.q_cq(qr, CompP(&op1.r, &op1.i), QuatP(&op2.r, &op2.i, &op2.j, &op2.k));
					++i2;
				}
				continue;
			case SIG_Q_QR://q_qr
				{
					auto &res=fData[in2.result], &op1=fData[in2.op1], &op2=fData[in2.op2];
				//	QuatP r(&res.r, &res.i, &res.j, &res.k);
					in2.ia32.q_qr(qr, QuatP(&op1.r, &op1.i, &op1.j, &op1.k), VectP(&op2.r));
					++i2;
				}
				continue;
			case SIG_Q_QC://q_qc
				{
					auto &res=fData[in2.result], &op1=fData[in2.op1], &op2=fData[in2.op2];
				//	QuatP r(&res.r, &res.i, &res.j, &res.k);
					in2.ia32.q_qc(qr, QuatP(&op1.r, &op1.i, &op1.j, &op1.k), CompP(&op2.r, &op2.i));
					++i2;
				}
				continue;
			case SIG_Q_QQ://q_qq
				{
					auto &res=fData[in2.result], &op1=fData[in2.op1], &op2=fData[in2.op2];
				//	QuatP r(&res.r, &res.i, &res.j, &res.k);
					in2.ia32.q_qq(qr, QuatP(&op1.r, &op1.i, &op1.j, &op1.k), QuatP(&op2.r, &op2.i, &op2.j, &op2.k));
					++i2;
				}
				continue;

			case SIG_C_R://c_r
				{
					auto &res=fData[in2.result], &op1=fData[in2.op1];
				//	CompP r(&res.r, &res.i);
					in2.ia32.c_r(cr, VectP(&op1.r));
					++i2;
				}
				continue;
			case SIG_C_Q://c_q
				{
					auto &res=fData[in2.result], &op1=fData[in2.op1];
				//	CompP r(&res.r, &res.i);
					in2.ia32.c_q(cr, QuatP(&op1.r, &op1.i, &op1.j, &op1.k));
					++i2;
				}
				continue;

			case SIG_R_C://r_c
				{
					auto &res=fData[in2.result], &op1=fData[in2.op1];
				//	VectP r(&res.r);
					in2.ia32.r_c(rr, CompP(&op1.r, &op1.i));
					++i2;
				}
				continue;
			case SIG_R_Q://r_q
				{
					auto &res=fData[in2.result], &op1=fData[in2.op1];
				//	VectP r(&res.r);
					in2.ia32.r_q(rr, QuatP(&op1.r, &op1.i, &op1.j, &op1.k));
					++i2;
				}
				continue;

			case SIG_C_RR://c_rr
				{
					auto &res=fData[in2.result], &op1=fData[in2.op1], &op2=fData[in2.op2];
				//	CompP r(&res.r, &res.i);
					in2.ia32.c_rr(cr, VectP(&op1.r), VectP(&op2.r));
					++i2;
				}
				continue;

			case SIG_R_RC://r_rc
				{
					auto &res=fData[in2.result], &op1=fData[in2.op1], &op2=fData[in2.op2];
				//	VectP r(&res.r);
					in2.ia32.r_rc(rr, VectP(&op1.r), CompP(&op2.r, &op2.i));
					++i2;
				}
				continue;
			case SIG_R_RQ://r_rq
				{
					auto &res=fData[in2.result], &op1=fData[in2.op1], &op2=fData[in2.op2];
				//	VectP r(&res.r);
					in2.ia32.r_rq(rr, VectP(&op1.r), QuatP(&op2.r, &op2.i, &op2.j, &op2.k));
					++i2;
				}
				continue;
			case SIG_R_CR://r_cr
				{
					auto &res=fData[in2.result], &op1=fData[in2.op1], &op2=fData[in2.op2];
				//	VectP r(&res.r);
					in2.ia32.r_cr(rr, CompP(&op1.r, &op1.i), VectP(&op2.r));
					++i2;
				}
				continue;
			case SIG_R_CC://r_cc
				{
					auto &res=fData[in2.result], &op1=fData[in2.op1], &op2=fData[in2.op2];
				//	VectP r(&res.r);
					in2.ia32.r_cc(rr, CompP(&op1.r, &op1.i), CompP(&op2.r, &op2.i));
					++i2;
				}
				continue;
			case SIG_R_CQ://r_cq
				{
					auto &res=fData[in2.result], &op1=fData[in2.op1], &op2=fData[in2.op2];
				//	VectP r(&res.r);
					in2.ia32.r_cq(rr, CompP(&op1.r, &op1.i), QuatP(&op2.r, &op2.i, &op2.j, &op2.k));
					++i2;
				}
				continue;
			case SIG_R_QR://r_qr
				{
					auto &res=fData[in2.result], &op1=fData[in2.op1], &op2=fData[in2.op2];
				//	VectP r(&res.r);
					in2.ia32.r_qr(rr, QuatP(&op1.r, &op1.i, &op1.j, &op1.k), &op2.r);
					++i2;
				}
				continue;
			case SIG_R_QC://r_qc
				{
					auto &res=fData[in2.result], &op1=fData[in2.op1], &op2=fData[in2.op2];
				//	VectP r(&res.r);
					in2.ia32.r_qc(rr, QuatP(&op1.r, &op1.i, &op1.j, &op1.k), CompP(&op2.r, &op2.i));
					++i2;
				}
				continue;
			case SIG_R_QQ://r_qq
				{
					auto &res=fData[in2.result], &op1=fData[in2.op1], &op2=fData[in2.op2];
				//	VectP r(&res.r);
					in2.ia32.r_qq(rr, QuatP(&op1.r, &op1.i, &op1.j, &op1.k), QuatP(&op2.r, &op2.i, &op2.j, &op2.k));
					++i2;
				}
				continue;
				
			case SIG_C_QC://c_qc
				{
					auto &res=fData[in2.result], &op1=fData[in2.op1], &op2=fData[in2.op2];
				//	CompP r(&res.r, &res.i);
					in2.ia32.c_qc(cr, QuatP(&op1.r, &op1.i, &op1.j, &op1.k), CompP(&op2.r, &op2.i));
					++i2;
				}
				continue;

			case SIG_INLINE_IF://a ? b : c
				{
					auto &res=fData[in2.result], &op1=fData[in2.op1], &op2=fData[in2.op2], &op3=fData[in2.op3];
					char r_ms=maximum(in2.op2_ms, in2.op3_ms), op_ms=(in2.op2_ms=='c')+2*(in2.op2_ms=='h')+3*(in2.op3_ms=='c')+6*(in2.op3_ms=='h');
					switch(op_ms)
					{
					case 0:res.r=op1.r?op2.r:op3.r;break;//r_rr
					case 1:CompP(&res.r, &res.i)				=istrue(Comp1d(op1.r, op1.i))				?Comp1d(op2.r)						:Comp1d(op3.r, op3.i);				break;//c_rc
					case 2:QuatP(&res.r, &res.i, &res.j, &res.k)=istrue(Quat1d(op1.r, op1.i, op1.j, op1.k))	?Quat1d(op2.r)						:Quat1d(op3.r, op3.i, op3.j, op3.k);break;//q_rq
					case 3:CompP(&res.r, &res.i)				=istrue(Comp1d(op1.r, op1.i))				?Comp1d(op2.r, op2.i)				:Comp1d(op3.r);						break;//c_cr
					case 4:CompP(&res.r, &res.i)				=istrue(Comp1d(op1.r, op1.i))				?Comp1d(op2.r, op2.i)				:Comp1d(op3.r, op3.i);				break;//c_cc
					case 5:QuatP(&res.r, &res.i, &res.j, &res.k)=istrue(Quat1d(op1.r, op1.i, op1.j, op1.k))	?Quat1d(op2.r, op2.i)				:Quat1d(op3.r, op3.i, op3.j, op3.k);break;//q_cq
					case 6:QuatP(&res.r, &res.i, &res.j, &res.k)=istrue(Quat1d(op1.r, op1.i, op1.j, op1.k))	?Quat1d(op2.r, op2.i, op2.j, op2.k)	:Quat1d(op3.r);						break;//q_qr
					case 7:QuatP(&res.r, &res.i, &res.j, &res.k)=istrue(Quat1d(op1.r, op1.i, op1.j, op1.k))	?Quat1d(op2.r, op2.i, op2.j, op2.k)	:Quat1d(op3.r, op3.i);				break;//q_qc
					case 8:QuatP(&res.r, &res.i, &res.j, &res.k)=istrue(Quat1d(op1.r, op1.i, op1.j, op1.k))	?Quat1d(op2.r, op2.i, op2.j, op2.k)	:Quat1d(op3.r, op3.i, op3.j, op3.k);break;//q_qq
					}
				}
				++i2;
				continue;

			case SIG_VA:
				in2.ia32.vf(nullptr, &expr.n, ArgIdx(in2.result, in2.r_ms), in2.args, 0);
				++i2;
				break;
			}
			break;
		}
	}
};
bool inline_if_default_true=true;
bool verticalBarAbs=false;
bool const omitExprWithUnexpectedCommas=false;
class		Compile
{
	static char const *precedence;
	static int const nOperators;
	static char *ub;
	static struct CompileTerm
	{
		bool constant, fresh;
		char mathSet;
		CompileTerm(bool constant, char mathSet, bool fresh=true):constant(constant), mathSet(mathSet), fresh(fresh){}
	} *term;
	static int bi_mass		(int);
	static int prec_convert	(int);
	static char prec		(int, char, int, char);
	static int default_overload(int);

	static void compile_instruction_f_def	(int);
	static void compile_instruction_select_u(int, char, char, FPSetter&, int&, DiscontinuityFunction&, int&, int&);
	static void compile_instruction_select_b(int, char, char, FPSetter&, int&, DiscontinuityFunction&, int&, int&);
	//static void compile_instruction_select_u(int, char, char, FPSetter&, char (*&)(char), DiscontinuityFunction&);
	//static void compile_instruction_select_b(int, char, char, FPSetter&, char (*&)(char, char), DiscontinuityFunction&);
	//static void compile_instruction_select_u(int, char, char, FPSetter&, MP::FPSetter&, char (*&)(char), DiscontinuityFunction&);
	//static void compile_instruction_select_b(int, char, char, FPSetter&, MP::FPSetter&, char (*&)(char, char), DiscontinuityFunction&);
	//static void compile_instruction_select_t(int, char, char, char, FPSetter&, int&, DiscontinuityFunction&, int&, int&);
	static void compile_instruction_select_v(int, FPSetter&, DiscontinuityFunction&, int&, int&);
	static void compile_instruction_u		(int, char, int, bool=false);
	static void compile_instruction_b		(int, int, int, bool=false);
	static void compile_instruction_b2		(int, int, int);
	static void compile_instruction_condition_111	(int, int, int);
	static void compile_instruction_condition_110	(int, int);
	static void compile_instruction_condition_101	(int, int);
	static void compile_instruction_condition_100	(int);
	static void compile_instruction_condition_011	(int, int);
	static void compile_instruction_condition_010	(int);
	static char compile_instruction			(int, char, int=-1, int=-1, int=-1);
	
	static int compile_instruction_userFunctionCall(int, std::vector<ArgIdx>&, bool=false);
	static int compile_instruction_branch_if		(int);
	static int compile_instruction_branch_if_not	(int);
	static int compile_instruction_jump				();
	static int compile_instruction_return			(int);
	static int compile_instruction_return			(Value const&);
	static void compile_instruction_assign			(int, int);
	static void compile_instruction_assign_value	(int, Value const&);

	static void compile_execute				(int, int, int);
	static void compile_abs					(int, int, int);
	static void compile_inline_if			(int, int, int);

	static void compile_assignment			(int, int);
	static void compile_expression_local	(int, int);
	static bool compile_exprStatement		(int&, int);
	static bool comp_seek_allowNewline		(int&, int, int);
	static bool comp_seek_condition			(int&, int, int&, int&);
	static bool comp_seek_forHeader			(int&, int, int&, int&, int&, int&);
	static bool comp_seek_block				(int&, int, int&, int&);

	static std::stack<std::pair<int, std::vector<int>>> loopInfo;//i_loop, i_break[]
	static void compile_statement			(int&, int);
	static void compile_block				(int, int);
public:
	static void compile_function			(Expression&);
	static void compile_expression_global	(Expression&);
	static int expressionResultLogicType();
	static char predictedMathSet;
	static Expression *expr;
	static bool procedural, recursiveFunction;
};
const char		*Compile::precedence=//"uu ub bu bb"	u: unary, b: binary
//<\>	++		!		%		~		p		t		^				*		+		s		c		=		&		#		|		a		x		o		@		f		_
/*++*/	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"_<_<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"
/*!*/	"><><"	">><<"	">><<"	">><<"	">>>>"	">>>>"	">>>>"	"_>_<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"
/*%*/	"><><"	">>>>"	"><><"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"
/*~*/	"><><"	">>>>"	"><><"	"><><"	">>>>"	">>>>"	">>>>"	"_>_<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"
/*p*/	"><><"	">>>>"	"><><"	">>>>"	">>>>"	"<<<<"	"<<<<"	"_>_>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"
/*t*/	"><><"	">>>>"	"><><"	">>>>"	">>>>"	">>>>"	"<<<<"	"_>_>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"
/*^*/	"><><"	">>>>"	"><><"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"
/* */	"__><"	"__>>"	"__><"	"__><"	"__>>"	"__>>"	"__>>"	"___<"	"__<<"	"__<<"	"__<<"	"__<<"	"__<<"	"__<<"	"__<<"	"__<<"	"__<<"	"__<<"	"__<<"	"__<<"	"__<<"	"__<<"
/***/	"><><"	">>>>"	"><><"	"><><"	">>>>"	">>>>"	">>>>"	"_>_>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"
/*+*/	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	"<<>>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	">>>>"	"<<<<"//2^-2*3
/*s*/	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	">>>>"	">>>>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	">>>>"	"<<<<"
/*c*/	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	">>>>"	">>>>"	">>>>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	">>>>"	"<<<<"
/*=*/	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	">>>>"	">>>>"	">>>>"	">>>>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	">>>>"	"<<<<"
/*&*/	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	">>>>"	"<<<<"
/*#*/	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	">>>>"	"<<<<"
/*|*/	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	">>>>"	"<<<<"
/*a*/	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	">>>>"	"<<<<"
/*x*/	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"<<<<"	"<<<<"	"<<<<"	">>>>"	"<<<<"
/*o*/	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"<<<<"	"<<<<"	">>>>"	"<<<<"
/*@*/	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"<<<<"	">>>>"	"<<<<"
/*f*/	">>>>"	">>>>"	"><><"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"	"<<<<"
/*_*/	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"_>_>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	">>>>"	"<<<<";
int const		Compile::nOperators=(int)std::sqrt(std::strlen(Compile::precedence)/4.);
char			*Compile::ub;
Compile::CompileTerm *Compile::term=nullptr;
char			Compile::predictedMathSet;
Expression		*Compile::expr=nullptr;
bool			Compile::procedural=false, Compile::recursiveFunction=false;
int				Compile::bi_mass		(int m)
{
	using namespace G2;
//	if(m>M_FUNCTION_START)																					return  1;
	if(m>M_FSTART)																							return  1;
	switch(m)
	{
	case M_FACTORIAL_LOGIC_NOT:	case M_BITWISE_NOT:case M_DECREMENT:case M_INCREMENT:						return  1;
	case M_PLUS:				case M_MINUS:																return  2;
	case M_BITWISE_AND:			case M_BITWISE_NAND:														return  3;
	case M_BITWISE_XOR:			case M_BITWISE_XNOR:														return  4;
	case M_VERTICAL_BAR:		case M_BITWISE_NOR:															return  5;
	case M_MULTIPLY:			case M_DIVIDE:case M_MODULO_PERCENT:case M_LOGIC_DIVIDES:					return  6;
	case M_BITWISE_SHIFT_LEFT:	case M_BITWISE_SHIFT_RIGHT:													return  7;
	case M_POWER:				case M_POWER_REAL:															return  8;
	case M_TETRATE:																							return  9;
	case M_PENTATE:																							return 10;
	case M_LOGIC_LESS:			case M_LOGIC_LESS_EQUAL:case M_LOGIC_GREATER:case M_LOGIC_GREATER_EQUAL:	return 11;
	case M_LOGIC_EQUAL:			case M_LOGIC_NOT_EQUAL:														return 12;
	case M_LOGIC_AND:																						return 13;
	case M_LOGIC_XOR:																						return 14;
	case M_LOGIC_OR:																						return 15;
	case M_CONDITION_ZERO:																					return 16;
	case M_S_EQUAL_ASSIGN:		case M_S_LESS:case M_S_LESS_EQUAL:case M_S_GREATER:case M_S_GREATER_EQUAL:	return 17;
	}
																											return -1;
}
int				Compile::prec_convert	(int m)
{
	using namespace G2;
	switch(m)
	{
	case M_DECREMENT:case M_INCREMENT:																		return  0;
	case M_FACTORIAL_LOGIC_NOT:																				return  1;
	case M_MODULO_PERCENT:																					return  2;
	case M_BITWISE_NOT:																						return  3;
	case M_PENTATE:																							return  4;
	case M_TETRATE:																							return  5;
	case M_POWER:case M_POWER_REAL:																			return  6;
	case M_N:																								return  7;
	case M_MULTIPLY:case M_DIVIDE:																			return  8;
	case M_PLUS:case M_MINUS:																				return  9;
	case M_BITWISE_SHIFT_LEFT:	case M_BITWISE_SHIFT_RIGHT:													return 10;
	case M_LOGIC_LESS:			case M_LOGIC_LESS_EQUAL:case M_LOGIC_GREATER:case M_LOGIC_GREATER_EQUAL:	return 11;
	case M_LOGIC_EQUAL:			case M_LOGIC_NOT_EQUAL:														return 12;
	case M_BITWISE_AND:			case M_BITWISE_NAND:														return 13;
	case M_BITWISE_XOR:			case M_BITWISE_XNOR:														return 14;
	case M_VERTICAL_BAR:		case M_BITWISE_NOR:															return 15;
	case M_LOGIC_AND:																						return 16;
	case M_LOGIC_XOR:																						return 17;
	case M_LOGIC_OR:																						return 18;
	case M_CONDITION_ZERO:																					return 19;
	case M_S_EQUAL_ASSIGN:		case M_S_LESS:case M_S_LESS_EQUAL:case M_S_GREATER:case M_S_GREATER_EQUAL:	return 21;
	}
//	if(m>M_FUNCTION_START)																					return 20;
	if(m>M_FSTART)																							return 20;
																											return 0;
																											//return -1;//stuck
}
char			Compile::prec			(int lop, char lub, int rop, char rub){return precedence[((nOperators*prec_convert(lop)+prec_convert(rop))<<2)|((lub=='b')<<1)|(rub=='b')];}
void			Compile::compile_instruction_f_def		(int f)
{
	using namespace G2;
	Value x;
	VectP r(&x.r);
	CompP c(&x.r, &x.i);
	bool complex=false;
	switch(expr->m[f]._0)
	{
	case M_REAL:		r_c_real(r, c);		complex=true;	break;
	case M_IMAG:		r_c_imag(r, c);		complex=true;	break;
	case M_COS:			r_r_cos(r, r);						break;
	case M_ACOS:		c_c_acos(c, c);		complex=true;	break;
	case M_COSD:		r_r_cosd(r, r);						break;
	case M_ACOSD:		c_c_acosd(c, c);	complex=true;	break;
	case M_COSH:		r_r_cosh(r, r);						break;
	case M_ACOSH:		c_c_acosh(c, c);	complex=true;	break;
	case M_COSC:		x.r=_HUGE;							break;//potential divide by zero
	case M_SEC:			r_r_sec(r, r);						break;
	case M_ASEC:		c_c_asec(c, c);		complex=true;	break;
	case M_SECD:		r_r_secd(r, r);						break;
	case M_ASECD:		c_c_asecd(c, c);	complex=true;	break;
	case M_SECH:		r_r_sech(r, r);						break;
	case M_ASECH:		c_c_asech(c, c);	complex=true;	break;
	case M_SIN:			r_r_sin(r, r);						break;
	case M_ASIN:		c_c_asin(c, c);		complex=true;	break;
	case M_SIND:		r_r_sind(r, r);						break;
	case M_ASIND:		c_c_asind(c, c);	complex=true;	break;
	case M_SINH:		r_r_sinh(r, r);						break;
	case M_ASINH:		r_r_asinh(r, r);					break;
	case M_SINC:		r_r_sinc(r, r);						break;
	case M_SINHC:		r_r_sinhc(r, r);					break;
	case M_CSC:			r_r_csc(r, r);						break;
	case M_ACSC:		c_c_acsc(c, c);		complex=true;	break;
	case M_CSCD:		r_r_cscd(r, r);						break;
	case M_ACSCD:		c_c_acscd(c, c);	complex=true;	break;
	case M_CSCH:		r_r_csch(r, r);						break;
	case M_ACSCH:		r_r_acsch(r, r);					break;
	case M_TAN:			r_r_tan(r, r);						break;
	case M_TAND:		r_r_tand(r, r);						break;
	case M_TANH:		r_r_tanh(r, r);						break;
	case M_ATANH:		c_c_atanh(c, c);	complex=true;	break;
	case M_TANC:		r_r_tanc(r, r);						break;
	case M_COT:			r_r_cot(r, r);						break;
	case M_ACOT:		r_r_acot(r, r);						break;
	case M_COTD:		r_r_cotd(r, r);						break;
	case M_ACOTD:		r_r_acotd(r, r);					break;
	case M_COTH:		r_r_coth(r, r);						break;
	case M_ACOTH:		c_c_acoth(c, c);	complex=true;	break;
	case M_EXP:			r_r_exp(r, r);						break;
	case M_LN:			c_c_ln(c, c);		complex=true;	break;
	case M_SQRT:		c_c_sqrt(c, c);		complex=true;	break;
	case M_CBRT:		r_r_cbrt(r, r);						break;
	case M_INVSQRT:		r_r_invsqrt(r, r);					break;
	case M_SQ:			r_r_sq(r, r);						break;
	case M_ERF:			r_r_erf(r, r);						break;
	case M_FIB:			r_r_fib(r, r);						break;
	case M_ZETA:		r_r_zeta(r, r);						break;
	case M_STEP:		r_r_step(r, r);						break;
	case M_SGN:			r_r_sgn(r, r);						break;
	case M_RECT:		r_r_rect(r, r);						break;
	case M_TENT:		r_r_trgl(r, r);						break;
	case M_CEIL:		r_r_ceil(r, r);						break;
	case M_FLOOR:		r_r_floor(r, r);					break;
	case M_ROUND:		r_r_round(r, r);					break;
	case M_INT:			r_r_int(r, r);						break;
	case M_FRAC:		r_r_frac(r, r);						break;
	case M_ABS:			r_r_abs(r, r);						break;
	case M_ARG:			r_r_arg(r, r);						break;
	case M_RAND:		r_r_random(r, r);					break;
	case M_ATAN:		r_r_atan(r, r);						break;
	case M_ATAND:		r_r_atand(r, r);					break;
	case M_LOG:			c_c_log(c, c);		complex=true;	break;
	case M_BETA:		r_r_beta(r, r);						break;
	case M_GAMMA:		r_r_tgamma(r, r);					break;
	case M_LNGAMMA:		r_r_loggamma(r, r);					break;
	case M_GAUSS:		r_r_gauss(r, r);					break;
	case M_PERMUTATION:	r_r_permutation(r, r);				break;
	case M_COMBINATION:	r_r_combination(r, r);				break;
	case M_BESSEL_J:	r_r_bessel_j(r, r);					break;
	case M_BESSEL_Y:	r_r_bessel_y(r, r);					break;
	case M_HANKEL1:		c_rr_hankel1(c, r, r);complex=true;	break;
	case M_SQWV:		r_r_sqwv(r, r);						break;
	case M_TRWV:		r_r_trwv(r, r);						break;
	case M_SAW:			r_r_saw(r, r);						break;
	case M_HYPOT:		x.setzero();						break;
	case M_MANDELBROT:	r_r_mandelbrot(r, r);				break;
//	case M_MIN:			r_min(r, r);						break;
//	case M_MAX:			r_max(r, r);						break;
	}
	expr->m[f]=::Map(expr->m[f].pos, expr->m[f].len, M_N, expr->n.size());
	if(complex)
		expr->insertData('c', x);
	else
		expr->insertData('R', x);
	term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm));
	term[expr->n.size()-1]=CompileTerm(true, expr->n.rbegin()->mathSet);
}
#define			SCALAR(x)	x, MP::x
#ifdef AVX_H
#define			SIMD(x)		x, sse2::x, avx::x, MP::x
#define			SIMD2(x)	x, SSE4_1?sse2::x:sse2::x##_sse2, avx::x, MP::x
#else
#define			SIMD(x)		x, sse2::x, sse2::x, MP::x
#define			SIMD2(x)	x, SSE4_1?sse2::x:sse2::x##_sse2, SSE4_1?sse2::x:sse2::x##_sse2, MP::x
#endif
#define ISEL_C(TOKEN, ret, args, RET, ARGS, name, NAME, ARCH) case M_##TOKEN:function.set(ARCH(ret##_##args##_##name)), signature=SIG_##RET##_##ARGS, d(),									cl_idx=RET##_##ARGS##_##NAME, cl_disc_idx=0; return;
#define ISEL_I(TOKEN, ret, args, RET, ARGS, name, NAME, ARCH) case M_##TOKEN:function.set(ARCH(ret##_##args##_##name)), signature=SIG_##RET##_##ARGS, d(disc_##args##_##name##_i),			cl_idx=RET##_##ARGS##_##NAME, cl_disc_idx=DISC_##ARGS##_##NAME##_I; return;
#define ISEL_O(TOKEN, ret, args, RET, ARGS, name, NAME, ARCH) case M_##TOKEN:function.set(ARCH(ret##_##args##_##name)), signature=SIG_##RET##_##ARGS, d(disc_##ret##_##name##_o, false),	cl_idx=RET##_##ARGS##_##NAME, cl_disc_idx=DISC_##RET##_##NAME##_O; return;

#define			CASE_NONE(TOKEN)								case M_##TOKEN:function.set(), signature=SIG_NOOP, d(), cl_idx=0; return;

#define			CASE_R_R(TOKEN, name, NAME, DISCTYPE, ARCH)		ISEL_##DISCTYPE(TOKEN, r, r, R, R, name, NAME, ARCH)
#define			CASE_C_C(TOKEN, name, NAME, DISCTYPE, ARCH)		ISEL_##DISCTYPE(TOKEN, c, c, C, C, name, NAME, ARCH)
#define			CASE_Q_Q(TOKEN, name, NAME, DISCTYPE, ARCH)		ISEL_##DISCTYPE(TOKEN, q, q, Q, Q, name, NAME, ARCH)

#define			CASE_R_RR(TOKEN, name, NAME, DISCTYPE, ARCH)	ISEL_##DISCTYPE(TOKEN, r, rr, R, RR, name, NAME, ARCH)
#define			CASE_C_RC(TOKEN, name, NAME, DISCTYPE, ARCH)	ISEL_##DISCTYPE(TOKEN, c, rc, C, RC, name, NAME, ARCH)
#define			CASE_Q_RQ(TOKEN, name, NAME, DISCTYPE, ARCH)	ISEL_##DISCTYPE(TOKEN, q, rq, Q, RQ, name, NAME, ARCH)
#define			CASE_C_CR(TOKEN, name, NAME, DISCTYPE, ARCH)	ISEL_##DISCTYPE(TOKEN, c, cr, C, CR, name, NAME, ARCH)
#define			CASE_C_CC(TOKEN, name, NAME, DISCTYPE, ARCH)	ISEL_##DISCTYPE(TOKEN, c, cc, C, CC, name, NAME, ARCH)
#define			CASE_Q_CQ(TOKEN, name, NAME, DISCTYPE, ARCH)	ISEL_##DISCTYPE(TOKEN, q, cq, Q, CQ, name, NAME, ARCH)
#define			CASE_Q_QR(TOKEN, name, NAME, DISCTYPE, ARCH)	ISEL_##DISCTYPE(TOKEN, q, qr, Q, QR, name, NAME, ARCH)
#define			CASE_Q_QC(TOKEN, name, NAME, DISCTYPE, ARCH)	ISEL_##DISCTYPE(TOKEN, q, qc, Q, QC, name, NAME, ARCH)
#define			CASE_Q_QQ(TOKEN, name, NAME, DISCTYPE, ARCH)	ISEL_##DISCTYPE(TOKEN, q, qq, Q, QQ, name, NAME, ARCH)

#define			CASE_C_R(TOKEN, name, NAME, DISCTYPE, ARCH)		ISEL_##DISCTYPE(TOKEN, c, r, C, R, name, NAME, ARCH)
#define			CASE_C_Q(TOKEN, name, NAME, DISCTYPE, ARCH)		ISEL_##DISCTYPE(TOKEN, c, q, C, Q, name, NAME, ARCH)
#define			CASE_R_C(TOKEN, name, NAME, DISCTYPE, ARCH)		ISEL_##DISCTYPE(TOKEN, r, c, R, C, name, NAME, ARCH)
#define			CASE_R_Q(TOKEN, name, NAME, DISCTYPE, ARCH)		ISEL_##DISCTYPE(TOKEN, r, q, R, Q, name, NAME, ARCH)

#define			CASE_C_RR(TOKEN, name, NAME, DISCTYPE, ARCH)	ISEL_##DISCTYPE(TOKEN, c, rr, C, RR, name, NAME, ARCH)

#define			CASE_R_RC(TOKEN, name, NAME, DISCTYPE, ARCH)	ISEL_##DISCTYPE(TOKEN, r, rc, R, RC, name, NAME, ARCH)
#define			CASE_R_RQ(TOKEN, name, NAME, DISCTYPE, ARCH)	ISEL_##DISCTYPE(TOKEN, r, rq, R, RQ, name, NAME, ARCH)
#define			CASE_R_CR(TOKEN, name, NAME, DISCTYPE, ARCH)	ISEL_##DISCTYPE(TOKEN, r, cr, R, CR, name, NAME, ARCH)
#define			CASE_R_CC(TOKEN, name, NAME, DISCTYPE, ARCH)	ISEL_##DISCTYPE(TOKEN, r, cc, R, CC, name, NAME, ARCH)
#define			CASE_R_CQ(TOKEN, name, NAME, DISCTYPE, ARCH)	ISEL_##DISCTYPE(TOKEN, r, cq, R, CQ, name, NAME, ARCH)
#define			CASE_R_QR(TOKEN, name, NAME, DISCTYPE, ARCH)	ISEL_##DISCTYPE(TOKEN, r, qr, R, QR, name, NAME, ARCH)
#define			CASE_R_QC(TOKEN, name, NAME, DISCTYPE, ARCH)	ISEL_##DISCTYPE(TOKEN, r, qc, R, QC, name, NAME, ARCH)
#define			CASE_R_QQ(TOKEN, name, NAME, DISCTYPE, ARCH)	ISEL_##DISCTYPE(TOKEN, r, qq, R, QQ, name, NAME, ARCH)

#define			CASE_C_QC(TOKEN, name, NAME, DISCTYPE, ARCH)	ISEL_##DISCTYPE(TOKEN, c, qc, C, QC, name, NAME, ARCH)

#define			CASE(SIG, NAME, name, DISCTYPE, ARCH)			CASE_##SIG(NAME, name, NAME, DISCTYPE, ARCH)

#define CASE_LONG_C(ret, RET, args, ARGS, name, NAME, ARCH) function.set(ARCH(ret##_##args##_##name)), signature=SIG_##RET##_##ARGS, d(),								cl_idx=RET##_##ARGS##_##NAME, cl_disc_idx=0
#define CASE_LONG_I(ret, RET, args, ARGS, name, NAME, ARCH) function.set(ARCH(ret##_##args##_##name)), signature=SIG_##RET##_##ARGS, d(disc_##ret##_##name##_i),		cl_idx=RET##_##ARGS##_##NAME, cl_disc_idx=DISC_##RET##_##NAME##_I
#define CASE_LONG_O(ret, RET, args, ARGS, name, NAME, ARCH) function.set(ARCH(ret##_##args##_##name)), signature=SIG_##RET##_##ARGS, d(disc_##ret##_##name##_o, false),	cl_idx=RET##_##ARGS##_##NAME, cl_disc_idx=DISC_##RET##_##NAME##_O
#define			CASE_LONG(ret, RET, args, ARGS, name, NAME, ARCH, DISCTYPE)	CASE_LONG_##DISCTYPE(ret, RET, args, ARGS, name, NAME, ARCH)
void			Compile::compile_instruction_select_u	(int f, char side, char op1type, FPSetter &function, int &signature, DiscontinuityFunction &d, int &cl_idx, int &cl_disc_idx)
//void			Compile::compile_instruction_select_u	(int f, char side, char op1type, FPSetter &function, char (*&umts)(char), DiscontinuityFunction &d)
{
	using namespace G2;
	switch(op1type)
	{
	case 'R':
		switch(f)
		{
		CASE_NONE(REAL)
		CASE_R_R(IMAG,				setzero, SETZERO,		C,	SIMD)
	//	CASE(R_R, CONJUGATE,		conjugate,				C,	SCALAR)
		CASE(C_R, POLAR,			polar,					I,	SIMD)
	//	CASE(C_R, CARTESIAN,		cartesian,				C,	SCALAR)
		CASE(R_R, DIVIDE,			divide,					I,	SIMD)
		CASE(R_R, MINUS,			minus,					C,	SIMD)
		CASE_R_R(MODULO_PERCENT,	percent, PERCENT,		C,	SIMD)
		CASE(R_R, INCREMENT,		increment,				C,	SIMD)
		CASE(R_R, DECREMENT,		decrement,				C,	SIMD)
		CASE(R_R, BITWISE_NOT,		bitwise_not,			I,	SCALAR)
		case M_BITWISE_SHIFT_LEFT:		 if(side=='<')	CASE_LONG(r, R, r, R, bitwise_shift_left_l, BITWISE_SHIFT_LEFT_L, SIMD, O);
									else				CASE_LONG(r, R, r, R, bitwise_shift_left_r, BITWISE_SHIFT_LEFT_R, SIMD, C);		return;
		case M_BITWISE_SHIFT_RIGHT:		 if(side=='<')	CASE_LONG(r, R, r, R, bitwise_shift_right_l, BITWISE_SHIFT_RIGHT_L, SIMD, O);
									else				CASE_LONG(r, R, r, R, bitwise_shift_right_r, BITWISE_SHIFT_RIGHT_R, SIMD, C);	return;
		case M_FACTORIAL_LOGIC_NOT:		 if(side=='<')	CASE_LONG(r, R, r, R, logic_not, LOGIC_NOT, SIMD, O);
									else				CASE_LONG(r, R, r, R, factorial, FACTORIAL, SCALAR, I);							return;
		case M_LOGIC_LESS:				 if(side=='<')	CASE_LONG(r, R, r, R, logic_less_l, LOGIC_LESS_L, SIMD, O);
									else				CASE_LONG(r, R, r, R, logic_less_r, LOGIC_LESS_R, SIMD, O);						return;
		case M_LOGIC_LESS_EQUAL:		 if(side=='<')	CASE_LONG(r, R, r, R, logic_less_equal_l, LOGIC_LESS_EQUAL_L, SIMD, O);
									else				CASE_LONG(r, R, r, R, logic_less_equal_r, LOGIC_LESS_EQUAL_R, SIMD, O);			return;
		case M_LOGIC_GREATER:			 if(side=='<')	CASE_LONG(r, R, r, R, logic_greater_l, LOGIC_GREATER_L, SIMD, O);
									else				CASE_LONG(r, R, r, R, logic_greater_r, LOGIC_GREATER_R, SIMD, O);				return;
		case M_LOGIC_GREATER_EQUAL:		 if(side=='<')	CASE_LONG(r, R, r, R, logic_greater_equal_l, LOGIC_GREATER_EQUAL_L, SIMD, O);
									else				CASE_LONG(r, R, r, R, logic_greater_equal_r, LOGIC_GREATER_EQUAL_R, SIMD, O);	return;
		CASE(R_R, LOGIC_EQUAL,		logic_equal,			O,	SIMD)
		CASE(R_R, LOGIC_NOT_EQUAL,	logic_not_equal,		O,	SIMD)
		CASE(R_R, BITWISE_AND,		bitwise_and,			O,	SCALAR)
		CASE(R_R, BITWISE_NAND,		bitwise_nand,			O,	SCALAR)
		CASE(R_R, BITWISE_XOR,		bitwise_xor,			O,	SCALAR)
		CASE(R_R, BITWISE_XNOR,		bitwise_xnor,			O,	SCALAR)
		CASE_R_R(VERTICAL_BAR,		bitwise_or, BITWISE_OR, O, SCALAR)
		CASE(R_R, BITWISE_NOR,		bitwise_nor,			O,	SCALAR)
		CASE(R_R, COS,				cos,					C,	SIMD)
		CASE(C_C, ACOS,				acos,					I,	SIMD)
		CASE(R_R, COSD,				cosd,					C,	SIMD)
		CASE(C_C, ACOSD,			acosd,					I,	SIMD)
		CASE(R_R, COSH,				cosh,					C,	SIMD)
		CASE(C_C, ACOSH,			acosh,					C,	SIMD)
		CASE(R_R, COSC,				cosc,					I,	SIMD)
		CASE(R_R, SEC,				sec,					I,	SIMD)
		CASE(C_C, ASEC,				asec,					I,	SIMD)
		CASE(R_R, SECD,				secd,					I,	SIMD)
		CASE(C_C, ASECD,			asecd,					I,	SIMD)
		CASE(R_R, SECH,				sech,					C,	SIMD)
		CASE(C_C, ASECH,			asech,					I,	SIMD)
		CASE(R_R, SIN,				sin,					C,	SIMD)
		CASE(C_C, ASIN,				asin,					I,	SIMD)
		CASE(R_R, SIND,				sind,					C,	SIMD)
		CASE(C_C, ASIND,			asind,					I,	SIMD)
		CASE(R_R, SINH,				sinh,					C,	SIMD)
		CASE(R_R, ASINH,			asinh,					C,	SIMD)
		CASE(R_R, SINC,				sinc,					C,	SIMD)
		CASE(R_R, SINHC,			sinhc,					C,	SIMD)
		CASE(R_R, CSC,				csc,					I,	SIMD)
		CASE(C_C, ACSC,				acsc,					I,	SIMD)
		CASE(R_R, CSCD,				cscd,					I,	SIMD)
		CASE(C_C, ACSCD,			acscd,					I,	SIMD)
		CASE(R_R, CSCH,				csch,					I,	SIMD)
		CASE(R_R, ACSCH,			acsch,					I,	SIMD)
		CASE(R_R, TAN,				tan,					I,	SIMD)
		CASE(R_R, ATAN,				atan,					C,	SIMD)
		CASE(R_R, TAND,				tand,					I,	SIMD)
		CASE(R_R, ATAND,			atand,					C,	SIMD)
		CASE(R_R, TANH,				tanh,					C,	SIMD)
		CASE(C_C, ATANH,			atanh,					I,	SIMD)
		CASE(R_R, TANC,				tanc,					I,	SIMD)
		CASE(R_R, COT,				cot,					I,	SIMD)
		CASE(R_R, ACOT,				acot,					I,	SIMD)
		CASE(R_R, COTD,				cotd,					I,	SIMD)
		CASE(R_R, ACOTD,			acotd,					I,	SIMD)
		CASE(R_R, COTH,				coth,					I,	SIMD)
		CASE(C_C, ACOTH,			acoth,					I,	SIMD)
		CASE(R_R, EXP,				exp,					C,	SIMD)
		CASE(C_C, LN,				ln,						I,	SIMD)
		CASE(C_C, LOG,				log,					I,	SIMD)
		CASE(C_C, SQRT,				sqrt,					C,	SIMD)
		CASE(R_R, CBRT,				cbrt,					C,	SIMD)
		CASE(R_R, INVSQRT,			invsqrt,				C,	SIMD)
		CASE(R_R, SQ,				sq,						C,	SIMD)
		CASE(R_R, ERF,				erf,					C,	SCALAR)
		CASE(R_R, FIB,				fib,					C,	SIMD)
		CASE(R_R, ZETA,				zeta,					I,	SCALAR)
		CASE(R_R, STEP,				step,					I,	SIMD)
		CASE(R_R, SGN,				sgn,					I,	SIMD)
		CASE(R_R, RECT,				rect,					I,	SIMD)
		CASE_R_R(TENT,				trgl, TRGL,				C,	SIMD)
		CASE(R_R, CEIL,				ceil,					O,	SIMD2)
		CASE(R_R, FLOOR,			floor,					O,	SIMD2)
		CASE(R_R, ROUND,			round,					O,	SIMD2)
		CASE(R_R, INT,				int,					O,	SCALAR)
		CASE(R_R, FRAC,				frac,					I,	SCALAR)
		CASE(R_R, ABS,				abs,					C,	SIMD)
		CASE(R_R, ARG,				arg,					I,	SIMD)
		CASE_R_R(RAND,				random, RANDOM,			O,	SCALAR)
		CASE_R_R(GAMMA,				tgamma, TGAMMA,			I,	SCALAR)
		CASE_R_R(LNGAMMA,			loggamma, LOGGAMMA,		I,	SIMD)
		CASE(R_R, GAUSS,			gauss,					C,	SIMD)
		CASE(R_R, PERMUTATION,		permutation,			C,	SCALAR)
		CASE(R_R, COMBINATION,		combination,			C,	SCALAR)
		CASE(R_R, SQWV,				sqwv,					O,	SIMD2)
		CASE(R_R, TRWV,				trwv,					C,	SIMD2)
		CASE(R_R, SAW,				saw,					I,	SIMD2)
		CASE_R_R(HYPOT,				abs, ABS,				C,	SIMD)
		CASE(R_R, MANDELBROT,		mandelbrot,				O,	SIMD)
		CASE(R_R, ISPRIME,			isprime,				C,	SCALAR)
		CASE(R_R, TOTIENT,			totient,				C,	SCALAR)
	//	CASE(R_R, MIN,				min,					C,	SCALAR)
	//	CASE(R_R, MAX,				max,					C,	SCALAR)
		CASE(R_R, BETA,				beta,					I,	SCALAR)
		CASE(R_R, BESSEL_J,			bessel_j,				I,	SCALAR)//TODO: rename M_BESSEL->M_BESSEL_J, r_r_cyl_bessel_j->r_r_bessel_j	DONE
		CASE(R_R, BESSEL_Y,			bessel_y,				I,	SCALAR)//TODO: rename M_NEUMANN->M_BESSEL_Y, r_r_cyl_neumann->r_r_bessel_y	DONE
		CASE(C_R, HANKEL1,			hankel1,				I,	SCALAR)
		}
		break;
	case 'c':
		switch(f)
		{
		CASE(R_C, REAL,				real,				C,	SIMD)
		CASE(R_C, IMAG,				imag,				C,	SIMD)
		CASE(C_C, CONJUGATE,		conjugate,			C,	SIMD)
		CASE(C_C, POLAR,			polar,				I,	SIMD)
		CASE(C_C, CARTESIAN,		cartesian,			C,	SIMD)
		CASE(C_C, DIVIDE,			divide,				I,	SIMD)
		CASE(C_C, MINUS,			minus,				C,	SIMD)
		CASE_C_C(MODULO_PERCENT,	percent, PERCENT,	C,	SIMD)
		CASE(C_C, INCREMENT,		increment,			C,	SIMD)
		CASE(C_C, DECREMENT,		decrement,			C,	SIMD)
		CASE(C_C, BITWISE_NOT,		bitwise_not,		I,	SCALAR)
		case M_BITWISE_SHIFT_LEFT:		 if(side=='<')	CASE_LONG(c, C, c, C, bitwise_shift_left_l, BITWISE_SHIFT_LEFT_L, SIMD, O);
									else				CASE_LONG(c, C, c, C, bitwise_shift_left_r, BITWISE_SHIFT_LEFT_R, SIMD, C);		return;
		case M_BITWISE_SHIFT_RIGHT:		 if(side=='<')	CASE_LONG(c, C, c, C, bitwise_shift_right_l, BITWISE_SHIFT_RIGHT_L, SIMD, O);
									else				CASE_LONG(c, C, c, C, bitwise_shift_right_r, BITWISE_SHIFT_RIGHT_R, SIMD, C);	return;
		case M_FACTORIAL_LOGIC_NOT:		 if(side=='<')	CASE_LONG(r, R, c, C, logic_not, LOGIC_NOT, SIMD, O);
									else				CASE_LONG(c, C, c, C, factorial, FACTORIAL, SCALAR, I);							return;
		case M_LOGIC_LESS:				 if(side=='<')	CASE_LONG(r, R, c, C, logic_less_l			, LOGIC_LESS_L			, SIMD, O);
									else				CASE_LONG(r, R, c, C, logic_less_r			, LOGIC_LESS_R			, SIMD, O);	return;
		case M_LOGIC_LESS_EQUAL:		 if(side=='<')	CASE_LONG(r, R, c, C, logic_less_equal_l	, LOGIC_LESS_EQUAL_L	, SIMD, O);
									else				CASE_LONG(r, R, c, C, logic_less_equal_r	, LOGIC_LESS_EQUAL_R	, SIMD, O);	return;
		case M_LOGIC_GREATER:			 if(side=='<')	CASE_LONG(r, R, c, C, logic_greater_l		, LOGIC_GREATER_L		, SIMD, O);
									else				CASE_LONG(r, R, c, C, logic_greater_r		, LOGIC_GREATER_R		, SIMD, O);	return;
		case M_LOGIC_GREATER_EQUAL:		 if(side=='<')	CASE_LONG(r, R, c, C, logic_greater_equal_l	, LOGIC_GREATER_EQUAL_L	, SIMD, O);
									else				CASE_LONG(r, R, c, C, logic_greater_equal_r	, LOGIC_GREATER_EQUAL_R	, SIMD, O);	return;
		CASE(R_C, LOGIC_EQUAL,		logic_equal,		O,	SIMD)
		CASE(R_C, LOGIC_NOT_EQUAL,	logic_not_equal,	O,	SIMD)
		CASE(C_C, BITWISE_AND,		bitwise_and,		O,	SCALAR)
		CASE(C_C, BITWISE_NAND,		bitwise_nand,		O,	SCALAR)
		CASE(C_C, BITWISE_XOR,		bitwise_xor,		O,	SCALAR)
		CASE(C_C, BITWISE_XNOR,		bitwise_xnor,		O,	SCALAR)
		CASE_C_C(VERTICAL_BAR,		bitwise_or, BITWISE_OR, O, SCALAR)
		CASE(C_C, BITWISE_NOR,		bitwise_nor,		O,	SCALAR)
		CASE(C_C, COS,				cos,				C,	SIMD)
		CASE(C_C, ACOS,				acos,				I,	SIMD)
		CASE(C_C, COSD,				cosd,				C,	SIMD)
		CASE(C_C, ACOSD,			acosd,				I,	SIMD)
		CASE(C_C, COSH,				cosh,				C,	SIMD)
		CASE(C_C, ACOSH,			acosh,				C,	SIMD)
		CASE(C_C, COSC,				cosc,				I,	SIMD)
		CASE(C_C, SEC,				sec,				I,	SIMD)
		CASE(C_C, ASEC,				asec,				I,	SIMD)
		CASE(C_C, SECD,				secd,				I,	SIMD)
		CASE(C_C, ASECD,			asecd,				I,	SIMD)
		CASE(C_C, SECH,				sech,				I,	SIMD)
		CASE(C_C, ASECH,			asech,				I,	SIMD)
		CASE(C_C, SIN,				sin,				C,	SIMD)
		CASE(C_C, ASIN,				asin,				I,	SIMD)
		CASE(C_C, SIND,				sind,				C,	SIMD)
		CASE(C_C, ASIND,			asind,				I,	SIMD)
		CASE(C_C, SINH,				sinh,				C,	SIMD)
		CASE(C_C, ASINH,			asinh,				I,	SIMD)
		CASE(C_C, SINC,				sinc,				C,	SIMD)
		CASE(C_C, SINHC,			sinhc,				C,	SIMD)
		CASE(C_C, CSC,				csc,				I,	SIMD)
		CASE(C_C, ACSC,				acsc,				I,	SIMD)
		CASE(C_C, CSCD,				cscd,				I,	SIMD)
		CASE(C_C, ACSCD,			acscd,				I,	SIMD)
		CASE(C_C, CSCH,				csch,				I,	SIMD)
		CASE(C_C, ACSCH,			acsch,				I,	SIMD)
		CASE(C_C, TAN,				tan,				I,	SIMD)
		CASE(C_C, ATAN,				atan,				I,	SIMD)
		CASE(C_C, TAND,				tand,				I,	SIMD)
		CASE(C_C, ATAND,			atand,				I,	SIMD)
		CASE(C_C, TANH,				tanh,				C,	SIMD)
		CASE(C_C, ATANH,			atanh,				I,	SIMD)
		CASE(C_C, TANC,				tanc,				I,	SIMD)
		CASE(C_C, COT,				cot,				I,	SIMD)
		CASE(C_C, ACOT,				acot,				I,	SIMD)
		CASE(C_C, COTD,				cotd,				I,	SIMD)
		CASE(C_C, ACOTD,			acotd,				I,	SIMD)
		CASE(C_C, COTH,				coth,				I,	SIMD)
		CASE(C_C, ACOTH,			acoth,				I,	SIMD)
		CASE(C_C, EXP,				exp,				C,	SIMD)
		CASE(C_C, LN,				ln,					I,	SIMD)
		CASE(C_C, LOG,				log,				I,	SIMD)
		CASE(C_C, SQRT,				sqrt,				C,	SIMD)
		CASE(C_C, CBRT,				cbrt,				C,	SIMD)
		CASE(C_C, SQ,				sq,					C,	SIMD)
		CASE(C_C, FIB,				fib,				C,	SIMD)
		CASE(C_C, SGN,				sgn,				I,	SIMD)
		CASE(C_C, STEP,				step,				I,	SIMD)
		CASE(C_C, RECT,				rect,				I,	SIMD)
		CASE_R_C(TENT,				trgl, TRGL,			C,	SIMD)
		CASE(C_C, CEIL,				ceil,				O,	SIMD2)
		CASE(C_C, FLOOR,			floor,				O,	SIMD2)
		CASE(C_C, ROUND,			round,				O,	SIMD2)
		CASE(C_C, INT,				int,				O,	SCALAR)
		CASE(C_C, FRAC,				frac,				I,	SCALAR)
		CASE(R_C, ABS,				abs,				C,	SIMD)
		CASE(R_C, ARG,				arg,				I,	SIMD)
		CASE_NONE(INVSQRT)
		CASE_NONE(ERF)
		CASE_NONE(ZETA)
		CASE_C_C(RAND,				random, RANDOM,		O,	SCALAR)
		CASE_C_C(GAMMA,				tgamma, TGAMMA,		I,	SCALAR)
		CASE_NONE(LNGAMMA)
		CASE(C_C, GAUSS,			gauss,				C,	SIMD)
		CASE(C_C, COMBINATION,		combination,		C,	SCALAR)
		CASE(C_C, PERMUTATION,		permutation,		C,	SCALAR)
		CASE(R_C, SQWV,				sqwv,				O,	SIMD2)
		CASE(R_C, TRWV,				trwv,				C,	SIMD2)
		CASE(R_C, SAW,				saw,				I,	SIMD2)
		CASE(R_C, MANDELBROT,		mandelbrot,			O,	SIMD)
	//	CASE(C_C, MIN,				min,				C,	SCALAR)
	//	CASE(C_C, MAX,				max,				C,	SCALAR)
		CASE_NONE(BETA)
		CASE_NONE(BESSEL_J)
		CASE_NONE(BESSEL_Y)
		CASE(C_C, HANKEL1,			hankel1,			C,	SCALAR)
		}
		break;
	case 'h':
		switch(f)
		{
		CASE(R_C, REAL,				real,				C,	SIMD)
		CASE(R_C, IMAG,				imag,				C,	SIMD)
		CASE(Q_Q, CONJUGATE,		conjugate,			C,	SIMD)
		CASE(C_Q, POLAR,			polar,				I,	SIMD)
		CASE(Q_Q, CARTESIAN,		cartesian,			C,	SIMD)
		CASE(Q_Q, DIVIDE,			divide,				I,	SIMD)
		CASE(Q_Q, MINUS,			minus,				C,	SIMD)
		CASE_Q_Q(MODULO_PERCENT,	percent, PERCENT,	C,	SIMD)
		CASE(Q_Q, INCREMENT,		increment,			C,	SIMD)
		CASE(Q_Q, DECREMENT,		decrement,			C,	SIMD)
		CASE(Q_Q, BITWISE_NOT,		bitwise_not,		I,	SCALAR)
		case M_BITWISE_SHIFT_LEFT:		 if(side=='<')	CASE_LONG(q, Q, q, Q, bitwise_shift_left_l	, BITWISE_SHIFT_LEFT_L	, SIMD, O);
									else				CASE_LONG(q, Q, q, Q, bitwise_shift_left_r	, BITWISE_SHIFT_LEFT_R	, SIMD, C);		return;
		case M_BITWISE_SHIFT_RIGHT:		 if(side=='<')	CASE_LONG(q, Q, q, Q, bitwise_shift_right_l	, BITWISE_SHIFT_RIGHT_L	, SIMD, O);
									else				CASE_LONG(q, Q, q, Q, bitwise_shift_right_r	, BITWISE_SHIFT_RIGHT_R	, SIMD, C);		return;
		case M_FACTORIAL_LOGIC_NOT:		 if(side=='<')	CASE_LONG(r, R, q, Q, logic_not				, LOGIC_NOT				, SIMD, O);
									else				CASE_LONG(q, Q, q, Q, factorial				, FACTORIAL				, SCALAR, I);	return;
		case M_LOGIC_LESS:				 if(side=='<')	CASE_LONG(r, R, q, Q, logic_less_l			, LOGIC_LESS_L			, SIMD, O);
									else				CASE_LONG(r, R, q, Q, logic_less_r			, LOGIC_LESS_R			, SIMD, O);		return;
		case M_LOGIC_LESS_EQUAL:		 if(side=='<')	CASE_LONG(r, R, q, Q, logic_less_equal_l	, LOGIC_LESS_EQUAL_L	, SIMD, O);
									else				CASE_LONG(r, R, q, Q, logic_less_equal_r	, LOGIC_LESS_EQUAL_R	, SIMD, O);		return;
		case M_LOGIC_GREATER:			 if(side=='<')	CASE_LONG(r, R, q, Q, logic_greater_l		, LOGIC_GREATER_L		, SIMD, O);
									else				CASE_LONG(r, R, q, Q, logic_greater_r		, LOGIC_GREATER_R		, SIMD, O);		return;
		case M_LOGIC_GREATER_EQUAL:		 if(side=='<')	CASE_LONG(r, R, q, Q, logic_greater_equal_l	, LOGIC_GREATER_EQUAL_L	, SIMD, O);
									else				CASE_LONG(r, R, q, Q, logic_greater_equal_r	, LOGIC_GREATER_EQUAL_R	, SIMD, O);		return;
		CASE(R_Q, LOGIC_EQUAL,		logic_equal,		O,	SIMD)
		CASE(R_Q, LOGIC_NOT_EQUAL,	logic_not_equal,	O,	SIMD)
		CASE(Q_Q, BITWISE_AND,		bitwise_and,		O,	SCALAR)
		CASE(Q_Q, BITWISE_NAND,		bitwise_nand,		O,	SCALAR)
		CASE(Q_Q, BITWISE_XOR,		bitwise_xor,		O,	SCALAR)
		CASE(Q_Q, BITWISE_XNOR,		bitwise_xnor,		O,	SCALAR)
		CASE_Q_Q(VERTICAL_BAR,		bitwise_or, BITWISE_OR, O, SCALAR)
		CASE(Q_Q, BITWISE_NOR,		bitwise_nor,		O,	SCALAR)
		CASE(Q_Q, COS,				cos,				C,	SIMD)
		CASE(Q_Q, ACOS,				acos,				I,	SIMD)
		CASE(Q_Q, COSD,				cosd,				C,	SIMD)
		CASE(Q_Q, ACOSD,			acosd,				I,	SIMD)
		CASE(Q_Q, COSH,				cosh,				C,	SIMD)
		CASE(Q_Q, ACOSH,			acosh,				C,	SIMD)
		CASE(Q_Q, COSC,				cosc,				I,	SIMD)
		CASE(Q_Q, SEC,				sec,				I,	SIMD)
		CASE(Q_Q, ASEC,				asec,				I,	SIMD)
		CASE(Q_Q, SECD,				secd,				I,	SIMD)
		CASE(Q_Q, ASECD,			asecd,				I,	SIMD)
		CASE(Q_Q, SECH,				sech,				I,	SIMD)
		CASE(Q_Q, ASECH,			asech,				I,	SIMD)
		CASE(Q_Q, SIN,				sin,				C,	SIMD)
		CASE(Q_Q, ASIN,				asin,				I,	SIMD)
		CASE(Q_Q, SIND,				sind,				C,	SIMD)
		CASE(Q_Q, ASIND,			asind,				I,	SIMD)
		CASE(Q_Q, SINH,				sinh,				C,	SIMD)
		CASE(Q_Q, ASINH,			asinh,				I,	SIMD)
		CASE(Q_Q, SINC,				sinc,				C,	SIMD)
		CASE(Q_Q, SINHC,			sinhc,				C,	SIMD)
		CASE(Q_Q, CSC,				csc,				I,	SIMD)
		CASE(Q_Q, ACSC,				acsc,				I,	SIMD)
		CASE(Q_Q, CSCD,				cscd,				I,	SIMD)
		CASE(Q_Q, ACSCD,			acscd,				I,	SIMD)
		CASE(Q_Q, CSCH,				csch,				I,	SIMD)
		CASE(Q_Q, ACSCH,			acsch,				I,	SIMD)
		CASE(Q_Q, TAN,				tan,				I,	SIMD)
		CASE(Q_Q, ATAN,				atan,				I,	SIMD)
		CASE(Q_Q, TAND,				tand,				I,	SIMD)
		CASE(Q_Q, ATAND,			atand,				I,	SIMD)
		CASE(Q_Q, TANH,				tanh,				C,	SIMD)
		CASE(Q_Q, ATANH,			atanh,				I,	SIMD)
		CASE(Q_Q, TANC,				tanc,				I,	SIMD)
		CASE(Q_Q, COT,				cot,				I,	SIMD)
		CASE(Q_Q, ACOT,				acot,				I,	SIMD)
		CASE(Q_Q, COTD,				cotd,				I,	SIMD)
		CASE(Q_Q, ACOTD,			acotd,				I,	SIMD)
		CASE(Q_Q, COTH,				coth,				I,	SIMD)
		CASE(Q_Q, ACOTH,			acoth,				I,	SIMD)
		CASE(Q_Q, EXP,				exp,				C,	SIMD)
		CASE(Q_Q, LN,				ln,					I,	SIMD)
		CASE(Q_Q, LOG,				log,				I,	SIMD)
		CASE(Q_Q, SQRT,				sqrt,				C,	SIMD)
		CASE(Q_Q, CBRT,				cbrt,				C,	SIMD)
		CASE(Q_Q, SQ,				sq,					C,	SIMD)
		CASE(Q_Q, FIB,				fib,				C,	SIMD)
		CASE(Q_Q, SGN,				sgn,				I,	SIMD)
		CASE(Q_Q, STEP,				step,				I,	SIMD)
		CASE(Q_Q, RECT,				rect,				I,	SIMD)
		CASE_R_Q(TENT,				trgl, TRGL,			C,	SIMD)
		CASE(Q_Q, CEIL,				ceil,				O,	SIMD2)
		CASE(Q_Q, FLOOR,			floor,				O,	SIMD2)
		CASE(Q_Q, ROUND,			round,				O,	SIMD2)
		CASE(Q_Q, INT,				int,				O,	SCALAR)
		CASE(Q_Q, FRAC,				frac,				I,	SCALAR)
		CASE(R_Q, ABS,				abs,				C,	SIMD)
		CASE(R_Q, ARG,				arg,				I,	SIMD)
		CASE_NONE(INVSQRT)
		CASE_NONE(ERF)
		CASE_NONE(ZETA)
		CASE_Q_Q(RAND,				random, RANDOM,		O,	SCALAR)
		CASE_Q_Q(GAMMA,				tgamma, TGAMMA,		I,	SCALAR)
		CASE_NONE(LNGAMMA)
		CASE(Q_Q, GAUSS,			gauss,				C,	SIMD)
		CASE(Q_Q, PERMUTATION,		permutation,		C,	SCALAR)
		CASE(Q_Q, COMBINATION,		combination,		C,	SCALAR)
		CASE(R_Q, SQWV,				sqwv,				O,	SIMD2)
		CASE(R_Q, TRWV,				trwv,				C,	SIMD2)
		CASE(R_Q, SAW,				saw,				I,	SIMD2)
	//	CASE(Q_Q, MIN,				min,				C,	SCALAR)
	//	CASE(Q_Q, MAX,				max,				C,	SCALAR)
		CASE_NONE(BETA)
		CASE_NONE(BESSEL_J)
		CASE_NONE(BESSEL_Y)
		CASE_NONE(HANKEL1)
		}
		break;
	}
}
void			Compile::compile_instruction_select_b	(int f, char op1type, char op2type, FPSetter &function, int &signature, DiscontinuityFunction &d, int &cl_idx, int &cl_disc_idx)
//void			Compile::compile_instruction_select_b	(int f, char op1type, char op2type, FPSetter &function, char (*&bmts)(char, char), DiscontinuityFunction &d)
{
	using namespace G2;
	switch(op1type)
	{
	case 'R':
		switch(op2type)
		{
		case 'R':
			switch(f)
			{
			CASE_C_CR(POWER,				pow, POW,			I,	SIMD)
			case M_ASSIGN_DIVIDE:
			CASE(R_RR, DIVIDE,				divide,				I,	SIMD)
			CASE(R_RR, LOGIC_DIVIDES,		logic_divides,		O,	SIMD2)
			case M_ASSIGN_MINUS:
			CASE(R_RR, MINUS,				minus,				C,	SIMD)
			CASE(C_RR, PENTATE,				pentate,			I,	SCALAR)
			CASE(C_RR, TETRATE,				tetrate,			I,	SCALAR)
			CASE(R_RR, POWER_REAL,			power_real,			I,	SCALAR)
			case M_ASSIGN_MULTIPLY:
			CASE(R_RR, MULTIPLY,			multiply,			C,	SIMD)
			case M_ASSIGN_PLUS:
			CASE(R_RR, PLUS,				plus,				C,	SIMD)
			CASE(R_RR, LOGIC_AND,			logic_and,			O,	SIMD)
			CASE(R_RR, LOGIC_XOR,			logic_xor,			O,	SIMD)
			CASE(R_RR, LOGIC_OR,			logic_or,			O,	SIMD)
			CASE(R_RR, CONDITION_ZERO,		condition_zero,		I,	SIMD)
			case M_ASSIGN_MOD:
			CASE_R_RR(MODULO_PERCENT,		modulo, MODULO,		I,	SIMD2)
			case M_ASSIGN_LEFT:
			CASE(R_RR, BITWISE_SHIFT_LEFT,	bitwise_shift_left, I, SIMD)
			case M_ASSIGN_RIGHT:
			CASE(R_RR, BITWISE_SHIFT_RIGHT,	bitwise_shift_right, I, SIMD)
			CASE(R_RR, LOGIC_LESS,			logic_less,			O,	SIMD)
			CASE(R_RR, LOGIC_LESS_EQUAL,	logic_less_equal,	O,	SIMD)
			CASE(R_RR, LOGIC_GREATER,		logic_greater,		O,	SIMD)
			CASE(R_RR, LOGIC_GREATER_EQUAL,	logic_greater_equal, O,	SIMD)
			CASE(R_RR, LOGIC_EQUAL,			logic_equal,		O,	SIMD)
			CASE(R_RR, LOGIC_NOT_EQUAL,		logic_not_equal,	O,	SIMD)
			case M_ASSIGN_AND:
			CASE(R_RR, BITWISE_AND,			bitwise_and,		O,	SCALAR)
			CASE(R_RR, BITWISE_NAND,		bitwise_nand,		O,	SCALAR)
			case M_ASSIGN_XOR:
			CASE(R_RR, BITWISE_XOR,			bitwise_xor,		O,	SCALAR)
			CASE(R_RR, BITWISE_XNOR,		bitwise_xnor,		O,	SCALAR)
			case M_ASSIGN_OR:
			CASE_R_RR(VERTICAL_BAR,			bitwise_or, BITWISE_OR, O, SCALAR)
			CASE(R_RR, BITWISE_NOR,			bitwise_nor,		O,	SCALAR)
			CASE(C_CR, LOG,					log,				I,	SIMD)
			CASE_R_RR(RAND,					random, RANDOM,		O,	SCALAR)
			CASE(R_RR, ATAN,				atan,				I,	SIMD)
			CASE(R_RR, ATAND,				atand,				I,	SIMD)
			CASE(R_RR, SQWV,				sqwv,				O,	SIMD2)
			CASE(R_RR, TRWV,				trwv,				C,	SIMD2)
			CASE(R_RR, SAW,					saw,				I,	SIMD2)
			CASE(R_RR, HYPOT,				hypot,				C,	SIMD)
			CASE(R_RR, MANDELBROT,			mandelbrot,			O,	SIMD)
			CASE(R_RR, INVMOD,				invmod,				C,	SCALAR)
			CASE(R_RR, MIN,					min,				C,	SIMD)
			CASE(R_RR, MAX,					max,				C,	SIMD)
			CASE(R_RR, BETA,				beta,				I,	SCALAR)
			CASE_R_RR(GAMMA,				tgamma, TGAMMA,		I,	SCALAR)
			CASE(R_RR, PERMUTATION,			permutation,		I,	SCALAR)
			CASE(R_RR, COMBINATION,			combination,		I,	SCALAR)
			CASE(R_RR, BESSEL_J,			bessel_j,			I,	SCALAR)
			CASE(R_RR, BESSEL_Y,			bessel_y,			I,	SCALAR)
			CASE(C_RR, HANKEL1,				hankel1,			I,	SCALAR)
		//	CASE(R_RR, HANKEL1,				hankel1,			I,	SCALAR)
			CASE(R_R, ASSIGN,				assign,				C,	SIMD)
			}
			break;
		case 'c':
			switch(f)
			{
			CASE_C_CC(POWER,				pow, POW,			I,	SIMD)
			case M_ASSIGN_DIVIDE:
			CASE(C_RC, DIVIDE,				divide,				I,	SIMD)
			CASE(R_RC, LOGIC_DIVIDES,		logic_divides,		O,	SIMD2)
			case M_ASSIGN_MINUS:
			CASE(C_RC, MINUS,				minus,				C,	SIMD)
			CASE_NONE(PENTATE)
			CASE(C_RC, TETRATE,				tetrate,			I,	SCALAR)
			case M_ASSIGN_MULTIPLY:
			CASE(C_RC, MULTIPLY,			multiply,			C,	SIMD)
			case M_ASSIGN_PLUS:
			CASE(C_RC, PLUS,				plus,				C,	SIMD)
			CASE(R_RC, LOGIC_AND,			logic_and,			O,	SIMD)
			CASE(R_RC, LOGIC_XOR,			logic_xor,			O,	SIMD)
			CASE(R_RC, LOGIC_OR,			logic_or,			O,	SIMD)
			CASE(C_RC, CONDITION_ZERO,		condition_zero,		I,	SIMD)
			case M_ASSIGN_MOD:
			CASE_C_RC(MODULO_PERCENT,		modulo, MODULO,		I,	SIMD2)
			case M_ASSIGN_LEFT:
			CASE(C_RC, BITWISE_SHIFT_LEFT,	bitwise_shift_left,	I,	SIMD)
			case M_ASSIGN_RIGHT:
			CASE(C_RC, BITWISE_SHIFT_RIGHT,	bitwise_shift_right, I,	SIMD)
			CASE(R_RC, LOGIC_LESS,			logic_less,			O,	SIMD)
			CASE(R_RC, LOGIC_LESS_EQUAL,	logic_less_equal,	O,	SIMD)
			CASE(R_RC, LOGIC_GREATER,		logic_greater,		O,	SIMD)
			CASE(R_RC, LOGIC_GREATER_EQUAL,	logic_greater_equal, O,	SIMD)
			CASE(R_RC, LOGIC_EQUAL,			logic_equal,		O,	SIMD)
			CASE(R_RC, LOGIC_NOT_EQUAL,		logic_not_equal,	O,	SIMD)
			case M_ASSIGN_AND:
			CASE(C_RC, BITWISE_AND,			bitwise_and,		O,	SCALAR)
			CASE(C_RC, BITWISE_NAND,		bitwise_nand,		O,	SCALAR)
			case M_ASSIGN_XOR:
			CASE(C_RC, BITWISE_XOR,			bitwise_xor,		O,	SCALAR)
			CASE(C_RC, BITWISE_XNOR,		bitwise_xnor,		O,	SCALAR)
			case M_ASSIGN_OR:
			CASE_C_RC(VERTICAL_BAR,			bitwise_or, BITWISE_OR, O,	SCALAR)
			CASE(C_RC, BITWISE_NOR,			bitwise_nor,		O,	SCALAR)
			CASE(C_CC, LOG,					log,				I,	SIMD)
			CASE_C_CC(RAND,					random, RANDOM,		O,	SCALAR)
		//	CASE_C_RC(RAND,					random, RANDOM,		O,	SCALAR)
			CASE(C_RC, ATAN,				atan,				I,	SIMD)
			CASE(C_RC, ATAND,				atand,				I,	SIMD)
			CASE(R_RC, SQWV,				sqwv,				O,	SIMD2)
			CASE(R_RC, TRWV,				trwv,				C,	SIMD2)
			CASE(R_RC, SAW,					saw,				I,	SIMD2)
		//	CASE(C_RC, MIN,					min,				C,	SIMD)
			CASE(C_CC, MIN,					min,				C,	SIMD)
		//	CASE(C_RC, MAX,					max,				C,	SIMD)
			CASE(C_CC, MAX,					max,				C,	SIMD)
			CASE_NONE(BETA)
			CASE_NONE(GAMMA)
			CASE(C_CC, PERMUTATION,			permutation,		I,	SCALAR)
		//	CASE_NONE(PERMUTATION)
		//	CASE_NONE(COMBINATION)
			CASE(C_CC, COMBINATION,			combination,		I,	SCALAR)
			CASE_NONE(BESSEL_J)
			CASE_NONE(BESSEL_Y)
			CASE_NONE(HANKEL1)
			CASE(C_C, ASSIGN,				assign,				C,	SIMD)
			}
			break;
		case 'h':
			switch(f)
			{
			CASE_Q_CQ(POWER,				pow, POW,			I,	SIMD)
			case M_ASSIGN_DIVIDE:
			CASE(Q_RQ, DIVIDE,				divide,				I,	SIMD)
			CASE(R_RQ, LOGIC_DIVIDES,		logic_divides,		O,	SIMD2)
			case M_ASSIGN_MINUS:
			CASE(Q_RQ, MINUS,				minus,				C,	SIMD)
			CASE_NONE(PENTATE)
			CASE_NONE(TETRATE)
			case M_ASSIGN_MULTIPLY:
			CASE(Q_RQ, MULTIPLY,			multiply,			C,	SIMD)
			case M_ASSIGN_PLUS:
			CASE(Q_RQ, PLUS,				plus,				C,	SIMD)
			CASE(R_RQ, LOGIC_AND,			logic_and,			O,	SIMD)
			CASE(R_RQ, LOGIC_XOR,			logic_xor,			O,	SIMD)
			CASE(R_RQ, LOGIC_OR,			logic_or,			O,	SIMD)
			CASE(Q_RQ, CONDITION_ZERO,		condition_zero,		I,	SIMD)
			case M_ASSIGN_MOD:
			CASE_Q_RQ(MODULO_PERCENT,		modulo, MODULO,		I,	SIMD2)
			case M_ASSIGN_LEFT:
			CASE(Q_RQ, BITWISE_SHIFT_LEFT,	bitwise_shift_left,	I,	SIMD)
			case M_ASSIGN_RIGHT:
			CASE(Q_RQ, BITWISE_SHIFT_RIGHT, bitwise_shift_right, I,	SIMD)
			CASE(R_RQ, LOGIC_LESS,			logic_less,			O,	SIMD)
			CASE(R_RQ, LOGIC_LESS_EQUAL,	logic_less_equal,	O,	SIMD)
			CASE(R_RQ, LOGIC_GREATER,		logic_greater,		O,	SIMD)
			CASE(R_RQ, LOGIC_GREATER_EQUAL,	logic_greater_equal, O,	SIMD)
			CASE(R_RQ, LOGIC_EQUAL,			logic_equal,		O,	SIMD)
			CASE(R_RQ, LOGIC_NOT_EQUAL,		logic_not_equal,	O,	SIMD)
			case M_ASSIGN_AND:
			CASE(Q_RQ, BITWISE_AND,			bitwise_and,		O,	SCALAR)
			CASE(Q_RQ, BITWISE_NAND,		bitwise_nand,		O,	SCALAR)
			case M_ASSIGN_XOR:
			CASE(Q_RQ, BITWISE_XOR,			bitwise_xor,		O,	SCALAR)
			CASE(Q_RQ, BITWISE_XNOR,		bitwise_xnor,		O,	SCALAR)
			case M_ASSIGN_OR:
			CASE_Q_RQ(VERTICAL_BAR,			bitwise_or, BITWISE_OR, O, SCALAR)
			CASE(Q_RQ, BITWISE_NOR,			bitwise_nor,		O,	SCALAR)
			CASE(Q_CQ, LOG,					log,				I,	SIMD)
			CASE_Q_QQ(RAND,					random, RANDOM,		O,	SCALAR)
		//	CASE_Q_RQ(RAND,					random, RANDOM,		O,	SCALAR)
			CASE(Q_RQ, ATAN,				atan,				I,	SIMD)
			CASE(Q_RQ, ATAND,				atand,				I,	SIMD)
			CASE(R_RQ, SQWV,				sqwv,				O,	SIMD2)
			CASE(R_RQ, TRWV,				trwv,				C,	SIMD2)
			CASE(R_RQ, SAW,					saw,				I,	SIMD2)
		//	CASE(Q_RQ, MIN,					min,				C,	SIMD)
			CASE(Q_QQ, MIN,					min,				C,	SIMD)
		//	CASE(Q_RQ, MAX,					max,				C,	SIMD)
			CASE(Q_QQ, MAX,					max,				C,	SIMD)
			CASE_NONE(BETA)
			CASE_NONE(GAMMA)
		//	CASE(Q_RQ, PERMUTATION,			permutation,		I,	SCALAR)
			CASE(Q_QQ, PERMUTATION,			permutation,		I,	SCALAR)
		//	CASE(Q_RQ, COMBINATION,			combination,		I,	SCALAR)
			CASE(Q_QQ, COMBINATION,			combination,		I,	SCALAR)
			CASE_NONE(BESSEL_J)
			CASE_NONE(BESSEL_Y)
			CASE_NONE(HANKEL1)
			CASE(Q_Q, ASSIGN,				assign,				C,	SIMD)
			}
			break;
		}
		break;
	case 'c':
		switch(op2type)
		{
		case 'R':
			switch(f)
			{
			CASE_C_CR(POWER,				pow, POW,			I,	SIMD)
			case M_ASSIGN_DIVIDE:
			CASE(C_CR, DIVIDE,				divide,				I,	SIMD)
			CASE(R_CR, LOGIC_DIVIDES,		logic_divides,		O,	SIMD2)
			case M_ASSIGN_MINUS:
			CASE(C_CR, MINUS,				minus,				C,	SIMD)
			CASE(C_CR, PENTATE,				pentate,			I,	SCALAR)
			CASE(C_CR, TETRATE,				tetrate,			I,	SCALAR)
			CASE(C_CR, POWER_REAL,			power_real,			I,	SCALAR)
			case M_ASSIGN_MULTIPLY:
			CASE(C_CR, MULTIPLY,			multiply,			C,	SIMD)
			case M_ASSIGN_PLUS:
			CASE(C_CR, PLUS,				plus,				C,	SIMD)
			CASE(R_CR, LOGIC_AND,			logic_and,			O,	SIMD)
			CASE(R_CR, LOGIC_XOR,			logic_xor,			O,	SIMD)
			CASE(R_CR, LOGIC_OR,			logic_or,			O,	SIMD)
			CASE(C_CR, CONDITION_ZERO,		condition_zero,		I,	SIMD)
			case M_ASSIGN_MOD:
			CASE_C_CR(MODULO_PERCENT,		modulo, MODULO,		I,	SIMD2)
			case M_ASSIGN_LEFT:
			CASE(C_CR, BITWISE_SHIFT_LEFT,	bitwise_shift_left,	I,	SIMD)
			case M_ASSIGN_RIGHT:
			CASE(C_CR, BITWISE_SHIFT_RIGHT,	bitwise_shift_right, I,	SIMD)
			CASE(R_CR, LOGIC_LESS,			logic_less,			O,	SIMD)
			CASE(R_CR, LOGIC_LESS_EQUAL,	logic_less_equal,	O,	SIMD)
			CASE(R_CR, LOGIC_GREATER,		logic_greater,		O,	SIMD)
			CASE(R_CR, LOGIC_GREATER_EQUAL,	logic_greater_equal, O,	SIMD)
			CASE(R_CR, LOGIC_EQUAL,			logic_equal,		O,	SIMD)
			CASE(R_CR, LOGIC_NOT_EQUAL,		logic_not_equal,	O,	SIMD)
			case M_ASSIGN_AND:
			CASE(C_CR, BITWISE_AND,			bitwise_and,		O,	SCALAR)
			CASE(C_CR, BITWISE_NAND,		bitwise_nand,		O,	SCALAR)
			case M_ASSIGN_XOR:
			CASE(C_CR, BITWISE_XOR,			bitwise_xor,		O,	SCALAR)
			CASE(C_CR, BITWISE_XNOR,		bitwise_xnor,		O,	SCALAR)
			case M_ASSIGN_OR:
			CASE_C_CR(VERTICAL_BAR,			bitwise_or, BITWISE_OR, O, SCALAR)
			CASE(C_CR, BITWISE_NOR,			bitwise_nor,		O,	SCALAR)
			CASE(C_CR, LOG,					log,				I,	SIMD)
			CASE_C_CR(RAND,					random, RANDOM,		O,	SCALAR)
			CASE(C_CR, ATAN,				atan,				I,	SIMD)
			CASE(C_CR, ATAND,				atand,				I,	SIMD)
			CASE(R_CR, SQWV,				sqwv,				O,	SIMD2)
			CASE(R_CR, TRWV,				trwv,				C,	SIMD2)
			CASE(R_CR, SAW,					saw,				I,	SIMD2)
			CASE(R_CR, MANDELBROT,			mandelbrot,			O,	SIMD)
			CASE(C_CR, MIN,					min,				C,	SIMD)
			CASE(C_CR, MAX,					max,				C,	SIMD)
			CASE_NONE(BETA)
			CASE_NONE(GAMMA)
			CASE(C_CR, PERMUTATION,			permutation,		I,	SCALAR)
			CASE(C_CR, COMBINATION,			combination,		I,	SCALAR)
			CASE_NONE(BESSEL_J)
			CASE_NONE(BESSEL_Y)
			CASE_NONE(HANKEL1)
			CASE(R_R, ASSIGN,				assign,				C,	SIMD)
			}
			break;
		case 'c':
			switch(f)
			{
			CASE_C_CC(POWER,				pow, POW,			I,	SIMD)
			case M_ASSIGN_DIVIDE:
			CASE(C_CC, DIVIDE,				divide,				I,	SIMD)
			CASE(R_CC, LOGIC_DIVIDES,		logic_divides,		O,	SIMD2)
			case M_ASSIGN_MINUS:
			CASE(C_CC, MINUS,				minus,				C,	SIMD)
			CASE_NONE(PENTATE)
			CASE(C_CC, TETRATE,				tetrate,			I,	SCALAR)
			case M_ASSIGN_MULTIPLY:
			CASE(C_CC, MULTIPLY,			multiply,			C,	SIMD)
			case M_ASSIGN_PLUS:
			CASE(C_CC, PLUS,				plus,				C,	SIMD)
			CASE(R_CC, LOGIC_AND,			logic_and,			O,	SIMD)
			CASE(R_CC, LOGIC_XOR,			logic_xor,			O,	SIMD)
			CASE(R_CC, LOGIC_OR,			logic_or,			O,	SIMD)
			CASE(C_CC, CONDITION_ZERO,		condition_zero,		I,	SIMD)
			case M_ASSIGN_MOD:
			CASE_C_CC(MODULO_PERCENT,		modulo, MODULO,		I,	SIMD2)
			case M_ASSIGN_LEFT:
			CASE(C_CC, BITWISE_SHIFT_LEFT,	bitwise_shift_left,	I,	SIMD)
			case M_ASSIGN_RIGHT:
			CASE(C_CC, BITWISE_SHIFT_RIGHT,	bitwise_shift_right, I,	SIMD)
			CASE(R_CC, LOGIC_LESS,			logic_less,			O,	SIMD)
			CASE(R_CC, LOGIC_LESS_EQUAL,	logic_less_equal,	O,	SIMD)
			CASE(R_CC, LOGIC_GREATER,		logic_greater,		O,	SIMD)
			CASE(R_CC, LOGIC_GREATER_EQUAL,	logic_greater_equal, O,	SIMD)
			CASE(R_CC, LOGIC_EQUAL,			logic_equal,		O,	SIMD)
			CASE(R_CC, LOGIC_NOT_EQUAL,		logic_not_equal,	O,	SIMD)
			case M_ASSIGN_AND:
			CASE(C_CC, BITWISE_AND,			bitwise_and,		O,	SCALAR)
			CASE(C_CC, BITWISE_NAND,		bitwise_nand,		O,	SCALAR)
			case M_ASSIGN_XOR:
			CASE(C_CC, BITWISE_XOR,			bitwise_xor,		O,	SCALAR)
			CASE(C_CC, BITWISE_XNOR,		bitwise_xnor,		O,	SCALAR)
			case M_ASSIGN_OR:
			CASE_C_CC(VERTICAL_BAR,			bitwise_or, BITWISE_OR, O,	SCALAR)
			CASE(C_CC, BITWISE_NOR,			bitwise_nor,		O,	SCALAR)
			CASE(C_CC, LOG,					log,				I,	SIMD)
			CASE_C_CC(RAND,					random, RANDOM,		O,	SCALAR)
			CASE(C_CC, ATAN,				atan,				I,	SIMD)
			CASE(C_CC, ATAND,				atand,				I,	SIMD)
			CASE(R_CC, SQWV,				sqwv,				O,	SIMD2)
			CASE(R_CC, TRWV,				trwv,				C,	SIMD2)
			CASE(R_CC, SAW,					saw,				I,	SIMD2)
			CASE(C_CC, MIN,					min,				C,	SIMD)
			CASE(C_CC, MAX,					max,				C,	SIMD)
			CASE_NONE(BETA)
			CASE_NONE(GAMMA)
			CASE(C_CC, PERMUTATION,			permutation,		I,	SCALAR)
			CASE(C_CC, COMBINATION,			combination,		I,	SCALAR)
			CASE_NONE(BESSEL_J)
			CASE_NONE(BESSEL_Y)
			CASE_NONE(HANKEL1)
			CASE(C_C, ASSIGN,				assign,				C,	SIMD)
			}
			break;
		case 'h':
			switch(f)
			{
			CASE_Q_CQ(POWER,				pow, POW,			I,	SIMD)
			case M_ASSIGN_DIVIDE:
			CASE(Q_CQ, DIVIDE,				divide,				I,	SIMD)
			CASE(R_CQ, LOGIC_DIVIDES,		logic_divides,		O,	SIMD2)
			case M_ASSIGN_MINUS:
			CASE(Q_CQ, MINUS,				minus,				C,	SIMD)
			CASE_NONE(PENTATE)
			CASE_NONE(TETRATE)
			case M_ASSIGN_MULTIPLY:
			CASE(Q_CQ, MULTIPLY,			multiply,			C,	SIMD)
			case M_ASSIGN_PLUS:
			CASE(Q_CQ, PLUS,				plus,				C,	SIMD)
			CASE(R_CQ, LOGIC_AND,			logic_and,			O,	SIMD)
			CASE(R_CQ, LOGIC_XOR,			logic_xor,			O,	SIMD)
			CASE(R_CQ, LOGIC_OR,			logic_or,			O,	SIMD)
			CASE(Q_CQ, CONDITION_ZERO,		condition_zero,		I,	SIMD)
			case M_ASSIGN_MOD:
			CASE_Q_CQ(MODULO_PERCENT,		modulo, MODULO,		I,	SIMD2)
			case M_ASSIGN_LEFT:
			CASE(Q_CQ, BITWISE_SHIFT_LEFT,	bitwise_shift_left,	I,	SIMD)
			case M_ASSIGN_RIGHT:
			CASE(Q_CQ, BITWISE_SHIFT_RIGHT,	bitwise_shift_right, I,	SIMD)
			CASE(R_CQ, LOGIC_LESS,			logic_less,			O,	SIMD)
			CASE(R_CQ, LOGIC_LESS_EQUAL,	logic_less_equal,	O,	SIMD)
			CASE(R_CQ, LOGIC_GREATER,		logic_greater,		O,	SIMD)
			CASE(R_CQ, LOGIC_GREATER_EQUAL,	logic_greater_equal, O,	SIMD)
			CASE(R_CQ, LOGIC_EQUAL,			logic_equal,		O,	SIMD)
			CASE(R_CQ, LOGIC_NOT_EQUAL,		logic_not_equal,	O,	SIMD)
			case M_ASSIGN_AND:
			CASE(Q_CQ, BITWISE_AND,			bitwise_and,		O,	SCALAR)
			CASE(Q_CQ, BITWISE_NAND,		bitwise_nand,		O,	SCALAR)
			case M_ASSIGN_XOR:
			CASE(Q_CQ, BITWISE_XOR,			bitwise_xor,		O,	SCALAR)
			CASE(Q_CQ, BITWISE_XNOR,		bitwise_xnor,		O,	SCALAR)
			case M_ASSIGN_OR:
			CASE_Q_CQ(VERTICAL_BAR,			bitwise_or, BITWISE_OR, O, SCALAR)
			CASE(Q_CQ, BITWISE_NOR,			bitwise_nor,		O,	SCALAR)
			CASE(Q_CQ, LOG,					log,				I,	SIMD)
			CASE_Q_QQ(RAND,					random, RANDOM,		O,	SCALAR)
		//	CASE_Q_CQ(RAND,					random, RANDOM,		O,	SCALAR)
			CASE(Q_CQ, ATAN,				atan,				I,	SIMD)
			CASE(Q_CQ, ATAND,				atand,				I,	SIMD)
			CASE(R_CQ, SQWV,				sqwv,				O,	SIMD2)
			CASE(R_CQ, TRWV,				trwv,				C,	SIMD2)
			CASE(R_CQ, SAW,					saw,				I,	SIMD2)
		//	CASE(Q_CQ, MIN,					min,				C,	SCALAR)
			CASE(Q_QQ, MIN,					min,				C,	SIMD)
		//	CASE(Q_CQ, MAX,					max,				C,	SCALAR)
			CASE(Q_QQ, MAX,					max,				C,	SIMD)
			CASE_NONE(BETA)
			CASE_NONE(GAMMA)
		//	CASE(Q_CQ, PERMUTATION,			permutation,		I,	SCALAR)
			CASE(Q_QQ, PERMUTATION,			permutation,		I,	SCALAR)
		//	CASE(Q_CQ, COMBINATION,			combination,		I,	SCALAR)
			CASE(Q_QQ, COMBINATION,			combination,		I,	SCALAR)
			CASE_NONE(BESSEL_J)
			CASE_NONE(BESSEL_Y)
			CASE_NONE(HANKEL1)
			CASE(Q_Q, ASSIGN,				assign,				C,	SIMD)
			}
			break;
		}
	case 'h':
		switch(op2type)
		{
		case 'R':
			switch(f)
			{
			CASE_Q_QR(POWER,				pow, POW,			I,	SIMD)
			case M_ASSIGN_DIVIDE:
			CASE(Q_QR, DIVIDE,				divide,				I,	SIMD)
			CASE(R_QR, LOGIC_DIVIDES,		logic_divides,		O,	SIMD2)
			case M_ASSIGN_MINUS:
			CASE(Q_QR, MINUS,				minus,				C,	SIMD)
			CASE_NONE(PENTATE)
			CASE(Q_QR, TETRATE,				tetrate,			I,	SCALAR)
			CASE(Q_QR, POWER_REAL,			power_real,			I,	SCALAR)
			case M_ASSIGN_MULTIPLY:
			CASE(Q_QR, MULTIPLY,			multiply,			C,	SIMD)
			case M_ASSIGN_PLUS:
			CASE(Q_QR, PLUS,				plus,				C,	SIMD)
			CASE(R_QR, LOGIC_AND,			logic_and,			O,	SIMD)
			CASE(R_QR, LOGIC_XOR,			logic_xor,			O,	SIMD)
			CASE(R_QR, LOGIC_OR,			logic_or,			O,	SIMD)
			CASE(Q_QR, CONDITION_ZERO,		condition_zero,		I,	SIMD)
			case M_ASSIGN_MOD:
			CASE_Q_QR(MODULO_PERCENT,		modulo, MODULO,		I,	SIMD2)
			case M_ASSIGN_LEFT:
			CASE(Q_QR, BITWISE_SHIFT_LEFT,	bitwise_shift_left,	I,	SIMD)
			case M_ASSIGN_RIGHT:
			CASE(Q_QR, BITWISE_SHIFT_RIGHT,	bitwise_shift_right, I,	SIMD)
			CASE(R_QR, LOGIC_LESS,			logic_less,			O,	SIMD)
			CASE(R_QR, LOGIC_LESS_EQUAL,	logic_less_equal,	O,	SIMD)
			CASE(R_QR, LOGIC_GREATER,		logic_greater,		O,	SIMD)
			CASE(R_QR, LOGIC_GREATER_EQUAL,	logic_greater_equal, O,	SIMD)
			CASE(R_QR, LOGIC_EQUAL,			logic_equal,		O,	SIMD)
			CASE(R_QR, LOGIC_NOT_EQUAL,		logic_not_equal,	O,	SIMD)
			case M_ASSIGN_AND:
			CASE(Q_QR, BITWISE_AND,			bitwise_and,		O,	SCALAR)
			CASE(Q_QR, BITWISE_NAND,		bitwise_nand,		O,	SCALAR)
			case M_ASSIGN_XOR:
			CASE(Q_QR, BITWISE_XOR,			bitwise_xor,		O,	SCALAR)
			CASE(Q_QR, BITWISE_XNOR,		bitwise_xnor,		O,	SCALAR)
			case M_ASSIGN_OR:
			CASE_Q_QR(VERTICAL_BAR,			bitwise_or, BITWISE_OR, O, SCALAR)
			CASE(Q_QR, BITWISE_NOR,			bitwise_nor,		O,	SCALAR)
			CASE(Q_QC, LOG,					log,				I,	SIMD)
			CASE_Q_QQ(RAND,					random, RANDOM,		O,	SCALAR)
		//	CASE_Q_QR(RAND,					random, RANDOM,		O,	SCALAR)
			CASE(Q_QR, ATAN,				atan,				I,	SIMD)
			CASE(Q_QR, ATAND,				atand,				I,	SIMD)
			CASE(R_QR, SQWV,				sqwv,				O,	SIMD2)
			CASE(R_QR, TRWV,				trwv,				C,	SIMD2)
			CASE(R_QR, SAW,					saw,				I,	SIMD2)
		//	CASE(Q_QR, MIN,					min,				C,	SIMD)
			CASE(Q_QQ, MIN,					min,				C,	SIMD)
		//	CASE(Q_QR, MAX,					max,				C,	SIMD)
			CASE(Q_QQ, MAX,					max,				C,	SIMD)
			CASE_NONE(BETA)
			CASE_NONE(GAMMA)
		//	CASE(Q_QR, PERMUTATION,			permutation,		I,	SCALAR)
			CASE(Q_QQ, PERMUTATION,			permutation,		I,	SCALAR)
		//	CASE(Q_QR, COMBINATION,			combination,		I,	SCALAR)
			CASE(Q_QQ, COMBINATION,			combination,		I,	SCALAR)
			CASE_NONE(BESSEL_J)
			CASE_NONE(BESSEL_Y)
			CASE_NONE(HANKEL1)
			CASE(R_R, ASSIGN,				assign,				C,	SIMD)
			}
			break;
		case 'c':
			switch(f)
			{
			CASE_Q_QC(POWER,				pow, POW,			I,	SIMD)
			case M_ASSIGN_DIVIDE:
			CASE(Q_QC, DIVIDE,				divide,				I,	SIMD)
			CASE(R_QC, LOGIC_DIVIDES,		logic_divides,		O,	SIMD2)
			case M_ASSIGN_MINUS:
			CASE(Q_QC, MINUS,				minus,				C,	SIMD)
			CASE_NONE(PENTATE)
			CASE_NONE(TETRATE)
			case M_ASSIGN_MULTIPLY:
			CASE(Q_QC, MULTIPLY,			multiply,			C,	SIMD)
			case M_ASSIGN_PLUS:
			CASE(Q_QC, PLUS,				plus,				C,	SIMD)
			CASE(R_QC, LOGIC_AND,			logic_and,			O,	SIMD)
			CASE(R_QC, LOGIC_XOR,			logic_xor,			O,	SIMD)
			CASE(R_QC, LOGIC_OR,			logic_or,			O,	SIMD)
			CASE(Q_QC, CONDITION_ZERO,		condition_zero,		I,	SIMD)
			case M_ASSIGN_MOD:
			CASE_Q_QC(MODULO_PERCENT,		modulo, MODULO,		I,	SIMD2)
			case M_ASSIGN_LEFT:
			CASE(Q_QC, BITWISE_SHIFT_LEFT,	bitwise_shift_left,	I,	SIMD)
			case M_ASSIGN_RIGHT:
			CASE(Q_QC, BITWISE_SHIFT_RIGHT,	bitwise_shift_right, I, SIMD)
			CASE(R_QC, LOGIC_LESS,			logic_less,			O,	SIMD)
			CASE(R_QC, LOGIC_LESS_EQUAL,	logic_less_equal,	O,	SIMD)
			CASE(R_QC, LOGIC_GREATER,		logic_greater,		O,	SIMD)
			CASE(R_QC, LOGIC_GREATER_EQUAL,	logic_greater_equal, O, SIMD)
			CASE(R_QC, LOGIC_EQUAL,			logic_equal,		O,	SIMD)
			CASE(R_QC, LOGIC_NOT_EQUAL,		logic_not_equal,	O,	SIMD)
			case M_ASSIGN_AND:
			CASE(Q_QC, BITWISE_AND,			bitwise_and,		O,	SCALAR)
			CASE(Q_QC, BITWISE_NAND,		bitwise_nand,		O,	SCALAR)
			case M_ASSIGN_XOR:
			CASE(Q_QC, BITWISE_XOR,			bitwise_xor,		O,	SCALAR)
			CASE(Q_QC, BITWISE_XNOR,		bitwise_xnor,		O,	SCALAR)
			case M_ASSIGN_OR:
			CASE_Q_QC(VERTICAL_BAR,			bitwise_or, BITWISE_OR, O, SCALAR)
			CASE(Q_QC, BITWISE_NOR,			bitwise_nor,		O,	SCALAR)
			CASE(Q_QC, LOG,					log,				I,	SIMD)
			CASE_Q_QQ(RAND,					random, RANDOM,		O,	SCALAR)
		//	CASE_Q_QC(RAND,					random, RANDOM,		O,	SCALAR)
			CASE(Q_QC, ATAN,				atan,				I,	SIMD)
			CASE(Q_QC, ATAND,				atand,				I,	SIMD)
			CASE(R_QC, SQWV,				sqwv,				O,	SIMD2)
			CASE(R_QC, TRWV,				trwv,				C,	SIMD2)
			CASE(R_QC, SAW,					saw,				I,	SIMD2)
		//	CASE(Q_QC, MIN,					min,				C,	SIMD)
			CASE(Q_QQ, MIN,					min,				C,	SIMD)
		//	CASE(Q_QC, MAX,					max,				C,	SIMD)
			CASE(Q_QQ, MAX,					max,				C,	SIMD)
			CASE_NONE(BETA)
			CASE_NONE(GAMMA)
		//	CASE(Q_QC, PERMUTATION,			permutation,		I,	SCALAR)
			CASE(Q_QQ, PERMUTATION,			permutation,		I,	SCALAR)
		//	CASE(Q_QC, COMBINATION,			combination,		I,	SCALAR)
			CASE(Q_QQ, COMBINATION,			combination,		I,	SCALAR)
			CASE_NONE(BESSEL_J)
			CASE_NONE(BESSEL_Y)
			CASE_NONE(HANKEL1)
			CASE(C_C, ASSIGN,				assign,				C,	SIMD)
			}
			break;
		case 'h':
			switch(f)
			{
			CASE_Q_QQ(POWER,				pow, POW,			I,	SIMD)
			case M_ASSIGN_DIVIDE:
			CASE(Q_QQ, DIVIDE,				divide,				I,	SIMD)
			CASE(R_QQ, LOGIC_DIVIDES,		logic_divides,		O,	SIMD2)
			case M_ASSIGN_MINUS:
			CASE(Q_QQ, MINUS,				minus,				C,	SIMD)
			CASE_NONE(PENTATE)
			CASE_NONE(TETRATE)
			case M_ASSIGN_MULTIPLY:
			CASE(Q_QQ, MULTIPLY,			multiply,			C,	SIMD)
			case M_ASSIGN_PLUS:
			CASE(Q_QQ, PLUS,				plus,				C,	SIMD)
			CASE(R_QQ, LOGIC_AND,			logic_and,			O,	SIMD)
			CASE(R_QQ, LOGIC_XOR,			logic_xor,			O,	SIMD)
			CASE(R_QQ, LOGIC_OR,			logic_or,			O,	SIMD)
			CASE(Q_QQ, CONDITION_ZERO,		condition_zero,		I,	SIMD)
			case M_ASSIGN_MOD:
			CASE_Q_QQ(MODULO_PERCENT,		modulo, MODULO,		I,	SIMD2)
			case M_ASSIGN_LEFT:
			CASE(Q_QQ, BITWISE_SHIFT_LEFT,	bitwise_shift_left,	I,	SIMD)
			case M_ASSIGN_RIGHT:
			CASE(Q_QQ, BITWISE_SHIFT_RIGHT,	bitwise_shift_right, I, SIMD)
			CASE(R_QQ, LOGIC_LESS,			logic_less,			O,	SIMD)
			CASE(R_QQ, LOGIC_LESS_EQUAL,	logic_less_equal,	O,	SIMD)
			CASE(R_QQ, LOGIC_GREATER,		logic_greater,		O,	SIMD)
			CASE(R_QQ, LOGIC_GREATER_EQUAL,	logic_greater_equal, O, SIMD)
			CASE(R_QQ, LOGIC_EQUAL,			logic_equal,		O,	SIMD)
			CASE(R_QQ, LOGIC_NOT_EQUAL,		logic_not_equal,	O,	SIMD)
			case M_ASSIGN_AND:
			CASE(Q_QQ, BITWISE_AND,			bitwise_and,		O,	SCALAR)
			CASE(Q_QQ, BITWISE_NAND,		bitwise_nand,		O,	SCALAR)
			case M_ASSIGN_XOR:
			CASE(Q_QQ, BITWISE_XOR,			bitwise_xor,		O,	SCALAR)
			CASE(Q_QQ, BITWISE_XNOR,		bitwise_xnor,		O,	SCALAR)
			case M_ASSIGN_OR:
			CASE_Q_QQ(VERTICAL_BAR,			bitwise_or, BITWISE_OR, O, SCALAR)
			CASE(Q_QQ, BITWISE_NOR,			bitwise_nor,		O,	SCALAR)
			CASE(Q_QQ, LOG,					log,				I,	SIMD)
			CASE_Q_QQ(RAND,					random, RANDOM,		O,	SCALAR)
			CASE(Q_QQ, ATAN,				atan,				I,	SIMD)
			CASE(Q_QQ, ATAND,				atand,				I,	SIMD)
			CASE(R_QQ, SQWV,				sqwv,				O,	SIMD2)
			CASE(R_QQ, TRWV,				trwv,				C,	SIMD2)
			CASE(R_QQ, SAW,					saw,				I,	SIMD2)
			CASE(Q_QQ, MIN,					min,				C,	SIMD)
			CASE(Q_QQ, MAX,					max,				C,	SIMD)
			CASE_NONE(BETA)
			CASE_NONE(GAMMA)
			CASE(Q_QQ, PERMUTATION,			permutation,		I,	SCALAR)
			CASE(Q_QQ, COMBINATION,			combination,		I,	SCALAR)
			CASE_NONE(BESSEL_J)
			CASE_NONE(BESSEL_Y)
			CASE_NONE(HANKEL1)
			CASE(Q_Q, ASSIGN,				assign,				C,	SIMD)
			}
			break;
		}
		break;
	}
}
//void			Compile::compile_instruction_select_t	(int f, char op1type, char op2type, char op3type, FPSetter &function, int &signature, DiscontinuityFunction &d, int &cl_idx, int &cl_disc_idx)
//{
//	using namespace G2;
//	switch(f)
//	{
//	case M_CLAMP:
//		function.set(
//		signature=SIG_CLAMP;
//		d();
//		cl_idx=0, disc_cl_idx=0;
//		break;
//	}
//}
void			Compile::compile_instruction_select_v	(int f, FPSetter &function, DiscontinuityFunction &d, int &cl_idx, int &cl_disc_idx)
{
	using namespace G2;//all variadic functions except gcd are continuous
	switch(f)
	{
	case M_CLAMP:
		function.set(SIMD(va_clamp));
		d();
		cl_idx=0, cl_disc_idx=0;//
		break;
	case M_MIN:
		function.set(SIMD(va_min));
		d();
		cl_idx=0, cl_disc_idx=0;//
		break;
	case M_MAX:
		function.set(SIMD(va_max));
		d();
		cl_idx=0, cl_disc_idx=0;//
		break;
	case M_AV:
		function.set(SIMD(va_average));
		d();
		cl_idx=0, cl_disc_idx=0;//
		break;
	case M_HYPOT:
		function.set(SIMD(va_hypot));
		d();
		cl_idx=0, cl_disc_idx=0;//
		break;
	case M_NORM:
		function.set(SIMD(va_norm));
		d();
		cl_idx=0, cl_disc_idx=0;//
		break;
	case M_GCD:
		function.set(SCALAR(va_gcd));
		d();
		cl_idx=0, cl_disc_idx=0;//
		break;
	}
}
void			Compile::compile_instruction_u			(int f, char side, int a1, bool assign)
{
	int result;
	int op=expr->m[a1]._1;
	if(procedural&&term[op].fresh&&(expr->n[op].constant||!assign))
	{
		char mathSet='R';
		expr->insertData(mathSet);//constant but doesn't matter
		result=expr->n.size()-1;
		bool constant=expr->n[result].constant=expr->n[op].constant;
		term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm));
		term[result]=CompileTerm(constant, mathSet, false);
	}
	else
		result=op;
	char op_ms=term[op].mathSet;
	FPSetter function;
	int signature=0;
//	char (*umts)(char);
	DiscontinuityFunction d;
	int cl_idx=0, disc_cl_idx=0;
	compile_instruction_select_u(f, side, term[op].mathSet, function, signature, d, cl_idx, disc_cl_idx);
//	compile_instruction_select_u(f, side, term[op].mathSet, function, umts, d);
	if(function.ia32.r_r)
	{
		char resultMathSet=returnMathSet_from_signature(signature, term[op].mathSet);
	//	char resultMathSet=umts(term[op].mathSet);
		if(!procedural||!term[result].fresh||!term[result].constant&&term[result].mathSet>resultMathSet)//'R' < 'c'
			term[result].mathSet=resultMathSet;
		if(term[op].constant||function.type==-1)
		{
			Value x=expr->data[op];
		//	PseudoQuaternion x;
		//	auto LOL_1=&x.r, LOL_2=&x.i, LOL_3=&x.j, LOL_4=&x.k;
		//	x=expr->data[op];
			VectP rr(&x.r);
			CompP cr(&x.r, &x.i);
			QuatP qr(&x.r, &x.i, &x.j, &x.k);
			switch(function.type)
			{
			case  1:function.ia32.r_r(rr, VectP(&x.r));						break;//r_r
			case  2:function.ia32.c_c(cr, CompP(&x.r, &x.i));				break;//c_c
			case  3:function.ia32.q_q(qr, QuatP(&x.r, &x.i, &x.j, &x.k));	break;//q_q
			//case  4:break;//r_rr
			//case  5:break;//c_rc
			//case  6:break;//q_rq
			//case  7:break;//c_cr
			//case  8:break;//c_cc
			//case  9:break;//q_cq
			//case 10:break;//q_qr
			//case 11:break;//q_qc
			//case 12:break;//q_qq
			case 13:function.ia32.c_r(cr, VectP(&x.r));						break;//c_r
			case 14:function.ia32.c_q(cr, QuatP(&x.r, &x.i, &x.j, &x.k));	break;//c_q +
			case 15:function.ia32.r_c(rr, CompP(&x.r, &x.i));				break;//r_c +
			case 16:function.ia32.r_q(rr, QuatP(&x.r, &x.i, &x.j, &x.k));	break;//r_q +
			}
			expr->data[result]=x;
		//	expr->data[result]=function(expr->data[op]);
			term[result].constant=true;
		}
		else
		{
			expr->i.push_back(Instruction(function, op, op_ms, result, resultMathSet, d, cl_idx, disc_cl_idx));
		//	expr->i.push_back(Instruction(function, umts, op, result, d));
		}
		expr->ni.push_back(MP::Instruction(function, op, op_ms, result, resultMathSet));
		auto &ms=expr->n[result].mathSet;
		ms=maximum(ms, term[result].mathSet);
		expr->resultTerm=result;
	}
	expr->m[a1]._1=result;
}
void			Compile::compile_instruction_b			(int f, int a1, int a2, bool assign)
//int					Compile::compile_instruction_b			(int f, int a1, int a2, bool assign)
//int				Compile::compile_instruction_b			(int f, int _op1, int _op2, bool r_op1, bool _1procVar, bool _2procVar)//r: resultGoesTo_op1=r_op1||op1<op2, 1: resultGoesTo_op1=true, 2: resultGoesTo_op1=false
//int				Compile::compile_instruction_b			(int f, int _op1, int _op2, bool r_op1, bool r_op2)//r: resultGoesTo_op1=r_op1||op1<op2, 1: resultGoesTo_op1=true, 2: resultGoesTo_op1=false
//int				Compile::compile_instruction_b			(int f, int _op1, int _op2, char r_op1)//r: 0: resultGoesTo_op1=op1<op2, 1: resultGoesTo_op1=true, 2: resultGoesTo_op1=false
{
	int op1=expr->m[a1]._1, op2=expr->m[a2]._1, result;
	char op1_ms=term[op1].mathSet, op2_ms=term[op2].mathSet;
	FPSetter function;
	int signature=0;
//	char (*bmts)(char, char);
	DiscontinuityFunction d;
	int cl_idx=0, disc_cl_idx=0;
	compile_instruction_select_b(f, op1_ms, op2_ms, function, signature, d, cl_idx, disc_cl_idx);
//	compile_instruction_select_b(f, op1_ms, op2_ms, function, bmts, d);
	if(function.ia32.r_rr)
	{
		if(procedural)
		{
			if(term[op1].fresh&&(expr->n[op1].constant||!assign))
			{
				if(term[op2].fresh)
				{
					char mathSet='R';
					expr->insertData(mathSet);
					result=expr->n.size()-1;
					bool constant=expr->n.rbegin()->constant=expr->n[op1].constant&&expr->n[op2].constant;
					term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm));
					term[result]=CompileTerm(constant, mathSet, false);
				}
				else
					result=op2;
			}
			else
				result=op1;
		}
		else
			result=(function.type==5)|(function.type==6)|(function.type==9)?op2:op1;
	//	expr->m[a2]._1=result;
		
		char resultMathSet=returnMathSet_from_signature(signature, op1_ms, op2_ms);
	//	char resultMathSet=bmts(op1_ms, op2_ms);
		if(!procedural||!term[result].fresh||!term[result].constant&&term[result].mathSet>resultMathSet)//'R' < 'c'
			term[result].mathSet=resultMathSet;
	//	term[result].mathSet=bmts(term[op1].mathSet, term[op2].mathSet);
		if(term[op1].constant&&term[op2].constant)
		{
			Value x=expr->data[op1], y=expr->data[op2];
			VectP rr(&x.r);
			CompP cr(&x.r, &x.i);
			QuatP qr(&x.r, &x.i, &x.j, &x.k);
			switch(function.type)
			{
			//case  1:function.ia32.r_r(rr,	VectP(&x.r));					break;//r_r
			//case  2:function.ia32.c_c(cr,	CompP(&x.r, &x.i));				break;//c_c
			//case  3:function.ia32.q_q(qr,	QuatP(&x.r, &x.i, &x.j, &x.k));	break;//q_q
			case  4:function.ia32.r_rr(rr,	VectP(&x.r),					VectP(&y.r));					break;//r_rr
			case  5:function.ia32.c_rc(cr,	VectP(&x.r),					CompP(&y.r, &y.i));				break;//c_rc
			case  6:function.ia32.q_rq(qr,	VectP(&x.r),					QuatP(&y.r, &y.i, &y.j, &y.k));	break;//q_rq
			case  7:function.ia32.c_cr(cr,	CompP(&x.r, &x.i),				VectP(&y.r));					break;//c_cr
			case  8:function.ia32.c_cc(cr,	CompP(&x.r, &x.i),				CompP(&y.r, &y.i));				break;//c_cc
			case  9:function.ia32.q_cq(qr,	CompP(&x.r, &x.i),				QuatP(&y.r, &y.i, &y.j, &y.k));	break;//q_cq
			case 10:function.ia32.q_qr(qr,	QuatP(&x.r, &x.i, &x.j, &x.k),	VectP(&y.r));					break;//q_qr
			case 11:function.ia32.q_qc(qr,	QuatP(&x.r, &x.i, &x.j, &x.k),	CompP(&y.r, &y.i));				break;//q_qc
			case 12:function.ia32.q_qq(qr,	QuatP(&x.r, &x.i, &x.j, &x.k),	QuatP(&y.r, &y.i, &y.j, &y.k));	break;//q_qq
			//case 13:function.ia32.c_r(cr,	VectP(&x.r));					break;//c_r
			//case 14:function.ia32.c_q(cr,	QuatP(&x.r, &x.i, &x.j, &x.k));	break;//c_q +
			//case 15:function.ia32.r_c(rr,	CompP(&x.r, &x.i));				break;//r_c +
			//case 16:function.ia32.r_q(rr,	QuatP(&x.r, &x.i, &x.j, &x.k));	break;//r_q +
			case 17:function.ia32.c_rr(cr,	VectP(&x.r),					VectP(&y.r));					break;//c_rr
			case 18:function.ia32.r_rc(rr,	VectP(&x.r),					CompP(&y.r, &y.i));				break;//r_rc
			case 19:function.ia32.r_rq(rr,	VectP(&x.r),					QuatP(&y.r, &y.i, &y.j, &y.k));	break;//r_rq
			case 20:function.ia32.r_cr(rr,	CompP(&x.r, &x.i),				VectP(&y.r));					break;//r_cr
			case 21:function.ia32.r_cc(rr,	CompP(&x.r, &x.i),				CompP(&y.r, &y.i));				break;//r_cc
			case 22:function.ia32.r_cq(rr,	CompP(&x.r, &x.i),				QuatP(&y.r, &y.i, &y.j, &y.k));	break;//r_cq
			case 23:function.ia32.r_qr(rr,	QuatP(&x.r, &x.i, &x.j, &x.k),	VectP(&y.r));					break;//r_qr
			case 24:function.ia32.r_qc(rr,	QuatP(&x.r, &x.i, &x.j, &x.k),	CompP(&y.r, &y.i));				break;//r_qc
			case 25:function.ia32.r_qq(rr,	QuatP(&x.r, &x.i, &x.j, &x.k),	QuatP(&y.r, &y.i, &y.j, &y.k));	break;//r_qq
			case 26:function.ia32.c_qc(cr,	QuatP(&x.r, &x.i, &x.j, &x.k),	CompP(&y.r, &y.i));				break;//c_qc
			}
			expr->data[result]=x;
			//if(other)
			//	expr->m[a1]._1=expr->m[a2]._1;
			//else
			//	expr->m[a2]._1=expr->m[a1]._1;
		//	expr->data[result]=function(expr->data[op1], expr->data[op2]);
		}
		else
		{
			expr->i.push_back(Instruction(function, op1, op1_ms, op2, op2_ms, result, resultMathSet, d, cl_idx, disc_cl_idx));
			term[result].constant=false;
		//	expr->i.push_back(Instruction(function, bmts, op1, op2, result, d)), term[result].constant=false;
		}
		expr->ni.push_back(MP::Instruction(function, op1, op1_ms, op2, op2_ms, result, resultMathSet));
		auto &ms=expr->n[result].mathSet;
		ms=maximum(ms, term[result].mathSet);
		expr->resultTerm=result;
	}
	expr->m[a1]._1=result, expr->m[a2]._0=G2::M_IGNORED;
}
void			Compile::compile_instruction_b2			(int f, int op1, int _op2)//M_ASSIGN n[op1]=m[n[_op2]], no m link removal
{
	int op2=expr->m[_op2]._1;
	int result=op1;//assign only
	FPSetter function;
	int signature=0;
//	char (*bmts)(char, char);
	DiscontinuityFunction d;
	int cl_idx=0, disc_cl_idx=0;
	char op1_ms=term[op1].mathSet, op2_ms=term[op2].mathSet, resultMathSet=op2_ms;
	compile_instruction_select_b(f, op1_ms, op2_ms, function, signature, d, cl_idx, disc_cl_idx);
//	compile_instruction_select_b(f, op1_ms, op2_ms, function, bmts, d);
	if(function.ia32.r_rr)
	{
		term[result].mathSet=returnMathSet_from_signature(signature, op1_ms, op2_ms);
	//	term[result].mathSet=bmts(term[op1].mathSet, term[op2].mathSet);
		if(term[op1].constant&&term[op2].constant)
		{
			Value x=expr->data[op1], y=expr->data[op2];
		//	PseudoQuaternion x=expr->data[op1], y=expr->data[op2];
			VectP rr(&x.r);
			CompP cr(&x.r, &x.i);
			QuatP qr(&x.r, &x.i, &x.j, &x.k);
			switch(function.type)
			{
			case  1:function.ia32.r_r(rr,	VectP(&x.r));					break;//r_r
			case  2:function.ia32.c_c(cr,	CompP(&x.r, &x.i));				break;//c_c
			case  3:function.ia32.q_q(qr,	QuatP(&x.r, &x.i, &x.j, &x.k));	break;//q_q
			//case  4:function.ia32.r_rr(rr,	VectP(&x.r),					VectP(&y.r));					break;//r_rr
			//case  5:function.ia32.c_rc(cr,	VectP(&x.r),					CompP(&y.r, &y.i));				break;//c_rc
			//case  6:function.ia32.q_rq(qr,	VectP(&x.r),					QuatP(&y.r, &y.i, &y.j, &y.k));	break;//q_rq
			//case  7:function.ia32.c_cr(cr,	CompP(&x.r, &x.i),				VectP(&y.r));					break;//c_cr
			//case  8:function.ia32.c_cc(cr,	CompP(&x.r, &x.i),				CompP(&y.r, &y.i));				break;//c_cc
			//case  9:function.ia32.q_cq(qr,	CompP(&x.r, &x.i),				QuatP(&y.r, &y.i, &y.j, &y.k));	break;//q_cq
			//case 10:function.ia32.q_qr(qr,	QuatP(&x.r, &x.i, &x.j, &x.k),	VectP(&y.r));					break;//q_qr
			//case 11:function.ia32.q_qc(qr,	QuatP(&x.r, &x.i, &x.j, &x.k),	CompP(&y.r, &y.i));				break;//q_qc
			//case 12:function.ia32.q_qq(qr,	QuatP(&x.r, &x.i, &x.j, &x.k),	QuatP(&y.r, &y.i, &y.j, &y.k));	break;//q_qq
			//case 13:function.ia32.c_r(cr,		VectP(&x.r));					break;//c_r
			//case 14:function.ia32.c_q(cr,		QuatP(&x.r, &x.i, &x.j, &x.k));	break;//c_q +
			//case 15:function.ia32.r_c(rr,		CompP(&x.r, &x.i));				break;//r_c +
			//case 16:function.ia32.r_q(rr,		QuatP(&x.r, &x.i, &x.j, &x.k));	break;//r_q +
			//case 17:function.ia32.c_rr(cr,	VectP(&x.r),					VectP(&y.r));					break;//c_rr
			//case 18:function.ia32.r_rc(rr,	VectP(&x.r),					CompP(&y.r, &y.i));				break;//r_rc
			//case 19:function.ia32.r_rq(rr,	VectP(&x.r),					QuatP(&y.r, &y.i, &y.j, &y.k));	break;//r_rq
			//case 20:function.ia32.r_cr(rr,	CompP(&x.r, &x.i),				VectP(&y.r));					break;//r_cr
			//case 21:function.ia32.r_cc(rr,	CompP(&x.r, &x.i),				CompP(&y.r, &y.i));				break;//r_cc
			//case 22:function.ia32.r_cq(rr,	CompP(&x.r, &x.i),				QuatP(&y.r, &y.i, &y.j, &y.k));	break;//r_cq
			//case 23:function.ia32.r_qr(rr,	QuatP(&x.r, &x.i, &x.j, &x.k),	VectP(&y.r));					break;//r_qr
			//case 24:function.ia32.r_qc(rr,	QuatP(&x.r, &x.i, &x.j, &x.k),	CompP(&y.r, &y.i));				break;//r_qc
			//case 25:function.ia32.r_qq(rr,	QuatP(&x.r, &x.i, &x.j, &x.k),	QuatP(&y.r, &y.i, &y.j, &y.k));	break;//r_qq
			//case 26:function.ia32.c_qc(cr,	QuatP(&x.r, &x.i, &x.j, &x.k),	CompP(&y.r, &y.i));				break;//c_qc
			}
			expr->data[result]=x;
		//	expr->data[result]=function(expr->data[op1], expr->data[op2]);
		}
		else
		{
			//if(function.type==5||function.type==6||function.type==9)
			//	std::swap(expr->m[a1]._1, expr->m[a2]._1);
			if(op2!=result)
				expr->i.push_back(Instruction(function, op2, op2_ms, result, resultMathSet, d, cl_idx, disc_cl_idx));
		//	expr->i.push_back(Instruction(function, op1, op1_ms, op2, op2_ms, result, resultMathSet, d));
			term[result].constant=false;
		//	expr->i.push_back(Instruction(function, bmts, op1, op2, result, d)), term[result].constant=false;
		}
		expr->ni.push_back(MP::Instruction(function, op2, op2_ms, result, resultMathSet));
		auto &ms=expr->n[result].mathSet;
		ms=maximum(ms, term[result].mathSet);
		expr->resultTerm=result;
	}
}
void			Compile::compile_instruction_condition_111	(int op1, int op2, int op3)
{
	using namespace G2;
	int result=op1;
	char op1_ms=term[op1].mathSet, op2_ms=term[op2].mathSet, op3_ms=term[op3].mathSet, resultMathSet=term[op1].mathSet=maximum(op2_ms, op3_ms);
	if(term[op1].constant&&term[op2].constant&&term[op3].constant)
	{
		expr->data[op1]=expr->data[op1].q_isTrue()?expr->data[op2]:expr->data[op3];
		expr->n[op1].mathSet=term[op1].mathSet;
	}
	else
	{
		expr->i.push_back(Instruction(op1, op1_ms, op2, op2_ms, op3, op3_ms, result, resultMathSet, DiscontinuityFunction(disc_conditional_111_i), CONDITIONAL_111, DISC_CONDITIONAL_111_I));
		term[op1].constant=false;
	//	expr->i.push_back(Instruction(conditional_111, returns_conditional, op1, op2, op3, result, DiscontinuityFunction(disc_conditional_111_i))), term[result].constant=false;
	}
	expr->ni.push_back(MP::Instruction(op1, op1_ms, op2, op2_ms, op3, op3_ms, result, resultMathSet));
}
void			Compile::compile_instruction_condition_110	(int op1, int op2)//*op1 ? *op2 : 0
{
	using namespace G2;
	int result=op2;//
	char op1_ms=term[op1].mathSet, op2_ms=term[op2].mathSet, resultMathSet=op2_ms;//
	term[op1].mathSet=op2_ms;
	FPSetter fp;
	int cl_idx=0;
		 if(op1_ms=='R'){	 if(op2_ms=='R')fp.set(SIMD(r_rr_conditional_110)), cl_idx=R_RR_CONDITIONAL_110;
						else if(op2_ms=='c')fp.set(SIMD(c_rc_conditional_110)), cl_idx=C_RC_CONDITIONAL_110;
						else				fp.set(SIMD(q_rq_conditional_110)), cl_idx=Q_RQ_CONDITIONAL_110;}
	else if(op1_ms=='c'){	 if(op2_ms=='R')fp.set(SIMD(r_cr_conditional_110)), cl_idx=R_CR_CONDITIONAL_110;
						else if(op2_ms=='c')fp.set(SIMD(c_cc_conditional_110)), cl_idx=C_CC_CONDITIONAL_110;
						else				fp.set(SIMD(q_cq_conditional_110)), cl_idx=Q_CQ_CONDITIONAL_110;}
	else if(op1_ms=='h'){	 if(op2_ms=='R')fp.set(SIMD(r_qr_conditional_110)), cl_idx=R_QR_CONDITIONAL_110;
						else if(op2_ms=='c')fp.set(SIMD(c_qc_conditional_110)), cl_idx=C_QC_CONDITIONAL_110;
						else				fp.set(SIMD(q_qq_conditional_110)), cl_idx=Q_QQ_CONDITIONAL_110;}
	if(term[op1].constant&&term[op2].constant)
	{
		expr->data[op1]=expr->data[op1].q_isTrue()?expr->data[op2]:MP::Quat();
	//	expr->data[op1]=conditional_110(expr->data[op1], expr->data[op2]);
		expr->n[op1].mathSet=term[op1].mathSet;
	}
	else
	{
		expr->i.push_back(Instruction(fp, op1, op1_ms, op2, op2_ms, result, resultMathSet, DiscontinuityFunction(disc_conditional_110_i), cl_idx, DISC_CONDITIONAL_110_I));
		term[op1].constant=false;
	//	expr->i.push_back(Instruction(conditional_110, returns_rrr_ccc_qqq, op1, op2, result, DiscontinuityFunction(disc_conditional_110_i))), term[result].constant=false;
	}
	expr->ni.push_back(MP::Instruction(fp, op1, op1_ms, op2, op2_ms, result, resultMathSet));
}
void			Compile::compile_instruction_condition_101	(int op1, int op3)//*op1 ? 0 : *op3
{
	using namespace G2;
	int result=op3;
	char op1_ms=term[op1].mathSet, op3_ms=term[op3].mathSet, resultMathSet=op3_ms;
	term[op1].mathSet=op3_ms;
	FPSetter fp;
	int cl_idx=0;
		 if(op1_ms=='R'){	 if(op3_ms=='R')fp.set(SIMD(r_rr_conditional_101)), cl_idx=R_RR_CONDITIONAL_110;
						else if(op3_ms=='c')fp.set(SIMD(c_rc_conditional_101)), cl_idx=C_RC_CONDITIONAL_110;
						else				fp.set(SIMD(q_rq_conditional_101)), cl_idx=Q_RQ_CONDITIONAL_110;}
	else if(op1_ms=='c'){	 if(op3_ms=='R')fp.set(SIMD(r_cr_conditional_101)), cl_idx=R_CR_CONDITIONAL_110;
						else if(op3_ms=='c')fp.set(SIMD(c_cc_conditional_101)), cl_idx=C_CC_CONDITIONAL_110;
						else				fp.set(SIMD(q_cq_conditional_101)), cl_idx=Q_CQ_CONDITIONAL_110;}
	else if(op1_ms=='h'){	 if(op3_ms=='R')fp.set(SIMD(r_qr_conditional_101)), cl_idx=R_QR_CONDITIONAL_110;
						else if(op3_ms=='c')fp.set(SIMD(c_qc_conditional_101)), cl_idx=C_QC_CONDITIONAL_110;
						else				fp.set(SIMD(q_qq_conditional_101)), cl_idx=Q_QQ_CONDITIONAL_110;}
	if(term[op1].constant&&term[op3].constant)
	{
		expr->data[op1]=expr->data[op1].q_isTrue()?MP::Quat():expr->data[op3];
		expr->n[op1].mathSet=term[op1].mathSet;
	//	expr->data[result]=conditional_101(expr->data[op1], expr->data[op2]), expr->n[result].mathSet=term[result].mathSet;
	}
	else
	{
		expr->i.push_back(Instruction(fp, op1, op1_ms, op3, op3_ms, result, resultMathSet, DiscontinuityFunction(disc_conditional_101_i), cl_idx, DISC_CONDITIONAL_110_I));
		term[op1].constant=false;
	//	expr->i.push_back(Instruction(conditional_101, G2::returns_rrr_ccc_qqq, op1, op2, result, DiscontinuityFunction(disc_conditional_101_i))), term[result].constant=false;
	}
	expr->ni.push_back(MP::Instruction(fp, op1, op1_ms, op3, op3_ms, result, resultMathSet));
}
void			Compile::compile_instruction_condition_100	(int op1){expr->data[op1]=Value(), term[op1].constant=true, expr->n[op1].mathSet=term[op1].mathSet='R';}
void			Compile::compile_instruction_condition_011	(int op2, int op3)//X link to op3 instead
{
	using namespace G2;
	int result=op3;
	char op2_ms=term[op2].mathSet, op3_ms=term[op3].mathSet, resultMathSet=term[op2].mathSet=op3_ms;
	FPSetter fp;
		 if(op3_ms=='R')fp.set(SIMD(r_r_assign));
	else if(op3_ms=='c')fp.set(SIMD(c_c_assign));
	else				fp.set(SIMD(q_q_assign));
	if(term[op2].constant&&term[op3].constant)
	{
		expr->data[op2]=expr->data[op3];
		expr->n[op2].mathSet=term[op2].mathSet;
	//	expr->data[op2]=conditional_011(expr->data[op1], expr->data[op2]), expr->n[result].mathSet=term[result].mathSet;
	}
	else
	{
		expr->i.push_back(Instruction(fp, op2, op2_ms, op3, op3_ms, result, resultMathSet, DiscontinuityFunction(), 0, 0));
		term[op2].constant=false;
	//	expr->i.push_back(Instruction(conditional_011, G2::returns_rrr_ccc_qqq, op1, op2, result, DiscontinuityFunction())), term[result].constant=false;
	}
	expr->ni.push_back(MP::Instruction(fp, op2, op2_ms, op3, op3_ms, result, resultMathSet));
}
void			Compile::compile_instruction_condition_010	(int op1){expr->data[op1]=Value(), term[op1].constant=true, expr->n[op1].mathSet=term[op1].mathSet='R';}
#undef			SCALAR
#undef			SIMD
#undef			SIMD2
//#undef the rest
char			Compile::compile_instruction			(int f, char side, int a1, int a2, int a3)
//int				Compile::compile_instruction			(int f, char side, int a1, int a2, int a3)
{
	using namespace G2;
	expr->lastInstruction=expr->m[f]._0;
//	bool _1procVar=procedural&&a1!=-1&&!expr->n[expr->m[a1]._1].constant, _2procVar=procedural&&a2!=-1&&!expr->n[expr->m[a2]._1].constant;
	switch(expr->m[f]._0)
	{
	case M_FACTORIAL_LOGIC_NOT:
		if(ub[f]=='u')
			compile_instruction_u(expr->m[f]._0, side, a1);
		else if(ub[f]=='b')
			compile_instruction_u(expr->m[f]._0, '>', a1);//*/
		break;
	case M_BITWISE_NOT:
		if(ub[f]=='u')
			compile_instruction_u(expr->m[f]._0, side, a1);
		else if(ub[f]=='b')
			compile_instruction_u(expr->m[f]._0, '<', a2);
		break;
	case M_PENTATE:
	case M_TETRATE:
	case M_MULTIPLY:
	case M_LOGIC_DIVIDES:
	case M_PLUS:
	case M_LOGIC_AND:
	case M_LOGIC_XOR:
	case M_LOGIC_OR:
	case M_CONDITION_ZERO:
		if(ub[f]=='b')
		{
			compile_instruction_b(expr->m[f]._0, a1, a2);
			return 'b';
		}
		break;
	case M_DIVIDE:
	case M_MINUS:
		if(ub[f]=='u')
		{
			if(side=='<')
				compile_instruction_u(expr->m[f]._0, side, a1);
		}
		else if(ub[f]=='b')
		{
			compile_instruction_b(expr->m[f]._0, a1, a2);
			return 'b';
		}
		break;
	case M_POWER:case M_POWER_REAL:
		if(ub[f]=='u')
		{
			if(side=='<')
				compile_instruction_u(M_EXP, side, a1);
		}
		else if(ub[f]=='b')
		{
			compile_instruction_b(expr->m[f]._0, a1, a2);
			return 'b';
		}
		break;
	case M_MODULO_PERCENT:
	case M_BITWISE_SHIFT_LEFT:case M_BITWISE_SHIFT_RIGHT:
	case M_LOGIC_LESS:case M_LOGIC_LESS_EQUAL:case M_LOGIC_GREATER:case M_LOGIC_GREATER_EQUAL:
	case M_LOGIC_EQUAL:case M_LOGIC_NOT_EQUAL:
	case M_BITWISE_AND:case M_BITWISE_NAND:
	case M_BITWISE_XOR:case M_BITWISE_XNOR:
	case M_VERTICAL_BAR:case M_BITWISE_NOR:
		if(ub[f]=='u')
			compile_instruction_u(expr->m[f]._0, side, a1);
		else if(ub[f]=='b')
		{
			compile_instruction_b(expr->m[f]._0, a1, a2);
			return 'b';
		}
		break;
	case M_N:
		compile_instruction_b(M_MULTIPLY, a1, a2);
		return 'b';
	case M_QUESTION_MARK://always not procedural
			 if(a1!=-1)	{		 if(a2!=-1)	{		 if(a3!=-1)		compile_instruction_condition_111(	expr->m[a1]._1,	expr->m[a2]._1,	expr->m[a3]._1	), expr->m[a2]._0=M_IGNORED, expr->m[a3]._0=M_IGNORED;
												else				compile_instruction_condition_110(	expr->m[a1]._1,	expr->m[a2]._1					), expr->m[a2]._0=M_IGNORED;							}
							else			{		 if(a3!=-1)		compile_instruction_condition_101(	expr->m[a1]._1,					expr->m[a3]._1	), expr->m[a3]._0=M_IGNORED;
												else				compile_instruction_condition_100(	expr->m[a1]._1									);														}}
		else			{		 if(a2!=-1)	{		 if(a3!=-1)	{	expr->m[a2]=expr->m[a3]; if(a2!=a3)expr->m[a3]._0=M_IGNORED;}//compile_instruction_condition_011(					expr->m[a2]._1, expr->m[a3]._1	), expr->m[a3]._0=M_IGNORED;
												else				compile_instruction_condition_010(					expr->m[a2]._1					);														}
							else			{		 if(a3!=-1)		;
												else				expr->m[f]._0=M_N, expr->m[f]._1=expr->n.size(), expr->insertData('R', Value()), term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm)), term[expr->n.size()-1]=CompileTerm(true, expr->n.rbegin()->mathSet); }}
		//										else				expr->m[f]=::Map(M_N, expr->n.size()), expr->insertData('r', Value()), term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm)), term[expr->n.size()-1]=CompileTerm(true, expr->n.rbegin()->mathSet); }}
		//										else				expr->m[f]=::Map(M_N, expr->n.size()), expr->insertData('R', Value()), term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm)), term[expr->n.size()-1]=CompileTerm(true, expr->n.rbegin()->mathSet); }}
		break;

	case M_ASSIGN://always procedural
		compile_instruction_b2(expr->m[f]._0, expr->m[a1]._1, a2);
		return 'b';
	case M_ASSIGN_MULTIPLY:case M_ASSIGN_DIVIDE:case M_ASSIGN_MOD:
	case M_ASSIGN_PLUS:case M_ASSIGN_MINUS:
	case M_ASSIGN_LEFT:case M_ASSIGN_RIGHT:
	case M_ASSIGN_AND:case M_ASSIGN_XOR:case M_ASSIGN_OR:
		compile_instruction_b(expr->m[f]._0, a1, a2, true);
		return 'b';
	case M_INCREMENT:case M_DECREMENT:
		if(ub[f]=='u')
		{
			if(side=='<')//++a1
				compile_instruction_u(expr->m[f]._0, '_', a1, true);
			else if(side=='>')//a1++
			{
				if(procedural)
				{
					if(term[expr->m[a1]._1].fresh&&!expr->n[expr->m[a1]._1].constant)
					{
						expr->insertData('R');
						term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm));
						term[expr->n.size()-1]=CompileTerm(expr->n.rbegin()->constant, expr->n.rbegin()->mathSet, false);
						compile_instruction_b2(M_ASSIGN, expr->n.size()-1, a1);
						compile_instruction_u(expr->m[f]._0, '_', a1, true);
						expr->m[a1]._1=expr->n.size()-1;
					}
				}
			}
		}
		else if(ub[f]=='b')//a1 ++ a2
			compile_instruction_u(expr->m[f]._0, '_', a2, true);
		break;
	}
//	if(expr->m[f]._0>M_FUNCTION_START&&expr->m[f]._0<M_USER_FUNCTION_START)//default function
	if(expr->m[f]._0>M_FSTART&&expr->m[f]._0<M_USER_FUNCTION)//default function
	{
		if(a1!=-1)
		{
			if(ub[f]=='b')//n	f	n
			{
				if(a3!=-1)//binary		a1	f(	a2,	a3)			//a3 is gone but commas are handled outside compile_execute, outdated?
					compile_instruction_b(expr->m[f]._0, a2, a3);
				else//unary		a1	f	a2
					compile_instruction_u(expr->m[f]._0, side, a2);
			}
			else if(side=='<')//f	n
			{
				if(a2!=-1)//binary		f(	a1,	a2)			//a2 is gone but commas are handled outside compile_execute, outdated?
					compile_instruction_b(expr->m[f]._0, a1, a2);
				else//unary		f	a1
					compile_instruction_u(expr->m[f]._0, side, a1);
			}
			else if(side=='>')//	n	f
			{
				compile_instruction_f_def(f);
				return 'd';
			}
		}
		else//f
		{
			compile_instruction_f_def(f);
			return 'd';
		}
	}
	return 0;
}

int				Compile::compile_instruction_userFunctionCall(int function, std::vector<ArgIdx> &args, bool recursiveCall)
//int				Compile::compile_instruction_userFunctionCall(int function, std::vector<int> const &args)
//void			Compile::compile_instruction_userFunctionCall(int function, std::vector<int> const &args)
//void			Compile::compile_instruction_userFunctionCall(int function, std::vector<int> const &args, int n_result)
{
	int result;
//	bool new_repositry=false;
	if(!args.size())
	{
		char mathSet='R';
		expr->insertData(mathSet);
		result=expr->n.size()-1;
	//	bool constant=expr->n[result].constant=expr->n[op].constant;
		term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm));
		term[result]=CompileTerm(true, mathSet, false);
	//	term[result]=CompileTerm(constant, mathSet, false);
	//	new_repositry=true;
	}
	else if(procedural)
	{
		bool t=true;
		for(unsigned k=0;k<args.size();++k)
		{
			int arg=args[k].idx;
			if(!term[arg].fresh)
			{
				result=arg;
				t=false;
				break;
			}
		}
		if(t)
		{
			char mathSet='R';
			expr->insertData(mathSet);
			result=expr->n.size()-1;
		//	bool constant=expr->n[result].constant=expr->n[op].constant;
			term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm));
			term[result]=CompileTerm(true, mathSet, false);
		//	term[result]=CompileTerm(constant, mathSet, false);
		//	new_repositry=true;
		}
		for(unsigned k=0;k<args.size();++k)
		{
			int arg=args[k].idx;
			if(!term[arg].constant)
			{
				term[result].constant=false;
				break;
			}
		}
	}
	else
	{
		result=args[0].idx;
		for(int k=1, kEnd=args.size();k<kEnd;++k)
			if(result>args[k].idx)
				result=args[k].idx;
	}
	//	result=args[0];
	
//	char resultMathSet=userFunctionDefinitions[function].resultMathSet;
	char resultMathSet;
	FPSetter fpsetter;
	DiscontinuityFunction d;//all built-in variadic functions are continuous so far
	int cl_idx=0, disc_cl_idx=0;
	for(int k=0, kEnd=args.size();k<kEnd;++k)
		args[k].mathSet=term[args[k].idx].mathSet;
	if(function>0)//user function
		resultMathSet=recursiveCall?predictedMathSet:userFunctionDefinitions[function].resultMathSet;
	else//built-in variadic function
	{
		compile_instruction_select_v(-function, fpsetter, d, cl_idx, disc_cl_idx);
		resultMathSet='R';//=max(all mathsets)
		for(int k=0, kEnd=args.size();k<kEnd;++k)
			if(resultMathSet<args[k].mathSet)
				resultMathSet=args[k].mathSet;
	}
	if(!procedural||!term[result].fresh||!term[result].constant&&term[result].mathSet>resultMathSet)//'R' < 'c'
		term[result].mathSet=resultMathSet;
	expr->resultTerm=result;
	auto &ms=expr->n[expr->resultTerm].mathSet;
	ms=maximum(ms, term[result].mathSet);
//	if(!recursiveCall)
//		term[result].mathSet=userFunctionDefinitions[function].resultMathSet;//
	bool result_constant=true;
	for(unsigned k=0;k<args.size();++k)
	{
		int arg=args[k].idx;
		if(!term[arg].constant)
		{
			result_constant=false;
			break;
		}
	}
	char type=function<0?SIG_VA:SIG_CALL;
	Instruction in(type, fpsetter, args, result, resultMathSet, cl_idx, disc_cl_idx, function);
//	Instruction in(function, args, result);
	MP::Instruction mp_in(type, fpsetter, args, result, resultMathSet, function);
//	expr->ni.push_back(MP::Instruction(function, args, result));
	if(result_constant)
	{
		if(recursiveCall)
		{
			expr->i.push_back(in);
			term[result].constant=false;
		}
		else if(function<0)
			mp_in.fp.vf(expr->data, ArgIdx(result, resultMathSet), args);
		//	in.ia32.vf(nullptr, expr->data, result, args, 0);
		else
			Solve_UserFunction(*expr, in, true)(0);
	}
	else
		expr->i.push_back(in);
	expr->ni.push_back(mp_in);
/*	if(result_constant)
		Solve_UserFunction(*expr, in)();
	else
		expr->i.push_back(in);//*/
/*	{
		expr->i.push_back(in);
		if(new_repositry)
			term[result].constant=false;
	}//*/
	return result;
}
int				Compile::compile_instruction_branch_if		(int n_condition){	expr->i.push_back(Instruction('b', n_condition)),	expr->ni.push_back(MP::Instruction('b', n_condition));	return expr->i.size()-1;}
int				Compile::compile_instruction_branch_if_not	(int n_condition){	expr->i.push_back(Instruction('B', n_condition)),	expr->ni.push_back(MP::Instruction('B', n_condition));	return expr->i.size()-1;}
int				Compile::compile_instruction_jump			(){					expr->i.push_back(Instruction()),					expr->ni.push_back(MP::Instruction());					return expr->i.size()-1;}
int				Compile::compile_instruction_return			(int n_result){		expr->i.push_back(Instruction(n_result)),			expr->ni.push_back(MP::Instruction(n_result));			return expr->i.size()-1;}
int				Compile::compile_instruction_return			(Value const &x)
{
	expr->insertData(x.j||x.k?'h':x.i?'c':'R', x);
	term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm));
	term[expr->n.size()-1]=CompileTerm(true, expr->n.rbegin()->mathSet);
	expr->i.push_back(Instruction(expr->n.size()-1));
	expr->ni.push_back(MP::Instruction(expr->n.size()-1));
	return expr->i.size()-1;
}
void			Compile::compile_instruction_assign			(int dst, int src){compile_instruction_b(G2::M_ASSIGN, dst, src, true);}
void			Compile::compile_instruction_assign_value	(int dst, Value const &x)
{
	expr->insertData(x.j||x.k?'h':x.i?'c':'R', x);
	term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm));
	term[expr->n.size()-1]=CompileTerm(true, expr->n.rbegin()->mathSet);
	compile_instruction_b(G2::M_ASSIGN, dst, expr->n.size()-1, true);
}

void			Compile::compile_execute				(int i, int f, int v)
{
	using namespace G2;
	std::list<int> pN;
	for(bool repeat=true;repeat;)
	{
		pN.clear();
		repeat=false;
		int lastF=-1;
		bool startField=true, binaryField=true;
		for(int k=i, kPeak, peak=0;k<f;++k)
		{
			auto &S=expr->m[k]._0;
			if(S==M_N)
			{
				pN.push_back(k);
				ub[k]='b';
				if(startField)
					startField=false;
				else if(peak)
					ub[kPeak]='b';
				peak=0, binaryField=true;
			}
			else if(S)
			{
				if(binaryField&&peak<bi_mass(S))
					kPeak=k, peak=bi_mass(S);
				ub[k]='u';
			//	if(S>M_FUNCTION_START)
				if(S>M_FSTART)
				{
					lastF=k;
					binaryField=false;
				}
			}
		}
		if(!pN.size()&&lastF>-1||pN.size()&&lastF>*pN.rbegin())
			compile_instruction_f_def(lastF), pN.push_back(lastF), ub[lastF]='b', repeat=true;
	}
	if(pN.size())
	{
		for(auto it=pN.begin();;)
		{
			int lOp=-1, rOp=-1;
			for(int k=*it-1;k>=i;--k)
			{
				if(expr->m[k]._0)
				{
					lOp=k;
					break;
				}
			}
			for(int k=*it+1;k<f;++k)
			{
				if(expr->m[k]._0)
				{
					if(v!=1||prec(M_COS, 'u', expr->m[k]._0, ub[k])=='>')//v==1: lazy call last arg f,[..]..	compare right op precedence to a function
						rOp=k;
					break;
				}
			}
			char s;
				 if(lOp>=0)	{		 if(rOp>=0)	s=prec(expr->m[lOp]._0, ub[lOp], expr->m[rOp]._0, ub[rOp]);
								else			s='<';}
			else			{		 if(rOp>=0)	s='>';
								else			s='_';}
			if(s=='<')
			{
				switch(ub[lOp])
				{
				case 'u'://			- [n]
					compile_instruction(lOp, '<', *it);
					expr->m[lOp]._0=M_IGNORED;
					continue;
				case 'b'://			n + [n]
					{
						auto itPrev=it; --itPrev;
						if(compile_instruction(lOp, '_', *itPrev, *it)=='b')//called compile_instruction_b, a2 is gone
							pN.erase(it--);
						if(lOp!=*it)
							expr->m[lOp]._0=M_IGNORED;
					}
					continue;
				}
			}
			else if(s=='>')
			{
				switch(ub[rOp])
				{
				case 'u'://			[n] !
					if(compile_instruction(rOp, '>', *it)==-1)//called compile_instruction_f_def
						ub[rOp]='b';
					else
						expr->m[rOp]._0=M_IGNORED;
					continue;
				case 'b'://			[n] + n
					++it;
					continue;
				}
			}
			else if(s=='_')
			{
				expr->m[i]=expr->m[*it];
				if(*it!=i)
					expr->m[*it]._0=M_IGNORED;
				break;
			}
		}
	}
	else
	{
		for(int k=i;k<f;++k)
			expr->m[k]._0=M_IGNORED;
		if(i==expr->m.size())
			expr->m.push_back(::Map(0, 0, M_N, expr->n.size()));
		else
			expr->m[i]=::Map(0, 0, M_N, expr->n.size());
		expr->insertData('R', Value()), term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm)), term[expr->n.size()-1]=CompileTerm(true, expr->n.rbegin()->mathSet);
	//	expr->m[i]=::Map(M_N, expr->n.size()), expr->insertData('R', Value()), term=(CompileTerm*)realloc(term, expr->n.size()*sizeof(CompileTerm)), term[expr->n.size()-1]=CompileTerm(true, expr->n.rbegin()->mathSet);
	}
}
void			Compile::compile_abs					(int i, int f, int v)
{
	if(verticalBarAbs)
	{
		bool field=false, active=false;
		for(int k=i, first=-1;k<f;++k)
		{
			if(expr->m[k]._0==G2::M_VERTICAL_BAR)
			{
				if(field)
				{
					compile_execute(first+1, k, 0);
					compile_instruction(first, '<', first+1);
					expr->m[first]._0=expr->m[k]._0=G2::M_IGNORED;
				}
				else
					first=k;
				field=!field;
			}
			else if(field&&expr->m[k]._0)
				active=true;
		}
	}
	compile_execute(i, f, v);
}
void Compile::compile_inline_if(int i, int f, int v)
//void Compile::compile_inline_if(int i, int f, int v, bool SIMD)
{
	using namespace G2;
	for(;;)
	{
		bool match_colon=false;
		int topLevel=0, i1=-1, f1=-1;
		{
			bool top=false;
			for(int k=i, level=0;k<f;++k)
			{
				auto &S=expr->m[k]._0;
				if(S==M_QUESTION_MARK)
				{
					++level;
					if(topLevel<=level)
						topLevel=level, i1=k, top=true, match_colon=false;
				}
				else if(S==M_COLON)
				{
					--level;
					if(top)
						f1=k, top=false, match_colon=true;
				}
			}
		}
		if(topLevel)
		{
			int i0=f, f2=-1;
			for(int k=i1-1;k>=i;--k)//find range 1 start: [..]?..:..
			{
				if(expr->m[k]._0==M_QUESTION_MARK||expr->m[k]._0==M_COLON)
				{
					if(k!=i1-1)
						i0=k+1;
					break;
				}
				if(k==i)
				{
					i0=k;
					break;
				}
			}
			if(f1!=-1)
			{
				for(int k=f1+1, mLevel=0;k<=f;++k)//find range 3 end: ..?..:[..]
				{
					if(k==f||expr->m[k]._0==M_QUESTION_MARK||expr->m[k]._0==M_COLON)
					{
						if(k!=f1+1)
							f2=k;
						break;
					}
				}
			}
			else
				f1=f2=f;
			if(procedural)
			{
				bool expr1=false;
				for(int k=i0;k<i1;++k)
				{
					if(expr->m[k]._0)
					{
						expr1=true;
						break;
					}
				}
				if(expr1)
				{
					if(expr->n[expr->m[i0+1]._1].constant)
					{
						if(expr->data[expr->m[i0+1]._1].q_isTrue())
					//	if(expr->n[expr->m[i0+1]._1].val.q_isTrue())
						{
							for(int k=i1+1;k<f1;++k)//just expr2
							{
								if(expr->m[k]._0)
								{
									compile_abs(i1+1, f1, 0);
									break;
								}
							}
							for(int k=f1+1;k<f2;++k)
								expr->m[k]=M_IGNORED;
						}
						else
						{
							for(int k=i1+1;k<f1;++k)//just expr3
								expr->m[k]=M_IGNORED;
							for(int k=f1+1;k<f2;++k)
							{
								if(expr->m[k]._0)
								{
									compile_abs(f1+1, f2, 0);
									break;
								}
							}
						}
					}
					else
					{
						bool expr2=false, expr3=false;
						for(int k=i1+1;k<f1;++k)
						{
							if(expr->m[k]._0)
							{
								expr2=true;
								break;
							}
						}
						for(int k=f1+1;k<f2;++k)
						{
							if(expr->m[k]._0)
							{
								expr3=true;
								break;
							}
						}
						if(expr2||expr3)
						{
						/*	expr1 ? expr2 : expr3

								<expr1>
								branch condition if
								<expr3>
								assign expr3
								jump end
							if:
								<expr2>
								assign expr2
							end:
							*/
							compile_abs(i0, i1, 0);//expr1
							int i_branch=compile_instruction_branch_if(expr->m[i0]._1);
							if(expr3)
							{
								compile_abs(f1+1, f2, 0);//expr3
								compile_instruction_assign(expr->m[i0]._1, expr->m[f1+1]._1);//n[i0]=n[f1+1]
							//	compile_instruction_assign(i0, f1+1);//n[i0]=n[f1+1]
							}
							else
								compile_instruction_assign_value(expr->m[i0]._1, Value());//n[i0]=0;
							//	compile_instruction_assign_value(i0, Value());//n[i0]=0;
							int i_jump=compile_instruction_jump();
							expr->ni[i_branch].op2=expr->i[i_branch].op2=expr->i.size();
							if(expr2)
							{
								compile_abs(i1+1, f1, 0);//expr2
								compile_instruction_assign(expr->m[i0]._1, expr->m[i1+1]._1);//n[i0]=n[i1+1]
							//	compile_instruction_assign(i0, i1+1);//n[i0]=n[i1+1]
							}
							else
								compile_instruction_assign_value(expr->m[i0]._1, Value());//n[i0]=0;
							//	compile_instruction_assign_value(i0, Value());//n[i0]=0;
							expr->ni[i_jump].op1=expr->i[i_jump].op1=expr->i.size();
							expr->m[i1+1]._0=M_IGNORED, expr->m[f1+1]._0=M_IGNORED;
#if 0//branch if not
						/*	expr1 ? expr2 : expr3

								<expr1>
								branch !condition else
								<expr2>
								assign expr2
								jump end
							else:
								<expr3>
								assign expr3
							end:
							*/
							compile_abs(i0, i1, 0);//expr1
							int i_branch=compile_instruction_branch_if_not(expr->m[i0]._1);
							if(expr2)
							{
								compile_abs(i1+1, f1, 0);//expr2
								compile_instruction_assign(expr.m[i0]._1, expr.m[i1+1]._1);//n[i0]=n[i1+1]
							//	compile_instruction_assign(i0, i1+1);//n[i0]=n[i1+1]
							}
							else
								compile_instruction_assign_value(expr.m[i0]._1, Value());//n[i0]=0;
							//	compile_instruction_assign_value(i0, Value());//n[i0]=0;
							int i_jump=compile_instruction_jump();
							expr->ni[i_branch].op2=expr->i[i_branch].op2=expr->i.size();
							if(expr3)
							{
								compile_abs(f1+1, f2, 0);//expr3
								compile_instruction_assign(expr.m[i0]._1, expr.m[f1+1]._1);//n[i0]=n[f1+1]
							//	compile_instruction_assign(i0, f1+1);//n[i0]=n[f1+1]
							}
							else
								compile_instruction_assign_value(expr.m[i0]._1, Value());//n[i0]=0;
							//	compile_instruction_assign_value(i0, Value());//n[i0]=0;
							expr->ni[i_jump].op1=expr->i[i_jump].op1=expr->i.size();
							expr->m[i1+1]._0=M_IGNORED, expr->m[f1+1]._0=M_IGNORED;
#endif
						}
						else
							compile_instruction(i1, '_', -1, -1, -1);
						//	compile_instruction_assign_value(i0, Value());//
					}
				}
				else if(inline_if_default_true)//condition (expr1) is empty: default true (like for loop condition)
				{
					bool expr2=false;
					for(int k=i1+1;k<f1;++k)//just expr2
					{
						if(expr->m[k]._0)
						{
							expr2=true;
							break;
						}
					}
					if(expr2)
						compile_abs(i1+1, f1, 0);
					else
						compile_instruction(i1, '_', -1, -1, -1);
					for(int k=f1+1;k<f2;++k)
						expr->m[k]=M_IGNORED;
				}
				else//default false when condition (expr1) is empty
				{
					bool expr3=false;
					for(int k=i1+1;k<f1;++k)//just expr3
						expr->m[k]=M_IGNORED;
					for(int k=f1+1;k<f2;++k)
					{
						if(expr->m[k]._0)
						{
							expr3=true;
							break;
						}
					}
					if(expr3)
						compile_abs(f1+1, f2, 0);
					else
						compile_instruction(i1, '_', -1, -1, -1);
				}
				expr->m[i1]._0=M_IGNORED, expr->m[f1]._0=M_IGNORED;
			}
			else
			{
				int r0=-1, r1=-1, r2=-1;
				for(int k=i0;k<i1;++k)
				{
					if(expr->m[k]._0)
					{
						compile_abs(r0=i0, i1, 0);
						break;
					}
				}
				for(int k=i1+1;k<f1;++k)
				{
					if(expr->m[k]._0)
					{
						compile_abs(r1=i1+1, f1, 0);
						break;
					}
				}
				for(int k=f1+1;k<f2;++k)
				{
					if(expr->m[k]._0)
					{
						compile_abs(r2=f1+1, f2, 0);
						break;
					}
				}
				compile_instruction(i1, '_', r0, r1, r2);
				if(expr->m[i1]._0!=M_N)
					expr->m[i1]._0=M_IGNORED;
				if(match_colon)
					expr->m[f1]._0=M_IGNORED;
			}
		}
		else
			break;
	}
	compile_abs(i, f, v);
}

void Compile::compile_assignment(int i, int f)
{
	using namespace G2;
	bool notAssignExpr=true;
	for(int k=f-1;k>=i;--k)
	{
		auto &S=expr->m[k]._0;
		if(S>M_PROCEDURAL_ASSIGN_START&&S<M_PROCEDURAL_ASSIGN_END)
		{
			compile_inline_if(k+1, f, 0);
		//	compile_inline_if(k+1, f, 0, false);
			int lastA=k;
			for(int k2=k-1;k2>=i;--k2)
			{
				auto &S2=expr->m[k2]._0;
				if(S2>M_PROCEDURAL_ASSIGN_START&&S2<M_PROCEDURAL_ASSIGN_END)
				{
					compile_inline_if(k2+1, lastA, 0);
				//	compile_inline_if(k2+1, lastA, 0, false);
					compile_instruction(k2, '_', k2+1, lastA+1);
					S2=M_IGNORED;
					lastA=k2;
				}
			}
			compile_inline_if(i, lastA, 0);
		//	compile_inline_if(i, lastA, 0, false);
			compile_instruction(k, '_', i, lastA+1);
			S=M_IGNORED;
			notAssignExpr=false;
			break;
		}
	}
	if(notAssignExpr)
		compile_inline_if(i, f, 0);
	//	compile_inline_if(i, f, 0, false);
}
void Compile::compile_expression_local(int _i, int _f)
{
	using namespace G2;
	for(;;)
	{
		int topLevel=0, i=-1, f=-1;
		{
			bool peak=false;
			for(int k=_i, level=0;k<_f;++k)
		//	for(int k=0, kEnd=expr->m.size(), level=0;k<kEnd;++k)
			{
				if(expr->m[k]._0==M_LPR)
				{
					++level;
					if(level>=topLevel)
						topLevel=level, i=k+1, peak=true;
				}
				else if(expr->m[k]._0==M_RPR)
				{
					--level;
					if(peak)
						f=k, peak=false;
				}
			}
		}
			 if(i==-1)	i=_i;//0;
		else			expr->m[i-1]._0=M_IGNORED;
			 if(f==-1)	f=_f;//expr->m.size();
		else			expr->m[f  ]._0=M_IGNORED;
	//	if(topLevel>0&&i-2>=0&&expr->m[i-2]._0>M_FUNCTION_START)
		if(topLevel>0&&i-2>=0&&expr->m[i-2]._0>M_FSTART)//call level
		{
			auto &S=expr->m[i-2]._0;
			std::vector<int> commas;
			bool notVoidCall=false;
			for(int k=i;k<f;++k)
			{
				auto &S2=expr->m[k]._0;
				if(S2==M_COMMA)
					commas.push_back(k);
				notVoidCall|=S2!=M_IGNORED;
			}
			int exprNArgs=commas.size()+notVoidCall;
		//	if(S<M_USER_FUNCTION_START)
			if(S<M_USER_FUNCTION)//default function call level
			{
				int signature=default_overload(S);
				if(signature&(1<<exprNArgs))//default overload match
				{
					int start=i;
					for(int k=0, kEnd=commas.size();k<kEnd;++k)
					{
						expr->m[commas[k]]._0=M_IGNORED;
						compile_assignment(start, commas[k]);
						start=commas[k]+1;
					}
					compile_assignment(start, f);
					if(commas.size()==2)//ternary function
						compile_instruction(i-2, '<', i, commas[0]+1, commas[1]+1), expr->m[commas[0]+1]=expr->m[commas[1]+1]=M_IGNORED;
					else if(commas.size())//binary function
						compile_instruction(i-2, '<', i, commas[0]+1), expr->m[commas[0]+1]=M_IGNORED;
					else//unary function
						compile_instruction(i-2, '<', i);
					S=M_IGNORED;
				}
				else//syntax error, no such overload
				{
					if(exprNArgs>signature)//too many args: highlight unexpected args
						expr->insertSyntaxError(expr->m[commas[signature>0x3]].pos, expr->m[f].pos);
					else//highlight arglist contents
						expr->insertSyntaxError(expr->m[i].pos, expr->m[f].pos);
					expr->i.clear();
					expr->ni.clear();
					expr->valid=false;
					return;
				}
			}
			else//user function call level
			{
				int name_id=expr->m[i-2]._1, d_match=-1;
				for(int d=0, dEnd=userFunctionDefinitions.size();d<dEnd&&expr->lineNo>=userFunctionDefinitions[d].lineNo;++d)//linearly through all user definitions		sorted by lineNo
			//	for(int d=0, dEnd=userFunctionDefinitions.size();d<dEnd&&expr->lineNo>userFunctionDefinitions[d].lineNo;++d)
				{
					auto &definition=userFunctionDefinitions[d];
					if(definition.valid&&name_id==definition.name_id&&exprNArgs==definition.nArgs)//find overload instance
						d_match=d;
				}
				if(d_match!=-1)
				{
					std::vector<ArgIdx> args(exprNArgs);
					if(notVoidCall)//compile args
					{
						int start=i;
						for(int k3=0, k3End=exprNArgs-1;k3<k3End;++k3)
						{
							expr->m[commas[k3]]._0=M_IGNORED;//before compile in case start==commas[k3]
							compile_assignment(start, commas[k3]);
							args[k3].idx=expr->m[start]._1, expr->m[start]._0=M_IGNORED;
							start=commas[k3]+1;
						}
						compile_assignment(start, f);
						args[exprNArgs-1].idx=expr->m[start]._1, expr->m[start]._0=M_IGNORED;
					}
					bool recursiveCall=&userFunctionDefinitions[d_match]==expr;
					recursiveFunction|=recursiveCall;
					int result=compile_instruction_userFunctionCall(d_match, args, recursiveCall);
				//	int result=compile_instruction_userFunctionCall(d_match, args, &userFunctionDefinitions[d_match]==expr);
					S=M_N, expr->m[i-2]._1=result;
				}
				else//syntax error, no such overload
				{
					expr->insertSyntaxError(expr->m[i].pos, expr->m[f].pos);//arglist
				//	expr->insertSyntaxError(expr->m[k]._1);//mark the error		function call level: highlight id, parentheses and arglist
					expr->i.clear();
					expr->ni.clear();
					expr->valid=false;
					return;
				}
			}
		}
		else//not a call level
		{
			int start=i;
			for(int k=i;k<f;++k)
			{
				if(expr->m[k]._0==M_COMMA)
				{
					compile_assignment(start, k);
					expr->m[start]._0=M_IGNORED, expr->m[k]._0=M_IGNORED;
					start=k+1;
				}
			}
			compile_assignment(start, f);
			if(start!=i)
				expr->m[i]=expr->m[start], expr->m[start]._0=M_IGNORED;
		}
		if(topLevel==0)
			break;
	}
}
bool Compile::compile_exprStatement(int &k, int mEnd)
//void Compile::compile_exprStatement(int &k, int mEnd)
{
	for(int k2=k, level=0;k2<mEnd;++k2)
	{
		auto &S=expr->m[k2]._0;
		if(S==G2::M_SEMICOLON)
		{
			compile_expression_local(k, k2);
			S=G2::M_IGNORED;//in case k==k2 & execute leaves a link: semicolon statements are expendable
			k=k2;
			return true;
		}
		else if(S>G2::M_PROCEDURAL_START&&S<G2::M_PROCEDURAL_ASSIGN_START)
	//	else if(S>G2::M_PROCEDURAL_START&&S<G2::M_PROCEDURAL_END)//X expression_local calls compile_assignments
		{
			//syntax error
			auto &S2=expr->m[k2-(k<k2-1)];
			expr->insertSyntaxError(expr->m[k].pos, S2.pos+S2.len);
			k=k2-1;
			break;
		}
		else if(S==G2::M_LPR)
			++level;
		else if(S==G2::M_RPR)
			--level;
		else if(S==G2::M_COMMA&&!level)
		{
			compile_expression_local(k, k2);
			S=G2::M_IGNORED;//in case k==k2 & execute leaves a link: semicolon statements are expendable
			k=k2+1;
		}
	}
	return false;
}
bool Compile::comp_seek_allowNewline(int &k, int mEnd, int S)
{
	for(int k2=k;k2<mEnd;++k2)
	{
		auto &S2=expr->m[k2]._0;
		if(S2==S)
		{
			k=k2;
			return true;
		}
		if(S2!=G2::M_IGNORED)
			return false;
	}
	return false;
}
bool Compile::comp_seek_condition(int &k, int mEnd, int &conditionStart, int &conditionEnd)
{
	using namespace G2;
	int k2=k;
	if(comp_seek_allowNewline(k2, mEnd, M_LPR))
	{
		conditionStart=++k2;
		for(int level=1;k2<mEnd;++k2)//profile condition
		{
			auto &S=expr->m[k2]._0;
			if(S==M_LPR)
				++level;
			else if(S==M_RPR)
			{
				--level;
				if(!level)
				{
					conditionEnd=k2;
					k=k2;
					return true;
				}
			}
			else if(S==M_SEMICOLON)
				return false;
		}
	}
	return false;
}
bool Compile::comp_seek_forHeader(int &k, int mEnd, int &headerStart, int &sc1, int &sc2, int &headerEnd)
{
	using namespace G2;
	int k2=k;
	if(comp_seek_allowNewline(k2, mEnd, M_LPR))
	{
		headerStart=++k2;
		for(int level=1, nSemicolons=0;k2<mEnd;++k2)
		{
			auto &S=expr->m[k2]._0;
			if(S==M_LPR)
				++level;
			else if(S==M_RPR)
			{
				--level;
				if(!level)
				{
					if(nSemicolons==2)
					{
						k=headerEnd=k2;
						return true;
					}
					return false;
				}
			}
			else if(S==M_SEMICOLON)
			{
				if(level==1)
				{
					++nSemicolons;
					if(nSemicolons==1)
						sc1=k2;
					else
						sc2=k2;
				}
				else return false;
			}
		}
	}
	return false;
}
bool Compile::comp_seek_block(int &k, int mEnd, int &blockStart, int &blockEnd)
{
	using namespace G2;
	if(comp_seek_allowNewline(k, mEnd, M_LBRACE))
	{
		blockStart=k+1;
		for(int k2=blockStart, level=1;k2<mEnd;++k2)//profile block
		{
			auto &S=expr->m[k2]._0;
			if(S==M_LBRACE)
				++level;
			else if(S==M_RBRACE)
			{
				--level;
				if(!level)
				{
					k=blockEnd=k2;
					return true;
				}
			}
		}
	}
	return false;
}
/*struct CompileBlockInfo
{
	int k;
	int mStart, mEnd;
	CompileBlockInfo(int k, int mStart, int mEnd):k(k), mStart(mStart), mEnd(mEnd){}
};//*/
std::stack<std::pair<int, std::vector<int>>> Compile::loopInfo;
//std::stack<int> Compile::loopStart, Compile::loopEnd;
//int Compile::n_lastResult;
//std::stack<int> loopStart, loopEnd;
//int n_lastResult;
void	compile_break_address(std::stack<std::pair<int, std::vector<int>>> &loopInfo, Expression *expr)
{
	int end=expr->i.size();//1
	auto &it=loopInfo.top().second;
	for(unsigned k3=0;k3<it.size();++k3)
	{
		int &i_break=it[k3];
		expr->ni[i_break].result=expr->i[i_break].result=end;
	}
}
void Compile::compile_statement(int &k, int mEnd)
{
	using namespace G2;
	switch(expr->m[k]._0)
	{
	case M_IF:
		{
			int k2=k+1;
			int conditionStart, conditionEnd;
			if(comp_seek_condition(k2, mEnd, conditionStart, conditionEnd))
			{
			/*	<condition>
				branch !condition end
				<if body>
			end:

				<condition>
				branch !condition else
				<if body>
				jump end
			else:
				<else body>
			end:
				*/
				compile_expression_local(conditionStart, conditionEnd);//<condition>
				int n_condition=expr->m[conditionStart]._1;
			//	int n_condition;
			//	compile_expression_local(n_condition=conditionStart, conditionEnd);	//n_condition: op1, i_branch: result	if(ex.n[ex.i[i].op1].ndr[v].r_isTrue())i=ex.i[i].result;

				int i_branch=compile_instruction_branch_if_not(n_condition);
				{
					int blockStart=0, blockEnd=0;
					k2=conditionEnd+1;
					if(comp_seek_block(k2, mEnd, blockStart, blockEnd))//<if body>
					{
						compile_block(blockStart, blockEnd);						//double recursive for now
						expr->m[blockStart-1]._0=M_IGNORED, expr->m[blockEnd]._0=M_IGNORED;
					}
					else
						compile_statement(k2, mEnd);
					//	compile_exprStatement(start, mEnd);
				}
				if(comp_seek_allowNewline(k2, mEnd, M_ELSE))
				{
					int i_jump=compile_instruction_jump();
					expr->ni[i_branch].result=expr->i[i_branch].result=expr->i.size();//branch to else
				//	expr->i[i_branch].op2=expr->i.size();
					++k2;
					compile_statement(k2, mEnd);//<else body> statement						//recursive for now
					expr->ni[i_jump].result=expr->i[i_jump].result=expr->i.size();//jump to end
				//	expr->i[i_jump].op2=expr->i.size();
				}
				else
					expr->ni[i_branch].result=expr->i[i_branch].result=expr->i.size();//branch to end
				//	expr->i[i_branch].op2=expr->i.size();
				k=k2;
			}
			else//syntax error: expected condition
				expr->insertSyntaxError(expr->m[k].pos, expr->m[k].pos+2);
		}
		break;
	case M_FOR:
		{
			int k2=k+1;
			int headerStart, sc1, sc2, headerEnd;
			if(comp_seek_forHeader(k2, mEnd, headerStart, sc1, sc2, headerEnd))
			{
			/*		<start>
					jump condition
				loop:
					<body>
					<increment>
				condition:
					<condition>
					branch condition loop
				*/
			/*		<start>						//empty condition
				loop:
					<body>
					<increment>
					jump loop
				*/
				if(headerStart<sc1)
					compile_expression_local(headerStart, sc1);//<start>
				bool conditionNotEmpty=sc1+1<sc2;
				int i_jump=-1;
				if(conditionNotEmpty)
					i_jump=compile_instruction_jump();
			//	int i_jump=compile_instruction_jump();//jump to condition below		//i_jump: result		i=expr->i[i].result;		//i_jump: op1		i=expr->i[i].op1;
				int i_loop=expr->i.size();
				loopInfo.push(std::pair<int, std::vector<int>>(i_loop, std::vector<int>()));
				{
					int blockStart=0, blockEnd=0;
					k2=headerEnd+1;
					if(comp_seek_block(k2, mEnd, blockStart, blockEnd))//<body>
						compile_block(blockStart, blockEnd);					//double recursive for now
					else
						compile_statement(k2, mEnd);
					//	compile_exprStatement(start, mEnd);
				}
				compile_expression_local(sc2+1, headerEnd);//<increment>
				if(conditionNotEmpty)
				{
					expr->ni[i_jump].result=expr->i[i_jump].result=expr->i.size();
				//	expr->ni[i_jump].op1=expr->i[i_jump].op1=expr->i.size();
					compile_expression_local(sc1+1, sc2);//<condition>
					int n_condition=expr->m[sc1+1]._1;
				//	int n_condition;
				//	compile_expression_local(n_condition=sc1+1, sc2);

					int i_branch=compile_instruction_branch_if(n_condition);
					expr->ni[i_branch].result=expr->i[i_branch].result=i_loop;
				//	expr->ni[i_branch].op2=expr->i[i_branch].op2=i_loop;
				}
				else
				{
					i_jump=compile_instruction_jump();
					expr->ni[i_jump].result=expr->i[i_jump].result=i_loop;
				}
				compile_break_address(loopInfo, expr);
				k=k2;
				loopInfo.pop();
			}
			else//expected for header
				expr->insertSyntaxError(expr->m[k].pos, expr->m[k].pos+3);
		}
		break;
	case M_WHILE:
		{
			int k2=k+1;
			int conditionStart, conditionEnd;
			if(comp_seek_condition(k2, mEnd, conditionStart, conditionEnd))
			{
			/*		jump condition
				loop:
					<body>
				condition:
					<condition>
					branch condition loop
				*/
			/*	loop:							//empty condition (syntax error in c/c++)
					<body>
					jump loop
				*/
				bool conditionNotEmpty=conditionStart<conditionEnd;
				int i_jump=-1;
				if(conditionNotEmpty)
					i_jump=compile_instruction_jump();
			//	int i_jump=compile_instruction_jump();
				int i_loop=expr->i.size();
				loopInfo.push(std::pair<int, std::vector<int>>(i_loop, std::vector<int>()));
				{
					int blockStart=0, blockEnd=0;
					k2=conditionEnd+1;
					if(comp_seek_block(k2, mEnd, blockStart, blockEnd))//<body>
						compile_block(blockStart, blockEnd);						//double recursive for now
					else
						compile_statement(k2, mEnd);
					//	compile_exprStatement(conditionEnd, mEnd);
				}
				if(conditionNotEmpty)
					expr->ni[i_jump].result=expr->i[i_jump].result=expr->i.size();
			//	expr->ni[i_jump].op1=expr->i[i_jump].op1=expr->i.size();
				
				if(conditionNotEmpty)
				{
					compile_expression_local(conditionStart, conditionEnd);//<condition>
					int n_condition=expr->m[conditionStart]._1;
				//	int n_condition;
				//	compile_expression_local(n_condition=conditionStart, conditionEnd);

					int i_branch=compile_instruction_branch_if(n_condition);
					expr->ni[i_branch].result=expr->i[i_branch].result=i_loop;
				//	expr->ni[i_branch].op2=expr->i[i_branch].op2=i_loop;
				}
				else
				{
					i_jump=compile_instruction_jump();
					expr->ni[i_jump].result=expr->i[i_jump].result=i_loop;
				}
				compile_break_address(loopInfo, expr);
				k=k2;
				loopInfo.pop();
			}
			else//expected condition
				expr->insertSyntaxError(expr->m[k].pos, expr->m[k].pos+5);
		}
		break;
	case M_DO:
		{
			int k2=k+1;
			int blockStart=0, blockEnd=0;
			bool block=comp_seek_block(k2, mEnd, blockStart, blockEnd);
			if(block)
				expr->m[blockStart-1]._0=M_IGNORED, expr->m[blockEnd]._0=M_IGNORED;
			if(comp_seek_allowNewline(k2, mEnd, M_WHILE))
			{
				int conditionStart, conditionEnd;
				++k2;
				if(comp_seek_condition(k2, mEnd, conditionStart, conditionEnd))
				{
				/*	loop:
						<body>
						<condition>
						branch condition loop
					*/
				/*	loop:							//empty condition (syntax error in c/c++)
						<body>
						jump loop
					*/
					int i_loop=expr->i.size();
					loopInfo.push(std::pair<int, std::vector<int>>(i_loop, std::vector<int>()));
					if(block)//<body>
						compile_block(blockStart, blockEnd);				//double recursive for now
					else
					{
						k2=conditionEnd+1;
						compile_statement(k2, mEnd);
					//	compile_exprStatement(conditionEnd, mEnd);
					}
					
					bool conditionNotEmpty=conditionStart<conditionEnd;
					if(conditionNotEmpty)
					{
						compile_expression_local(conditionStart, conditionEnd);//<conditions>
						int n_condition=expr->m[conditionStart]._1;
					//	int n_condition;
					//	compile_expression_local(n_condition=conditionStart, conditionEnd);

						int i_branch=compile_instruction_branch_if(n_condition);
						expr->ni[i_branch].result=expr->i[i_branch].result=i_loop;
					//	expr->ni[i_branch].op2=expr->i[i_branch].op2=i_loop;
					}
					else
					{
						int i_jump=compile_instruction_jump();
						expr->ni[i_jump].result=expr->i[i_jump].result=i_loop;
					}
					compile_break_address(loopInfo, expr);
					k=k2;
				}
				else//expected condition
					expr->insertSyntaxError(expr->m[k].pos, expr->m[k2].pos+5);
			}
			else//expected do
				expr->insertSyntaxError(expr->m[k].pos, expr->m[blockEnd].pos);
		}
		break;
	case M_LBRACE:
		{
		//	int k2=k+1;//X comp_seek_block: seek '{' (in this case: again) then close with '}'
			int k2=k;
			int blockStart=0, blockEnd=0;
			if(comp_seek_block(k2, mEnd, blockStart, blockEnd))
			{
				compile_block(blockStart, blockEnd);				//double recursive for now
				k=k2;
			}
			else//unmatched brace, unreachable
				expr->insertSyntaxError(expr->m[k].pos, expr->m[k].pos+1);
		}
		break;
	case M_CONTINUE:
		if(loopInfo.size())
		{
			int i_jump=compile_instruction_jump();
			auto &LOL_1=loopInfo.top().first;
			expr->ni[i_jump].result=expr->i[i_jump].result=loopInfo.top().first;
		}
		else//continue not expected here
			expr->insertSyntaxError(expr->m[k].pos, expr->m[k].pos+8);
	/*	if(loopStart.size())
		{
			int i_jump=compile_instruction_jump();
			expr->ni[i_jump]=expr->i[i_jump]=loopStart.top();
		}
		else//continue not expected here
			expr->insertSyntaxError(expr->m[k].pos, expr->m[k].pos+8);//*/
		break;
	case M_BREAK:
		if(loopInfo.size())
		{
			int i_jump=compile_instruction_jump();
			loopInfo.top().second.push_back(i_jump);
		}
		else//break not expected here
			expr->insertSyntaxError(expr->m[k].pos, expr->m[k].pos+5);
	/*	if(loopStart.size())
		{
			int i_jump=compile_instruction_jump();
			loopEnd.push(i_jump);//when loop is compiled	if(loopEnd.size())expr->ni[loopEnd.top()].op1=expr->i[loopEnd.top()].op1=expr->i.size(), loopEnd.pop();
		}
		else//break not expected here
			expr->insertSyntaxError(expr->m[k].pos, expr->m[k].pos+5);//*/
		break;
	case M_RETURN:
		if(k+1<mEnd&&expr->m[k+1]._0==M_SEMICOLON)//return;		default return 0;
			compile_instruction_return(Value());
		else
		{
			int k2=k+1;
			if(compile_exprStatement(k2, mEnd))
			{
				compile_instruction_return(expr->m[k+1]._1);
				char mathSet=term[expr->m[k+1]._1].mathSet;
			//	char mathSet=expr->n[expr->m[k+1]._1].mathSet;//X not updated
				if(predictedMathSet<mathSet)
					expr->resultMathSet=predictedMathSet=mathSet;
				else
					expr->resultMathSet=predictedMathSet;//just to initialize?
			}//else syntax error: marked & ignored
			k=k2;

		//	++k;
		//	compile_exprStatement(k, mEnd);
		//	compile_instruction_return(k);
		}
		break;
	default:
	/*	{
			int start=k;
			compile_exprStatement(k, mEnd);
			n_lastResult=expr->m[start]._1;//when function is done compiling
		}//*/
		compile_exprStatement(k, mEnd);
	//	n_lastResult=k;//X
		break;
	}
}
void Compile::compile_block(int mStart, int mEnd)
{
//	std::stack<CompileBlockInfo> s;
	for(int k=mStart;k<mEnd;++k)
		compile_statement(k, mEnd);
}
void Compile::compile_function(Expression &expr)
{
	procedural=true, recursiveFunction=false;
//	expr.resultMathSet=predictedMathSet='R';
	predictedMathSet='R';
	Compile::expr=&expr;
	if(expr.m.size())
	{
		ub=new char[expr.m.size()];
		memset(ub, 0, expr.m.size()*sizeof(char));
	}
	else
		ub=nullptr;
	if(expr.n.size())
	{
		term=(CompileTerm*)malloc(expr.n.size()*sizeof(CompileTerm));
		for(unsigned n=0;n<expr.n.size();++n)
		{
			auto &t=expr.n[n];
			term[n]=CompileTerm(t.constant, t.mathSet);
		}
	}
	else
		term=nullptr;


	auto map=expr.m;
	int dataSize=expr.n.size();
	int f=expr.m.size()-1;
	compile_block(1, f);
	if(recursiveFunction&&predictedMathSet>'R')//'R' < 'c'
	{
		expr.m=map;
		delete[] ub;
		if(expr.m.size())
		{
			ub=new char[expr.m.size()];
			memset(ub, 0, expr.m.size()*sizeof(char));
		}
		else
			ub=nullptr;
		expr.n.resize(dataSize), expr.data.resize(dataSize);
		if(dataSize)
		{
			term=(CompileTerm*)realloc(term, dataSize*sizeof(CompileTerm));
			for(unsigned n=0;n<expr.n.size();++n)
			{
				auto &t=expr.n[n];
				term[n]=CompileTerm(t.constant, t.mathSet);
			}
		}
		else
			term=nullptr;
		expr.i.clear();
		compile_block(1, f);
	}
//	compile_block(1, expr.m.size()-1);

//	compile_block(0, expr.m.size());
//	int k=0;
//	compile_statement(k, expr.m.size());

	delete[] ub;

	if(expr.i.size())
	{
		bool noBranches=true;
		for(unsigned k=0;k<expr.i.size();++k)
		{
			auto &in=expr.i[k];
			if(in.type>13&&in.type!='c')
			{
				noBranches=false;
				break;
			}
		}
		if(noBranches)//last instruction affects predictedMathType
		{
			auto &lastInstr=*expr.i.rbegin();
			if(lastInstr.type<4)
			{
				char mathSet=term[lastInstr.result].mathSet;
				if(predictedMathSet>mathSet)
				//	expr.resultMathSet=predictedMathSet=mathSet;
					predictedMathSet=mathSet;
			}
			else if(lastInstr.type=='c')
			{
				auto &definition=userFunctionDefinitions[lastInstr.op1];
				if(&definition!=&expr)//not a recursive call
				{
					char mathSet=definition.resultMathSet;
					predictedMathSet=maximum(predictedMathSet, mathSet);
					//if(predictedMathSet>mathSet)
					////	expr.resultMathSet=predictedMathSet=mathSet;
					//	predictedMathSet=mathSet;
				}
			}//'r' handled in compile_statement
		}
	}
	else//no instructions, default return 0;
		compile_instruction_return(Value());
	free(term);
}

int				Compile::expressionResultLogicType()
{
	using namespace G2;
//	if(expr->lastInstruction>M_FUNCTION_START)																return 0;
	if(expr->lastInstruction>M_FSTART)																		return 0;
	switch(expr->lastInstruction)
	{
	case M_FACTORIAL_LOGIC_NOT:	case M_BITWISE_NOT:															return 0;
	case M_PLUS:				case M_MINUS:																return 0;
	case M_BITWISE_AND:			case M_BITWISE_NAND:														return 0;
	case M_BITWISE_XOR:			case M_BITWISE_XNOR:														return 0;
	case M_VERTICAL_BAR:		case M_BITWISE_NOR:															return 0;
	case M_MULTIPLY:			case M_DIVIDE:case M_MODULO_PERCENT:										return 0;
	case M_LOGIC_DIVIDES:																					return 1;
	case M_BITWISE_SHIFT_LEFT:	case M_BITWISE_SHIFT_RIGHT:													return 0;
	case M_POWER:																							return 0;
	case M_TETRATE:																							return 0;
	case M_PENTATE:																							return 0;
	case M_LOGIC_LESS:			case M_LOGIC_LESS_EQUAL:case M_LOGIC_GREATER:case M_LOGIC_GREATER_EQUAL:	return 1;
	case M_LOGIC_EQUAL:																						return 2;
	case M_LOGIC_NOT_EQUAL:																					return 3;
	case M_LOGIC_AND:																						return 1;
	case M_LOGIC_XOR:																						return 1;
	case M_LOGIC_OR:																						return 1;
	case M_CONDITION_ZERO:																					return 0;
	case M_S_EQUAL_ASSIGN:																					return 2;
	case M_S_NOT_EQUAL:																						return 3;
	case M_S_LESS:case M_S_LESS_EQUAL:case M_S_GREATER:case M_S_GREATER_EQUAL:								return 1;
	}
																											return 0;//
}
int Compile::default_overload(int S)//each bit marks correponding overload
{
	using namespace G2;
	if(S>M_FSTART&&S<M_BFSTART)//unary function
		return 0x02;//B0010		only 1 arg overload (no 0 arg overload)
	if(S<M_VFSTART)
		return 0x06;//B0110		1 arg & 2 arg overloads
	//if(S<M_VFSTART)
	//	return 0x0E;//B1110		1, 2 or 3 args
	if(S<M_USER_FUNCTION)
		return -1;//all bits set: variadic
	return 0;
}
void Compile::compile_expression_global(Expression &expr)
{
	using namespace G2;
	procedural=false;//, recursiveFunction=false;
	Compile::expr=&expr;

	auto data0=expr.data;//copy of original data for n0d
	std::vector<char> mathSet0(expr.n.size());
	for(int k=0, kEnd=expr.n.size();k<kEnd;++k)
		mathSet0[k]=expr.n[k].mathSet;

	if(expr.m.size())
	{
		ub=new char[expr.m.size()];
		memset(ub, 0, expr.m.size()*sizeof(char));
	}
	else
		ub=0;
	if(expr.n.size())
	{
		term=(CompileTerm*)malloc(expr.n.size()*sizeof(CompileTerm));
		for(unsigned n=0;n<expr.n.size();++n)
		{
			auto &t=expr.n[n];
			term[n]=CompileTerm(t.constant, t.mathSet);
		}
	}
	else
		term=0;
	for(;;)
	{
		int topLevel=0, i=-1, f=-1;
		{
			bool peak=false;
			for(int k=0, kEnd=expr.m.size(), level=0;k<kEnd;++k)
			{
				if(expr.m[k]._0==M_LPR)
				{
					++level;
					if(level>=topLevel)
						topLevel=level, i=k+1, peak=true;
				}
				else if(expr.m[k]._0==M_RPR)
				{
					--level;
					if(peak)
						f=k, peak=false;
				}
			}
		}
			 if(i==-1)	i=0;
		else			expr.m[i-1]._0=M_IGNORED;
			 if(f==-1)	f=expr.m.size();
		else			expr.m[f  ]._0=M_IGNORED;
		bool callLevel=topLevel>0&&i-2>=0&&expr.m[i-2]._0>M_FSTART;
		for(int k=i;k<f;++k)//parse lazy calls
		{
			auto &S=expr.m[k]._0;				//sys 20150525 overloads and redefinitions
			if(S>M_BFSTART)
		//	if(S==M_USER_FUNCTION)//user function lazy call
			{
				std::vector<int> commas;
				int k2=k+1;
				for(;k2<f&&expr.m[k2]._0<M_FSTART;++k2)
					if(expr.m[k2]._0==M_COMMA)
						commas.push_back(k2);
				if(commas.size())//lazy call
				{
					int name_id=expr.m[k]._1, d_match=-1, exprNArgs=commas.size()+1, overloads=0;
					if(S==M_USER_FUNCTION)
					{
						for(int d=0, dEnd=userFunctionDefinitions.size(), max_nArgs=-1;d<dEnd&&expr.lineNo>userFunctionDefinitions[d].lineNo;++d)//linearly through all user definitions
						{
							auto &definition=userFunctionDefinitions[d];
							if(definition.valid&&name_id==definition.name_id&&exprNArgs>=definition.nArgs&&max_nArgs<=definition.nArgs)
								d_match=d, max_nArgs=definition.nArgs;
						}
						if(callLevel&&exprNArgs!=userFunctionDefinitions[d_match].nArgs)
							d_match=-1;
					}
					else//built-in function
					{
						overloads=default_overload(S);
						d_match=-!(overloads==-1||exprNArgs<32&&overloads&1<<exprNArgs);
					}
				//	if(S<M_USER_FUNCTION||d_match!=-1&&(!callLevel||exprNArgs==userFunctionDefinitions[d_match].nArgs))
					if(d_match!=-1)
					{
						std::vector<ArgIdx> args(exprNArgs);
						{
							int start=k+1;
						//	int start=k;
							for(int k3=0, k3End=exprNArgs-1;k3<k3End;++k3)
							{
								expr.m[commas[k3]]._0=M_IGNORED;
								compile_inline_if(start, commas[k3], 0);
								args[k3].idx=expr.m[start]._1, expr.m[start]._0=M_IGNORED;
								start=commas[k3]+1;
							}
							compile_inline_if(start, f, 1);
							args[exprNArgs-1].idx=expr.m[start]._1, expr.m[start]._0=M_IGNORED;
						}
						if(S==M_USER_FUNCTION)
						{
							int result=compile_instruction_userFunctionCall(d_match, args);
							S=M_N, expr.m[k]._1=result;
						}
						else if(S>M_VFSTART)//built-in variadic
						{
							int result=compile_instruction_userFunctionCall(-S, args);
							S=M_N, expr.m[k]._1=result;
						}
						else//built-in binary or triary
						{
							compile_instruction(k, '<', k+1, commas[0]+1, commas.size()>1?commas[1]+1:-1);
							S=M_N, expr.m[k]._1=expr.ni.rbegin()->result;
						}
					}
					else//syntax error, no such overload
					{
						expr.insertSyntaxError(expr.m[k].pos, expr.m[*commas.rbegin()].pos+1);//function id and 'arglist'
				//		expr.insertSyntaxError(expr.m[k].pos, expr.m[k].len);//mark the error		lazy call mismatch: highlight function id
				//	//	expr.insertSyntaxError(expr.m[k]._1);
						expr.i.clear();
						expr.valid=false;
						return;
					}
				}
			}
#if 0
		//	else if(S>M_BINARY_FUNCTION_START)
			else if(S>M_BFSTART)//default binary function lazy call
			{
				std::vector<int> commas;
				int k2=k+1;
				for(;k2<f&&expr.m[k2]._0<M_FSTART;++k2)
					if(expr.m[k2]._0==M_COMMA)
						commas.push_back(k2);
			//	int overloads=default_overload(S), exprNArgs=commas.size()+1;
			//	if(overloads==-1||exprNArgs<32&&overloads&1<<exprNArgs)//variadic or overload found
			//	{
			//	}
				if(commas.size())
				{
					if(callLevel||commas.size()==1)
					{
						compile_inline_if(k+1, *commas.data(), 0);
						int a2_start=commas[0]+1, a2_end=commas.size()>1?commas[1]:f;
						if(a2_start==a2_end)
							compile_instruction(k, '<', k+1);
						else
						{
							compile_inline_if(a2_start, a2_end, 3);
						//	compile_inline_if(commas[0]+1, commas.size()>1?commas[1]:f, 3);
						//	compile_inline_if(k+1, *commas.data(), 0, true);
						//	compile_inline_if(commas[0]+1, commas.size()>1?commas[1]:f, 3, true);
							compile_instruction(k, '<', k+1, commas[0]+1);
						}
						S=G2::M_IGNORED, expr.m[commas[0]]._0=M_IGNORED;
					}
					else
					{
						expr.insertSyntaxError(expr.m[commas[1]].pos, expr.m[commas[1]].pos+1);//unexpected comma(s)
						expr.i.clear();
						expr.valid=false;
						return;
					}
				}
				else if(!(default_overload(S)&0x03))//no unary/void overload: call mismatch		later?
				{
				//	expr.insertSyntaxError(expr.m[k].pos, expr.m[k].len);//call mismatch, [function id]		default function: missing arguments get default values
					expr.i.clear();
					expr.valid=false;
					return;
				}
			}
#endif
		}
		if(callLevel)
	//	if(topLevel>0&&i-2>=0&&expr.m[i-2]._0>M_FSTART)
		{
			auto &S=expr.m[i-2]._0;
			std::vector<int> commas;
			bool notVoidCall=false;
			for(int k=i;k<f;++k)
			{
				auto &S2=expr.m[k]._0;
				if(S2==M_COMMA)
					commas.push_back(k);
				notVoidCall|=S2!=M_IGNORED;
			}
			int exprNArgs=commas.size()+notVoidCall;
#if 0
			if(S<M_USER_FUNCTION)//default function call level
			{
				int signature=default_overload(S);
				if(signature&(1<<exprNArgs))//default overload match
				{
					int start=i;
					for(int k=0, kEnd=commas.size();k<kEnd;++k)
					{
						expr.m[commas[k]]._0=M_IGNORED;
						compile_inline_if(start, commas[k], 0);
					//	compile_inline_if(start+1, commas[k], 0, true);
						start=commas[k]+1;
					}
					compile_inline_if(start, f, 0);
				//	compile_inline_if(start+1, f, 0, true);
					if(exprNArgs==1)
						compile_instruction(i-2, '<', i);
					else if(exprNArgs==2)
						compile_instruction(i-2, '<', i, commas[0]+1);
					S=G2::M_IGNORED;
				}
				else//syntax error, no such overload
				{
					if(exprNArgs>signature)//too many args: highlight unexpected args
						expr.insertSyntaxError(expr.m[commas[signature>0x3]].pos, expr.m[f].pos);
				//	else//highlight arglist contents
				//		expr.insertSyntaxError(expr.m[i].pos, expr.m[f].pos);		//default function: missing args get default values
					//	expr.insertSyntaxError(expr.m[i-(i==f)].pos, expr.m[f].pos);
					expr.i.clear();
					expr.valid=false;
					return;
				}
			}
			else//user function call level
#endif
			{
				int name_id=expr.m[i-2]._1, d_match=-1, overloads=0;
				if(S==M_USER_FUNCTION)
				{
					for(int d=0, dEnd=userFunctionDefinitions.size();d<dEnd&&expr.lineNo>userFunctionDefinitions[d].lineNo;++d)//linearly through all user definitions
					{
						auto &definition=userFunctionDefinitions[d];
						if(definition.valid&&name_id==definition.name_id&&exprNArgs==definition.nArgs)//find overload instance		sorted by lineNo
							d_match=d;
					}
				}
				else//built-in function
				{
					overloads=default_overload(S);
					d_match=-!(overloads==-1||exprNArgs<32&&overloads&1<<exprNArgs);
				}
				if(d_match!=-1)
				{
					std::vector<ArgIdx> args(exprNArgs);
					if(notVoidCall)//compile args
					{
						int start=i;
						for(int k3=0, k3End=exprNArgs-1;k3<k3End;++k3)
						{
							expr.m[commas[k3]]._0=M_IGNORED;
							compile_inline_if(start, commas[k3], 0);
							args[k3].idx=expr.m[start]._1, expr.m[start]._0=M_IGNORED;
							start=commas[k3]+1;
						}
						compile_inline_if(start, f, 0);
						args[exprNArgs-1].idx=expr.m[start]._1, expr.m[start]._0=M_IGNORED;
					}
					int k=i-2;
					if(S==M_USER_FUNCTION)
					{
						int result=compile_instruction_userFunctionCall(d_match, args);
						S=M_N, expr.m[k]._1=result;
					}
					else if(S>M_VFSTART)//built-in variadic
					{
						int result=compile_instruction_userFunctionCall(-S, args);
						S=M_N, expr.m[k]._1=result;
					}
					else//built-in unary or binary
					{
						compile_instruction(k, '<', i, commas.size()?commas[0]+1:-1, commas.size()>1?commas[1]+1:-1);
						S=M_N, expr.m[k]._1=expr.ni.size()?expr.ni.rbegin()->result:expr.m[i]._1;
					}
				}
				else//syntax error, no such overload
				{
					expr.insertSyntaxError(expr.m[i-(i==f)].pos, expr.m[f].pos);//arglist
				//	expr.insertSyntaxError(expr.m[k]._1);//mark the error		function call level: highlight id, parentheses and arglist
					expr.i.clear();
					expr.valid=false;
					return;
				}
			}
		}
		else//not a call	or ground level
		{
			for(int k=i;k<f;++k)
			{
				if(expr.m[k]._0==M_COMMA)//unexpected comma
				{
					expr.insertSyntaxError(expr.m[k].pos, expr.m[k].pos+1);//just the comma
				//	expr.insertSyntaxError(expr.m[k]._1);//mark the error		unexpected commas: highlight
					if(omitExprWithUnexpectedCommas)
					{
						expr.i.clear();
						expr.valid=false;
						return;
					}
					expr.m[k]._0=M_IGNORED;
				//	break;
				}
			}
			compile_inline_if(i, f, 0);
		//	compile_inline_if(i, f, 0, true);
		}
		if(topLevel<=0)
			break;
	}
	delete[] ub;
	if(expr.n.size())
	{
		if(expr.i.size())
			expr.resultTerm=expr.i.rbegin()->result;
		else if(expr.ni.size())//
			expr.resultTerm=expr.ni.rbegin()->result;
		else//
			expr.resultTerm=0;
		predictedMathSet=term[expr.resultTerm].mathSet;
		if(!expr.nISD)//n0d - use numeric instructions on original data
		{
			for(int k=0, kEnd=data0.size();k<kEnd;++k)
			{
				expr.data[k]=std::move(data0[k]);
				expr.n[k].mathSet=mathSet0[k];
			}
		//	expr.data=data0;
		}
	}
	free(term);
}

#ifdef CHECK_NULL_POINTERS
#define		NPA(pointer, idx)	(pointer?pointer[idx]:0)//null pointer access
#define		NPO(vec, mask)		(vec.p+(k2&mask))		//null pointer offset
//#define	NPO(vec, idx)		(vec.p+(idx&-(vec.p!=nullptr)))
//#define	NPO(pointer, idx)	(pointer+(idx&-(pointer!=nullptr)))
//#define	NPO(pointer, idx)	(pointer?pointer+idx:nullptr)
#else
#define		NPA(pointer, idx)	(pointer[idx])
#define		NPO(vec, mask)		(vec.p+k2)
#endif
#ifdef __GNUC__
#define		BITREF		auto
#else
#define		BITREF		auto&
#endif
bool disc_conditional(Value const &x0, Value const &x1)
{
	using namespace G2;
	return _1d_zero_in_range(x0.r, x1.r)&&_1d_zero_in_range(x0.i, x1.i)&&_1d_zero_in_range(x0.j, x1.j)&&_1d_zero_in_range(x0.k, x1.k);
//	return _1d_zero_in_range(x0.r, x1.r)||_1d_zero_in_range(x0.i, x1.i)||_1d_zero_in_range(x0.j, x1.j)||_1d_zero_in_range(x0.k, x1.k);
}
void disc_1d_in_u	(Expression &ex, Instruction &in, int offset, int disc_offset, int x1, int x2, int y1, int y2, int z1, int z2, int Xplaces, int Yplaces, int Zplaces)
{//discontinuity function: 1D, input, unary instruction
	auto &op1=ex.n[in.op1];
	auto op1_r=(double*)op1.r.p, op1_i=(double*)op1.i.p, op1_j=(double*)op1.j.p, op1_k=(double*)op1.k.p;
	for(int v=x1, vEnd=x2-1;v<vEnd;++v)
	{
		BITREF condition=ex.discontinuities[v];
		condition=condition||in.d.ud_i
		(
			Value(op1_r[v], NPA(op1_i, v), NPA(op1_j, v), NPA(op1_k, v)),
			Value(op1_r[v+1], NPA(op1_i, v+1), NPA(op1_j, v+1), NPA(op1_k, v+1))
		);
	}
}
void disc_1d_in_b	(Expression &ex, Instruction &in, int offset, int disc_offset, int x1, int x2, int y1, int y2, int z1, int z2, int Xplaces, int Yplaces, int Zplaces)
{//discontinuity function: 1D, input, binary instruction
	auto &op1=ex.n[in.op1], &op2=ex.n[in.op2];
	auto op1_r=(double*)op1.r.p, op1_i=(double*)op1.i.p, op1_j=(double*)op1.j.p, op1_k=(double*)op1.k.p;
	auto op2_r=(double*)op2.r.p, op2_i=(double*)op2.i.p, op2_j=(double*)op2.j.p, op2_k=(double*)op2.k.p;
	for(int v=x1, vEnd=x2-1;v<vEnd;++v)
	{
		BITREF condition=ex.discontinuities[v];
		condition=condition||in.d.bd_i
		(
			Value(op1_r[v], NPA(op1_i, v), NPA(op1_j, v), NPA(op1_k, v)),
			Value(op2_r[v], NPA(op2_i, v), NPA(op2_j, v), NPA(op2_k, v)),
			Value(op1_r[v+1], NPA(op1_i, v+1), NPA(op1_j, v+1), NPA(op1_k, v+1)),
			Value(op2_r[v+1], NPA(op2_i, v+1), NPA(op2_j, v+1), NPA(op2_k, v+1))
		);
	}
}
void disc_1d_in_t	(Expression &ex, Instruction &in, int offset, int disc_offset, int x1, int x2, int y1, int y2, int z1, int z2, int Xplaces, int Yplaces, int Zplaces)
{//discontinuity function: 1D, input, triary (only inline if is a default triary function)
	auto &op1=ex.n[in.op1];
	auto op1_r=(double*)op1.r.p, op1_i=(double*)op1.i.p, op1_j=(double*)op1.j.p, op1_k=(double*)op1.k.p;
	for(int v=x1, vEnd=x2-1;v<vEnd;++v)
	{
		BITREF condition=ex.discontinuities[v];
		condition=condition||disc_conditional
		(
			Value(op1_r[v], NPA(op1_i, v), NPA(op1_j, v), NPA(op1_k, v)),
			Value(op1_r[v+1], NPA(op1_i, v+1), NPA(op1_j, v+1), NPA(op1_k, v+1))
		);
	}
}
void disc_1d_out	(Expression &ex, Instruction &in, int offset, int disc_offset, int x1, int x2, int y1, int y2, int z1, int z2, int Xplaces, int Yplaces, int Zplaces)
{//discontinuity function: 1D, output, (always unary)
	auto &op1=ex.n[in.result];
	auto op1_r=(double*)op1.r.p, op1_i=(double*)op1.i.p, op1_j=(double*)op1.j.p, op1_k=(double*)op1.k.p;
	for(int v=x1;v<x2-1;++v)
	{
		BITREF condition=ex.discontinuities[v];
		condition=condition||in.d.d_o
		(
			Value(op1_r[v], NPA(op1_i, v), NPA(op1_j, v), NPA(op1_k, v)),
			Value(op1_r[v+1], NPA(op1_i, v+1), NPA(op1_j, v+1), NPA(op1_k, v+1))
		);
	}
}

void disc_i2d_in_u	(Expression &ex, Instruction &in, int offset, int disc_offset, int x1, int x2, int y1, int y2, int z1, int z2, int aXplaces, int aYplaces, int Zplaces)
{
	auto &op1=ex.n[in.op1];
	auto op1_r=(double*)op1.r.p, op1_i=(double*)op1.i.p, op1_j=(double*)op1.j.p, op1_k=(double*)op1.k.p;
	int Xplaces=aXplaces-2, Yplaces=aYplaces-2;
	for(int y=y1;y<y2;++y)
	{
		for(int x=x1;x<x2-1;++x)
		{
			unsigned v=(Xplaces+2)*y+x;
			//if(v>=op1.ndr.size()||(Xplaces+1)*y+x>=ex.discontinuities.size())
			//	int LOL_1=0;
			BITREF condition=ex.discontinuities[(Xplaces+1)*y+x];
			condition=condition||in.d.ud_i
			(
				Value(op1_r[v], NPA(op1_i, v), NPA(op1_j, v), NPA(op1_k, v)),
				Value(op1_r[v+1], NPA(op1_i, v+1), NPA(op1_j, v+1), NPA(op1_k, v+1))
			);
		}
	}
	for(int y=y1;y<y2-1;++y)
	{
		for(int x=x1;x<x2;++x)
		{
			unsigned v=(Xplaces+2)*y+x;
			BITREF condition=ex.discontinuities[disc_offset+v];
			condition=condition||in.d.ud_i
			(
				Value(op1_r[v], op1_i?op1_i[v]:0, op1_j?op1_j[v]:0, op1_k?op1_k[v]:0),
				Value(op1_r[v+Xplaces+2], op1_i?op1_i[v+Xplaces+2]:0, op1_j?op1_j[v+Xplaces+2]:0, op1_k?op1_k[v+Xplaces+2]:0)
			);
		}
	}
}
void disc_i2d_in_b	(Expression &ex, Instruction &in, int offset, int disc_offset, int x1, int x2, int y1, int y2, int z1, int z2, int aXplaces, int aYplaces, int Zplaces)
{
	auto &op1=ex.n[in.op1], &op2=ex.n[in.op2];
	auto op1_r=(double*)op1.r.p, op1_i=(double*)op1.i.p, op1_j=(double*)op1.j.p, op1_k=(double*)op1.k.p;
	auto op2_r=(double*)op2.r.p, op2_i=(double*)op2.i.p, op2_j=(double*)op2.j.p, op2_k=(double*)op2.k.p;
	int Xplaces=aXplaces-2, Yplaces=aYplaces-2;
	for(int y=y1;y<y2;++y)
	{
		for(int x=x1;x<x2-1;++x)
		{
			unsigned v=(Xplaces+2)*y+x;
			BITREF condition=ex.discontinuities[(Xplaces+1)*y+x];
			condition=condition||in.d.bd_i
			(
				Value(op1_r[v], op1_i?op1_i[v]:0, op1_j?op1_j[v]:0, op1_k?op1_k[v]:0),
				Value(op2_r[v], op2_i?op2_i[v]:0, op2_j?op2_j[v]:0, op2_k?op2_k[v]:0),
				Value(op1_r[v+1], op1_i?op1_i[v+1]:0, op1_j?op1_j[v+1]:0, op1_k?op1_k[v+1]:0),
				Value(op2_r[v+1], op2_i?op2_i[v+1]:0, op2_j?op2_j[v+1]:0, op2_k?op2_k[v+1]:0)
			);
		}
	}
	for(int y=y1;y<y2-1;++y)
	{
		for(int x=x1;x<x2;++x)
		{
			unsigned v=(Xplaces+2)*y+x;
			BITREF condition=ex.discontinuities[disc_offset+v];
			condition=condition||in.d.bd_i
			(
				Value(op1_r[v], op1_i?op1_i[v]:0, op1_j?op1_j[v]:0, op1_k?op1_k[v]:0),
				Value(op2_r[v], op2_i?op2_i[v]:0, op2_j?op2_j[v]:0, op2_k?op2_k[v]:0),
				Value(op1_r[v+Xplaces+2], op1_i?op1_i[v+Xplaces+2]:0, op1_j?op1_j[v+Xplaces+2]:0, op1_k?op1_k[v+Xplaces+2]:0),
				Value(op2_r[v+Xplaces+2], op2_i?op2_i[v+Xplaces+2]:0, op2_j?op2_j[v+Xplaces+2]:0, op2_k?op2_k[v+Xplaces+2]:0)
			);
		}
	}
}
void disc_i2d_in_t	(Expression &ex, Instruction &in, int offset, int disc_offset, int x1, int x2, int y1, int y2, int z1, int z2, int aXplaces, int aYplaces, int Zplaces)
{
	auto &op1=ex.n[in.op1];
	auto op1_r=(double*)op1.r.p, op1_i=(double*)op1.i.p, op1_j=(double*)op1.j.p, op1_k=(double*)op1.k.p;
	int Xplaces=aXplaces-2, Yplaces=aYplaces-2;
	for(int y=y1;y<y2;++y)
	{
		for(int x=x1;x<x2-1;++x)
		{
			unsigned v=(Xplaces+2)*y+x;
			BITREF condition=ex.discontinuities[(Xplaces+1)*y+x];
			condition=condition||disc_conditional
			(
				Value(op1_r[v], op1_i?op1_i[v]:0, op1_j?op1_j[v]:0, op1_k?op1_k[v]:0),
				Value(op1_r[v+1], op1_i?op1_i[v+1]:0, op1_j?op1_j[v+1]:0, op1_k?op1_k[v+1]:0)
			);
		}
	}
	for(int y=y1;y<y2-1;++y)
	{
		for(int x=x1;x<x2;++x)
		{
			unsigned v=(Xplaces+2)*y+x;
			BITREF condition=ex.discontinuities[disc_offset+v];
			condition=condition||disc_conditional
			(
				Value(op1_r[v], op1_i?op1_i[v]:0, op1_j?op1_j[v]:0, op1_k?op1_k[v]:0),
				Value(op1_r[v+Xplaces+2], op1_i?op1_i[v+Xplaces+2]:0, op1_j?op1_j[v+Xplaces+2]:0, op1_k?op1_k[v+Xplaces+2]:0)
			);
		}
	}
}
void disc_i2d_out	(Expression &ex, Instruction &in, int offset, int disc_offset, int x1, int x2, int y1, int y2, int z1, int z2, int aXplaces, int aYplaces, int Zplaces)
{
	auto &op1=ex.n[in.result];
	auto op1_r=(double*)op1.r.p, op1_i=(double*)op1.i.p, op1_j=(double*)op1.j.p, op1_k=(double*)op1.k.p;
	int Xplaces=aXplaces-2, Yplaces=aYplaces-2;
	for(int y=y1;y<y2;++y)
	{
		for(int x=x1;x<x2-1;++x)
		{
			unsigned v=(Xplaces+2)*y+x;
			BITREF condition=ex.discontinuities[(Xplaces+1)*y+x];
			condition=condition||in.d.d_o
			(
				Value(op1_r[v], op1_i?op1_i[v]:0, op1_j?op1_j[v]:0, op1_k?op1_k[v]:0),
				Value(op1_r[v+1], op1_i?op1_i[v+1]:0, op1_j?op1_j[v+1]:0, op1_k?op1_k[v+1]:0)
			);
		}
	}
	for(int y=y1;y<y2-1;++y)
	{
		for(int x=x1;x<x2;++x)
		{
			unsigned v=(Xplaces+2)*y+x;
			BITREF condition=ex.discontinuities[disc_offset+v];
			condition=condition||in.d.d_o
			(
				Value(op1_r[v], op1_i?op1_i[v]:0, op1_j?op1_j[v]:0, op1_k?op1_k[v]:0),
				Value(op1_r[v+Xplaces+2], op1_i?op1_i[v+Xplaces+2]:0, op1_j?op1_j[v+Xplaces+2]:0, op1_k?op1_k[v+Xplaces+2]:0)
			);
		}
	}
}

void disc_2d_in_u	(Expression &ex, Instruction &in, int offset, int disc_offset, int x1, int x2, int y1, int y2, int z1, int z2, int Xplaces, int Yplaces, int Zplaces)
{
	auto &op1=ex.n[in.op1];
	auto op1_r=(double*)op1.r.p, op1_i=(double*)op1.i.p, op1_j=(double*)op1.j.p, op1_k=(double*)op1.k.p;
//	unsigned yDiscOffset=(Xplaces-1)*Yplaces;
	for(int y=y1;y<y2;++y)
	{
		for(int x=x1;x<x2-1;++x)
		{
			unsigned v=Xplaces*y+x;
			BITREF condition=ex.discontinuities[(Xplaces-1)*y+x];
			condition=condition||in.d.ud_i(Value(op1_r[v], op1_i?op1_i[v]:0, op1_j?op1_j[v]:0, op1_k?op1_k[v]:0),
				Value(op1_r[v+1], op1_i?op1_i[v+1]:0, op1_j?op1_j[v+1]:0, op1_k?op1_k[v+1]:0));
		//	condition=condition||in.d.ud_i(op1.ndr[v], op1.ndr[v+1]);
		}
	}
	for(int x=x1;x<x2;++x)
	{
		for(int y=y1;y<y2-1;++y)
		{
			unsigned v=Xplaces*y+x;
			BITREF condition=ex.discontinuities[disc_offset+(Yplaces-1)*x+y];
			condition=condition||in.d.ud_i(Value(op1_r[v], op1_i?op1_i[v]:0, op1_j?op1_j[v]:0, op1_k?op1_k[v]:0),
				Value(op1_r[v+Xplaces], op1_i?op1_i[v+Xplaces]:0, op1_j?op1_j[v+Xplaces]:0, op1_k?op1_k[v+Xplaces]:0));
		//	condition=condition||in.d.ud_i(op1.ndr[v], op1.ndr[v+Xplaces]);
		}
	}
}
void disc_2d_in_b	(Expression &ex, Instruction &in, int offset, int disc_offset, int x1, int x2, int y1, int y2, int z1, int z2, int Xplaces, int Yplaces, int Zplaces)
{
	auto &op1=ex.n[in.op1], &op2=ex.n[in.op2];
	auto op1_r=(double*)op1.r.p, op1_i=(double*)op1.i.p, op1_j=(double*)op1.j.p, op1_k=(double*)op1.k.p;
	auto op2_r=(double*)op2.r.p, op2_i=(double*)op2.i.p, op2_j=(double*)op2.j.p, op2_k=(double*)op2.k.p;
//	unsigned yDiscOffset=(Xplaces-1)*Yplaces;
	for(int y=y1;y<y2;++y)
	{
		for(int x=x1;x<x2-1;++x)
		{
			unsigned v=Xplaces*y+x;
			BITREF condition=ex.discontinuities[(Xplaces-1)*y+x];
			condition=condition||in.d.bd_i
			(
				Value(op1_r[v], op1_i?op1_i[v]:0, op1_j?op1_j[v]:0, op1_k?op1_k[v]:0),
				Value(op2_r[v], op2_i?op2_i[v]:0, op2_j?op2_j[v]:0, op2_k?op2_k[v]:0),
				Value(op1_r[v+1], op1_i?op1_i[v+1]:0, op1_j?op1_j[v+1]:0, op1_k?op1_k[v+1]:0),
				Value(op2_r[v+1], op2_i?op2_i[v+1]:0, op2_j?op2_j[v+1]:0, op2_k?op2_k[v+1]:0)
			);
		}
	}
	for(int x=x1;x<x2;++x)
	{
		for(int y=y1;y<y2-1;++y)
		{
			unsigned v=Xplaces*y+x;
			BITREF condition=ex.discontinuities[disc_offset+(Yplaces-1)*x+y];
			condition=condition||in.d.bd_i
			(
				Value(op1_r[v], op1_i?op1_i[v]:0, op1_j?op1_j[v]:0, op1_k?op1_k[v]:0),
				Value(op2_r[v], op2_i?op2_i[v]:0, op2_j?op2_j[v]:0, op2_k?op2_k[v]:0),
				Value(op1_r[v+Xplaces], op1_i?op1_i[v+Xplaces]:0, op1_j?op1_j[v+Xplaces]:0, op1_k?op1_k[v+Xplaces]:0),
				Value(op2_r[v+Xplaces], op2_i?op2_i[v+Xplaces]:0, op2_j?op2_j[v+Xplaces]:0, op2_k?op2_k[v+Xplaces]:0)
			);
		}
	}
}
void disc_2d_in_t	(Expression &ex, Instruction &in, int offset, int disc_offset, int x1, int x2, int y1, int y2, int z1, int z2, int Xplaces, int Yplaces, int Zplaces)
{
	auto &op1=ex.n[in.op1];
	auto op1_r=(double*)op1.r.p, op1_i=(double*)op1.i.p, op1_j=(double*)op1.j.p, op1_k=(double*)op1.k.p;
//	unsigned yDiscOffset=(Xplaces-1)*Yplaces;
	for(int y=y1;y<y2;++y)
	{
		for(int x=x1;x<x2-1;++x)
		{
			unsigned v=Xplaces*y+x;
			BITREF condition=ex.discontinuities[(Xplaces-1)*y+x];
			condition=condition||disc_conditional
			(
				Value(op1_r[v], op1_i?op1_i[v]:0, op1_j?op1_j[v]:0, op1_k?op1_k[v]:0),
				Value(op1_r[v+1], op1_i?op1_i[v+1]:0, op1_j?op1_j[v+1]:0, op1_k?op1_k[v+1]:0)
			);
		}
	}
	for(int x=x1;x<x2;++x)
	{
		for(int y=y1;y<y2-1;++y)
		{
			unsigned v=Xplaces*y+x;
			BITREF condition=ex.discontinuities[disc_offset+(Yplaces-1)*x+y];
			condition=condition||disc_conditional
			(
				Value(op1_r[v], op1_i?op1_i[v]:0, op1_j?op1_j[v]:0, op1_k?op1_k[v]:0),
				Value(op1_r[v+Xplaces], op1_i?op1_i[v+Xplaces]:0, op1_j?op1_j[v+Xplaces]:0, op1_k?op1_k[v+Xplaces]:0)
			);
		}
	}
}
void disc_2d_out	(Expression &ex, Instruction &in, int offset, int disc_offset, int x1, int x2, int y1, int y2, int z1, int z2, int Xplaces, int Yplaces, int Zplaces)
{
	auto &op1=ex.n[in.result];
	auto op1_r=(double*)op1.r.p, op1_i=(double*)op1.i.p, op1_j=(double*)op1.j.p, op1_k=(double*)op1.k.p;
//	unsigned yDiscOffset=(Xplaces-1)*Yplaces;
	for(int y=y1;y<y2;++y)
	{
		for(int x=x1;x<x2-1;++x)
		{
			unsigned v=Xplaces*y+x;
			BITREF condition=ex.discontinuities[(Xplaces-1)*y+x];
			condition=condition||in.d.d_o
			(
				Value(op1_r[v], op1_i?op1_i[v]:0, op1_j?op1_j[v]:0, op1_k?op1_k[v]:0),
				Value(op1_r[v+1], op1_i?op1_i[v+1]:0, op1_j?op1_j[v+1]:0, op1_k?op1_k[v+1]:0)
			);
		}
	}
	for(int x=x1;x<x2;++x)
	{
		for(int y=y1;y<y2-1;++y)
		{
			unsigned v=Xplaces*y+x;
			BITREF condition=ex.discontinuities[disc_offset+(Yplaces-1)*x+y];
			condition=condition||in.d.d_o
			(
				Value(op1_r[v], op1_i?op1_i[v]:0, op1_j?op1_j[v]:0, op1_k?op1_k[v]:0),
				Value(op1_r[v+Xplaces], op1_i?op1_i[v+Xplaces]:0, op1_j?op1_j[v+Xplaces]:0, op1_k?op1_k[v+Xplaces]:0)
			);
		}
	}
}

void disc_l2d_X_in_u(Expression &ex, Instruction &in, int offset, int disc_offset, int x1, int x2, int y1, int y2, int z1, int z2, int Xplaces, int Yplaces, int Zplaces)
{
	auto &op1=ex.n[in.op1];
	auto op1_r=(double*)op1.r.p, op1_i=(double*)op1.i.p, op1_j=(double*)op1.j.p, op1_k=(double*)op1.k.p;
	for(int y=y1;y<y2;++y)
	{
		for(int x=x1;x<x2-1;++x)
		{
			unsigned v=Xplaces*y+x;
			BITREF condition=ex.discontinuities[(Xplaces-1)*y+x];
			condition=condition||in.d.ud_i
			(
				Value(op1_r[v], op1_i?op1_i[v]:0, op1_j?op1_j[v]:0, op1_k?op1_k[v]:0),
				Value(op1_r[v+1], op1_i?op1_i[v+1]:0, op1_j?op1_j[v+1]:0, op1_k?op1_k[v+1]:0)
			);
		//	condition=condition||in.d.ud_i(op1.ndr[v], op1.ndr[v+1]);
		}
	}
}
void disc_l2d_Y_in_u(Expression &ex, Instruction &in, int offset, int disc_offset, int y1, int y2, int x1, int x2, int z1, int z2, int Yplaces, int Xplaces, int Zplaces)//x and y swapped
{
	auto &op1=ex.n[in.op1];
	auto op1_r=(double*)op1.r.p, op1_i=(double*)op1.i.p, op1_j=(double*)op1.j.p, op1_k=(double*)op1.k.p;
	for(int x=x1;x<x2;++x)
	{
		for(int y=y1;y<y2-1;++y)
		{
			unsigned v=offset+Yplaces*x+y;
			BITREF condition=ex.discontinuities[disc_offset+(Yplaces-1)*x+y];
			condition=condition||in.d.ud_i
			(
				Value(op1_r[v], op1_i?op1_i[v]:0, op1_j?op1_j[v]:0, op1_k?op1_k[v]:0),
				Value(op1_r[v+1], op1_i?op1_i[v+1]:0, op1_j?op1_j[v+1]:0, op1_k?op1_k[v+1]:0)
			);
		//	condition=condition||in.d.ud_i(op1.ndr[v], op1.ndr[v+1]);
		}
	}
}
void disc_l2d_X_in_b(Expression &ex, Instruction &in, int offset, int disc_offset, int x1, int x2, int y1, int y2, int z1, int z2, int Xplaces, int Yplaces, int Zplaces)
{
	auto &op1=ex.n[in.op1], &op2=ex.n[in.op2];
	auto op1_r=(double*)op1.r.p, op1_i=(double*)op1.i.p, op1_j=(double*)op1.j.p, op1_k=(double*)op1.k.p;
	auto op2_r=(double*)op2.r.p, op2_i=(double*)op2.i.p, op2_j=(double*)op2.j.p, op2_k=(double*)op2.k.p;
	for(int y=y1;y<y2;++y)
	{
		for(int x=x1;x<x2-1;++x)
		{
			unsigned v=Xplaces*y+x;
			BITREF condition=ex.discontinuities[(Xplaces-1)*y+x];
			condition=condition||in.d.bd_i
			(
				Value(op1_r[v], op1_i?op1_i[v]:0, op1_j?op1_j[v]:0, op1_k?op1_k[v]:0),
				Value(op2_r[v], op2_i?op2_i[v]:0, op2_j?op2_j[v]:0, op2_k?op2_k[v]:0),
				Value(op1_r[v+1], op1_i?op1_i[v+1]:0, op1_j?op1_j[v+1]:0, op1_k?op1_k[v+1]:0),
				Value(op2_r[v+1], op2_i?op2_i[v+1]:0, op2_j?op2_j[v+1]:0, op2_k?op2_k[v+1]:0)
			);
		//	condition=condition||in.d.bd_i(op1.ndr[v], op2.ndr[v], op1.ndr[v+1], op2.ndr[v+1]);
		}
	}
}
void disc_l2d_Y_in_b(Expression &ex, Instruction &in, int offset, int disc_offset, int y1, int y2, int x1, int x2, int z1, int z2, int Yplaces, int Xplaces, int Zplaces)//x and y swapped
{
	auto &op1=ex.n[in.op1], &op2=ex.n[in.op2];
	auto op1_r=(double*)op1.r.p, op1_i=(double*)op1.i.p, op1_j=(double*)op1.j.p, op1_k=(double*)op1.k.p;
	auto op2_r=(double*)op2.r.p, op2_i=(double*)op2.i.p, op2_j=(double*)op2.j.p, op2_k=(double*)op2.k.p;
	for(int x=x1;x<x2;++x)
	{
		for(int y=y1;y<y2-1;++y)
		{
			unsigned v=offset+Yplaces*x+y;
			BITREF condition=ex.discontinuities[disc_offset+(Yplaces-1)*x+y];
			condition=condition||in.d.bd_i
			(
				Value(op1_r[v], op1_i?op1_i[v]:0, op1_j?op1_j[v]:0, op1_k?op1_k[v]:0),
				Value(op2_r[v], op2_i?op2_i[v]:0, op2_j?op2_j[v]:0, op2_k?op2_k[v]:0),
				Value(op1_r[v+1], op1_i?op1_i[v+1]:0, op1_j?op1_j[v+1]:0, op1_k?op1_k[v+1]:0),
				Value(op2_r[v+1], op2_i?op2_i[v+1]:0, op2_j?op2_j[v+1]:0, op2_k?op2_k[v+1]:0)
			);
		//	condition=condition||in.d.bd_i(op1.ndr[v], op2.ndr[v], op1.ndr[v+1], op2.ndr[v+1]);
		}
	}
}
void disc_l2d_X_in_t(Expression &ex, Instruction &in, int offset, int disc_offset, int x1, int x2, int y1, int y2, int z1, int z2, int Xplaces, int Yplaces, int Zplaces)
{
	auto &op1=ex.n[in.op1];
	auto op1_r=(double*)op1.r.p, op1_i=(double*)op1.i.p, op1_j=(double*)op1.j.p, op1_k=(double*)op1.k.p;
	for(int y=y1;y<y2;++y)
	{
		for(int x=x1;x<x2-1;++x)
		{
			unsigned v=Xplaces*y+x;
			BITREF condition=ex.discontinuities[(Xplaces-1)*y+x];
			condition=condition||disc_conditional
			(
				Value(op1_r[v], op1_i?op1_i[v]:0, op1_j?op1_j[v]:0, op1_k?op1_k[v]:0),
				Value(op1_r[v+1], op1_i?op1_i[v+1]:0, op1_j?op1_j[v+1]:0, op1_k?op1_k[v+1]:0)
			);
		//	condition=condition||in.d.td_i(op1.ndr[v], op2.ndr[v], op3.ndr[v], op1.ndr[v+1], op2.ndr[v+1], op3.ndr[v+1]);
		}
	}
}
void disc_l2d_Y_in_t(Expression &ex, Instruction &in, int offset, int disc_offset, int y1, int y2, int x1, int x2, int z1, int z2, int Yplaces, int Xplaces, int Zplaces)//x and y swapped
{
	auto &op1=ex.n[in.op1];
	auto op1_r=(double*)op1.r.p, op1_i=(double*)op1.i.p, op1_j=(double*)op1.j.p, op1_k=(double*)op1.k.p;
	for(int x=x1;x<x2;++x)
	{
		for(int y=y1;y<y2-1;++y)
		{
			unsigned v=offset+Yplaces*x+y;
			BITREF condition=ex.discontinuities[disc_offset+(Yplaces-1)*x+y];
			condition=condition||disc_conditional
			(
				Value(op1_r[v], op1_i?op1_i[v]:0, op1_j?op1_j[v]:0, op1_k?op1_k[v]:0),
				Value(op1_r[v+1], op1_i?op1_i[v+1]:0, op1_j?op1_j[v+1]:0, op1_k?op1_k[v+1]:0)
			);
		//	condition=in.d.td_i(op1.ndr[v], op2.ndr[v], op3.ndr[v], op1.ndr[v+1], op2.ndr[v+1], op3.ndr[v+1]);
		}
	}
}
void disc_l2d_X_out	(Expression &ex, Instruction &in, int offset, int disc_offset, int x1, int x2, int y1, int y2, int z1, int z2, int Xplaces, int Yplaces, int Zplaces)
{
	auto &op1=ex.n[in.result];
	auto op1_r=(double*)op1.r.p, op1_i=(double*)op1.i.p, op1_j=(double*)op1.j.p, op1_k=(double*)op1.k.p;
	for(int y=y1;y<y2;++y)
	{
		for(int x=x1;x<x2-1;++x)
		{
			unsigned v=Xplaces*y+x;
			BITREF condition=ex.discontinuities[(Xplaces-1)*y+x];
			condition=condition||in.d.d_o
			(
				Value(op1_r[v], op1_i?op1_i[v]:0, op1_j?op1_j[v]:0, op1_k?op1_k[v]:0),
				Value(op1_r[v+1], op1_i?op1_i[v+1]:0, op1_j?op1_j[v+1]:0, op1_k?op1_k[v+1]:0)
			);
		//	condition=condition||in.d.d_o(result.ndr[v], result.ndr[v+1]);
		}
	}
}
void disc_l2d_Y_out	(Expression &ex, Instruction &in, int offset, int disc_offset, int y1, int y2, int x1, int x2, int z1, int z2, int Yplaces, int Xplaces, int Zplaces)//x and y swapped
{
	auto &op1=ex.n[in.result];
	auto op1_r=(double*)op1.r.p, op1_i=(double*)op1.i.p, op1_j=(double*)op1.j.p, op1_k=(double*)op1.k.p;
	for(int x=x1;x<x2;++x)
	{
		for(int y=y1;y<y2-1;++y)
		{
			unsigned v=offset+Yplaces*x+y;
			BITREF condition=ex.discontinuities[disc_offset+(Yplaces-1)*x+y];
			condition=condition||in.d.d_o
			(
				Value(op1_r[v], op1_i?op1_i[v]:0, op1_j?op1_j[v]:0, op1_k?op1_k[v]:0),
				Value(op1_r[v+1], op1_i?op1_i[v+1]:0, op1_j?op1_j[v+1]:0, op1_k?op1_k[v+1]:0)
			);
		//	condition=in.d.d_o(result.ndr[v], result.ndr[v+1]);
		}
	}
}
typedef void (*Disc_fn)(Expression &ex, Instruction &in, int offset, int disc_offset, int x1, int x2, int y1, int y2, int z1, int z2, int Xplaces, int Yplaces, int Zplaces);
inline int ceil_n(int x, int log2_n){return (x>>log2_n)+((x&(1<<log2_n)-1)!=0);}
inline int ceil_quarter(int x){return (x>>2)+((x&3)!=0);}
inline int ceil_half(int x){return (x>>1)+(x&1);}
void solve(Expression &ex, int offset, int x1, int x2, int y1, int y2, int z1, int z2, int Xplaces, int Yplaces, int Zplaces)//CPU-bound		will crash if dx not a multiple of simd step, exception: n0d
{
//	int dx=x2-x1, dy=y2-y1, dz=z2-z1, workSize=dx*dy*dz, ndrSize=Xplaces*Yplaces*Zplaces;
	int dx=x2-x1, dy=y2-y1, dz=z2-z1, workSize=dx*dy*dz, ndrSize=ex.n[0].r.size();
	//int increment=1<<simd_method, idx_sh=2;
	int logstep=simd_method&-(workSize>1);//simd compute unit size = 1<<logstep, logstep=0 for n0d/ia32, 1 for sse2, 2 for avx
	int offset_n=ceil_n(offset, logstep), x1_n=x1>>logstep, x2_n=ceil_n(x2, logstep), Xplaces_n=ceil_n(Xplaces, logstep), dx_n=x2_n-x1_n, workSize_n=dx_n*dy*dz;
#if defined _DEBUG || defined __GNUC__//
	for(int k=0, kEnd=workSize_n;k<kEnd;++k)
#else
	Concurrency::parallel_for(0, workSize_n, [&](int k)//for each SIMD group
#endif
	{
		int ka=k<<logstep;
		int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
		for(int i=0, iEnd=ex.i.size();i<iEnd;++i)//for each instruction
		{
			auto &in=ex.i[i];
			auto &res=ex.n[in.result], &op1=ex.n[in.op1], &op2=ex.n[in.type>=4&&in.type<=12||in.type>=18&&in.type<=27?in.op2:in.op1];
#ifdef CHECK_NULL_POINTERS
			unsigned
				mrr=-(res.r.p!=nullptr), mri=-(res.i.p!=nullptr), mrj=-(res.j.p!=nullptr), mrk=-(res.k.p!=nullptr),
				m1r=-(op1.r.p!=nullptr), m1i=-(op1.i.p!=nullptr), m1j=-(op1.j.p!=nullptr), m1k=-(op1.k.p!=nullptr),
				m2r=-(op2.r.p!=nullptr), m2i=-(op2.i.p!=nullptr), m2j=-(op2.j.p!=nullptr), m2k=-(op2.k.p!=nullptr);
#endif
			for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)//for each element in SIMD group (for non-SIMD instructions)
			{
				VectP rr;
				CompP cr;
				QuatP qr;
				switch(in.r_ms)
				{
				case 'R':
					rr.set(NPO(res.r, mrr));
					break;
				case 'c':
					cr.set(NPO(res.r, mrr), NPO(res.i, mri));
					break;
				case 'h':
					qr.set(NPO(res.r, mrr), NPO(res.i, mri), NPO(res.j, mrj), NPO(res.k, mrk));
					break;
				}
				switch(in.type)
				{
				case SIG_CALL:Solve_UserFunction(ex, in, false)(k2);break;
				case SIG_R_R:	(&in.ia32)[logstep]. r_r(rr,	VectP(NPO(op1.r, m1r)));													break;//r_r
				case SIG_C_C:	(&in.ia32)[logstep]. c_c(cr,	CompP(NPO(op1.r, m1r), NPO(op1.i, m1i)));									break;//c_c
				case SIG_Q_Q:	(&in.ia32)[logstep]. q_q(qr,	QuatP(NPO(op1.r, m1r), NPO(op1.i, m1i), NPO(op1.j, m1j), NPO(op1.k, m1k)));	break;//q_q
				case SIG_R_RR:	(&in.ia32)[logstep].r_rr(rr,	VectP(NPO(op1.r, m1r)),														VectP(NPO(op2.r, m2r)));													break;//r_rr
				case SIG_C_RC:	(&in.ia32)[logstep].c_rc(cr,	VectP(NPO(op1.r, m1r)),														CompP(NPO(op2.r, m2r), NPO(op2.i, m2i)));									break;//c_rc
				case SIG_Q_RQ:	(&in.ia32)[logstep].q_rq(qr,	VectP(NPO(op1.r, m1r)),														QuatP(NPO(op2.r, m2r), NPO(op2.i, m2i), NPO(op2.j, m2j), NPO(op2.k, m2k)));	break;//q_rq
				case SIG_C_CR:	(&in.ia32)[logstep].c_cr(cr,	CompP(NPO(op1.r, m1r), NPO(op1.i, m1i)),									VectP(NPO(op2.r, m2r)));													break;//c_cr
				case SIG_C_CC:	(&in.ia32)[logstep].c_cc(cr,	CompP(NPO(op1.r, m1r), NPO(op1.i, m1i)),									CompP(NPO(op2.r, m2r), NPO(op2.i, m2i)));									break;//c_cc
				case SIG_Q_CQ:	(&in.ia32)[logstep].q_cq(qr,	CompP(NPO(op1.r, m1r), NPO(op1.i, m1i)),									QuatP(NPO(op2.r, m2r), NPO(op2.i, m2i), NPO(op2.j, m2j), NPO(op2.k, m2k)));	break;//q_cq
				case SIG_Q_QR:	(&in.ia32)[logstep].q_qr(qr,	QuatP(NPO(op1.r, m1r), NPO(op1.i, m1i), NPO(op1.j, m1j), NPO(op1.k, m1k)),	VectP(NPO(op2.r, m2r)));													break;//q_qr
				case SIG_Q_QC:	(&in.ia32)[logstep].q_qc(qr,	QuatP(NPO(op1.r, m1r), NPO(op1.i, m1i), NPO(op1.j, m1j), NPO(op1.k, m1k)),	CompP(NPO(op2.r, m2r), NPO(op2.i, m2i)));									break;//q_qc
				case SIG_Q_QQ:	(&in.ia32)[logstep].q_qq(qr,	QuatP(NPO(op1.r, m1r), NPO(op1.i, m1i), NPO(op1.j, m1j), NPO(op1.k, m1k)),	QuatP(NPO(op2.r, m2r), NPO(op2.i, m2i), NPO(op2.j, m2j), NPO(op2.k, m2k)));	break;//q_qq
				case SIG_C_R:	(&in.ia32)[logstep]. c_r(cr,	VectP(NPO(op1.r, m1r)));													break;//c_r
				case SIG_C_Q:	(&in.ia32)[logstep]. c_q(cr,	QuatP(NPO(op1.r, m1r), NPO(op1.i, m1i), NPO(op1.j, m1j), NPO(op1.k, m1k)));	break;//c_q
				case SIG_R_C:	(&in.ia32)[logstep]. r_c(rr,	CompP(NPO(op1.r, m1r), NPO(op1.i, m1i)));									break;//r_c
				case SIG_R_Q:	(&in.ia32)[logstep]. r_q(rr,	QuatP(NPO(op1.r, m1r), NPO(op1.i, m1i), NPO(op1.j, m1j), NPO(op1.k, m1k)));	break;//r_q
				case SIG_C_RR:	(&in.ia32)[logstep].c_rr(cr,	VectP(NPO(op1.r, m1r)),														VectP(NPO(op2.r, m2r)));													break;//c_rr
				case SIG_R_RC:	(&in.ia32)[logstep].r_rc(rr,	VectP(NPO(op1.r, m1r)),														CompP(NPO(op2.r, m2r), NPO(op2.i, m2i)));									break;//r_rc
				case SIG_R_RQ:	(&in.ia32)[logstep].r_rq(rr,	VectP(NPO(op1.r, m1r)),														QuatP(NPO(op2.r, m2r), NPO(op2.i, m2i), NPO(op2.j, m2j), NPO(op2.k, m2k)));	break;//r_rq
				case SIG_R_CR:	(&in.ia32)[logstep].r_cr(rr,	CompP(NPO(op1.r, m1r), NPO(op1.i, m1i)),									VectP(NPO(op2.r, m2r)));													break;//r_cr
				case SIG_R_CC:	(&in.ia32)[logstep].r_cc(rr,	CompP(NPO(op1.r, m1r), NPO(op1.i, m1i)),									CompP(NPO(op2.r, m2r), NPO(op2.i, m2i)));									break;//r_cc
				case SIG_R_CQ:	(&in.ia32)[logstep].r_cq(rr,	CompP(NPO(op1.r, m1r), NPO(op1.i, m1i)),									QuatP(NPO(op2.r, m2r), NPO(op2.i, m2i), NPO(op2.j, m2j), NPO(op2.k, m2k)));	break;//r_cq
				case SIG_R_QR:	(&in.ia32)[logstep].r_qr(rr,	QuatP(NPO(op1.r, m1r), NPO(op1.i, m1i), NPO(op1.j, m1j), NPO(op1.k, m1k)),	VectP(NPO(op2.r, m2r)));													break;//r_qr
				case SIG_R_QC:	(&in.ia32)[logstep].r_qc(rr,	QuatP(NPO(op1.r, m1r), NPO(op1.i, m1i), NPO(op1.j, m1j), NPO(op1.k, m1k)),	CompP(NPO(op2.r, m2r), NPO(op2.i, m2i)));									break;//r_qc
				case SIG_R_QQ:	(&in.ia32)[logstep].r_qq(rr,	QuatP(NPO(op1.r, m1r), NPO(op1.i, m1i), NPO(op1.j, m1j), NPO(op1.k, m1k)),	QuatP(NPO(op2.r, m2r), NPO(op2.i, m2i), NPO(op2.j, m2j), NPO(op2.k, m2k)));	break;//r_qq
				case SIG_C_QC:	(&in.ia32)[logstep].c_qc(cr,	QuatP(NPO(op1.r, m1r), NPO(op1.i, m1i), NPO(op1.j, m1j), NPO(op1.k, m1k)),	CompP(NPO(op2.r, m2r), NPO(op2.i, m2i)));									break;//c_qc
				case SIG_INLINE_IF://a ? b : c
					{
						auto &op3=ex.n[in.op3];
						char r_ms=maximum(in.op2_ms, in.op3_ms), op_ms=(in.op2_ms=='c')+2*(in.op2_ms=='h')+3*(in.op3_ms=='c')+6*(in.op3_ms=='h');
						if(r_ms>='c')
						{
							if(res.i.size()!=ndrSize)
								res.i.resize(ndrSize);
							if(r_ms=='h'&&(res.j.size()!=ndrSize||res.k.size()!=ndrSize))
								res.j.resize(ndrSize), res.k.resize(ndrSize);
						}
						if(!logstep)//n0d/ia32
						{
							bool first=
								in.op1_ms=='R'?	op1.r[k2]!=0
								:in.op1_ms=='c'?(op1.r[k2]!=0)|(op1.i[k2]!=0)
								:				(op1.r[k2]!=0)|(op1.i[k2]!=0)|(op1.j[k2]!=0)|(op1.k[k2]!=0);
							switch(op_ms)
							{
							case 0:res.r[k2]=first?op2.r[k2]:op3.r[k2];break;//r_rr
							case 1:CompP(NPO(res.r, mrr), NPO(res.i, mri))									=first?Comp1d(op2.r[k2])									:Comp1d(op3.r[k2], op3.i[k2]);						break;//c_rc
							case 2:QuatP(NPO(res.r, mrr), NPO(res.i, mri), NPO(res.j, mrj), NPO(res.k, mrk))=first?Quat1d(op2.r[k2])									:Quat1d(op3.r[k2], op3.i[k2], op3.j[k2], op3.k[k2]);break;//q_rq
							case 3:CompP(NPO(res.r, mrr), NPO(res.i, mri))									=first?Comp1d(op2.r[k2], op2.i[k2])							:Comp1d(op3.r[k2]);									break;//c_cr
							case 4:CompP(NPO(res.r, mrr), NPO(res.i, mri))									=first?Comp1d(op2.r[k2], op2.i[k2])							:Comp1d(op3.r[k2], op3.i[k2]);						break;//c_cc
							case 5:QuatP(NPO(res.r, mrr), NPO(res.i, mri), NPO(res.j, mrj), NPO(res.k, mrk))=first?Quat1d(op2.r[k2], op2.i[k2])							:Quat1d(op3.r[k2], op3.i[k2], op3.j[k2], op3.k[k2]);break;//q_cq
							case 6:QuatP(NPO(res.r, mrr), NPO(res.i, mri), NPO(res.j, mrj), NPO(res.k, mrk))=first?Quat1d(op2.r[k2], op2.i[k2], op2.j[k2], op2.k[k2])	:Quat1d(op3.r[k2]);									break;//q_qr
							case 7:QuatP(NPO(res.r, mrr), NPO(res.i, mri), NPO(res.j, mrj), NPO(res.k, mrk))=first?Quat1d(op2.r[k2], op2.i[k2], op2.j[k2], op2.k[k2])	:Quat1d(op3.r[k2], op3.i[k2]);						break;//q_qc
							case 8:QuatP(NPO(res.r, mrr), NPO(res.i, mri), NPO(res.j, mrj), NPO(res.k, mrk))=first?Quat1d(op2.r[k2], op2.i[k2], op2.j[k2], op2.k[k2])	:Quat1d(op3.r[k2], op3.i[k2], op3.j[k2], op3.k[k2]);break;//q_qq
							}
						}
						else if(logstep==1)//sse2
						{
							QuatP r(res.r.p, res.i.p, res.j.p, res.k.p);
							G2::sse2::conditional_111(
								r,
								QuatP(op1.r.p, op1.i.p, op1.j.p, op1.k.p),
								QuatP(op2.r.p, op2.i.p, op2.j.p, op2.k.p),
								QuatP(op3.r.p, op3.i.p, op3.j.p, op3.k.p), k2, in.op1_ms, op_ms);
						}
						else//logstep==2, avx
						{
							QuatP r(res.r.p, res.i.p, res.j.p, res.k.p);
#ifdef AVX_H
							G2::avx::conditional_111
#else
							G2::sse2::conditional_111
#endif
							(
								r,
								QuatP(op1.r.p, op1.i.p, op1.j.p, op1.k.p),
								QuatP(op2.r.p, op2.i.p, op2.j.p, op2.k.p),
								QuatP(op3.r.p, op3.i.p, op3.j.p, op3.k.p), k2, in.op1_ms, op_ms);
						}
					}
					break;
				case SIG_VA:
					(&in.ia32)[logstep].vf(&ex.n, nullptr, ArgIdx(in.result, in.r_ms), in.args, k2);
					break;
				}
				//if(simd_method==2)
				//	_mm256_zeroupper();
				//	G2::avx::zeroupper();
			}
		}
	}
#if !defined _DEBUG && !defined __GNUC__
	);
#endif
	if(ex.i.size())
	{
#ifdef AVX_H
		if(simd_method>=2)
			G2::avx::zeroall();
		else
#endif
		if(simd_method>=1)
			_mm_empty();
	}
}
unsigned initialize_npmask(Expression const &ex, Instruction const &in, char argument, char component)
{//null pointer index mask, argument: 0 result, 1 op1, 2 op2
	if(in.type<32)//printable characters for procedural
	{
		if(argument==2)
		{
			if(in.is_binary())
				return -((&ex.n[in.op2].r)[component].p!=nullptr);
			return 0;
		}
		return -((&ex.n[(&in.result)[argument]].r)[component].p!=nullptr);
	}
	return 0;
}
#define		INP(arg, comp)		initialize_npmask(ex, in, arg, comp)	//initialize null pointer mask
void solve_disc(Expression &ex, int offset, int x1, int x2, int y1, int y2, int z1, int z2, int Xplaces, int Yplaces, int Zplaces, Disc_fn disc_in_u, Disc_fn disc_in_b, Disc_fn disc_in_t, Disc_fn disc_out, int disc_offset, bool skip_last_instr)
{
//	int ndrSize=Xplaces*Yplaces*Zplaces;
	int dx=x2-x1, dy=y2-y1, dz=z2-z1, workSize=dx*dy*dz, ndrSize=ex.n[0].r.size();
	int logstep=simd_method&-(workSize>1);//simd compute unit size = 1<<logstep, logstep=0 for n0d/ia32, 1 for sse2, 2 for avx
	int offset_n=ceil_n(offset, logstep), x1_n=x1>>logstep, x2_n=ceil_n(x2, logstep), Xplaces_n=ceil_n(Xplaces, logstep), dx_n=x2_n-x1_n, workSize_n=dx_n*dy*dz;
	for(int i=0, iEnd=ex.i.size()-skip_last_instr;i<iEnd;++i)
	{
		auto &in=ex.i[i];
		//for(int kn=0;kn<ex.n.size();++kn)
		//	ndr_to_clipboard_2d((double*)ex.n[kn].r.p, Xplaces0, Yplaces);//
		if(in.d.disc_in)
		{
			if(in.type<=3)
			{
				if(disc_in_u)
					disc_in_u(ex, in, offset, disc_offset, x1, x2, y1, y2, z1, z2, Xplaces, Yplaces, Zplaces);
			}
			else if(in.type<=26)
			{
				if(disc_in_b)
					disc_in_b(ex, in, offset, disc_offset, x1, x2, y1, y2, z1, z2, Xplaces, Yplaces, Zplaces);
			}
			else if(in.type==27&&disc_in_t!=0)
				disc_1d_in_t(ex, in, offset, disc_offset, x1, x2, y1, y2, z1, z2, Xplaces, Yplaces, Zplaces);
		}
#ifdef _DEBUG
		free(malloc(1));//
#endif
#ifdef CHECK_NULL_POINTERS
		unsigned
			mrr=INP(0, 0), mri=INP(0, 1), mrj=INP(0, 2), mrk=INP(0, 3),
			m1r=INP(1, 0), m1i=INP(1, 1), m1j=INP(1, 2), m1k=INP(1, 3),
			m2r=INP(2, 0), m2i=INP(2, 1), m2j=INP(2, 2), m2k=INP(2, 3);
#endif
		switch(in.type)
		{
		case SIG_CALL:
			{
				Solve_UserFunction uf(ex, in, false);
			//	Concurrency::parallel_for(0, workSize, [&](int k)
				for(int k=0;k<workSize;++k)
				{
					int x=x1+k%dx, y=y1+(k/dx)%dy, z=z1+k/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					//auto &n=ex.n[in.args[0]];//
					//if(idx>=n.r.size()<<1||n.mathSet=='c'&&idx>=n.i.size()<<1)//
					//{
					//	GUIPrint(ghMemDC, w/2, h/2, "(%d, %d, %d), idx=%d, size=%d", x, y, z, idx, ndrSize_2<<1);
					//	return;
					//}
					//	int LOL_1=0;
					uf(idx);
				}//);
			}
			break;
		case SIG_VA:
			{
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
						(&in.ia32)[logstep].vf(&ex.n, nullptr, ArgIdx(in.result, in.r_ms), in.args, k2);
				}//);
			}
			break;
		case SIG_R_R://r_r
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1];
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
					{
						VectP r(NPO(res.r, mrr));
						(&in.ia32)[logstep].r_r(r, VectP(NPO(op1.r, m1r)));
					}
				}//);
			}
			break;
		case SIG_C_C://c_c
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1];
				if(res.i.size()!=ndrSize)
					res.i.resize(ndrSize);
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
					{
						//if(idx>=res.r.size())
						//	int LOL_1=0;
						CompP r(NPO(res.r, mrr), NPO(res.i, mri));
						(&in.ia32)[logstep].c_c(r, CompP(NPO(op1.r, m1r), NPO(op1.i, m1i)));
					}
				}//);
			}
			break;
		case SIG_Q_Q://q_q
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1];
				if(res.i.size()!=ndrSize)
				{
					res.i.resize(ndrSize);
					if(res.j.size()!=ndrSize)
						res.j.resize(ndrSize), op1.k.resize(ndrSize);
				}
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
					{
						QuatP r(NPO(res.r, mrr), NPO(res.i, mri), NPO(res.j, mrj), NPO(res.k, mrk));
						(&in.ia32)[logstep].q_q(r, QuatP(NPO(op1.r, m1r), NPO(op1.i, m1i), NPO(op1.j, m1j), NPO(op1.k, m1k)));
					}
				}//);
			}
			break;
		case SIG_R_RR://r_rr
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1], &op2=ex.n[in.op2];
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
					{
						VectP r(NPO(res.r, mrr));
						(&in.ia32)[logstep].r_rr(r, VectP(NPO(op1.r, m1r)), VectP(NPO(op2.r, m2r)));
					}
				}//);
			}
			break;
		case SIG_C_RC://c_rc
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1], &op2=ex.n[in.op2];
				if(res.i.size()!=ndrSize)
					res.i.resize(ndrSize);
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
					{
						CompP r(NPO(res.r, mrr), NPO(res.i, mri));
						(&in.ia32)[logstep].c_rc(r, VectP(NPO(op1.r, m1r)), CompP(NPO(op2.r, m2r), NPO(op2.i, m2i)));
					}
				}//);
			}
			break;
		case SIG_Q_RQ://q_rq
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1], &op2=ex.n[in.op2];
				if(res.i.size()!=ndrSize)
				{
					res.i.resize(ndrSize);
					if(res.j.size()!=ndrSize)
						res.j.resize(ndrSize), op2.k.resize(ndrSize);
				}
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
					{
						QuatP r(NPO(res.r, mrr), NPO(res.i, mri), NPO(res.j, mrj), NPO(res.k, mrk));
						(&in.ia32)[logstep].q_rq(r, VectP(NPO(op1.r, m1r)), QuatP(NPO(op2.r, m2r), NPO(op2.i, m2i), NPO(op2.j, m2j), NPO(op2.k, m2k)));
					}
				}//);
			}
			break;
		case SIG_C_CR://c_cr
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1], &op2=ex.n[in.op2];
				if(res.i.size()!=ndrSize)
					res.i.resize(ndrSize);
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
					{
						CompP r(NPO(res.r, mrr), NPO(res.i, mri));
						(&in.ia32)[logstep].c_cr(r, CompP(NPO(op1.r, m1r), NPO(op1.i, m1i)), VectP(NPO(op2.r, m2r)));
					}
				}//);
			}
			break;
		case SIG_C_CC://c_cc
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1], &op2=ex.n[in.op2];
				if(res.i.size()!=ndrSize)
					res.i.resize(ndrSize);
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
					{
						CompP r(NPO(res.r, mrr), NPO(res.i, mri));
						(&in.ia32)[logstep].c_cc(r, CompP(NPO(op1.r, m1r), NPO(op1.i, m1i)), CompP(NPO(op2.r, m2r), NPO(op2.i, m2i)));
					}
				}//);
			}
			break;
		case SIG_Q_CQ://q_cq
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1], &op2=ex.n[in.op2];
				if(res.i.size()!=ndrSize)
				{
					res.i.resize(ndrSize);
					if(res.j.size()!=ndrSize)
						res.j.resize(ndrSize), op2.k.resize(ndrSize);
				}
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
					{
						QuatP r(NPO(res.r, mrr), NPO(res.i, mri), NPO(res.j, mrj), NPO(res.k, mrk));
						(&in.ia32)[logstep].q_cq(r, CompP(NPO(op1.r, m1r), NPO(op1.i, m1i)), QuatP(NPO(op2.r, m2r), NPO(op2.i, m2i), NPO(op2.j, m2j), NPO(op2.k, m2k)));
					}
				}//);
			}
			break;
		case SIG_Q_QR://q_qr
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1], &op2=ex.n[in.op2];
				if(res.i.size()!=ndrSize)
				{
					res.i.resize(ndrSize);
					if(res.j.size()!=ndrSize)
						res.j.resize(ndrSize), op1.k.resize(ndrSize);
				}
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
					{
						QuatP r(NPO(res.r, mrr), NPO(res.i, mri), NPO(res.j, mrj), NPO(res.k, mrk));
						(&in.ia32)[logstep].q_qr(r, QuatP(NPO(op1.r, m1r), NPO(op1.i, m1i), NPO(op1.j, m1j), NPO(op1.k, m1k)), VectP(NPO(op2.r, m2r)));
					}
				}//);
			}
			break;
		case SIG_Q_QC://q_qc
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1], &op2=ex.n[in.op2];
				if(res.i.size()!=ndrSize)
				{
					res.i.resize(ndrSize);
					if(res.j.size()!=ndrSize)
						res.j.resize(ndrSize), op1.k.resize(ndrSize);
				}
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
					{
						QuatP r(NPO(res.r, mrr), NPO(res.i, mri), NPO(res.j, mrj), NPO(res.k, mrk));
						(&in.ia32)[logstep].q_qc(r, QuatP(NPO(op1.r, m1r), NPO(op1.i, m1i), NPO(op1.j, m1j), NPO(op1.k, m1k)), CompP(NPO(op2.r, m2r), NPO(op2.i, m2i)));
					}
				}//);
			}
			break;
		case SIG_Q_QQ://q_qq
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1], &op2=ex.n[in.op2];
				if(res.i.size()!=ndrSize)
				{
					res.i.resize(ndrSize);
					if(res.j.size()!=ndrSize)
						res.j.resize(ndrSize), op1.k.resize(ndrSize);
				}
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
					{
						QuatP r(NPO(res.r, mrr), NPO(res.i, mri), NPO(res.j, mrj), NPO(res.k, mrk));
						(&in.ia32)[logstep].q_qq(r, QuatP(NPO(op1.r, m1r), NPO(op1.i, m1i), NPO(op1.j, m1j), NPO(op1.k, m1k)), QuatP(NPO(op2.r, m2r), NPO(op2.i, m2i), NPO(op2.j, m2j), NPO(op2.k, m2k)));
					}
				}//);
			}
			break;

		case SIG_C_R://c_r
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1];
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
					{
						CompP r(NPO(res.r, mrr), NPO(res.i, mri));
						(&in.ia32)[logstep].c_r(r, VectP(NPO(op1.r, m1r)));
					}
				}//);
			}
			break;
		case SIG_C_Q://c_q
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1];
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
					{
						CompP r(NPO(res.r, mrr), NPO(res.i, mri));
						(&in.ia32)[logstep].c_q(r, QuatP(NPO(op1.r, m1r), NPO(op1.i, m1i), NPO(op1.j, m1j), NPO(op1.k, m1k)));
					}
				}//);
			}
			break;

		case SIG_R_C://r_c
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1];
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
					{
						VectP r(NPO(res.r, mrr));
						(&in.ia32)[logstep].r_c(r, CompP(NPO(op1.r, m1r), NPO(op1.i, m1i)));
					}
				}//);
			}
			break;
		case SIG_R_Q://r_q
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1];
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
					{
						VectP r(NPO(res.r, mrr));
						(&in.ia32)[logstep].r_q(r, QuatP(NPO(op1.r, m1r), NPO(op1.i, m1i), NPO(op1.j, m1j), NPO(op1.k, m1k)));
					}
				}//);
			}
			break;

		case SIG_C_RR://c_rr
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1], &op2=ex.n[in.op2];
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
					{
						CompP r(NPO(res.r, mrr), NPO(res.i, mri));
						(&in.ia32)[logstep].c_rr(r, VectP(NPO(op1.r, m1r)), VectP(NPO(op2.r, m2r)));
					}
				}//);
			}
			break;

		case SIG_R_RC://r_rc
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1], &op2=ex.n[in.op2];
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
					{
						VectP r(NPO(res.r, mrr));
						(&in.ia32)[logstep].r_rc(r, VectP(NPO(op1.r, m1r)), CompP(NPO(op2.r, m2r), NPO(op2.i, m2i)));
					}
				}//);
			}
			break;
		case SIG_R_RQ://r_rq
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1], &op2=ex.n[in.op2];
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
					{
						VectP r(NPO(res.r, mrr));
						(&in.ia32)[logstep].r_rq(r, VectP(NPO(op1.r, m1r)), QuatP(NPO(op2.r, m2r), NPO(op2.i, m2i), NPO(op2.j, m2j), NPO(op2.k, m2k)));
					}
				}//);
			}
			break;
		case SIG_R_CR://r_cr
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1], &op2=ex.n[in.op2];
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
					{
						VectP r(NPO(res.r, mrr));
						(&in.ia32)[logstep].r_cr(r, CompP(NPO(op1.r, m1r), NPO(op1.i, m1i)), VectP(NPO(op2.r, m2r)));
					}
				}//);
			}
			break;
		case SIG_R_CC://r_cc
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1], &op2=ex.n[in.op2];
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
					{
						VectP r(NPO(res.r, mrr));
						(&in.ia32)[logstep].r_cc(r, CompP(NPO(op1.r, m1r), NPO(op1.i, m1i)), CompP(NPO(op2.r, m2r), NPO(op2.i, m2i)));
					}
				}//);
			}
			break;
		case SIG_R_CQ://r_cq
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1], &op2=ex.n[in.op2];
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
					{
						VectP r(NPO(res.r, mrr));
						(&in.ia32)[logstep].r_cq(r, CompP(NPO(op1.r, m1r), NPO(op1.i, m1i)), QuatP(NPO(op2.r, m2r), NPO(op2.i, m2i), NPO(op2.j, m2j), NPO(op2.k, m2k)));
					}
				}//);
			}
			break;
		case SIG_R_QR://r_qr
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1], &op2=ex.n[in.op2];
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
					{
						VectP r(NPO(res.r, mrr));
						(&in.ia32)[logstep].r_qr(r, QuatP(NPO(op1.r, m1r), NPO(op1.i, m1i), NPO(op1.j, m1j), NPO(op1.k, m1k)), NPO(op2.r, m2r));
					}
				}//);
			}
			break;
		case SIG_R_QC://r_qc
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1], &op2=ex.n[in.op2];
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
					{
						VectP r(NPO(res.r, mrr));
						(&in.ia32)[logstep].r_qc(r, QuatP(NPO(op1.r, m1r), NPO(op1.i, m1i), NPO(op1.j, m1j), NPO(op1.k, m1k)), CompP(NPO(op2.r, m2r), NPO(op2.i, m2i)));
					}
				}//);
			}
			break;
		case SIG_R_QQ://r_qq
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1], &op2=ex.n[in.op2];
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
					{
						VectP r(NPO(res.r, mrr));
						(&in.ia32)[logstep].r_qq(r, QuatP(NPO(op1.r, m1r), NPO(op1.i, m1i), NPO(op1.j, m1j), NPO(op1.k, m1k)), QuatP(NPO(op2.r, m2r), NPO(op2.i, m2i), NPO(op2.j, m2j), NPO(op2.k, m2k)));
					}
				}//);
			}
			break;

		case SIG_C_QC://c_qc
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1], &op2=ex.n[in.op2];
			//	Concurrency::parallel_for(0, workSize_n, [&](int k)
				for(int k=0;k<workSize_n;++k)
				{
					int ka=k<<logstep;
					int x=x1+ka%dx, y=y1+(ka/dx)%dy, z=z1+ka/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
					for(int k2=idx, increment=1<<(logstep&-(int)in.simd), k2End=idx+(1<<logstep);k2<k2End;k2+=increment)
					{
						CompP r(NPO(res.r, mrr), NPO(res.i, mri));
						(&in.ia32)[logstep].c_qc(r, QuatP(NPO(op1.r, m1r), op1.i.p+k2, NPO(op1.j, m1j), NPO(op1.k, m1k)), CompP(NPO(op2.r, m2r), NPO(op2.i, m2i)));
					}
				}//);
			}
			break;

		case SIG_INLINE_IF://a ? b : c
			{
				auto &res=ex.n[in.result], &op1=ex.n[in.op1], &op2=ex.n[in.op2], &op3=ex.n[in.op3];
				char r_ms=maximum(in.op2_ms, in.op3_ms), op_ms=(in.op2_ms=='c')+2*(in.op2_ms=='h')+3*(in.op3_ms=='c')+6*(in.op3_ms=='h');
				if(r_ms>='c')
				{
					if(res.i.size()!=ndrSize)
						res.i.resize(ndrSize);
					if(r_ms=='h'&&res.j.size()!=ndrSize)
						res.j.resize(ndrSize), res.k.resize(ndrSize);
				}
				if(!logstep)
				{
					switch(op_ms)
					{
					case 0://r_rr
						for(int k=0;k<workSize;++k)
						{
							int x=x1+k%dx, y=y1+(k/dx)%dy, z=z1+k/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
							bool first=
								in.op1_ms=='R'?	op1.r[idx]!=0
								:in.op1_ms=='c'?(op1.r[idx]!=0)|(op1.i[idx]!=0)
								:				(op1.r[idx]!=0)|(op1.i[idx]!=0)|(op1.j[idx]!=0)|(op1.k[idx]!=0);
							res.r[idx]=first?op2.r[idx]:op3.r[idx];
						}
						break;
					case 1://c_rc
						for(int k=0;k<workSize;++k)
						{
							int x=x1+k%dx, y=y1+(k/dx)%dy, z=z1+k/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
							bool first=
								in.op1_ms=='R'?	op1.r[idx]!=0
								:in.op1_ms=='c'?(op1.r[idx]!=0)|(op1.i[idx]!=0)
								:				(op1.r[idx]!=0)|(op1.i[idx]!=0)|(op1.j[idx]!=0)|(op1.k[idx]!=0);
							CompP(res.r.p+idx, res.i.p+idx)=first?Comp1d(op2.r[idx]):Comp1d(op3.r[idx], op3.i[idx]);
						}
						break;
					case 2://q_rq
						for(int k=0;k<workSize;++k)
						{
							int x=x1+k%dx, y=y1+(k/dx)%dy, z=z1+k/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
							bool first=
								in.op1_ms=='R'?	op1.r[idx]!=0
								:in.op1_ms=='c'?(op1.r[idx]!=0)|(op1.i[idx]!=0)
								:				(op1.r[idx]!=0)|(op1.i[idx]!=0)|(op1.j[idx]!=0)|(op1.k[idx]!=0);
							QuatP(res.r.p+idx, res.i.p+idx, res.j.p+idx, res.k.p+idx)=first?Quat1d(op2.r[idx]):Quat1d(op3.r[idx], op3.i[idx], op3.j[idx], op3.k[idx]);
						}
						break;
					case 3://c_cr
						for(int k=0;k<workSize;++k)
						{
							int x=x1+k%dx, y=y1+(k/dx)%dy, z=z1+k/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
							bool first=
								in.op1_ms=='R'?	op1.r[idx]!=0
								:in.op1_ms=='c'?(op1.r[idx]!=0)|(op1.i[idx]!=0)
								:				(op1.r[idx]!=0)|(op1.i[idx]!=0)|(op1.j[idx]!=0)|(op1.k[idx]!=0);
							CompP(res.r.p+idx, res.i.p+idx)=first?Comp1d(op2.r[idx], op2.i[idx]):Comp1d(op3.r[idx]);
						}
						break;
					case 4://c_cc
						for(int k=0;k<workSize;++k)
						{
							int x=x1+k%dx, y=y1+(k/dx)%dy, z=z1+k/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
							bool first=
								in.op1_ms=='R'?	op1.r[idx]!=0
								:in.op1_ms=='c'?(op1.r[idx]!=0)|(op1.i[idx]!=0)
								:				(op1.r[idx]!=0)|(op1.i[idx]!=0)|(op1.j[idx]!=0)|(op1.k[idx]!=0);
							CompP(res.r.p+idx, res.i.p+idx)=first?Comp1d(op2.r[idx], op2.i[idx]):Comp1d(op3.r[idx], op3.i[idx]);
						}
						break;
					case 5://q_cq
						for(int k=0;k<workSize;++k)
						{
							int x=x1+k%dx, y=y1+(k/dx)%dy, z=z1+k/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
							bool first=
								in.op1_ms=='R'?	op1.r[idx]!=0
								:in.op1_ms=='c'?(op1.r[idx]!=0)|(op1.i[idx]!=0)
								:				(op1.r[idx]!=0)|(op1.i[idx]!=0)|(op1.j[idx]!=0)|(op1.k[idx]!=0);
							QuatP(res.r.p+idx, res.i.p+idx, res.j.p+idx, res.k.p+idx)=first?Quat1d(op2.r[idx], op2.i[idx]):Quat1d(op3.r[idx], op3.i[idx], op3.j[idx], op3.k[idx]);
						}
						break;
					case 6://q_qr
						for(int k=0;k<workSize;++k)
						{
							int x=x1+k%dx, y=y1+(k/dx)%dy, z=z1+k/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
							bool first=
								in.op1_ms=='R'?	op1.r[idx]!=0
								:in.op1_ms=='c'?(op1.r[idx]!=0)|(op1.i[idx]!=0)
								:				(op1.r[idx]!=0)|(op1.i[idx]!=0)|(op1.j[idx]!=0)|(op1.k[idx]!=0);
							QuatP(res.r.p+idx, res.i.p+idx, res.j.p+idx, res.k.p+idx)=first?Quat1d(op2.r[idx], op2.i[idx], op2.j[idx], op2.k[idx]):Quat1d(op3.r[idx]);
						}
						break;
					case 7://q_qc
						for(int k=0;k<workSize;++k)
						{
							int x=x1+k%dx, y=y1+(k/dx)%dy, z=z1+k/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
							bool first=
								in.op1_ms=='R'?	op1.r[idx]!=0
								:in.op1_ms=='c'?(op1.r[idx]!=0)|(op1.i[idx]!=0)
								:				(op1.r[idx]!=0)|(op1.i[idx]!=0)|(op1.j[idx]!=0)|(op1.k[idx]!=0);
							QuatP(res.r.p+idx, res.i.p+idx, res.j.p+idx, res.k.p+idx)=first?Quat1d(op2.r[idx], op2.i[idx], op2.j[idx], op2.k[idx]):Quat1d(op3.r[idx], op3.i[idx]);
						}
						break;
					case 8://q_qq
						for(int k=0;k<workSize;++k)
						{
							int x=x1+k%dx, y=y1+(k/dx)%dy, z=z1+k/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
							bool first=
								in.op1_ms=='R'?	op1.r[idx]!=0
								:in.op1_ms=='c'?(op1.r[idx]!=0)|(op1.i[idx]!=0)
								:				(op1.r[idx]!=0)|(op1.i[idx]!=0)|(op1.j[idx]!=0)|(op1.k[idx]!=0);
							QuatP(res.r.p+idx, res.i.p+idx, res.j.p+idx, res.k.p+idx)=first?Quat1d(op2.r[idx], op2.i[idx], op2.j[idx], op2.k[idx]):Quat1d(op3.r[idx], op3.i[idx], op3.j[idx], op3.k[idx]);
						}
						break;
					}
				}
				else if(logstep==1)//sse2
				{
					for(int k=0;k<workSize;k+=2)
					{
						int x=x1+k%dx, y=y1+(k/dx)%dy, z=z1+k/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
						QuatP r(res.r.p, res.i.p, res.j.p, res.k.p);
						G2::sse2::conditional_111(
							r,
							QuatP(op1.r.p, op1.i.p, op1.j.p, op1.k.p),
							QuatP(op2.r.p, op2.i.p, op2.j.p, op2.k.p),
							QuatP(op3.r.p, op3.i.p, op3.j.p, op3.k.p), idx, in.op1_ms, op_ms);
					}
				}
				else//logstep==2, avx
				{
					for(int k=0;k<workSize;k+=4)
					{
						int x=x1+k%dx, y=y1+(k/dx)%dy, z=z1+k/(dy*dx), idx=offset+Xplaces*(Yplaces*z+y)+x;
						QuatP r(res.r.p, res.i.p, res.j.p, res.k.p);
#ifdef AVX_H
						G2::avx::conditional_111
#else
						G2::sse2::conditional_111
#endif
							(
							r,
							QuatP(op1.r.p, op1.i.p, op1.j.p, op1.k.p),
							QuatP(op2.r.p, op2.i.p, op2.j.p, op2.k.p),
							QuatP(op3.r.p, op3.i.p, op3.j.p, op3.k.p), idx, in.op1_ms, op_ms);
					}
				}
			}
			break;
		}
		if(in.d.disc_out&&disc_out!=0)
			disc_out(ex, in, offset, disc_offset, x1, x2, y1, y2, z1, z2, Xplaces, Yplaces, Zplaces);
		//for(int kn=0;kn<ex.n.size();++kn)
		//	ndr_to_clipboard_2d((double*)ex.n[kn].r.p, Xplaces0, Yplaces);//
	}
	if(ex.i.size())
	{
#ifdef AVX_H
		if(simd_method>=2)
			G2::avx::zeroall();
		else
#endif
		if(simd_method>=1)
			_mm_empty();
	}
}
FP::R_R g_r_r_minus=nullptr;
FP::R_RR g_r_rr_minus=nullptr;
struct UnaryMinus
{
	int x1, dx, y1, dy, Xplaces;
	AVector_v4d *res, *op1;
	UnaryMinus(int x1, int dx, int y1, int dy, int Xplaces, AVector_v4d *res, AVector_v4d *op1):x1(x1), dx(dx), y1(y1), dy(dy), Xplaces(Xplaces), res(res), op1(op1){}
	void operator()(int k)
	{
		int x=x1+k%dx, y=y1+k/dx, idx=Xplaces*y+x;
		VectP r(res->p+idx);
		g_r_r_minus(r, VectP(op1->p+idx));
	}
};
struct BinaryMinus
{
	int x1, dx, y1, dy, Xplaces;
	AVector_v4d *res, *op1, *op2;
	BinaryMinus(int x1, int dx, int y1, int dy, int Xplaces, AVector_v4d *res, AVector_v4d *op1, AVector_v4d *op2):x1(x1), dx(dx), y1(y1), dy(dy), Xplaces(Xplaces), res(res), op1(op1), op2(op2){}
	void operator()(int k)
	{
		int x=x1+k%dx, y=y1+k/dx, idx=Xplaces*y+x;
		VectP r(res->p+idx);
		g_r_rr_minus(r, VectP(op1->p+idx), VectP(op2->p+idx));
	}
};
inline void subtract_NDRs_component(int workSize, int x1, int dx, int y1, int dy, int Xplaces, AVector_v4d *res, AVector_v4d *op1)
{
	g_r_r_minus=
#ifdef AVX_H
		simd_method==2?G2::avx::r_r_minus:
#endif
		simd_method==1?G2::sse2::r_r_minus:G2::r_r_minus;
//	Concurrency::parallel_for(0, workSize, UnaryMinus(x1, dx, y1, dy, Xplaces, op1));
//	UnaryMinus um(x1, dx, y1, dy, Xplaces, op1);
	for(int k=0, increment=1<<(simd_method&-(workSize>1));k<workSize;k+=increment)
	//	um(k);
	{
		int x=x1+k%dx, y=y1+k/dx, idx=Xplaces*y+x;
		VectP r(res->p+idx);
		g_r_r_minus(r, VectP(op1->p+idx));
	}
}
inline void subtract_NDRs_component(int workSize, int x1, int dx, int y1, int dy, int Xplaces, AVector_v4d *res, AVector_v4d *op1, AVector_v4d *op2)
{
	g_r_rr_minus=
#ifdef AVX_H
		simd_method==2?G2::avx::r_rr_minus:
#endif
		simd_method==1?G2::sse2::r_rr_minus:G2::r_rr_minus;
//	Concurrency::parallel_for(0, workSize, BinaryMinus(x1, dx, y1, dy, Xplaces, op1, op2));
	BinaryMinus bm(x1, dx, y1, dy, Xplaces, res, op1, op2);
	for(int k=0, increment=1<<(simd_method&-(workSize>1));k<workSize;k+=increment)
		bm(k);
}
void subtract_NDRs(Expression &ex, int x1, int x2, int y1, int y2, int Xplaces, int Yplaces)
{
	auto &in=*ex.i.rbegin();
	auto &res=ex.n[in.result], &op1=ex.n[in.op1];
	int dx=x2-x1, dy=y2-y1, workSize=dx*dy;
//	int logstep=simd_method&-(workSize>1);//simd compute unit size = 1<<logstep, logstep=0 for n0d/ia32, 1 for sse2, 2 for avx
//	int x1_n=x1>>logstep, x2_n=ceil_n(x2, logstep), Xplaces_n=ceil_n(Xplaces, logstep);
//	x1>>=1, x2=ceil_half(x2), Xplaces=ceil_half(Xplaces);
	if(in.type<=3||in.type>=13&&in.type<=16||in.type=='c')//unary == or !=		can't be 'c'
	{
		subtract_NDRs_component(workSize, x1, dx, y1, dy, Xplaces, &res.r, &op1.r);
		if(in.op1_ms>='c')
		{
			subtract_NDRs_component(workSize, x1, dx, y1, dy, Xplaces, &res.i, &op1.i);
			if(in.op1_ms=='h')
			{
				subtract_NDRs_component(workSize, x1, dx, y1, dy, Xplaces, &res.j, &op1.j);
				subtract_NDRs_component(workSize, x1, dx, y1, dy, Xplaces, &res.k, &op1.k);
			}
		}
	}
	else//binary
	{
		auto &op2=ex.n[in.op2];
		subtract_NDRs_component(workSize, x1, dx, y1, dy, Xplaces, &res.r, &op1.r, &op2.r);
		if(in.op1_ms>='c'&&in.op2_ms>='c')
			subtract_NDRs_component(workSize, x1, dx, y1, dy, Xplaces, &res.i, &op1.i, &op2.i);
		else if(in.op2_ms>='c')
		{
			subtract_NDRs_component(workSize, x1, dx, y1, dy, Xplaces, &res.i, &op2.i);
			op1.i=std::move(op2.i);
		}
		if(in.op1_ms=='h'&&in.op2_ms=='h')
		{
			subtract_NDRs_component(workSize, x1, dx, y1, dy, Xplaces, &res.j, &op1.j, &op2.j);
			subtract_NDRs_component(workSize, x1, dx, y1, dy, Xplaces, &res.k, &op1.k, &op2.k);
		}
		else if(in.op2_ms=='h')
		{
			subtract_NDRs_component(workSize, x1, dx, y1, dy, Xplaces, &res.j, &op1.j);
			subtract_NDRs_component(workSize, x1, dx, y1, dy, Xplaces, &res.k, &op1.k);
			res.j=std::move(op2.j);//what happens with ranged solve?
			res.k=std::move(op2.k);
		}
	}
	if(ex.i.size())
	{
#ifdef AVX_H
		if(simd_method>=2)
			G2::avx::zeroall();
		else
#endif
		if(simd_method>=1)
			_mm_empty();
	}
}
template<int _size>void append(char *&a, int &alen, char (&b)[_size], int &blen)
{
	a=(char*)realloc(a, (alen+blen+1)*sizeof(char));
	memcpy(&a[alen], b, (blen+1)*sizeof(char));
	alen+=blen;
}
void print_contextHelp(const char **helpMsg, short msg_count, short dx)
{
	short X0=w>>1, Y0=h>>1, dy=msg_count*18, dx_2=dx>>1, dy_2=dy>>1;
	short xs=X0-dx_2, ys=Y0-dy_2;
	rectangle(xs-1, ys-1, X0+dx_2, Y0+dy_2);
	for(short k=0;k<msg_count;++k)
		GUIPrint(xs, ys+18*k, helpMsg[k]);
}
void report_error()
{
	if(first_error_msg[0])
	{
		emergencyPrint(0, h>>1, first_error_msg);
		emergencyPrint(0, (h>>1)+16, latest_error_msg);
		//emergencyPrint(w>>1, h>>1, first_error_msg);
		//emergencyPrint(w>>1, (h>>1)+16, latest_error_msg);
	}
//	if(broken)
	//{
	//	int code=*(int*)&broken, line=((int*)&broken)[1];
	//	if(line)
	//	{
	//		if(code)
	//			emergencyPrint(w>>1, h>>1, "ERROR: code %d, line %d", code, line);
	//		else
	//			emergencyPrint(w>>1, h>>1, "ERROR: line %d", line);
	//	}
	//	else
	//		emergencyPrint(w>>1, h>>1, "ERROR: code %d", code);
	//}
}
namespace	modes
{
	bool active=0, ready=0;
	unsigned const _2dCheckColor=0x00E0E0E0,//0x00D0D0D0	0x00EFEFEF
		_3dGridColor=0x00D0D0D0;
	int const N_MODES=13;
	std::vector<int> nExpr(N_MODES, 0);
	struct		Label
	{
		std::string label;
		int exNo;
		Label(std::string const &label, int exNo):label(label), exNo(exNo){}
	};
	struct		CLabel:public Label
	{
		bool isTime;
		double value;
		CLabel(std::string const &label, int exNo):Label(label, exNo), isTime(true){}
		CLabel(std::string const &label, int exNo, double value):Label(label, exNo), value(value), isTime(false){}
	};
	class		Labels
	{
		virtual void LOL(int, std::string const&, int, double)=0;
	public:
		std::vector<CLabel> Clabels;
		void fill(int exNo)
		{
		//	for(auto &v:expr[exNo].variables)
			auto & ex_var=expr[exNo].variables;
			for(unsigned k=0;k<ex_var.size();++k)
			{
				auto &v=ex_var[k];
				switch(v.mathSet)
				{
				case 'R':
					LOL(v.varTypeR, v.name, exNo, v.val.r);
					break;
				case 'c':
					LOL(v.varTypeR, "Re("+v.name+")", exNo, v.val.r);
					LOL(v.varTypeI, "Im("+v.name+")", exNo, v.val.i);
					break;
				case 'h':
					LOL(v.varTypeR, "Re("+v.name+")", exNo, v.val.r);
					LOL(v.varTypeI, "I("+v.name+")", exNo, v.val.i);
					LOL(v.varTypeJ, "J("+v.name+")", exNo, v.val.j);
					LOL(v.varTypeK, "K("+v.name+")", exNo, v.val.k);
					break;
				}
			}
		}
	};
	class		Labels_0D:public Labels
	{
		std::unordered_set<int> exprs;
		void LOL(int LOL_1, std::string const &str, int exNo, double value)
		{
			switch(LOL_1)
			{
			case 't':Clabels.push_back(CLabel(str, exNo)), exprs.insert(exNo);if(exprs.size()>1)colored=1;break;
			case 'c':Clabels.push_back(CLabel(str, exNo, value)), exprs.insert(exNo);if(exprs.size()>1)colored=1;break;
			}
		}
	public:
		int colored;
		void clear(){Clabels.clear(), colored=0, exprs.clear();}
	};
	class		Labels_1D:public Labels
	{
		void LOL(int LOL_1, std::string const &str, int exNo, double value)
		{
			switch(LOL_1)
			{
			case 'x':Xlabels.push_back(Label(str, exNo));break;
			case 't':Clabels.push_back(CLabel(str, exNo));break;
			case 'c':Clabels.push_back(CLabel(str, exNo, value));break;
			}
		}
	public:
		std::vector<Label> Xlabels;
		void clear(){Xlabels.clear(), Clabels.clear();}
	};
	class		Labels_2D:public Labels
	{
		void LOL(int LOL_1, std::string const &str, int exNo, double value)
		{
			switch(LOL_1)
			{
			case 'x':Xlabels.push_back(Label(str, exNo));break;
			case 'y':Ylabels.push_back(Label(str, exNo));break;
			case 't':Clabels.push_back(CLabel(str, exNo));break;
			case 'c':Clabels.push_back(CLabel(str, exNo, value));break;
			}
		}
	public:
		std::vector<Label> Xlabels, Ylabels;
		void clear(){Xlabels.clear(), Ylabels.clear(), Clabels.clear();}
	};
	class		Labels_3D:public Labels
	{
		void LOL(int LOL_1, std::string const &str, int exNo, double value)
		{
			switch(LOL_1)
			{
			case 'x':Xlabels.push_back(Label(str, exNo));break;
			case 'y':Ylabels.push_back(Label(str, exNo));break;
			case 'z':Zlabels.push_back(Label(str, exNo));break;
			case 't':Clabels.push_back(CLabel(str, exNo));break;
			case 'c':Clabels.push_back(CLabel(str, exNo, value));break;
			}
		}
	public:
		std::vector<Label> Xlabels, Ylabels, Zlabels;
		void clear(){Xlabels.clear(), Ylabels.clear(), Zlabels.clear(), Clabels.clear();}
	};
	
	class		_2D
	{
		bool continuous;
		int c_x1;
		double c_y1;
	public:
		int lineColor;
		_2D():lineColor(0){}
		void curve_start()
		{
			if(usingOpenGL)
				GL2_2D::continuous=false;
			else
				continuous=false;
		}
		void curve_point(int x, double y)
		{
			if(usingOpenGL)
			{
				GL2_2D::curve_point((float)x, (float)y);
				return;
			}
			if(continuous)
			{
				double abs_y1=abs(c_y1), abs_y2=abs(y);
				if(abs_y1<1e6)
				{
					if(abs_y2<1e6)
						line(c_x1, int(c_y1)-(c_y1<0), x, int(y)-(y<0));			//-0.5 truncated as 0
					//	MoveToEx(ghMemDC, c_x1, int(std::floor(c_y1)), 0), LineTo(ghMemDC, x, int(std::floor(y)));
					else if(!std::isnan(y))
						line(c_x1, int(c_y1)-(c_y1<0), c_x1, y>0?h:0);
					//	MoveToEx(ghMemDC, c_x1, int(std::floor(c_y1)), 0), LineTo(ghMemDC, c_x1, y>0?h:0);
				}
				else if(!std::isnan(c_y1))
				{
					if(abs_y2<1e6)
						line(x, c_y1>0?h:0, x, int(y)-(y<0));
					//	MoveToEx(ghMemDC, x, c_y1>0?h:0, 0), LineTo(ghMemDC, x, int(std::floor(y)));
					else if(!std::isnan(y))
					{
						if(abs_y1>abs_y2)
							line(x, c_y1>0?h:0, x, y>0?h:0);
						else
							line(c_x1, c_y1>0?h:0, c_x1, y>0?h:0);
					}
				}
			}
			else
			{
				setPixel(x, (int)y, lineColor);
				//if(x>=0&&x<w&&y>=0&&y<h)
				//	rgb[w*int(y)+x]=lineColor;
				continuous=true;
			}
			c_x1=x, c_y1=y;
		}
		void set_point()
		{
			setPixel(c_x1, (int)c_y1, 0);
			//if(c_x1>=0&&c_x1<w&&c_y1>=0&&c_y1<h)
			//	setPixel(c_x1, (int)c_y1, 0);
			//	rgb[w*int(c_y1)+c_x1]=0;
		}
	};
	class		_2D_L2D//interpolate	linear is best
	{
		bool continuous;
		double X0, Y0;
		bool cast(double X, int &x)
		{
			double const INT_LIMIT=2e9;
			int const int_limit=int(2e9);
			if(std::abs(X0)<INT_LIMIT)
			{
				x=int(X);
				return true;
			}
			if(!std::isnan(X))
			{
				x=X>0?int_limit:-int_limit;
				return true;
			}
			return false;

		}
		double linearY(double x1, double y1, double x2, double y2, double x){return (y2-y1)/(x2-x1)*(x-x1)+y1;}
		double linearX(double x1, double y1, double x2, double y2, double y){return (x2-x1)/(y2-y1)*(y-y1)+x1;}
	public:
		void curve_start()
		{
			if(usingOpenGL)
				GL2_2D::continuous=false;
			else
				continuous=false;
		}
		void curve_point(double X, double Y)
		{
			if(usingOpenGL)
			{
				GL2_2D::curve_point((float)X, (float)Y);
				return;
			}
			if(continuous)
			{
				double const INT_LIMIT=2e6;//2e9
				int const int_limit=int(INT_LIMIT);
				if(std::abs(X0)<INT_LIMIT&&std::abs(Y0)<INT_LIMIT&&std::abs(X)<INT_LIMIT&&std::abs(Y)<INT_LIMIT)
					line(int(X0)-(X0<0), int(Y0)-(Y0<0), int(X)-(X<0), int(Y)-(Y<0));//-0.5 truncated as 0

				//	MoveToEx(ghMemDC, int(std::floor(X0)), int(std::floor(Y0)), 0), LineTo(ghMemDC, int(std::floor(X)), int(std::floor(Y)));
				else if(!(std::isnan(X0)||std::isnan(Y0)||std::isnan(X)||std::isnan(Y)||std::isinf(X0)||std::isinf(Y0)||std::isinf(X)||std::isinf(Y)))
			//	else if(!(std::isnan(X0)||std::isnan(Y0)||std::isnan(X)||std::isnan(Y)))
				{
					auto &x1=X0, &y1=Y0, x2=X, y2=Y;
					double const bx1=0, bx2=w, by1=0, by2=h;

					bool valid=true;
					//up
					if(y1<by1)
					{
						if(y2<by1)
							valid=false;
						else
							x1=linearX(x1, y1, x2, y2, by1), y1=by1;
					}
					else if(y2<by1)
						x2=linearX(x1, y1, x2, y2, by1), y2=by1;

					if(valid)
					{
						//right
						if(x1>bx2)
						{
							if(x2>bx2)
								valid=false;
							else
								y1=linearY(x1, y1, x2, y2, bx2), x1=bx2;
						}
						else if(x2>bx2)
							y2=linearY(x1, y1, x2, y2, bx2), x2=bx2;

						if(valid)
						{
							//bottom
							if(y1>by2)
							{
								if(y2>by2)
									valid=false;
								else
									x1=linearX(x1, y1, x2, y2, by2), y1=by2;
							}
							else if(y2>by2)
								x2=linearX(x1, y1, x2, y2, by2), y2=by2;

							if(valid)
							{
								//left
								if(x1<bx1)
								{
									if(x2<bx1)
										valid=false;
									else
										y1=linearY(x1, y1, x2, y2, bx1), x1=bx1;
								}
								else if(x2<bx1)
									y2=linearY(x1, y1, x2, y2, bx1), x2=bx1;

								if(valid)
									line(int(x1)-(x1<0), int(y1)-(y1<0), int(x2)-(x2<0), int(y2)-(y2<0));//-0.5 truncated as 0
								//	MoveToEx(ghMemDC, int(std::floor(x1)), int(std::floor(y1)), 0), LineTo(ghMemDC, int(std::floor(x2)), int(std::floor(y2)));
							}
						}
					}
				}
			}
			else
			{
				if(X>=0&&X<w&&Y>=0&&Y<h)
					setPixel((int)X, (int)Y, 0);
				//	rgb[w*int(Y)+int(X)]=0;
				continuous=true;
			}
			X0=X, Y0=Y;
		}
		void set_point()
		{
			setPixel((int)X0, (int)Y0, 0);
			//if(X0>=0&&X0<w&&Y0>=0&&Y0<h)
			//	rgb[w*int(Y0)+int(X0)]=0;
		}
	};
	struct Text
	{
		int x, y;
		int bkMode;
		bool enable_color;	int color;
		std::string str;
		Text(int x, int y, int bkMode, std::string &str)			:x(x), y(y), bkMode(bkMode), enable_color(false), str(str){}
		Text(int x, int y, int bkMode, const char *a)				:x(x), y(y), bkMode(bkMode), enable_color(false), str(a){}
		Text(int x, int y, int bkMode, int color, std::string &str)	:x(x), y(y), bkMode(bkMode), enable_color(true), color(color), str(str){}
		Text(int x, int y, int bkMode, int color, const char *a)	:x(x), y(y), bkMode(bkMode), enable_color(true), color(color), str(a){}
	};
	typedef std::pair<double, Text> ZT;
	bool operator<(ZT const &a, ZT const &b){return a.first<b.first;}
	class		_3D//trash code here
	{
	public:
		struct Triangle
		{
			vec3 a, b, c;
		//	double X1, Y1, Z1, X2, Y2, Z2, X3, Y3, Z3;
		//	int p1hash, p2hash, p3hash;
			Triangle(vec3 const &a, vec3 const &b, vec3 const &c):a(a), b(b), c(c){}
			Triangle(double ax, double ay, double az, double bx, double by, double bz, double cx, double cy, double cz):a((float)ax, (float)ay, (float)az), b((float)bx, (float)by, (float)bz), c((float)cx, (float)cy, (float)cz){}
			//Triangle(double X1, double Y1, double Z1, double X2, double Y2, double Z2, double X3, double Y3, double Z3):
			//	X1(X1), Y1(Y1), Z1(Z1), X2(X2), Y2(Y2), Z2(Z2), X3(X3), Y3(Y3), Z3(Z3)
			////	, p1hash(hash_3d(&X1)), p2hash(hash_3d(&X2)), p3hash(hash_3d(&X3))
			//{}
			bool valid()const
			{
				const float tolerance=1e-10f;
				vec3 ab=b-a, ac=c-a, d=ab.cross(ac);
				return d.mag_sq()>tolerance;
			}
			//float _4_area_sq()const
			//{
			//	vec3 ab=b-a, ac=c-a, d=ab.cross(ac);
			//	return d.mag_sq();
			//}
			//double _4_area_sq()const
			//{
			//	double
			//		x12=X2-X1, y12=Y2-Y1, z12=Z2-Z1,
			//		x13=X3-X1, y13=Y3-Y1, z13=Z3-Z1,
			//		cx=y12*z13-z12*y13, cy=z12*x13-x12*z13, cz=x12*y13-y12*x13;
			//	return cx*cx+cy*cy+cz*cz;
			//}
			bool operator==(Triangle const &other)const
			{
			//	return p1hash==other.p1hash&&p2hash==other.p2hash&&p3hash==other.p3hash;
				return a==other.a && b==other.b && c==other.c
					|| a==other.c && b==other.a && c==other.b
					|| a==other.b && b==other.c && c==other.a
					|| a==other.c && b==other.b && c==other.a
					|| a==other.a && b==other.c && c==other.b
					|| a==other.b && b==other.a && c==other.c;
				//return X1==other.X1&&Y1==other.Y1&&Z1==other.Z1 && X2==other.X2&&Y2==other.Y2&&Z2==other.Z2 && X3==other.X3&&Y3==other.Y3&&Z3==other.Z3
				//	|| X1==other.X3&&Y1==other.Y3&&Z1==other.Z3 && X2==other.X1&&Y2==other.Y1&&Z2==other.Z1 && X3==other.X2&&Y3==other.Y2&&Z3==other.Z2
				//	|| X1==other.X2&&Y1==other.Y2&&Z1==other.Z2 && X2==other.X3&&Y2==other.Y3&&Z2==other.Z3 && X3==other.X1&&Y3==other.Y1&&Z3==other.Z1
				//	|| X1==other.X3&&Y1==other.Y3&&Z1==other.Z3 && X2==other.X2&&Y2==other.Y2&&Z2==other.Z2 && X3==other.X1&&Y3==other.Y1&&Z3==other.Z1
				//	|| X1==other.X1&&Y1==other.Y1&&Z1==other.Z1 && X2==other.X3&&Y2==other.Y3&&Z2==other.Z3 && X3==other.X2&&Y3==other.Y2&&Z3==other.Z2
				//	|| X1==other.X2&&Y1==other.Y2&&Z1==other.Z2 && X2==other.X1&&Y2==other.Y1&&Z2==other.Z1 && X3==other.X3&&Y3==other.Y3&&Z3==other.Z3;
			//	return hash_9d(&X1)==hash_9d(&other.X1);
			}
		};
		struct Stick
		{
			double X1, Y1, Z1, X2, Y2, Z2;
			Stick(double X1, double Y1, double Z1, double X2, double Y2, double Z2):X1(X1), Y1(Y1), Z1(Z1), X2(X2), Y2(Y2), Z2(Z2){}
		};
	//	Region r;
		int bx1, bx2, by1, by2, bw, bh, X0, Y0;
		Camera cam;
	//	double camx, camy, camz, ax, ay, cax, sax, cay, say, da, dcam, tanfov, dtanfov, mouse_sensitivity, *wbuffer;
	//	_3D(){memset(this, 0, sizeof(_3D));}//CRASHES map & vector
		_3D(double camx, double camy, double camz, double ax, double ay, double tanfov):cam(camx, camy, camz, ax, ay, tanfov){}
	//	_3D(double camx, double camy, double camz, double ax, double ay, double tanfov):camx(camx), camy(camy), camz(camz), ax(ax), ay(ay), cax(cos(ax)), sax(sin(ax)), cay(cos(ay)), say(sin(ay)), da(2*G2::_pi/180), dcam(.04), tanfov(tanfov), dtanfov(1.1), mouse_sensitivity(.003){}
	//	~_3D(){free(wbuffer);}
		void set(double camx, double camy, double camz, double ax, double ay, double tanfov)
		{
			cam.set(camx, camy, camz, ax, ay, tanfov);
		}
		void setDimensions(int x, int y, int w, int h)
		{
			bx1=x, by1=y, bx2=x+w, by2=h, bw=w, bh=h, X0=w/2, Y0=h/2;
			resize_3D(w, h);
			clipX1=x, clipY1=y, clipX2=x+w-50, clipY2=y+h-24;
		}
		void teleport(double camx, double camy, double camz, double ax, double ay, double tanfov)
		{
			cam.teleport(dvec3(camx, camy, camz), ax, ay, tanfov);
		}
		void teleport_degrees(double camx, double camy, double camz, double ax_deg, double ay_deg, double tanfov)
		{
			cam.teleport(dvec3(camx, camy, camz), ax_deg*G2::_pi_180, ay_deg*G2::_pi_180, tanfov);
		}
	private:
		void line_A_coeff_x(double Xcp1, double Ycp1, double Zcp1, double Xcp2, double Ycp2, double Zcp2, double &a, double &b)
		{
			auto &tanfov=cam.tanfov;
			double t=(Xcp2-Xcp1)*Zcp1-Xcp1*(Zcp2-Zcp1);
			a=(Zcp1-Zcp2)*tanfov/(X0*t), b=((Zcp2-Zcp1)*tanfov+Xcp2-Xcp1)/t;
		}
		void line_A_coeff_y(double Xcp1, double Ycp1, double Zcp1, double Xcp2, double Ycp2, double Zcp2, double &a, double &b)
		{
			auto &tanfov=cam.tanfov;
			double t=(Ycp2-Ycp1)*Zcp1-Ycp1*(Zcp2-Zcp1);
			a=(Zcp1-Zcp2)*tanfov/(X0*t), b=((Zcp2-Zcp1)*Y0*tanfov/X0+Ycp2-Ycp1)/t;
		}
		double linearY(double x1, double y1, double x2, double y2, double x){return (y2-y1)/(x2-x1)*(x-x1)+y1;}
		double linearX(double x1, double y1, double x2, double y2, double y){return (x2-x1)/(y2-y1)*(y-y1)+x1;}
		void _3dLineOnScreen(dvec2 const &s1, dvec3 const &cp1, dvec2 const &s2, dvec3 const &cp2)
	//	void _3dLineOnScreen(double x1, double y1, double Xcp1, double Ycp1, double Zcp1, double x2, double y2, double Xcp2, double Ycp2, double Zcp2)
		{
			double x1=s1.x, y1=s1.y, Xcp1=cp1.x, Ycp1=cp1.y, Zcp1=cp1.z, x2=s2.x, y2=s2.y, Xcp2=cp2.x, Ycp2=cp2.y, Zcp2=cp2.z;
		//	const double &x1=s1.x, &y1=s1.y, &Xcp1=cp1.x, &Ycp1=cp1.y, &Zcp1=cp1.z, &x2=s2.x, &y2=s2.y, &Xcp2=cp2.x, &Ycp2=cp2.y, &Zcp2=cp2.z;
			if(abs(x1)>2e9||abs(y1)>2e9||abs(x2)>2e9||abs(y2)>2e9)
			{
				bool valid=true;
				//up
				if(y1<by1)
				{
					if(y2<by1)
						valid=false;
					else
						x1=linearX(x1, y1, x2, y2, by1), y1=by1;
				}
				else if(y2<by1)
					x2=linearX(x1, y1, x2, y2, by1), y2=by1;

				if(valid)
				{
					//right
					if(x1>bx2)
					{
						if(x2>bx2)
							valid=false;
						else
							y1=linearY(x1, y1, x2, y2, bx2), x1=bx2;
					}
					else if(x2>bx2)
						y2=linearY(x1, y1, x2, y2, bx2), x2=bx2;

					if(valid)
					{
						//bottom
						if(y1>by2)
						{
							if(y2>by2)
								valid=false;
							else
								x1=linearX(x1, y1, x2, y2, by2), y1=by2;
						}
						else if(y2>by2)
							x2=linearX(x1, y1, x2, y2, by2), y2=by2;

						if(valid)
						{
							//left
							if(x1<bx1)
							{
								if(x2<bx1)
									valid=false;
								else
									y1=linearY(x1, y1, x2, y2, bx1), x1=bx1;
							}
							else if(x2<bx1)
								y2=linearY(x1, y1, x2, y2, bx1), x2=bx1;

							if(valid)
								line_3D(cam, dvec2(x1, y1), dvec3(Xcp1, Ycp1, Zcp1), dvec2(x2, y2), dvec3(Xcp2, Ycp2, Zcp2), lineColor);
							//	_3dLineOnScreen_draw(x1, y1, Xcp1, Ycp1, Zcp1, x2, y2, Xcp2, Ycp2, Zcp2);
						}
					}
				}
			}
			else
				line_3D(cam, dvec2(x1, y1), dvec3(Xcp1, Ycp1, Zcp1), dvec2(x2, y2), dvec3(Xcp2, Ycp2, Zcp2), lineColor);
			//	_3dLineOnScreen_draw(x1, y1, Xcp1, Ycp1, Zcp1, x2, y2, Xcp2, Ycp2, Zcp2);
		}
		void _2dExtrapolateLine(dvec2 &s1, dvec3 &cp1, dvec2 &s2, dvec3 &cp2)//P1 behind
	//	void _2dExtrapolateLine(double x1, double y1, double Xcp1, double Ycp1, double Zcp1, double x2, double y2, double Xcp2, double Ycp2, double Zcp2)
		{
			double &x1=s1.x, &y1=s1.y, &Xcp1=cp1.x, &Ycp1=cp1.y, &Zcp1=cp1.z, &x2=s2.x, &y2=s2.y, &Xcp2=cp2.x, &Ycp2=cp2.y, &Zcp2=cp2.z;
			if(x1==x2&&y1==y2)
			{
				point_3D_cam(cam, cp1, lineColor);
				//if(Zcp1>0)
				//{
				//	double Acp1=1/Zcp1;
				//	if(x1>=bx1&&x1<bx2&&y1>=by1&&y1<by2)
				//	{
				//		int pos=int(x1)+bw*int(y1);
				//		if(Acp1>wbuffer[pos])
				//			rgb[pos]=lineColor, wbuffer[pos]=Acp1;
				//	}
				//}
			}
			else
			{
				dvec2 d=s2-s1;
				double r=G2::_sqrt2*(abs(x2)+abs(y2)+2*(X0+Y0))/(abs(d.x)+abs(d.y));
				_3dLineOnScreen(s2, cp1, s2+r*d, cp2);
			//	_3dLineOnScreen(x2, y2, Xcp1, Ycp1, Zcp1, x2+r*dx, y2+r*dy, Xcp2, Ycp2, Zcp2);
			}
		}
		dvec3 p0, cp1, cp2;
		dvec2 s1, s2;
		//double x0, y0, z0,
		//	Xs1, Ys1, Xcp1, Ycp1, Zcp1,
		//	Xs2, Ys2, Xcp2, Ycp2, Zcp2;
	public:
		int lineColor;//rgb
	private:
		bool isNanOrInf(double x){return (((int*)&x)[1]&0x7FF00000)==0x7FF00000;}
		void doPoint1(dvec3 const &p)
	//	void doPoint1(double x, double y, double z)
		{
			cam.world2camscreen(p, cp1, s1);

		//	cam.world2camscreen(dvec3(x, y, z), cp1, s1);

		//	auto &camx=cam.p.x, &camy=cam.p.y, &camz=cam.p.z, &tanfov=cam.tanfov;
			//double dx=x-camx, dy=y-camy, dz=z-camz, cpt=dx*cax+dy*sax;
			//Xcp1=dx*sax-dy*cax, Ycp1=cpt*say-dz*cay, Zcp1=cpt*cay+dz*say;
			//cpt=Zcp1*tanfov/X0, Xs1=X0+Xcp1/cpt, Ys1=Y0+Ycp1/cpt;
		}
		//world coordinates -> camera coordinates
		void point_world_camera(dvec3 const &d, dvec3 &cp)
	//	void point_world_camera(double dx, double dy, double dz, double &Xcp, double &Ycp, double &Zcp)
		{
			cam.relworld2cam(d, cp);

			//cam.relworld2cam(dvec3(dx, dy, dz), cp);

			//auto &cax=cam.cax, &sax=cam.sax, &cay=cam.cay, &say=cam.say;
			//double temp=dx*cax+dy*sax;
			//Xcp=dx*sax-dy*cax, Ycp=temp*say-dz*cay, Zcp=temp*cay+dz*say;
		}
		//camera coordinates -> screen coordinates
		void point_camera_screen(dvec3 const &cp, dvec2 &s)
	//	void point_camera_screen(double Xcp, double Ycp, double Zcp, double &Xs, double &Ys)
		{
			cam.cam2screen(cp, s);
			//auto &tanfov=cam.tanfov;
			//double temp=X0/(Zcp*tanfov);
			//Xs=X0+Xcp*temp, Ys=Y0+Ycp*temp;
		}
		//world coordinates -> screen coordinates		with depth info
		void point_world_screen(dvec3 const &d, dvec3 &cp, dvec2 &s)
	//	void point_world_screen(double dx, double dy, double dz, double &Xcp, double &Ycp, double &Zcp, double &Xs, double &Ys)
		{
			cam.relworld2camscreen(d, cp, s);
			//auto &cax=cam.cax, &sax=cam.sax, &cay=cam.cay, &say=cam.say, &tanfov=cam.tanfov;
			//double temp=dx*cax+dy*sax;
			//Xcp=dx*sax-dy*cax, Ycp=temp*say-dz*cay, Zcp=temp*cay+dz*say;
			//temp=X0/(Zcp*tanfov);
			//Xs=X0+Xcp*temp, Ys=Y0+Ycp*temp;
		}
		void _2dExtrapolateInfRay(dvec2 &s1, dvec3 &cp1, dvec2 &s2, dvec3 &cp2)
	//	void _2dExtrapolateInfRay(double x1, double y1, double Xcp1, double Ycp1, double Zcp1, double x2, double y2, double Xcp2, double Ycp2, double Zcp2)
		{
			double &x1=s1.x, &y1=s1.y, &Xcp1=cp1.x, &Ycp1=cp1.y, &Zcp1=cp1.z, &x2=s2.x, &y2=s2.y, &Xcp2=cp2.x, &Ycp2=cp2.y, &Zcp2=cp2.z;
			if(x1==x2&&y1==y2)
			{
				point_3D_cam(cam, cp1, lineColor);
				//if(Zcp1>0)
				//{
				//	double Acp1=1/Zcp1;
				//	if(x1>=bx1&&x1<bx2&&y1>=by1&&y1<by2)
				//	{
				//		int pos=int(x1)+bw*int(y1);
				//		if(Acp1>wbuffer[pos])
				//			rgb[pos]=lineColor, wbuffer[pos]=Acp1;
				//	}
				//}
			}
			else
			{
				dvec2 d12=s2-s1;
				double r=G2::_sqrt2*(abs(x2)+abs(y2)+2*(X0+Y0))/(abs(d12.x)+abs(d12.y));
				_3dLineOnScreen(s1, cp1, s2+r*d12, cp2);//[1 2 ->]
				//double dx12=x2-x1, dy12=y2-y1, r=G2::_sqrt2*(abs(x2)+abs(y2)+2*(X0+Y0))/(abs(dx12)+abs(dy12));
				//_3dLineOnScreen(x1, y1, Xcp1, Ycp1, Zcp1, x2+r*dx12, y2+r*dy12, Xcp2, Ycp2, Zcp2);//[1 2 ->]
			}
		}
		//draws a ray starting at P1 through P2
		void infiniteRay(dvec3 const &p1, dvec3 const &p2)//[1 2 -> inf]
	//	void infiniteRay(double x1, double y1, double z1, double x2, double y2, double z2)
		{
			dvec3 cp1;
			cam.world2cam(cp1, cp1);//P1: starting point
		//	point_world_camera(p1-cam.p, cp1);
		//	double Xcp1, Ycp1, Zcp1;
		//	point_world_camera(x1-camx, y1-camy, z1-camz, Xcp1, Ycp1, Zcp1);
			dvec3 cpInf;
			cam.relworld2cam(p2-p1, cpInf);//Inf: direction from camera
			//double XcpInf, YcpInf, ZcpInf;
			//point_world_camera(x2-x1, y2-y1, z2-z1, XcpInf, YcpInf, ZcpInf);
			if(cpInf.z>0)//ray pointing forward
		//	if(ZcpInf>0)
			{
				dvec2 sInf;
				cam.cam2screen(cpInf, sInf);//Inf
				//double XsInf, YsInf;
				//point_camera_screen(XcpInf, YcpInf, ZcpInf, XsInf, YsInf);
				dvec3 cp2;
				cam.world2cam(p2, cp2);//P2
				//double Xcp2, Ycp2, Zcp2;
				//point_world_camera(x2-camx, y2-camy, z2-camz, Xcp2, Ycp2, Zcp2);
				if(cp1.z>0)//starts in front of the camera
			//	if(Zcp1>0)
				{
					dvec2 s1;
					cam.cam2screen(cp1, s1);
					//double Xs1, Ys1;
					//point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					_3dLineOnScreen(s1, cp1, sInf, cp2);
				//	_3dLineOnScreen(Xs1, Ys1, Xcp1, Ycp1, Zcp1, XsInf, YsInf, Xcp2, Ycp2, Zcp2);
				}
				else if(cp1.z==0)//starts at the camera plane
			//	else if(Zcp1==0)
				{
					cp1+=cp1-cp2;//1 behind
				//	Xcp1+=Xcp1-Xcp2, Ycp1+=Ycp1-Ycp2, Zcp1+=Zcp1-Zcp2;
					dvec2 s1;
					cam.cam2screen(cp1, s1);
					//double Xs1, Ys1;
					//point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					//if(_2dNotInMyFace(Xs1, Ys1, Xcp1, Ycp1, Zcp1, XsInf, YsInf, Xcp2, Ycp2, Zcp2))
					//{
					//	double dx12, dy12, r;	_2dExtrapolate(Xs1, Ys1, XsInf, YsInf, dx12, dy12, r);
					//	_3dLineOnScreen(Xs1, Ys1, Xcp1, Ycp1, Zcp1, XsInf, YsInf, Xcp2, Ycp2, Zcp2);
					//}
					_2dExtrapolateLine(s1, cp1, sInf, cp2);
				//	_2dExtrapolateLine(Xs1, Ys1, Xcp1, Ycp1, Zcp1, XsInf, YsInf, Xcp2, Ycp2, Zcp2);
				}
				else//starts behind the camera
				{
					dvec2 s1;
					cam.cam2screen(cp1, s1);
					//double Xs1, Ys1;
					//point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					_2dExtrapolateLine(s1, cp1, sInf, cp2);
				//	_2dExtrapolateLine(Xs1, Ys1, Xcp1, Ycp1, Zcp1, XsInf, YsInf, Xcp2, Ycp2, Zcp2);
				}
			}
			else if(cpInf.z==0)//ray pointing parallel to camera plane
		//	else if(ZcpInf==0)
			{
				if(cp1.z>0)//starts in front of the camera
			//	if(Zcp1>0)
				{
					dvec3 cp2;
					dvec2 s2;
					cam.world2camscreen(p2, cp2, s2);//P2
					//double Xcp2, Ycp2, Zcp2, Xs2, Ys2;
					//point_world_screen(x2-camx, y2-camy, z2-camz, Xcp2, Ycp2, Zcp2, Xs2, Ys2);
					dvec2 s1;
					cam.cam2screen(cp1, s1);
					//double Xs1, Ys1;
					//point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					_2dExtrapolateInfRay(s2, cp1, s1, cp2);
				//	_2dExtrapolateInfRay(Xs2, Ys2, Xcp1, Ycp1, Zcp1, Xs1, Ys1, Xcp2, Ycp2, Zcp2);
				}
			}
			else//ray pointing back
			{
				if(cp1.z>0)//starts in front of the camera
			//	if(Zcp1>0)
				{
					dvec2 sInf;
					cam.cam2screen(cpInf, sInf);//Inf
					//double XsInf, YsInf;
					//point_camera_screen(XcpInf, YcpInf, ZcpInf, XsInf, YsInf);
					dvec3 cp2;
					cam.world2cam(p2, cp2);//P2
					//double Xcp2, Ycp2, Zcp2;
					//point_world_camera(x2-camx, y2-camy, z2-camz, Xcp2, Ycp2, Zcp2);
					dvec2 s1;
					cam.cam2screen(cp1, s1);
					//double Xs1, Ys1;
					//point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					_2dExtrapolateLine(sInf, cp1, s1, cp2);
				//	_2dExtrapolateLine(XsInf, YsInf, Xcp1, Ycp1, Zcp1, Xs1, Ys1, Xcp2, Ycp2, Zcp2);
				}
			}
		}
		void _2dExtrapolateInfLine(dvec2 &s1, dvec3 &cp1, dvec2 &s2, dvec3 &cp2)
	//	void _2dExtrapolateInfLine(double x1, double y1, double Xcp1, double Ycp1, double Zcp1, double x2, double y2, double Xcp2, double Ycp2, double Zcp2)
		{
			double &x1=s1.x, &y1=s1.y, &Xcp1=cp1.x, &Ycp1=cp1.y, &Zcp1=cp1.z, &x2=s2.x, &y2=s2.y, &Xcp2=cp2.x, &Ycp2=cp2.y, &Zcp2=cp2.z;
			if(x1==x2&&y1==y2)
			{
				point_3D_cam(cam, cp1, lineColor);
				//if(Zcp1>0)
				//{
				//	double Acp1=1/Zcp1;
				//	if(x1>=bx1&&x1<bx2&&y1>=by1&&y1<by2)
				//	{
				//		int pos=int(x1)+bw*int(y1);
				//		if(Acp1>wbuffer[pos])
				//			rgb[pos]=lineColor, wbuffer[pos]=Acp1;
				//	}
				//}
			}
			else
			{
				dvec2 d12=s2-s1;
				double r=G2::_sqrt2*(abs(x2)+abs(y2)+2*(X0+Y0))/(abs(d12.x)+abs(d12.y));
				_3dLineOnScreen(s1-r*d12, cp1, s1+r*d12, cp2);//[<- 1 2 ->]
				//double dx12=x2-x1, dy12=y2-y1, r=G2::_sqrt2*(abs(x2)+abs(y2)+2*(X0+Y0))/(abs(dx12)+abs(dy12));
				//_3dLineOnScreen(x1-r*dx12, y1-r*dy12, Xcp1, Ycp1, Zcp1, x1+r*dx12, y1+r*dy12, Xcp2, Ycp2, Zcp2);
			}
		}
		//draws the line through P1 and P2
		void infiniteLine(dvec3 const &p1, dvec3 const &p2)//[inf <- 1 2 -> inf]
	//	void infiniteLine(double x1, double y1, double z1, double x2, double y2, double z2)
		{
			dvec3 cp1;
			cam.world2cam(p1, cp1);//P1
			//double Xcp1, Ycp1, Zcp1;
			//point_world_camera(x1-camx, y1-camy, z1-camz, Xcp1, Ycp1, Zcp1);
			dvec3 cpInf;
			cam.world2cam(p2-p1, cpInf);//1-2 from cam
			//double XcpInf, YcpInf, ZcpInf;
			//point_world_camera(x2-x1, y2-y1, z2-z1, XcpInf, YcpInf, ZcpInf);
			if(cpInf.z>0)//1-2 points forward
		//	if(ZcpInf>0)
			{
				dvec2 sInf;
				cam.cam2screen(cpInf, sInf);//Inf
				//double XsInf, YsInf;
				//point_camera_screen(XcpInf, YcpInf, ZcpInf, XsInf, YsInf);

				dvec3 cp2;
				cam.world2cam(p2, cp2);//P2
				//double Xcp2, Ycp2, Zcp2;
				//point_world_camera(x2-camx, y2-camy, z2-camz, Xcp2, Ycp2, Zcp2);
				if(cp1.z>0)//P1 in front of the camera
			//	if(Zcp1>0)
				{
					dvec2 s1;
					cam.cam2screen(cp1, s1);
					//double Xs1, Ys1;
					//point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					_2dExtrapolateInfRay(sInf, cp1, s1, cp2);
				//	_2dExtrapolateInfRay(XsInf, YsInf, Xcp1, Ycp1, Zcp1, Xs1, Ys1, Xcp2, Ycp2, Zcp2);
				}
				else
				{
					if(cp1.z==0)//P1 at the camera plane
						cp1+=cp1-cp2;
				//	if(Zcp1==0)
				//		Xcp1+=Xcp1-Xcp2, Ycp1+=Ycp1-Ycp2, Zcp1+=Zcp1-Zcp2;
					dvec2 s1;
					cam.cam2screen(cp1, s1);
					//double Xs1, Ys1;
					//point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					_2dExtrapolateLine(s1, cp1, sInf, cp2);//P1 behind the camera
				//	_2dExtrapolateLine(Xs1, Ys1, Xcp1, Ycp1, Zcp1, XsInf, YsInf, Xcp2, Ycp2, Zcp2);
				}
			}
			else if(cpInf.z==0)//1-2 is parallel to cam plane
		//	else if(ZcpInf==0)
			{
				if(cp1.z>0)//in front of cam
			//	if(Zcp1>0)
				{
					dvec3 cp2;
					dvec2 s2;
					cam.world2camscreen(p2, cp2, s2);//P2
					//double Xcp2, Ycp2, Zcp2, Xs2, Ys2;
					//point_world_screen(x2-camx, y2-camy, z2-camz, Xcp2, Ycp2, Zcp2, Xs2, Ys2);
					dvec2 s1;
					cam.cam2screen(cp1, s1);
					//double Xs1, Ys1;
					//point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					_2dExtrapolateInfLine(s2, cp1, s1, cp2);
				//	_2dExtrapolateInfLine(Xs2, Ys2, Xcp1, Ycp1, Zcp1, Xs1, Ys1, Xcp2, Ycp2, Zcp2);
				}
			}
			else//1-2 points back
			{
				dvec2 sInf;
				cam.cam2screen(cpInf, sInf);//Inf
				//double XsInf, YsInf;
				//point_camera_screen(XcpInf, YcpInf, ZcpInf, XsInf, YsInf);

				dvec3 cp2;
				cam.world2cam(p2, cp2);//P2
				//double Xcp2, Ycp2, Zcp2;
				//point_world_camera(x2-camx, y2-camy, z2-camz, Xcp2, Ycp2, Zcp2);
				if(cp1.z>0)//P1 in front of cam
			//	if(Zcp1>0)
				{
					dvec2 s1;
					cam.cam2screen(cp1, s1);
					//double Xs1, Ys1;
					//point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					_2dExtrapolateInfRay(sInf, cp1, s1, cp2);
				//	_2dExtrapolateInfRay(XsInf, YsInf, Xcp1, Ycp1, Zcp1, Xs1, Ys1, Xcp2, Ycp2, Zcp2);
				}
				else
				{
					if(cp1.z==0)//P1 at cam plane
						cp1-=cp1-cp2;
				//	if(Zcp1==0)
				//		Xcp1-=Xcp1-Xcp2, Ycp1-=Ycp1-Ycp2, Zcp1-=Zcp1-Zcp2;
					dvec2 s1;
					cam.cam2screen(cp1, s1);
					//double Xs1, Ys1;
					//point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					_2dExtrapolateLine(s1, cp1, sInf, cp2);//P1 behind the camera
				//	_2dExtrapolateLine(Xs1, Ys1, Xcp1, Ycp1, Zcp1, XsInf, YsInf, Xcp2, Ycp2, Zcp2);
				}
			}
		}
		int continuous;
	public:
		void curve_start(){continuous=0;}
		void curve_point(double x, double y, double z)
		{
			if(continuous)
				line(p0, dvec3(x, y, z));
			//	line(x0, y0, z0, x, y, z);
			else
			{
				point_3D(cam, dvec3(x, y, z), lineColor);
			//	point(x, y, z);
				continuous=1;
			}
			p0.set(x, y, z);
		//	x0=x, y0=y, z0=z;
		}

		void moveTo(double x, double y, double z){p0.set(x, y, z);}
	//	void moveTo(double x, double y, double z){x0=x, y0=y, z0=z;}
		void lineTo(double x, double y, double z){line(p0, dvec3(x, y, z));}
	//	void lineTo(double x, double y, double z){line(x0, y0, z0, x, y, z);}
		void line(dvec3 const &p1, dvec3 const &p2)//alpha is ignored
	//	void line(double x1, double y1, double z1, double x2, double y2, double z2)
		{
			if(usingOpenGL)
			{
				gl_line_3D(p1, p2, lineColor);
				return;
			}
			const double &x1=p1.x, &y1=p1.y, &z1=p1.z, &x2=p2.x, &y2=p2.y, &z2=p2.z;
			int drawn=0;
			switch(count_nan_inf(p1)+count_nan_inf(p2))
		//	switch(isNanOrInf(x1)+isNanOrInf(y1)+isNanOrInf(z1)+isNanOrInf(x2)+isNanOrInf(y2)+isNanOrInf(z2))
			{
			case 0:
				{
					dvec3 cp1, cp2;
					cam.world2cam(p1, cp1);
					cam.world2cam(p2, cp2);
					//{
					//	double dx=x1-camx, dy=y1-camy, dz=z1-camz, cpt=dx*cax+dy*sax;
					//	Xcp1=dx*sax-dy*cax, Ycp1=cpt*say-dz*cay, Zcp1=cpt*cay+dz*say;
					//}
					//double dx=x2-camx, dy=y2-camy, dz=z2-camz, cpt=dx*cax+dy*sax, Xcp2=dx*sax-dy*cax, Ycp2=cpt*say-dz*cay, Zcp2=cpt*cay+dz*say;
					if(cp2.z>0)
				//	if(Zcp2>0)
					{
						if(cp1.z>0)
					//	if(Zcp1>0)
						{
							cam.cam2screen(cp1, s1);
							cam.cam2screen(cp2, s2);
							_3dLineOnScreen(s1, cp1, s2, cp2);
							//cpt=X0/(Zcp1*tanfov), Xs1=X0+Xcp1*cpt, Ys1=Y0+Ycp1*cpt;
							//cpt=X0/(Zcp2*tanfov), Xs2=X0+Xcp2*cpt, Ys2=Y0+Ycp2*cpt;
							//_3dLineOnScreen(Xs1, Ys1, Xcp1, Ycp1, Zcp1, Xs2, Ys2, Xcp2, Ycp2, Zcp2);
						}
						else if(cp1.z==0)
					//	else if(Zcp1==0)
						{
							cp1+=cp1-cp2;
							cam.cam2screen(cp1, s1);
							cam.cam2screen(cp2, s2);
							_2dExtrapolateLine(s1, cp1, s2, cp2);
							//Xcp1+=Xcp1-Xcp2, Ycp1+=Ycp1-Ycp2, Zcp1+=Zcp1-Zcp2;
							//cpt=X0/(Zcp1*tanfov), Xs1=X0+Xcp1*cpt, Ys1=Y0+Ycp1*cpt;
							//cpt=X0/(Zcp2*tanfov), Xs2=X0+Xcp2*cpt, Ys2=Y0+Ycp2*cpt;
							//_2dExtrapolateLine(Xs1, Ys1, Xcp1, Ycp1, Zcp1, Xs2, Ys2, Xcp2, Ycp2, Zcp2);
						}
						else
						{
							cam.cam2screen(cp1, s1);
							cam.cam2screen(cp2, s2);
							_2dExtrapolateLine(s1, cp1, s2, cp2);
							//cpt=X0/(Zcp1*tanfov), Xs1=X0+Xcp1*cpt, Ys1=Y0+Ycp1*cpt;
							//cpt=X0/(Zcp2*tanfov), Xs2=X0+Xcp2*cpt, Ys2=Y0+Ycp2*cpt;
							//_2dExtrapolateLine(Xs1, Ys1, Xcp1, Ycp1, Zcp1, Xs2, Ys2, Xcp2, Ycp2, Zcp2);
						}
						drawn=1;
					}
					else if(cp2.z==0)
				//	else if(Zcp2==0)
					{
						if(cp1.z>0)
					//	if(Zcp1>0)
						{
							cp2+=cp2-cp1;
							cam.cam2screen(cp1, s1);
							cam.cam2screen(cp2, s2);
							_2dExtrapolateLine(s2, cp1, s1, cp2);
							//Xcp2+=Xcp2-Xcp1, Ycp2+=Ycp2-Ycp1, Zcp2+=Zcp2-Zcp1;
							//cpt=X0/(Zcp1*tanfov), Xs1=X0+Xcp1*cpt, Ys1=Y0+Ycp1*cpt;
							//cpt=X0/(Zcp2*tanfov), Xs2=X0+Xcp2*cpt, Ys2=Y0+Ycp2*cpt;
							//_2dExtrapolateLine(Xs2, Ys2, Xcp1, Ycp1, Zcp1, Xs1, Ys1, Xcp2, Ycp2, Zcp2);
							drawn=1;
						}
					}
					else if(cp1.z>0)
				//	else if(Zcp1>0)
					{
						cam.cam2screen(cp1, s1);
						cam.cam2screen(cp2, s2);
						_2dExtrapolateLine(s2, cp1, s1, cp2);
						//cpt=X0/(Zcp1*tanfov), Xs1=X0+Xcp1*cpt, Ys1=Y0+Ycp1*cpt;
						//cpt=X0/(Zcp2*tanfov), Xs2=X0+Xcp2*cpt, Ys2=Y0+Ycp2*cpt;
						//_2dExtrapolateLine(Xs2, Ys2, Xcp1, Ycp1, Zcp1, Xs1, Ys1, Xcp2, Ycp2, Zcp2);
						drawn=1;
					}
				}
				break;
			case 1:
				{
					if(std::isinf(x1))
						infiniteRay(p2, dvec3(p1.x==_HUGE?p2.x+1:p2.x-1, p2.y, p2.z)), drawn=1;
					//	infiniteRay(x2, y2, z2, x1==_HUGE?x2+1:x2-1, y2, z2), drawn=1;
					else if(std::isinf(y1))
						infiniteRay(p2, dvec3(p2.x, p1.y==_HUGE?p2.y+1:p2.y-1, p2.z)), drawn=1;
					//	infiniteRay(x2, y2, z2, x2, y1==_HUGE?y2+1:y2-1, z2), drawn=1;
					else if(std::isinf(z1))
						infiniteRay(p2, dvec3(p2.x, p2.y, p1.z==_HUGE?p2.z+1:p2.z-1)), drawn=1;
					//	infiniteRay(x2, y2, z2, x2, y2, z1==_HUGE?z2+1:z2-1), drawn=1;
					else if(std::isinf(x2))
						infiniteRay(p1, dvec3(p2.x==_HUGE?p1.x+1:p1.x-1, p1.y, p1.z)), drawn=1;
					//	infiniteRay(x1, y1, z1, x2==_HUGE?x1+1:x1-1, y1, z1), drawn=1;
					else if(std::isinf(y2))
						infiniteRay(p1, dvec3(p1.x, p2.y==_HUGE?p1.y+1:p1.y-1, p1.z)), drawn=1;
					//	infiniteRay(x1, y1, z1, x1, y2==_HUGE?y1+1:y1-1, z1), drawn=1;
					else if(std::isinf(z2))
						infiniteRay(p1, dvec3(p1.x, p1.y, p2.z==_HUGE?p1.z+1:p1.z-1)), drawn=1;
					//	infiniteRay(x1, y1, z1, x1, y1, z2==_HUGE?z1+1:z1-1), drawn=1;
				}
				break;
			case 2:
				{
					if(std::isinf(x1)&&std::isinf(x2))
					{
						if(y1==x2&&z1==z2)
							infiniteLine(dvec3(cam.p.x, x2, z2), dvec3(cam.p.x+1, x2, z2)), drawn=1;
						//	infiniteLine(camx, x2, z2, camx+1, x2, z2), drawn=1;
					}
					else if(std::isinf(y1)&&std::isinf(x2))
					{
						if(z1==z2&&x1==x2)
							infiniteLine(dvec3(x2, cam.p.y, z2), dvec3(x2, cam.p.y+1, z2)), drawn=1;
						//	infiniteLine(x2, camy, z2, x2, camy+1, z2), drawn=1;
					}
					else if(std::isinf(z1)&&std::isinf(z2))
					{
						if(x1==x2&&y1==x2)
							infiniteLine(dvec3(x2, x2, cam.p.z), dvec3(x2, x2, cam.p.z+1)), drawn=1;
						//	infiniteLine(x2, x2, camz, x2, x2, camz+1), drawn=1;
					}
				}
				break;
			}
			if(!drawn)
			{
				if(!count_nan_inf(p1))
					point_3D(cam, p1, lineColor);
				else if(!count_nan_inf(p2))
					point_3D(cam, p2, lineColor);
				//if(!(isNanOrInf(x1)+isNanOrInf(y1)+isNanOrInf(z1)))
				//	point(x1, y1, z1);
				//else if(!(isNanOrInf(x2)+isNanOrInf(x2)+isNanOrInf(z2)))
				//	point(x1, y1, z1);
			}
		}
	//	void line(vec3 const &p1, vec3 const &p2){line(dvec3(p1.x, p1.y, p1.z), dvec3(p2.x, p2.y, p2.z));}
	//	void line(vec3 const &p1, vec3 const &p2){line(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);}

	private:
	//	int *libuffer, *lfbuffer;

		void			world_to_screen(vec3 const &p_world, vec2 &p_screen, vec3 &p_cam)
		{
			dvec3 cp;
			dvec2 s;
			cam.world2camscreen(dvec3(p_world.x, p_world.y, p_world.z), cp, s);
			p_screen.set((float)s.x, (float)s.y);
			p_cam.set((float)cp.x, (float)cp.y, (float)cp.z);
		//	vec3 d=p_world-vec3((float)camx, (float)camy, (float)camz);
		////	float dx=p_world.x-cam.x, dy=p_world.y-cam.y, dz=p_world.z-cam.z;
		//	float cpt=d.x*(float)cax+d.y*(float)sax;
		//	p_cam.set(d.x*(float)sax-d.y*(float)cax, cpt*(float)say-d.z*(float)cay, cpt*(float)cay+d.z*(float)say);
		//	cpt=p_cam.z*(float)tanfov/X0;
		//	p_screen.set(X0+p_cam.x/cpt, Y0+p_cam.y/cpt);
		}
	public:
	//	bool			lsw_transparency_multiply;
		void			transform(dvec3 &p1, dvec3 &p2, dvec3 &p3, vec2 &tx1, vec2 &tx2, vec2 &tx3, mat2 &m)//fill the texture matrix given texture coordinates
		{
			vec3 v12=p2-p1, v13=p3-p1;
			auto mag_v12=v12.mag_sq();
			auto r=v12.dot(v13)/mag_v12;
			vec3 vx3=v13-r*v12;
			mag_v12=sqrt(mag_v12);
			auto mag_vx3=sqrt(vx3.mag_sq());
			vec2 t13=tx3-tx1, t12=tx2-tx1;
			m.set_v((t13-r*t12)/mag_vx3, t12/mag_v12);

			//double _x12=p.x2-p.x1, _y12=p.y2-p.y1, _z12=p.z2-p.z1;
			//double _x13=p.x3-p.x1, _y13=p.y3-p.y1, _z13=p.z3-p.z1;
			//double _r=(_x12*_x13+_y12*_y13+_z12*_z13)/(_x12*_x12+_y12*_y12+_z12*_z12);
			//double _xx3=_x13-_r*_x12, _yx3=_y13-_r*_y12, _zx3=_z13-_r*_z12;
			//double _x3=sqrt(_xx3*_xx3+_yx3*_yx3+_zx3*_zx3), _12=sqrt(_x12*_x12+_y12*_y12+_z12*_z12);
			//p.txXX=(p.tx3x-p.tx1x-_r*(p.tx2x-p.tx1x))/_x3, p.txXY=(p.tx2x-p.tx1x)/_12;
			//p.txYX=(p.tx3y-p.tx1y-_r*(p.tx2y-p.tx1y))/_x3, p.txYY=(p.tx2y-p.tx1y)/_12;
		}
	//private:
	/*	public:
		void triangle_halfTransparent(Triangle &Tr, int color)
		{
			double dx, dy, dz, cpt, v1[5], v2[5], v3[5], admittance;
			dx=Tr.X1-camx, dy=Tr.Y1-camy, dz=Tr.Z1-camz, cpt=dx*cax+dy*sax, v1[2]=dx*sax-dy*cax, v1[3]=cpt*say-dz*cay, v1[4]=cpt*cay+dz*say, cpt=v1[4]*tanfov/X0, v1[0]=X0+v1[2]/cpt, v1[1]=Y0+v1[3]/cpt;
			dx=Tr.X2-camx, dy=Tr.Y2-camy, dz=Tr.Z2-camz, cpt=dx*cax+dy*sax, v2[2]=dx*sax-dy*cax, v2[3]=cpt*say-dz*cay, v2[4]=cpt*cay+dz*say, cpt=v2[4]*tanfov/X0, v2[0]=X0+v2[2]/cpt, v2[1]=Y0+v2[3]/cpt;
			dx=Tr.X3-camx, dy=Tr.Y3-camy, dz=Tr.Z3-camz, cpt=dx*cax+dy*sax, v3[2]=dx*sax-dy*cax, v3[3]=cpt*say-dz*cay, v3[4]=cpt*cay+dz*say, cpt=v3[4]*tanfov/X0, v3[0]=X0+v3[2]/cpt, v3[1]=Y0+v3[3]/cpt;
			if(v1[4]<0&&v2[4]<0&&v3[4]<0)		return;
			for(int k2=0;k2<h;++k2)libuffer[k2]=w; memset(lfbuffer, 0, h*sizeof(int));
			if(v1[4]<0||v2[4]<0||v3[4]<0)
			{
						if(v1[4]<0	&&	v2[4]<0				)	draft_2behind(v3, v1, v2);
				else if(			v2[4]<0	&&	v3[4]<0	)	draft_2behind(v1, v2, v3);
				else if(v1[4]<0				&&	v3[4]<0	)	draft_2behind(v2, v3, v1);
				else if(v1[4]<0							)	draft_1behind(v2, v3, v1);
				else if(			v2[4]<0				)	draft_1behind(v3, v1, v2);
				else										draft_1behind(v1, v2, v3);
			}
			else											draft_start(v1, v2), draft(v2, v3), draft(v3, v1);
			double au12=v2[2]-v1[2],			bu12=v2[3]-v1[3],			cu12=v2[4]-v1[4];									//u12	=<12>
			double aux3=v3[2]-v1[2],			bux3=v3[3]-v1[3],			cux3=v3[4]-v1[4];									//ux3	=<13>
			double a=bu12*cux3-bux3*cu12,		b=aux3*cu12-au12*cux3,		c=au12*bux3-aux3*bu12;								//abc	=<n>	=<12>x<13>
			double t=a*v1[2]+b*v1[3]+c*v1[4];
			if(!t)return;
			double B7=a, B8=b, B9=c*X0/tanfov-a*X0-b*Y0;	cpt=t*X0/tanfov;
			double A1=B7/cpt, A2=B8/cpt, A3=B9/cpt;
			double *wbk=wbuffer;
			int libk, lfbk;
			int *rgbk=rgb;

			auto C=(unsigned char*)&color;
			for(int k2=0;k2<h;++k2)
			{
				libk=libuffer[k2]<0?0:libuffer[k2], lfbk=lfbuffer[k2]>w?w:lfbuffer[k2];
				admittance=A1*libk+A2*k2+A3;
				for(int k3=libk;k3<lfbk;++k3)
				{
					if(admittance>wbk[k3])
					{
						auto p=(unsigned char*)&rgbk[k3];
						p[0]=p[0]*C[0]>>8, p[1]=p[1]*C[1]>>8, p[2]=p[2]*C[2]>>8;
					}
					admittance+=A1;
				}
				wbk=wbk+w, rgbk=rgbk+w;
			}
		}
		void triangle_halfTransparent(double x1, double y1, double z1, double x2, double y2, double z2, double x3, double y3, double z3, int color)
		{
			double dx, dy, dz, cpt, v1[5], v2[5], v3[5], admittance;
			dx=x1-camx, dy=y1-camy, dz=z1-camz, cpt=dx*cax+dy*sax, v1[2]=dx*sax-dy*cax, v1[3]=cpt*say-dz*cay, v1[4]=cpt*cay+dz*say, cpt=v1[4]*tanfov/X0, v1[0]=X0+v1[2]/cpt, v1[1]=Y0+v1[3]/cpt;
			dx=x2-camx, dy=y2-camy, dz=z2-camz, cpt=dx*cax+dy*sax, v2[2]=dx*sax-dy*cax, v2[3]=cpt*say-dz*cay, v2[4]=cpt*cay+dz*say, cpt=v2[4]*tanfov/X0, v2[0]=X0+v2[2]/cpt, v2[1]=Y0+v2[3]/cpt;
			dx=x3-camx, dy=y3-camy, dz=z3-camz, cpt=dx*cax+dy*sax, v3[2]=dx*sax-dy*cax, v3[3]=cpt*say-dz*cay, v3[4]=cpt*cay+dz*say, cpt=v3[4]*tanfov/X0, v3[0]=X0+v3[2]/cpt, v3[1]=Y0+v3[3]/cpt;
			if(v1[4]<0&&v2[4]<0&&v3[4]<0)		return;
			for(int k2=0;k2<h;++k2)libuffer[k2]=w; memset(lfbuffer, 0, h*sizeof(int));
			if(v1[4]<0||v2[4]<0||v3[4]<0)
			{
						if(v1[4]<0	&&	v2[4]<0				)	draft_2behind(v3, v1, v2);
				else if(			v2[4]<0	&&	v3[4]<0	)	draft_2behind(v1, v2, v3);
				else if(v1[4]<0				&&	v3[4]<0	)	draft_2behind(v2, v3, v1);
				else if(v1[4]<0							)	draft_1behind(v2, v3, v1);
				else if(			v2[4]<0				)	draft_1behind(v3, v1, v2);
				else										draft_1behind(v1, v2, v3);
			}
			else											draft_start(v1, v2), draft(v2, v3), draft(v3, v1);
			double au12=v2[2]-v1[2],			bu12=v2[3]-v1[3],			cu12=v2[4]-v1[4];									//u12	=<12>
			double aux3=v3[2]-v1[2],			bux3=v3[3]-v1[3],			cux3=v3[4]-v1[4];									//ux3	=<13>
			double a=bu12*cux3-bux3*cu12,		b=aux3*cu12-au12*cux3,		c=au12*bux3-aux3*bu12;								//abc	=<n>	=<12>x<13>
			double t=a*v1[2]+b*v1[3]+c*v1[4];
			if(!t)return;
			double B7=a, B8=b, B9=c*X0/tanfov-a*X0-b*Y0;	cpt=t*X0/tanfov;
			double A1=B7/cpt, A2=B8/cpt, A3=B9/cpt;
			double *wbk=wbuffer;
			int libk, lfbk;
			int *rgbk=rgb;

			auto C=(unsigned char*)&color;
			for(int k2=0;k2<h;++k2)
			{
				libk=libuffer[k2]<0?0:libuffer[k2], lfbk=lfbuffer[k2]>w?w:lfbuffer[k2];
				admittance=A1*libk+A2*k2+A3;
				for(int k3=libk;k3<lfbk;++k3)
				{
					if(admittance>wbk[k3])
					{
						auto p=(unsigned char*)&rgbk[k3];
						p[0]=p[0]*C[0]>>8, p[1]=p[1]*C[1]>>8, p[2]=p[2]*C[2]>>8;
					}
					admittance+=A1;
				}
				wbk=wbk+w, rgbk=rgbk+w;
			}
		}//*/
/*	private:
		void draft_1behind		(double *v1, double *v2, double *v3)
		{
			draft_start(v1, v2);
			draft_crit(v3, v1);
			draft_crit(v3, v2);
			if(v3[1]>v1[1]&&v3[1]<v2[1]||v3[1]>v2[1]&&v3[1]<v1[1]){		 if(v3[0]<(v2[0]-v1[0])*(v3[1]-v1[1])/(v2[1]-v1[1])+v1[0])	for(int k=0;k<h;++k)lfbuffer[k]=w;
																	else															memset(libuffer, 0, h*sizeof(int));}
		}
		void draft_2behind		(double *v1, double *v2, double *v3)
		{
			draft_crit_start(v2, v1);
			draft_crit(v3, v1);
			if(v1[1]>v2[1]&&v1[1]<v3[1]||v1[1]>v3[1]&&v1[1]<v2[1]){		 if(v1[0]<(v3[0]-v2[0])*(v1[1]-v2[1])/(v3[1]-v2[1])+v2[0])	memset(libuffer, 0, h*sizeof(int));
																	else															for(int k=0;k<h;++k)lfbuffer[k]=w;}
		}
		void draft_start		(double *v1, double *v2)
		{
			long long k2;double k3, A=(v2[0]-v1[0])/(v2[1]-v1[1]);
				 if(v1[1]<v2[1]){	k3=v1[0]+A*(clamp_positive_ll(v1[1])-v1[1]);	int kEnd=minimum(h, (int)v2[1]);	 if(v1[0]<v2[0])for(long long k=clamp_positive_ll(v1[1]);k<kEnd;++k)	k2=int(k3), k2=k2<0?clamp_positive_ll(int(v1[0])):k2>w?minimum(int(v2[0]), w):k2<v1[0]?int(v1[0]):minimum(int(v2[0]), (int)k2), libuffer[k]=lfbuffer[k]=(int)k2, k3+=A;
																													else				for(long long k=clamp_positive_ll(v1[1]);k<kEnd;++k)	k2=int(k3), k2=k2<0?clamp_positive_ll(int(v2[0])):k2>w?minimum(int(v1[0]), w):k2<v2[0]?int(v2[0]):minimum(int(v1[0]), (int)k2), libuffer[k]=lfbuffer[k]=(int)k2, k3+=A;}
			else				{	k3=v1[0]+A*(clamp_positive_ll(v2[1])-v1[1]);	int kEnd=minimum(h, (int)v1[1]);	 if(v1[0]<v2[0])for(long long k=clamp_positive_ll(v2[1]);k<kEnd;++k)	k2=int(k3), k2=k2<0?clamp_positive_ll(int(v1[0])):k2>w?minimum(int(v2[0]), w):k2<v1[0]?int(v1[0]):minimum(int(v2[0]), (int)k2), libuffer[k]=lfbuffer[k]=(int)k2, k3+=A;
																													else				for(long long k=clamp_positive_ll(v2[1]);k<kEnd;++k)	k2=int(k3), k2=k2<0?clamp_positive_ll(int(v2[0])):k2>w?minimum(int(v1[0]), w):k2<v2[0]?int(v2[0]):minimum(int(v1[0]), (int)k2), libuffer[k]=lfbuffer[k]=(int)k2, k3+=A;}
		}
		void draft				(double *v1, double *v2)
		{
			long long k2;double k3, A=(v2[0]-v1[0])/(v2[1]-v1[1]);
				 if(v1[1]<v2[1]){	k3=v1[0]+A*(clamp_positive_ll(v1[1])-v1[1]);	int kEnd=minimum(h, (int)v2[1]);	 if(v1[0]<v2[0])for(long long k=clamp_positive_ll(v1[1]);k<kEnd;++k)	k2=int(k3), k2=k2<0?clamp_positive_ll(int(v1[0])):k2>w?minimum(int(v2[0]), w):k2<v1[0]?int(v1[0]):minimum(int(v2[0]), (int)k2), libuffer[k]=minimum(libuffer[k], (int)k2), lfbuffer[k]=maximum(lfbuffer[k], (int)k2), k3+=A;
																													else				for(long long k=clamp_positive_ll(v1[1]);k<kEnd;++k)	k2=int(k3), k2=k2<0?clamp_positive_ll(int(v2[0])):k2>w?minimum(int(v1[0]), w):k2<v2[0]?int(v2[0]):minimum(int(v1[0]), (int)k2), libuffer[k]=minimum(libuffer[k], (int)k2), lfbuffer[k]=maximum(lfbuffer[k], (int)k2), k3+=A;}
			else				{	k3=v1[0]+A*(clamp_positive_ll(v2[1])-v1[1]);	int kEnd=minimum(h, (int)v1[1]);	 if(v1[0]<v2[0])for(long long k=clamp_positive_ll(v2[1]);k<kEnd;++k)	k2=int(k3), k2=k2<0?clamp_positive_ll(int(v1[0])):k2>w?minimum(int(v2[0]), w):k2<v1[0]?int(v1[0]):minimum(int(v2[0]), (int)k2), libuffer[k]=minimum(libuffer[k], (int)k2), lfbuffer[k]=maximum(lfbuffer[k], (int)k2), k3+=A;
																													else				for(long long k=clamp_positive_ll(v2[1]);k<kEnd;++k)	k2=int(k3), k2=k2<0?clamp_positive_ll(int(v2[0])):k2>w?minimum(int(v1[0]), w):k2<v2[0]?int(v2[0]):minimum(int(v1[0]), (int)k2), libuffer[k]=minimum(libuffer[k], (int)k2), lfbuffer[k]=maximum(lfbuffer[k], (int)k2), k3+=A;}
		}
		void draft_crit_start	(double *v1, double *v2)
		{
			long long k2;double k3, A=(v2[0]-v1[0])/(v2[1]-v1[1]);
				 if(v1[1]<v2[1]){	k3=v1[0]+A*(clamp_positive_ll(v2[1])-v1[1]);										 if(v1[0]<v2[0])for(long long k=clamp_positive_ll(v2[1]);k<h	;++k)	k2=int(k3), k2=k2<0?clamp_positive_ll(int(v2[0])):k2>w?w:maximum(int(v2[0]), (int)k2),	libuffer[k]=lfbuffer[k]=(int)k2, k3+=A;
																													else				for(long long k=clamp_positive_ll(v2[1]);k<h	;++k)	k2=int(k3), k2=k2<0?0:minimum(int(v2[0]), w, (int)k2),									libuffer[k]=lfbuffer[k]=(int)k2, k3+=A;}
			else				{	k3=v1[0]-A*((long long)v1[1]-(v1[1]<0));	int kEnd=minimum(h, (int)v2[1]);		 if(v1[0]<v2[0])for(long long k=0						;k<kEnd	;++k)	k2=int(k3), k2=k2<0?clamp_positive_ll(int(v2[0])):k2>w?w:maximum(int(v2[0]), (int)k2),	libuffer[k]=lfbuffer[k]=(int)k2, k3+=A;
																													else				for(long long k=0						;k<kEnd	;++k)	k2=int(k3), k2=k2<0?0:minimum(int(v2[0]), w, (int)k2),									libuffer[k]=lfbuffer[k]=(int)k2, k3+=A;}
		}
		void draft_crit			(double *v1, double *v2)
		{
			long long k2;double k3, A=(v2[0]-v1[0])/(v2[1]-v1[1]);
				 if(v1[1]<v2[1]){	k3=v1[0]+A*(clamp_positive_ll(v2[1])-v1[1]);										 if(v1[0]<v2[0])for(long long k=clamp_positive_ll(v2[1]);k<h	;++k)	k2=int(k3), k2=k2<0?clamp_positive_ll(int(v2[0])):k2>w?w:maximum(int(v2[0]), (int)k2),	libuffer[k]=minimum(libuffer[k], (int)k2), lfbuffer[k]=maximum(lfbuffer[k], (int)k2), k3+=A;
																													else				for(long long k=clamp_positive_ll(v2[1]);k<h	;++k)	k2=int(k3), k2=k2<0?0:minimum(int(v2[0]), w, (int)k2),									libuffer[k]=minimum(libuffer[k], (int)k2), lfbuffer[k]=maximum(lfbuffer[k], (int)k2), k3+=A;}
			else				{	k3=v1[0]-A*((long long)v1[1]-(v1[1]<0));	int kEnd=minimum(h, (int)v2[1]);		 if(v1[0]<v2[0])for(long long k=0						;k<kEnd	;++k)	k2=int(k3), k2=k2<0?clamp_positive_ll(int(v2[0])):k2>w?w:maximum(int(v2[0]), (int)k2),	libuffer[k]=minimum(libuffer[k], (int)k2), lfbuffer[k]=maximum(lfbuffer[k], (int)k2), k3+=A;
																													else				for(long long k=0						;k<kEnd	;++k)	k2=int(k3), k2=k2<0?0:minimum(int(v2[0]), w, (int)k2),									libuffer[k]=minimum(libuffer[k], (int)k2), lfbuffer[k]=maximum(lfbuffer[k], (int)k2), k3+=A;}
		}//*/

	public:
		void label(double x, double y, double z, char const *format, ...)
		{
			dvec3 cp;
			cam.world2cam(dvec3(x, y, z), cp);
		//	prof_add_loop(0);
			//double Xcp, Ycp, Zcp;
			//point_world_camera(x-camx, y-camy, z-camz, Xcp, Ycp, Zcp);
			if(cp.z>0)
		//	if(Zcp>0)
			{
				dvec2 s;
				cam.cam2screen(cp, s);
			//	prof_add_loop(1);
				//double Xs, Ys;
				//point_camera_screen(Xcp, Ycp, Zcp, Xs, Ys);
				//auto LOL_0=&format;
				//auto LOL_05=&format+1;
				//auto LOL_06=(char*)&(const char&)format+4;
				//auto LOL_07=(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3);
				//auto LOL_1=(char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3);
				//auto LOL_2=(char*)(&format+1);
				if(abs(s.x)<1e6&&abs(s.y)<1e6&&vsprintf_s(g_buf, g_buf_size, format, (char*)(&format+1))>0)
				{
					insert_label(cp.z, Text(int(s.x)-(s.x<0), int(s.y)-(s.y<0), TRANSPARENT, g_buf));
				//	prof_add_loop(2);
				}
				//{
				//	double k=1/cp.z;
				//	Text v(int(s.x)-(s.x<0), int(s.y)-(s.y<0), TRANSPARENT, g_buf);
				//	auto it=LOL_text.find(k);
				//	if(it==LOL_text.end())
				//	{
				//		auto &what=LOL_text.insert(std::pair<double, std::list<Text>>(k, std::list<Text>()));
				//		it=what.first;
				//	}
				//	it->second.push_back(v);

				////	auto &v=LOL_text[1/cp.z];
				////	v.push_back(t);
				//}
				//	LOL_text[1/cp.z].push_back(Text(int(s.x)-(s.x<0), int(s.y)-(s.y<0), TRANSPARENT, g_buf));//-0.5 truncated as 0
				//if(abs(Xs)<1e6&&abs(Ys)<1e6&&vsprintf_s(g_buf, g_buf_size, format, (char*)(&format+1))>0)
				//	LOL_text[1/Zcp].push_back(Text(int(Xs)-(Xs<0), int(Ys)-(Ys<0), TRANSPARENT, g_buf));//-0.5 truncated as 0
			//	if(abs(Xs)<1e6&&abs(Ys)<1e6&&vsprintf_s(buf, sizeof(buf), format, (char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3))>0)
			//		LOL_text[1/Zcp].push_back(Text(int(Xs)-(Xs<0), int(Ys)-(Ys<0), TRANSPARENT, buf));//-0.5 truncated as 0
			}
		}
	private:
		int clipX1, clipY1, clipX2, clipY2;
		//	->1->2->		+depth info
		bool arrowLabel_2dLine(double &x1, double &y1, double &x2, double &y2)
		{
			if(y1==y2)
			{
				if(y2<clipY1||y2>clipY2)
					return false;
				if(x1>x2)
				{
					double tx=x2, ty=y2;
					y2=linearY(x1, y1, x2, y2, clipX1), x2=clipX1;
					y1=linearY(x1, y1, tx, ty, clipX2), x1=clipX2;
				}
				else
				{
					double tx=x2, ty=y2;
					y2=linearY(x1, y1, x2, y2, clipX2), x2=clipX2;
					y1=linearY(x1, y1, tx, ty, clipX1), x1=clipX1;
				}
			}
			else
			{
				if(y1>y2)							//	<-	<-	Y1	<-	<-	Y2	<-	<-
				{
					double tx=x2, ty=y2;
					x2=linearX(x1, y1, x2, y2, clipY1), y2=clipY1;
					x1=linearX(x1, y1, tx, ty, clipY2), y1=clipY2;
				}
				else								//	->	->	Y1	->	->	Y2	->	->
				{
					double tx=x2, ty=y2;
					x2=linearX(x1, y1, x2, y2, clipY2), y2=clipY2;
					x1=linearX(x1, y1, tx, ty, clipY1), y1=clipY1;
				}
				if(x2<clipX1)
				{
					if(x1<clipX1)
						return false;
					else if(x1>clipX2)
					{
						double tx=x2, ty=y2;
						y2=linearY(x1, y1, x2, y2, clipX1), x2=clipX1;
						y1=linearY(x1, y1, tx, ty, clipX2), x1=clipX2;
					}
					else
						y2=linearY(x1, y1, x2, y2, clipX1), x2=clipX1;
				}
				else if(x2>clipX2)
				{
					if(x1<clipX1)
					{
						double tx=x2, ty=y2;
						y2=linearY(x1, y1, x2, y2, clipX2), x2=clipX2;
						y1=linearY(x1, y1, tx, ty, clipX1), x1=clipX1;
					}
					else if(x1>clipX2)
						return false;
					else
						y2=linearY(x1, y1, x2, y2, clipX2), x2=clipX2;
				}
				else
				{
					if(x1<clipX1)
						y1=linearY(x1, y1, x2, y2, clipX1), x1=clipX1;
					else if(x1>clipX2)
						y1=linearY(x1, y1, x2, y2, clipX2), x1=clipX2;
				}
			}
			return true;
		}
		//	->1->2		+depth info
		bool arrowLabel_2dRay(double &x1, double &y1, double &x2, double &y2)
		{
			if(y1==y2)
			{
				if(y2<clipY1||y2>clipY2)
					return false;
				if(x1>x2)
				{
					double tx=x2, ty=y2;
					y2=linearY(x1, y1, x2, y2, clipX1), x2=clipX1;
					y1=linearY(x1, y1, tx, ty, clipX2), x1=clipX2;
				}
				else
				{
					double tx=x2, ty=y2;
					y2=linearY(x1, y1, x2, y2, clipX2), x2=clipX2;
					y1=linearY(x1, y1, tx, ty, clipX1), x1=clipX1;
				}
			}
			else
			{
				if(y1>y2)
				{
					if(y2<clipY1)					//	y2	<-	Y1	<-	<-	Y2	<-	<-
					{
						double tx=x2, ty=y2;
						x2=linearX(x1, y1, x2, y2, clipY1), y2=clipY1;
						x1=linearX(x1, y1, tx, ty, clipY2), y1=clipY2;
					}
					else if(y2>clipY2)				//			Y1			Y2	y2	<-
						return false;
					else							//			Y1	y2	<-	Y2	<-	<-
						x1=linearX(x1, y1, x2, y2, clipY2), y1=clipY2;
				}
				else
				{
					if(y2<clipY1)					//	->	y2	Y1			Y2
						return false;
					else if(y2>clipY2)				//	->	->	Y1	->	->	Y2	->	y2
					{
						double tx=x2, ty=y2;
						x2=linearX(x1, y1, x2, y2, clipY2), y2=clipY2;
						x1=linearX(x1, y1, tx, ty, clipY1), y1=clipY1;
					}
					else							//	->	->	Y1	->	y2	Y2
						x1=linearX(x1, y1, x2, y2, clipY1), y1=clipY1;
				}
				if(x2<clipX1)
				{
					if(x1<clipX1)
						return false;
					else if(x1>clipX2)
					{
						double tx=x2, ty=y2;
						y2=linearY(x1, y1, x2, y2, clipX1), x2=clipX1;
						y1=linearY(x1, y1, tx, ty, clipX2), x1=clipX2;
					}
					else
						y2=linearY(x1, y1, x2, y2, clipX1), x2=clipX1;
				}
				else if(x2>clipX2)
				{
					if(x1<clipX1)
					{
						double tx=x2, ty=y2;
						y2=linearY(x1, y1, x2, y2, clipX2), x2=clipX2;
						y1=linearY(x1, y1, tx, ty, clipX1), x1=clipX1;
					}
					else if(x1>clipX2)
						return false;
					else
						y2=linearY(x1, y1, x2, y2, clipX2), x2=clipX2;
				}
				else
				{
					if(x1<clipX1)
						y1=linearY(x1, y1, x2, y2, clipX1), x1=clipX1;
					else if(x1>clipX2)
						y1=linearY(x1, y1, x2, y2, clipX2), x1=clipX2;
				}
			}
			return true;
		}
		//	1 2<-		+depth info
		bool arrowLabel_2dExtrapolateRay(double &Xs1, double &Ys1, double &Xs2, double &Ys2)
		{
			double dx=Xs2-Xs1, dy=Ys2-Ys1, r=G2::_sqrt2*(abs(Xs2)+abs(Ys2)+2*(X0+Y0))/(abs(dx)+abs(dy));
			return arrowLabel_2dRay(Xs1=Xs2+r*dx, Ys1=Ys2+r*dy, Xs2, Ys2);
		}
		void arrowLabel_finishPoint1(double &x1, double &y1, double Xcp1, double Ycp1, double Zcp1, double &x2, double &y2, double Xcp2, double Ycp2, double Zcp2, int &Xs, int &Ys, double &A)
		{
			double dx=x2-x1, dy=y2-y1, a, b;
			if(abs(dx)>abs(dy))
			{
				line_A_coeff_x(Xcp1, Ycp1, Zcp1, Xcp2, Ycp2, Zcp2, a, b);
				A=a*x1+b;
			}
			else
			{
				line_A_coeff_y(Xcp1, Ycp1, Zcp1, Xcp2, Ycp2, Zcp2, a, b);
				A=a*y1+b;
			}
			Xs=int(x1), Ys=int(y1);
		}
		void arrowLabel_finishPoint2(double &x1, double &y1, double Xcp1, double Ycp1, double Zcp1, double &x2, double &y2, double Xcp2, double Ycp2, double Zcp2, int &Xs, int &Ys, double &A)
		{
			double dx=x2-x1, dy=y2-y1, a, b;
			if(abs(dx)>abs(dy))
			{
				line_A_coeff_x(Xcp1, Ycp1, Zcp1, Xcp2, Ycp2, Zcp2, a, b);
				A=a*x2+b;
			}
			else
			{
				line_A_coeff_y(Xcp1, Ycp1, Zcp1, Xcp2, Ycp2, Zcp2, a, b);
				A=a*y2+b;
			}
			Xs=int(x2), Ys=int(y2);
		}
		bool arrowLabel_infiniteRay(dvec3 const &p1, dvec3 const &p2, int &Xs, int &Ys, double &A)
	//	bool arrowLabel_infiniteRay(double x1, double y1, double z1, double x2, double y2, double z2, int &Xs, int &Ys, double &A)
		{
			bool valid=false;
			dvec3 cp1;		cam.world2cam(p1, cp1);
			dvec3 cpInf;	cam.relworld2cam(p2-p1, cpInf);
			//double Xcp1, Ycp1, Zcp1;		point_world_camera(x1-camx, y1-camy, z1-camz, Xcp1, Ycp1, Zcp1);
			//double XcpInf, YcpInf, ZcpInf;	point_world_camera(x2-x1, y2-y1, z2-z1, XcpInf, YcpInf, ZcpInf);
			if(cpInf.z>0)
		//	if(ZcpInf>0)
			{
				dvec2 sInf;		cam.cam2screen(cpInf, sInf);
			//	double XsInf, YsInf;	point_camera_screen(XcpInf, YcpInf, ZcpInf, XsInf, YsInf);
				if(cp1.z>0)		//		|	P1	->Inf
			//	if(Zcp1>0)
				{
					dvec3 cp2;	cam.world2cam(p2, cp2);
					dvec2 s1;	cam.cam2screen(cp1, s1);
					//double Xcp2, Ycp2, Zcp2;	point_world_camera(x2-camx, y2-camy, z2-camz, Xcp2, Ycp2, Zcp2);
					//double Xs1, Ys1;			point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					if(arrowLabel_2dRay(s1.x, s1.y, sInf.x, sInf.y))
				//	if(arrowLabel_2dRay(Xs1, Ys1, XsInf, YsInf))
					{
						arrowLabel_finishPoint2(s1.x, s1.y, cp1.x, cp1.y, cp1.z, sInf.x, sInf.y, cp2.x, cp2.y, cp2.z, Xs, Ys, A);
					//	arrowLabel_finishPoint2(Xs1, Ys1, Xcp1, Ycp1, Zcp1, XsInf, YsInf, Xcp2, Ycp2, Zcp2, Xs, Ys, A);
						return true;
					}
				}
				else if(cp1.z==0)//		|P1|	->Inf
			//	else if(Zcp1==0)
				{
					dvec3 cp2;		cam.world2cam(p2, cp2);//P2
					cp1+=cp1-cp2;//P1 behind
					dvec2 s1;		cam.cam2screen(cp1, s1);
					//double Xcp2, Ycp2, Zcp2;	point_world_camera(x2-camx, y2-camy, z2-camz, Xcp2, Ycp2, Zcp2);
					//Xcp1+=Xcp1-Xcp2, Ycp1+=Ycp1-Ycp2, Zcp1+=Zcp1-Zcp2;
					//double Xs1, Ys1;			point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					if(arrowLabel_2dExtrapolateRay(s1.x, s1.y, sInf.x, sInf.y))
				//	if(arrowLabel_2dExtrapolateRay(Xs1, Ys1, XsInf, YsInf))
					{
						arrowLabel_finishPoint2(s1.x, s1.y, cp1.x, cp1.y, cp1.z, sInf.x, sInf.y, cp2.x, cp2.y, cp2.z, Xs, Ys, A);
					//	arrowLabel_finishPoint2(Xs1, Ys1, Xcp1, Ycp1, Zcp1, XsInf, YsInf, Xcp2, Ycp2, Zcp2, Xs, Ys, A);
						return true;
					}
				}
				else			//P1	|	->Inf
				{
					dvec3 cp2;		cam.world2cam(p2, cp2);
					dvec2 s1;		cam.cam2screen(cp1, s1);
					//double Xcp2, Ycp2, Zcp2;	point_world_camera(x2-camx, y2-camy, z2-camz, Xcp2, Ycp2, Zcp2);
					//double Xs1, Ys1;			point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					if(arrowLabel_2dExtrapolateRay(s1.x, s1.y, sInf.x, sInf.y))
				//	if(arrowLabel_2dExtrapolateRay(Xs1, Ys1, XsInf, YsInf))
					{
						arrowLabel_finishPoint2(s1.x, s1.y, cp1.x, cp1.y, cp1.z, sInf.x, sInf.y, cp2.x, cp2.y, cp2.z, Xs, Ys, A);
					//	arrowLabel_finishPoint2(Xs1, Ys1, Xcp1, Ycp1, Zcp1, XsInf, YsInf, Xcp2, Ycp2, Zcp2, Xs, Ys, A);
						return true;
					}
				}
			}
			else if(cpInf.z==0)
		//	else if(ZcpInf==0)
			{
				if(cp1.z>0)		//		|	//P1->Inf
			//	if(Zcp1>0)
				{
					dvec3 cp2;
					dvec2 s2, s1;
					cam.world2camscreen(p2, cp2, s2);
					cam.cam2screen(cp1, s1);
					//double Xcp2, Ycp2, Zcp2, Xs2, Ys2;	point_world_screen(x2-camx, y2-camy, z2-camz, Xcp2, Ycp2, Zcp2, Xs2, Ys2);
					//double Xs1, Ys1;					point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					if(arrowLabel_2dLine(s1.x, s1.y, s2.x, s2.y))
				//	if(arrowLabel_2dLine(Xs1, Ys1, Xs2, Ys2))
					{
						arrowLabel_finishPoint2(s1.x, s1.y, cp1.x, cp1.y, cp1.z, s2.x, s2.y, cp2.x, cp2.y, cp2.z, Xs, Ys, A);
					//	arrowLabel_finishPoint2(Xs1, Ys1, Xcp1, Ycp1, Zcp1, Xcp2, Ycp2, Xcp2, Ycp2, Zcp2, Xs, Ys, A);//typo
						return true;
					}
				}
			}
			else
			{
				dvec2 sInf;		cam.cam2screen(cpInf, sInf);
			//	double XsInf, YsInf;	point_camera_screen(XcpInf, YcpInf, ZcpInf, XsInf, YsInf);
				if(cp1.z>0)		//Inf<-	|	P1
			//	if(Zcp1>0)
				{
					dvec3 cp2;	cam.world2cam(p2, cp2);
					dvec2 s1;	cam.cam2screen(cp1, s1);
					//double Xcp2, Ycp2, Zcp2;	point_world_camera(x2-camx, y2-camy, z2-camz, Xcp2, Ycp2, Zcp2);
					//double Xs1, Ys1;			point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					if(arrowLabel_2dRay(s1.x, s1.y, sInf.x, sInf.y))
				//	if(arrowLabel_2dRay(Xs1, Ys1, XsInf, YsInf))
					{
						arrowLabel_finishPoint1(s1.x, s1.y, cp1.x, cp1.y, cp1.z, sInf.x, sInf.y, cp2.x, cp2.y, cp2.z, Xs, Ys, A);
					//	arrowLabel_finishPoint1(Xs1, Ys1, Xcp1, Ycp1, Zcp1, XsInf, YsInf, Xcp2, Ycp2, Zcp2, Xs, Ys, A);
						return true;
					}
				}
				else if(cp1.z==0)//Inf<-	|P1|
			//	else if(Zcp1==0)
				{
					dvec3 cp2;	cam.world2cam(p2, cp2);
					cp1+=cp1-cp2;
					dvec2 s1;	cam.cam2screen(cp1, s1);
					//double Xcp2, Ycp2, Zcp2;	point_world_camera(x2-camx, y2-camy, z2-camz, Xcp2, Ycp2, Zcp2);
					//Xcp1+=Xcp1-Xcp2, Ycp1+=Ycp1-Ycp2, Zcp1+=Zcp1-Zcp2;//P1 behind
					//double Xs1, Ys1;			point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					if(arrowLabel_2dExtrapolateRay(s1.x, s1.y, sInf.x, sInf.y))
				//	if(arrowLabel_2dExtrapolateRay(Xs1, Ys1, XsInf, YsInf))
					{
						arrowLabel_finishPoint1(s1.x, s1.y, cp1.x, cp1.y, cp1.z, sInf.x, sInf.y, cp2.x, cp2.y, cp2.z, Xs, Ys, A);
					//	arrowLabel_finishPoint1(Xs1, Ys1, Xcp1, Ycp1, Zcp1, XsInf, YsInf, Xcp2, Ycp2, Zcp2, Xs, Ys, A);
						return true;
					}
				}
				else			//Inf<-	P1	|
				{
					dvec3 cp2;	cam.world2cam(p2, cp2);
					dvec2 s1;	cam.cam2screen(cp1, s1);
					//double Xcp2, Ycp2, Zcp2;	point_world_camera(x2-camx, y2-camy, z2-camz, Xcp2, Ycp2, Zcp2);
					//double Xs1, Ys1;			point_camera_screen(Xcp1, Ycp1, Zcp1, Xs1, Ys1);
					if(arrowLabel_2dExtrapolateRay(s1.x, s1.y, sInf.x, sInf.y))
				//	if(arrowLabel_2dExtrapolateRay(Xs1, Ys1, XsInf, YsInf))
					{
						arrowLabel_finishPoint1(s1.x, s1.y, cp1.x, cp1.y, cp1.z, sInf.x, sInf.y, cp2.x, cp2.y, cp2.z, Xs, Ys, A);
					//	arrowLabel_finishPoint1(Xs1, Ys1, Xcp1, Ycp1, Zcp1, XsInf, YsInf, Xcp2, Ycp2, Zcp2, Xs, Ys, A);
						return true;
					}
				}
			}
			return false;

		/*	posInf=doPointFromCam(x2-x1, y2-y1, z2-z1, Xs2, Ys2)>0;
			doPoint1(x1, y1, z1);
			if(Zcp1>0)
				_2dRay(Xs1, Ys1, Xs2, Ys2, valid);
			else
			{
				double dx=Xs2-Xs1, dy=Ys2-Ys1, r=G2::_sqrt2*(abs(Xs2)+abs(Ys2)+2*(X0+Y0))/(abs(dx)+abs(dy));
				_2dRay(Xs1=Xs2+r*dx, Ys1=Ys2+r*dy, Xs2, Ys2, valid);
			}//*/
		}
	public:
		void arrowLabel(double x1, double y1, double z1, double x2, double y2, double z2, char const *format)
		{
			int Xs, Ys;
			double A;
			if(arrowLabel_infiniteRay(dvec3(x1, y1, z1), dvec3(x2, y2, z2), Xs, Ys, A))
		//	if(arrowLabel_infiniteRay(x1, y1, z1, x2, y2, z2, Xs, Ys, A))
				insert_label(1/A, Text(Xs, Ys, TRANSPARENT, format));
			//	LOL_text[A].push_back(Text(Xs, Ys, TRANSPARENT, format));
		}
		void arrowLabelsColor(double x1, double y1, double z1, double x2, double y2, double z2, std::vector<Label> &labels)
		{
			int Xs, Ys;
			double A;
			if(arrowLabel_infiniteRay(dvec3(x1, y1, z1), dvec3(x2, y2, z2), Xs, Ys, A))
		//	if(arrowLabel_infiniteRay(x1, y1, z1, x2, y2, z2, Xs, Ys, A))
			{
			//	for(auto &label:labels)
				for(unsigned k=0;k<labels.size();++k)
				{
					auto &label=labels[k];
					insert_label(1/A, Text(Xs, Ys, TRANSPARENT, expr[label.exNo].winColor, label.label));
				//	LOL_text[A].push_back(Text(Xs, Ys, TRANSPARENT, expr[label.exNo].winColor, label.label));
					Ys+=16;
				}
			}
		}
		void arrowLabelsColor(double x1, double y1, double z1, double x2, double y2, double z2, char const *const *labels, int const *colors, unsigned nLabels)
		{
			int Xs, Ys;
			double A;
			if(arrowLabel_infiniteRay(dvec3(x1, y1, z1), dvec3(x2, y2, z2), Xs, Ys, A))
		//	if(arrowLabel_infiniteRay(x1, y1, z1, x2, y2, z2, Xs, Ys, A))
			{
				for(unsigned l=0;l<nLabels;++l)
				{
					insert_label(1/A, Text(Xs, Ys, TRANSPARENT, colors[l], labels[l]));
				//	LOL_text[A].push_back(Text(Xs, Ys, TRANSPARENT, colors[l], labels[l]));
					Ys+=16;
				}
			}
		}
		void arrowLabels(double x1, double y1, double z1, double x2, double y2, double z2, std::vector<Label> &labels)
		{
			int Xs, Ys;
			double A;
			if(arrowLabel_infiniteRay(dvec3(x1, y1, z1), dvec3(x2, y2, z2), Xs, Ys, A))
		//	if(arrowLabel_infiniteRay(x1, y1, z1, x2, y2, z2, Xs, Ys, A))
			{
			//	for(auto &label:labels)
				for(unsigned k=0;k<labels.size();++k)
				{
					auto &label=labels[k];
					insert_label(1/A, Text(Xs, Ys, TRANSPARENT, label.label));
				//	LOL_text[A].push_back(Text(Xs, Ys, TRANSPARENT, label.label));
					Ys+=16;
				}
			}
		}
	private:
		//void point(double x, double y, double z)
		//{
		//	dvec3 cp;
		//	cam.world2cam(dvec3(x, y, z), cp);
		//	//double dx=x-camx, dy=y-camy, dz=z-camz, cpt=dx*cax+dy*sax, Xcp1=dx*sax-dy*cax, Ycp1=cpt*say-dz*cay;
		//	//double Zcp1=cpt*cay+dz*say;
		//	if(cp1.z>0)
		////	if(Zcp1>0)
		//	{
		//		double Acp1=1/Zcp1;
		//		cpt=X0/(Zcp1*tanfov);
		//		double Xs1=X0+Xcp1*cpt, Ys1=Y0+Ycp1*cpt;
		//		if((Xs1>=bx1)&(Xs1<bx2)&(Ys1>=by1)&(Ys1<by2))
		//		{
		//			int pos=int(Xs1)+bw*int(Ys1);
		//			if(Acp1>wbuffer[pos])
		//				rgb[pos]=lineColor, wbuffer[pos]=Acp1;
		//		}
		//	}
		//}
		//void _2dSet3dPoint(int x, int y, double a, int c)
		//{
		//	if((x>=bx1)&(x<bx2)&(y>=by1)&(y<by2))
		////	if(x>=bx1&&x<bx2&&y>=by1&&y<by2)
		//	{
		//		int pos=int(x+bw*y);
		//		if(a>wbuffer[pos])
		//			rgb[pos]=c, wbuffer[pos]=a;
		//	}
		//}
	public:
		//void point(double x, double y, double z, int Rcolor)
		//{
		//	double dx=x-camx, dy=y-camy, dz=z-camz, cpt=dx*cax+dy*sax, Xcp1=dx*sax-dy*cax, Ycp1=cpt*say-dz*cay;
		//	double Zcp1=cpt*cay+dz*say;
		//	if(Zcp1>0)
		//	{
		//		double Acp1=1/Zcp1;
		//		cpt=X0/(Zcp1*tanfov);
		//		double Xs1=X0+Xcp1*cpt, Ys1=Y0+Ycp1*cpt;
		//	//	GUIPrint(ghMemDC, Xs1, Ys1, Rcolor);
		//		int xs1=int(Xs1)-(Xs1<0), ys1=int(Ys1)-(Ys1<0);
		//		_2dSet3dPoint(xs1, ys1	, Acp1, Rcolor), _2dSet3dPoint(xs1+1, ys1	, Acp1, Rcolor);
		//		_2dSet3dPoint(xs1, ys1+1, Acp1, Rcolor), _2dSet3dPoint(xs1+1, ys1+1	, Acp1, Rcolor);
		//	}
		//}
		//void point(double x, double y, double z, int Rcolor, int Icolor, int Jcolor, int Kcolor)
		//{
		//	double dx=x-camx, dy=y-camy, dz=z-camz, cpt=dx*cax+dy*sax, Xcp1=dx*sax-dy*cax, Ycp1=cpt*say-dz*cay;
		//	double Zcp1=cpt*cay+dz*say;
		//	if(Zcp1>0)
		//	{
		//		double Acp1=1/Zcp1;
		//		cpt=X0/(Zcp1*tanfov);
		//		double Xs1=X0+Xcp1*cpt, Ys1=Y0+Ycp1*cpt;
		//		int xs1=int(Xs1)-(Xs1<0), ys1=int(Ys1)-(Ys1<0);
		//		_2dSet3dPoint(xs1		, ys1		, Acp1, Rcolor);
		//		_2dSet3dPoint(xs1+1		, ys1		, Acp1, Rcolor);
		//		_2dSet3dPoint(xs1+1		, ys1+1		, Acp1, Rcolor);
		//		_2dSet3dPoint(xs1		, ys1+1		, Acp1, Rcolor);
		//
		//		_2dSet3dPoint(xs1+3		, ys1		, Acp1, Icolor);
		//		_2dSet3dPoint(xs1+3+1	, ys1		, Acp1, Icolor);
		//		_2dSet3dPoint(xs1+3+1	, ys1+1		, Acp1, Icolor);
		//		_2dSet3dPoint(xs1+3		, ys1+1		, Acp1, Icolor);
		//
		//		_2dSet3dPoint(xs1		, ys1+3		, Acp1, Jcolor);
		//		_2dSet3dPoint(xs1+1		, ys1+3		, Acp1, Jcolor);
		//		_2dSet3dPoint(xs1+1		, ys1+3+1	, Acp1, Jcolor);
		//		_2dSet3dPoint(xs1		, ys1+3+1	, Acp1, Jcolor);
		//
		//		_2dSet3dPoint(xs1+3		, ys1+3		, Acp1, Kcolor);
		//		_2dSet3dPoint(xs1+3+1	, ys1+3		, Acp1, Kcolor);
		//		_2dSet3dPoint(xs1+3+1	, ys1+3+1	, Acp1, Kcolor);
		//		_2dSet3dPoint(xs1+3		, ys1+3+1	, Acp1, Kcolor);
		//	}
		//}

		//calculate the screen coordinates of the point (x, y, z)
		//as integers
		//returns true if can be cast to integers
		bool pointCoordinates(double x, double y, double z, int &Xs, int &Ys)
		{
			dvec3 cp;
			cam.world2cam(dvec3(x, y, z), cp);
			//double dx=x-camx, dy=y-camy, dz=z-camz, cpt=dx*cax+dy*sax, Xcp1=dx*sax-dy*cax, Ycp1=cpt*say-dz*cay;
			//double Zcp1=cpt*cay+dz*say;
			if(cp.z>0)
		//	if(Zcp1>0)
			{
				double Acp=1/cp.z;
			//	double Acp1=1/Zcp1;
				dvec2 s;
				cam.cam2screen(cp, s);
				//cpt=X0/(Zcp1*tanfov);
				//double _Xs=X0+Xcp1*cpt, _Ys=Y0+Ycp1*cpt;
				if(s.x>-1e6&&s.x<1e6&&s.y>-1e6&&s.y<1e6)
			//	if(Xs1>-1e6&&Xs1<1e6&&Ys1>-1e6&&Ys1<1e6)
				{
					Xs=int(s.x)-(s.x<0), Ys=int(s.y)-(s.y<0);
					return true;
				}
			}
			return false;
		}

		//calculate the screen coordinates of the point (x, y, z)
		//as doubles
		//returns true if can be cast to integers
		bool pointCoordinates(double x, double y, double z, double &Xs, double &Ys)
		{
			dvec3 cp;
			cam.world2cam(dvec3(x, y, z), cp);
			//double dx=x-camx, dy=y-camy, dz=z-camz, cpt=dx*cax+dy*sax, Xcp1=dx*sax-dy*cax, Ycp1=cpt*say-dz*cay;
			//double Zcp1=cpt*cay+dz*say;
			if(cp.z>0)
		//	if(Zcp1>0)
			{
				double Acp=1/cp.z;
			//	double Acp1=1/Zcp1;
				dvec2 s;
				cam.cam2screen(cp, s);
				Xs=s.x, Ys=s.y;
				//cpt=X0/(Zcp1*tanfov);
				//Xs=X0+Xcp1*cpt, Ys=Y0+Ycp1*cpt;
				if(Xs>-1e6&&Xs<1e6&&Ys>-1e6&&Ys<1e6)
			//	if(Xs1>-1e6&&Xs1<1e6&&Ys1>-1e6&&Ys1<1e6)//typo
					return true;
			}
			return false;
		}

		//calculate the screen coordinates of the point (x, y, z)
		//as doubles
		//return value:
		//3: can be cast to integers and is not obstructed so far
		//2: can be cast to integers but obstructed
		//1: can not be cast to integers
		//0: behind
		//int pointCoordinatesRect(double x, double y, double z, double &Xs, double &Ys)
		//{
		//	dvec3 cp;
		//	cam.world2cam(dvec3(x, y, z), cp);
		//	//double dx=x-camx, dy=y-camy, dz=z-camz, cpt=dx*cax+dy*sax, Xcp1=dx*sax-dy*cax, Ycp1=cpt*say-dz*cay;
		//	//double Zcp1=cpt*cay+dz*say;
		//	if(cp.z>0)
		////	if(Zcp1>0)
		//	{
		//		double Acp=1/cp.z;
		//	//	double Acp1=1/Zcp1;
		//		dvec2 s;
		//		cam.cam2screen(cp, s);
		//		//cpt=X0/(Zcp1*tanfov);
		//		//Xs=X0+Xcp1*cpt, Ys=Y0+Ycp1*cpt;
		//		if(s.x>=bx1&&s.x<bx2&&s.y>=by1&&s.y<by2)
		//	//	if(Xs1>=bx1&&Xs1<bx2&&Ys1>=by1&&Ys1<by2)
		//		{
		//			int pos=bw*int(s.y)+int(s.x);
		//			if(Acp>wbuffer[pos])
		//				return 3;
		//			return 2;
		//		}
		//		return 1;
		//	}
		//	return 0;
		//}

	private:
		std::vector<ZT> LOL_text;//closest to farthest
		void insert_label(double z, Text const &t)
		{
			LOL_text.push_back(std::make_pair(z, t));
			//int k=0;
			//for(int size=LOL_text.size();k<size;++k)
			//{
			//	auto &vk=LOL_text[k];
			//	if(z>vk.first)
			//		break;
			//}
			//LOL_text.insert(LOL_text.begin()+k, std::make_pair(z, t));
		}
	//	std::map<double, std::list<Text>> LOL_text;//closest to farthest

	public:
		//print text hud style in screen coordinates, always appears on top of text in 3d
		void textIn2D(int xs, int ys, int bkMode, char const *format, ...)
		{
			int buflen=vsprintf_s(g_buf, g_buf_size, format, (char*)(&format+1));
			//int buflen=vsprintf_s(g_buf, g_buf_size, format, (char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3));
			if(buflen>0)
				insert_label(0, Text(xs, ys, bkMode, g_buf));
			//	LOL_text[_HUGE].push_back(Text(xs, ys, bkMode, g_buf));
		//	buflen=vsprintf_s(buf, sizeof(buf), format, (char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3));
		//	if(buflen>0)
		//		LOL_text[_HUGE].push_back(Text(xs, ys, bkMode, buf));
		}
		void textIn2D(int xs, int ys, int bkMode, int color, char const *format, ...)
		{
			int buflen=vsprintf_s(g_buf, g_buf_size, format, (char*)(&format+1));
			//int buflen=vsprintf_s(g_buf, g_buf_size, format, (char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3));
			if(buflen>0)
				insert_label(0, Text(xs, ys, bkMode, color, g_buf));
			//	LOL_text[_HUGE].push_back(Text(xs, ys, bkMode, color, g_buf));
		//	buflen=vsprintf_s(buf, sizeof(buf), format, (char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3));
		//	if(buflen>0)
		//		LOL_text[_HUGE].push_back(Text(xs, ys, bkMode, color, buf));
		}

		//calculate the screen coordinates of the point (x, y, z) and writes the distance in Zcp1
		//as integers
		//returns true if can be cast to integers
		bool pointCoordinates3dText(double x, double y, double z, int &Xs, int &Ys)
		{
		//	dvec3 cp;
			cam.world2cam(dvec3(x, y, z), cp1);
			//double dx=x-camx, dy=y-camy, dz=z-camz, cpt=dx*cax+dy*sax, Xcp1=dx*sax-dy*cax, Ycp1=cpt*say-dz*cay;
			//if((Zcp1=cpt*cay+dz*say)>0)
			if(cp1.z>0)
			{
				double Acp=1/cp1.z;
			//	double Acp1=1/Zcp1;
				dvec2 s;
				cam.cam2screen(cp1, s);
				//cpt=X0/(Zcp1*tanfov);
				//double _Xs=X0+Xcp1*cpt, _Ys=Y0+Ycp1*cpt;
				if(s.x>-1e6&&s.x<1e6&&s.y>-1e6&&s.y<1e6)
			//	if(Xs1>-1e6&&Xs1<1e6&&Ys1>-1e6&&Ys1<1e6)
				{
					Xs=int(s.x)-(s.x<0), Ys=int(s.y)-(s.y<0);
				//	Xs=int(_Xs)-(_Xs<0), Ys=int(_Ys)-(_Ys<0);
					return true;
				}
			}
			return false;
		}

		//print text at (x, y, z) in 3d space coordinates
		void textIn3D(double x, double y, double z, int bkMode, const char *format, ...)
		{
			cam.world2camscreen(dvec3(x, y, z), cp1, s1);
		//	doPoint1(x, y, z);
			if(cp1.z>0&&abs(s1.x)<1e6&&abs(s1.y)<1e6)
		//	if(Zcp1>0&&abs(Xs1)<1e6&&abs(Ys1)<1e6)
			{
				int buflen=vsprintf_s(g_buf, g_buf_size, format, (char*)(&format+1));
				//int buflen=vsprintf_s(g_buf, g_buf_size, format, (char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3));
				if(buflen>0)
					insert_label(cp1.z, Text(int(s1.x)-(s1.x<0), int(s1.y)-(s1.y<0), bkMode, g_buf));
				//	LOL_text[double(1/cp1.z)].push_back(Text(int(s1.x)-(s1.x<0), int(s1.y)-(s1.y<0), bkMode, g_buf));
				//	LOL_text[double(1/Zcp1)].push_back(Text(int(Xs1)-(Xs1<0), int(Ys1)-(Ys1<0), bkMode, g_buf));
			//	buflen=vsprintf_s(buf, sizeof(buf), format, (char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3));
			//	if(buflen>0)
			//		LOL_text[double(1/Zcp1)].push_back(Text(int(Xs1)-(Xs1<0), int(Ys1)-(Ys1<0), bkMode, buf));
			}
		}

		//print text at (xs, ys) in screen coordinates, given inverse of the distance (A)
		void textIn3D_screenCoord(int xs, int ys, double A, int bkMode, const char *format, ...)
		{
			if(A>0)
			{
				int buflen=vsprintf_s(g_buf, g_buf_size, format, (char*)(&format+1));
				//int buflen=vsprintf_s(g_buf, g_buf_size, format, (char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3));
				if(buflen>0)
					insert_label(1/A, Text(xs, ys, bkMode, g_buf));
				//	LOL_text[A].push_back(Text(xs, ys, bkMode, g_buf));
			//	buflen=vsprintf_s(buf, sizeof(buf), format, (char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3));
			//	if(buflen>0)
			//		LOL_text[A].push_back(Text(xs, ys, bkMode, buf));
			}
		}

		//print text at (xs, ys) in screen coordinates, after using a function that writes the point distance Zcp in (Zcp1)
		void textIn3D_screenCoord(int xs, int ys, int bkMode, const char *format, ...)
		{
			if(cp1.z>0)
		//	if(Zcp1>0)
			{
				int buflen=vsprintf_s(g_buf, g_buf_size, format, (char*)(&format+1));
			//	int buflen=vsprintf_s(g_buf, g_buf_size, format, (char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3));
			//	int buflen=vsprintf_s(g_buf, sizeof(g_buf), format, (char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3));
				if(buflen>0)
					insert_label(cp1.z, Text(xs, ys, bkMode, g_buf));
				//	LOL_text[double(1/cp1.z)].push_back(Text(xs, ys, bkMode, g_buf));
				//	LOL_text[double(1/Zcp1)].push_back(Text(xs, ys, bkMode, g_buf));
			//	buflen=vsprintf_s(buf, sizeof(buf), format, (char*)(&reinterpret_cast<const char&>(format))+((sizeof(format)+3)&~3));
			//	if(buflen>0)
			//		LOL_text[double(1/Zcp1)].push_back(Text(xs, ys, bkMode, buf));
			}
		}

		//show the text that was printed in 3d space
		void text_show()
		{
			std::sort(LOL_text.begin(), LOL_text.end());
			prof_add("sort text");
			//const char *labels[]=
			//{
			//	"show txt: references",
			//	"show txt: set color",
			//	"show txt: prep",
			//	"show txt: loop",
			//	"show txt: bufferdata",
			//	"show txt: vertexattribpointer",
			//	"show txt: drawarrays",
			//	"show txt: set color",
			//};
			//prof_loop_start(labels, sizeof(labels)/sizeof(char*));
			int bkMode=getBkMode();
		//	for(auto &LOL:LOL_text)
			for(int k=0, size=LOL_text.size();k<size;++k)
			{
				auto &vk=LOL_text[k];
				auto &text=vk.second;
			//	prof_add_loop(0);
				setBkMode(text.bkMode);
				if(text.enable_color)
					setTextColor(text.color);
			//	prof_add_loop(1);
				print(text.x, text.y, text.str.c_str(), text.str.size());
				if(text.enable_color)
					setTextColor(0);
			//	prof_add_loop(7);
			}
			setBkMode(bkMode);
			//for(auto it=LOL_text.begin();it!=LOL_text.end();++it)
			//{
			//	auto &LOL=*it;
			////	for(auto &LOL_2:LOL.second)
			//	for(auto it2=LOL.second.begin();it2!=LOL.second.end();++it2)
			//	{
			//		auto &LOL_2=*it2;
			//		setBkMode(LOL_2.bkMode);
			//	//	SetBkMode(ghMemDC, LOL_2.bkMode);
			//		if(LOL_2.enable_color)
			//			setTextColor(LOL_2.color);
			//		//	SetTextColor(ghMemDC, LOL_2.color);
			//		print(LOL_2.x, LOL_2.y, LOL_2.str.c_str(), LOL_2.str.size());
			//	//	TextOutA(ghMemDC, LOL_2.x, LOL_2.y, LOL_2.str.c_str(), LOL_2.str.size());
			//		if(LOL_2.enable_color)
			//			setTextColor(0);
			//		//	SetTextColor(ghMemDC, 0);
			//	}
			//}
			LOL_text.clear();
		}
		void text_dump(){LOL_text.clear();}
	};//_3D

	int colorFunction_r(double &r)
	{
		if(r!=r)
			return 0x7F7F7F7F;
		else if(r==_HUGE)
			return 0x7FED7F11;//arg=0
		else if(r==-_HUGE)
			return 0x7F117FED;//arg=pi
		double mag=255/G2::_pi*atan(std::abs(r)), cosx=r>0?1:-1, sinx=0;
	//	return (unsigned char)(mag*1.866025403784439)<<16|unsigned char(mag*0.133974596215561);
		const double cos_pi_6=0.866025403784439, sin_pi_6=0.5;
		double red=mag*(1+cosx*cos_pi_6), green=mag, blue=mag*(1+cosx*-cos_pi_6);
		if(usingOpenGL)
			return 0x7F000000|(unsigned char)(blue)<<16|(unsigned char)(green)<<8|(unsigned char)(red);//OpenGL 0xAABBGGRR
		return 0x7F000000|(unsigned char)(red)<<16|(unsigned char)(green)<<8|(unsigned char)(blue);//Win32 bitmap 0xXXRRGGBB
	//	return (unsigned char)(mag*(1+cosx*cos_pi_6-sinx*sin_pi_6))<<16|unsigned char(mag*(1+sinx))<<8|unsigned char(mag*(1+cosx*-cos_pi_6-sinx*sin_pi_6));//*/

	/*	if(r!=r)
			return 0x7F7F7F;
		else if(r==_HUGE)
		{
			double mag=255/G2::_pi*atan(std::abs(r)), arg=(0);
			return (unsigned char)(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
		}
		else if(r==-_HUGE)
		{
			double mag=255/G2::_pi*atan(std::abs(r)), arg=(G2::_pi);
			return (unsigned char)(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
		}
		double mag=255/G2::_pi*atan(std::abs(r)), arg=atan2(0, r);
		return (unsigned char)(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));//*/
	}
	int colorFunction_i(double &i)
	{
		if(i!=i)
			return 0x7F7F7F;
		else if(i==_HUGE)
			return 0x003FFF3F;//arg=pi/2
		else if(i==-_HUGE)
			return 0x00BF00BF;//arg=-pi/2
		double mag=255/G2::_pi*atan(abs(i)), cosx=0, sinx=i>0?1:-1;
	//	return (unsigned char)(mag*0.5)<<16|unsigned char(mag*2)<<8|unsigned char(mag*0.5);
		const double cos_pi_6=0.866025403784439, sin_pi_6=0.5;
		return (unsigned char)(mag*(1-sin_pi_6))<<16|(unsigned char)(mag*(1+1))<<8|(unsigned char)(mag*(1-sin_pi_6));//*/

	/*	if(i!=i)
			return 0x7F7F7F;
		else if(i==_HUGE)
		{
			double mag=255/G2::_pi*atan(std::abs(i)), arg=(G2::_pi/2);
			return (unsigned char)(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
		}
		else if(i==-_HUGE)
		{
			double mag=255/G2::_pi*atan(std::abs(i)), arg=(-G2::_pi/2);
			return (unsigned char)(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
		}
		double mag=255/G2::_pi*atan(std::abs(i)), arg=atan2(i, 0);
		return (unsigned char)(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));//*/
	}
	int colorFunction(Value &x)
	{
		if(x.r!=x.r||x.i!=x.i)
			return 0x7F7F7F;
		if(x.r==_HUGE)
		{
			if(x.i==_HUGE||x.i==-_HUGE)
				return 0x00FFFFFF;
			else
				return 0x00ED7F11;//arg=0
		}
		else if(x.r==-_HUGE)
		{
			if(x.i==_HUGE||x.i==-_HUGE)
				return 0x00FFFFFF;
			else
				return 0x00117FED;//arg=pi
		}
		else if(x.i==_HUGE)
			return 0x003FFF3F;//arg=pi/2
		else if(x.i==-_HUGE)
			return 0x00BF00BF;//arg=-pi/2
		const double cos_pi_6=0.866025403784439, sin_pi_6=0.5;//, cos_pi3_2=0, sin_pi3_2=-1, cos_pi5_6=-cos_pi_6, sin_pi5_6=sin_pi_6;
		double _1_hyp=inv_sqrt(x.r*x.r+x.i*x.i), mag=255/G2::_pi*atan(1/_1_hyp), cosx=x.r*_1_hyp, sinx=x.i*_1_hyp;
	//	double hyp=sqrt(x.r*x.r+x.i*x.i), mag=255/G2::_pi*atan(hyp), cosx=x.r/hyp, sinx=x.i/hyp;
		return (unsigned char)(mag*(1+cosx*cos_pi_6-sinx*sin_pi_6))<<16|(unsigned char)(mag*(1+sinx))<<8|(unsigned char)(mag*(1+cosx*-cos_pi_6-sinx*sin_pi_6));
	//	return (unsigned char)(mag*(1+cosx*cos_pi_6-sinx*sin_pi_6))<<16;
	//	return (unsigned char)(mag*(1+cosx*cos_pi_6-sinx*sin_pi_6))<<16|(unsigned char)(mag*(1+cosx*cos_pi3_2-sinx*sin_pi3_2))<<8|unsigned char(mag*(1+cosx*cos_pi5_6-sinx*sin_pi5_6));
	/*	if(x.r!=x.r||x.i!=x.i)
			return 0x7F7F7F;
		if(x.r==_HUGE)
		{
			if(x.i==_HUGE||x.i==-_HUGE)
				return 0x00FFFFFF;
			else
			{
				double mag=127.5, arg=(0);
				return (unsigned char)(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
			}
		}
		else if(x.r==-_HUGE)
		{
			if(x.i==_HUGE||x.i==-_HUGE)
				return 0x00FFFFFF;
			else
			{
				double mag=-127.5, arg=(G2::_pi);
				return (unsigned char)(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
			}
		}
		else if(x.i==_HUGE)
		{
			double mag=255/G2::_pi*atan(sqrt(x.r*x.r+x.i*x.i)), arg=(G2::_pi/2);
			return (unsigned char)(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
		}
		else if(x.i==-_HUGE)
		{
			double mag=255/G2::_pi*atan(sqrt(x.r*x.r+x.i*x.i)), arg=(-G2::_pi/2);
			return (unsigned char)(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));
		}
		mag=255/G2::_pi*atan(sqrt(x.r*x.r+x.i*x.i)); double arg=atan2(x.i, x.r);//600ms
		int v1=(unsigned char)(mag*(1+cos(arg+G2::_pi/6)))<<16|unsigned char(mag*(1+cos(arg-G2::_pi/2)))<<8|unsigned char(mag*(1+cos(arg+G2::_pi*5/6)));//*/
	}
	void colorFunction_q(Value const &x, int &r, int &i, int &j, int &k)//TODO: swap red & blue with OpenGL
	{
		const double f=255*2/G2::_pi;
		((unsigned char*)&r)[x.r<0]=(unsigned char)(atan(abs(x.r))*f);
		((unsigned char*)&i)[x.i<0]=(unsigned char)(atan(abs(x.i))*f);
		((unsigned char*)&j)[x.j<0]=(unsigned char)(atan(abs(x.j))*f);
		((unsigned char*)&k)[x.k<0]=(unsigned char)(atan(abs(x.k))*f);
		//r=(unsigned char)(f*atan(abs(x.r)))<<(16&-(x.r<0));
		//i=(unsigned char)(f*atan(abs(x.i)))<<(16&-(x.i<0));
		//j=(unsigned char)(f*atan(abs(x.j)))<<(16&-(x.j<0));
		//k=(unsigned char)(f*atan(abs(x.k)))<<(16&-(x.k<0));
		//r=x.r>=0?unsigned char(255*atan(x.r)*2/G2::_pi):unsigned char(255*atan(-x.r)*2/G2::_pi)<<16;
		//i=x.i>=0?unsigned char(255*atan(x.i)*2/G2::_pi):unsigned char(255*atan(-x.i)*2/G2::_pi)<<16;
		//j=x.j>=0?unsigned char(255*atan(x.j)*2/G2::_pi):unsigned char(255*atan(-x.j)*2/G2::_pi)<<16;
		//k=x.k>=0?unsigned char(255*atan(x.k)*2/G2::_pi):unsigned char(255*atan(-x.k)*2/G2::_pi)<<16;
	}
	void colorFunction_bcw(CompP const &v, int *rgb)
	{
		const double &r=*v.r, &i=*v.i;
		if(r!=r||i!=i)
			*rgb=0x7F7F7F;
		else if(abs(r)==_HUGE||abs(i)==_HUGE)
			*rgb=0xFFFFFF;
		else
		{
			double threshold=10, inv_th=1/threshold;//1			//black->color->white		81.98 cycles/px
			const double cos_pi_6=0.866025403784439, sin_pi_6=0.5;
			double hyp=sqrt(r*r+i*i), cosx=r/hyp, sinx=i/hyp,
				mag=255*exp(-hyp*G2::_ln2*inv_th);
			double red=1+cosx*cos_pi_6-sinx*sin_pi_6, green=1+sinx, blue=1+cosx*-cos_pi_6-sinx*sin_pi_6;
			if(hyp<threshold)
				mag=255-mag, red*=mag, green*=mag, blue*=mag;
			else
				red=255-mag*(2-red), green=255-mag*(2-green), blue=255-mag*(2-blue);
			auto p=(unsigned char*)rgb;
			if(usingOpenGL)
				p[0]=(unsigned char)(red), p[1]=(unsigned char)(green), p[2]=(unsigned char)(blue), p[3]=0;//0xabgr
			else
				p[0]=(unsigned char)(blue), p[1]=(unsigned char)(green), p[2]=(unsigned char)(red), p[3]=0;//0xargb
		}
	}
	void colorFunction_bc_l(CompP const &v, int *rgb)
	{
		const double &r=*v.r, &i=*v.i;
		if(r!=r||i!=i)
			*rgb=0x7F7F7F;
		else if(abs(r)==_HUGE||abs(i)==_HUGE)
			*rgb=0xFFFFFF;
		else
		{
			const double cos_pi_6=0.866025403784439, sin_pi_6=0.5;//black->color whitening loop		94.04 cycles/px
			double hyp=sqrt(r*r+i*i), cosx=r/hyp, sinx=i/hyp,
				fh=floor(hyp*0.1), c, f;
			c=fh*0.01;
			c=255*(c-floor(c)), f=12.75*(hyp-fh*10)*(1-c*1./255);
			double red=1+cosx*cos_pi_6-sinx*sin_pi_6, green=1+sinx, blue=1+cosx*-cos_pi_6-sinx*sin_pi_6;
			red=c+f*red, green=c+f*green, blue=c+f*blue;
			auto p=(unsigned char*)rgb;
			p[0]=(unsigned char)(blue), p[1]=(unsigned char)(green), p[2]=(unsigned char)(red), p[3]=0;//argb
		}
	}
	
	int setXplaces(int w)
	{
		//if(simd_method==2)//avx, multiple of 4
			return (w&0xFFFFFFFC)+(((w&3)!=0)<<2);
		//if(simd_method==1)//sse2, multiple of 2
		//	return w+(w&1);
		//return w;//ia32
	}
	double		Xstart, Xsample, Ystart, Yend, Ysample, Zstart, Zsample;
	int			Xplaces, Yplaces, Zplaces, ndrSize;
	double		*p;
	double		T;//time from count start
	int			x, y, z;
	double		fx			()
	{
		return modes::Xstart+modes::x*modes::Xsample;
	}
	double		fy			()
	{
		return modes::Ystart+modes::y*modes::Ysample;
	}
	double		fz			(){return Zstart+z*Zsample;}
	double		fx_logscale	()
	{
		return modes::Xstart*_10pow(modes::x*modes::Xsample);
	}
	double		fy_logscale	(){return Ystart*_10pow(y*Ysample);}
	double		fz_logscale	(){return Zstart*_10pow(z*Zsample);}
	double		fc(){return *p;}
	double		fy2(){return Yend-y*Ysample;}
	typedef double (*F_fn)();
	void		choose_fill_fn		(Variable &var, F_fn &f, int component, bool &LOL_1_const, bool xlogscale, bool ylogscale, bool zlogscale)
	{
		switch((&var.varTypeR)[component])
		{
		case 'x':f=xlogscale?&fx_logscale:&fx, LOL_1_const=0;break;
		case 'y':f=ylogscale?&fy_logscale:&fy, LOL_1_const=0;break;
		case 'z':f=zlogscale?&fz_logscale:&fz, LOL_1_const=0;break;
		case 'c':f=&fc, p=&var.val.r+component;break;
		case 't':f=&fc, p=&T;break;
		}
	};
	void		choose_fill_fn_2di	(Variable &var, F_fn &f, int component, bool &LOL_1_const, bool xlogscale, bool ylogscale, bool zlogscale)
	{
		switch((&var.varTypeR)[component])
		{
		case 'x':f=&fx, LOL_1_const=0;break;
		case 'y':f=&fy2, LOL_1_const=0;break;//
		case 'z':f=&fz, LOL_1_const=0;break;
		case 'c':f=&fc, p=&var.val.r+component;break;
		case 't':f=&fc, p=&T;break;
		}
	};
	
	double XXstart, XXstep, XYstart, XYstep, YXstart, YXstep, YYstart, YYstep;
	double fxx(){return XXstart+x*XXstep;}
	double fxy(){return XYstart+y*XYstep;}
	double fyx(){return YXstart+y*YXstep;}//x and y swapped
	double fyy(){return YYstart+x*YYstep;}
	//double fyx(){return YXstart+x*YXstep;}
	//double fyy(){return YYstart+y*YYstep;}
	void		choose_fill_fn_l2d_X(Variable &var, F_fn &f, int component, bool &LOL_1_const, bool xlogscale, bool ylogscale, bool zlogscale)
	{
		switch((&var.varTypeR)[component])
		{
		case 'x':f=&fxx, LOL_1_const=0;break;
		case 'y':f=&fxy, LOL_1_const=0;break;
		case 'c':f=&fc, p=&var.val.r+component;break;
		case 't':f=&fc, p=&T;break;
		}
	}
	void		choose_fill_fn_l2d_Y(Variable &var, F_fn &fb, int component, bool &LOL_1_const, bool xlogscale, bool ylogscale, bool zlogscale)
	{
		switch((&var.varTypeR)[component])
		{
		case 'x':fb=&fyx, LOL_1_const=0;break;
		case 'y':fb=&fyy, LOL_1_const=0;break;
		case 'c':fb=&fc, p=&var.val.r+component;break;
		case 't':fb=&fc, p=&T;break;
		}
	}
	void		resize_terms(Expression &ex, int ndrSize)
	{
		for(int kn=0, knEnd=ex.n.size();kn<knEnd;++kn)
		{
			auto &n=ex.n[kn];
			n.r.resize(ndrSize);
			if(n.mathSet>='c')
			{
				n.i.resize(ndrSize);
				if(n.mathSet=='h')
				{
					n.j.resize(ndrSize);
					n.k.resize(ndrSize);
				}
			}
		}
	}
	void		initialize_const_comp(Expression &ex, int kn, double val, int component, int offset, int x1, int x2, int y1, int y2, int z1, int z2, int Xplaces, int Yplaces, int kzStep)
	{
		auto &n=ex.n[kn];
		auto ndr=(double*)(&n.r)[component].p;
		auto _First=ndr+offset+x1, _Last=ndr+offset+x2;
		for(int kz=Xplaces*Yplaces*z1, kzEnd=Xplaces*Yplaces*z2;kz<kzEnd;kz+=kzStep)
			for(int ky=kz+Xplaces*y1, kyEnd=kz+Xplaces*y2;ky<kyEnd;ky+=Xplaces)
				std::fill(_First+ky, _Last+ky, val);
	}
	void		initialize_component(Expression &ex, int kn, decltype(&choose_fill_fn) choose_fn, int component,
		int offset, int x1, int x2, int y1, int y2, int z1, int z2, int Xplaces, int Yplaces, int kzStep,//x1, x2 multiples of two
		bool xlogscale, bool ylogscale, bool zlogscale)
	{
		auto &n=ex.n[kn];
		auto &var=ex.variables[n.varNo];
		bool const_comp=true;
		double (*f)();
		choose_fn(var, f, component, const_comp, xlogscale, ylogscale, zlogscale);
		if(const_comp)
			initialize_const_comp(ex, kn, f(), component, offset, x1, x2, y1, y2, z1, z2, Xplaces, Yplaces, kzStep);
		else
		{
			auto ndr=(double*)(&n.r)[component].p;
			modes::z=z1;
			for(int kz=z1*kzStep;z<z2;++z, kz+=kzStep)
			{
				modes::y=y1;
				for(int ky=kz+Xplaces*y1;y<y2;++y, ky+=Xplaces)
				{
					for(modes::x=x1;x<x2;++x)
						ndr[offset+ky+modes::x]=f();
				//	int LOL_1=0;//
				}
			}
		}
	}
	void		fill_range(Expression &ex, decltype(&choose_fill_fn) choose_fn,
		int offset, int x1, int x2, int y1, int y2, int z1, int z2, int Xplaces, int Yplaces, int Zplaces, int kzStep,//x1, x2 multiples of 4
		bool xlogscale, bool ylogscale, bool zlogscale)
	{
	//	offset+=offset&1, x1-=x1&1, x2+=x2&1, Xplaces+=Xplaces&1;
		kzStep=Xplaces*Yplaces;
		for(int kn=0, knEnd=ex.n.size();kn<knEnd;++kn)
		{
			auto &n=ex.n[kn];
			if(n.constant)
			{
				initialize_const_comp(ex, kn, ex.data[kn].r.toDouble(), 0, offset, x1, x2, y1, y2, z1, z2, Xplaces, Yplaces, kzStep);
				if(n.mathSet>='c')
				{
					initialize_const_comp(ex, kn, ex.data[kn].i.toDouble(), 1, offset, x1, x2, y1, y2, z1, z2, Xplaces, Yplaces, kzStep);
					if(n.mathSet=='h')
					{
						initialize_const_comp(ex, kn, ex.data[kn].j.toDouble(), 2, offset, x1, x2, y1, y2, z1, z2, Xplaces, Yplaces, kzStep);
						initialize_const_comp(ex, kn, ex.data[kn].k.toDouble(), 3, offset, x1, x2, y1, y2, z1, z2, Xplaces, Yplaces, kzStep);
					}
					else
					{
						if(n.j.size())
							initialize_const_comp(ex, kn, 0, 2, offset, x1, x2, y1, y2, z1, z2, Xplaces, Yplaces, kzStep);
						if(n.k.size())
							initialize_const_comp(ex, kn, 0, 3, offset, x1, x2, y1, y2, z1, z2, Xplaces, Yplaces, kzStep);
					}
				}
				else if(n.i.size())
					initialize_const_comp(ex, kn, 0, 1, offset, x1, x2, y1, y2, z1, z2, Xplaces, Yplaces, kzStep);
			}
			else
			{
				auto &var=ex.variables[n.varNo];
				initialize_component(ex, kn, choose_fn, 0, offset, x1, x2, y1, y2, z1, z2, Xplaces, Yplaces, kzStep, xlogscale, ylogscale, zlogscale);
				if(var.mathSet>='c')
				{
					initialize_component(ex, kn, choose_fn, 1, offset, x1, x2, y1, y2, z1, z2, Xplaces, Yplaces, kzStep, xlogscale, ylogscale, zlogscale);
					if(var.mathSet=='h')
					{
						initialize_component(ex, kn, choose_fn, 2, offset, x1, x2, y1, y2, z1, z2, Xplaces, Yplaces, kzStep, xlogscale, ylogscale, zlogscale);
						initialize_component(ex, kn, choose_fn, 3, offset, x1, x2, y1, y2, z1, z2, Xplaces, Yplaces, kzStep, xlogscale, ylogscale, zlogscale);
					}
					else
					{
						if(n.j.size())
							initialize_const_comp(ex, kn, 0, 2, offset, x1, x2, y1, y2, z1, z2, Xplaces, Yplaces, kzStep);
						if(n.k.size())
							initialize_const_comp(ex, kn, 0, 3, offset, x1, x2, y1, y2, z1, z2, Xplaces, Yplaces, kzStep);
					}
				}
				else if(n.i.size())
					initialize_const_comp(ex, kn, 0, 1, offset, x1, x2, y1, y2, z1, z2, Xplaces, Yplaces, kzStep);
			}
		}
		//for(int kn=0;kn<ex.n.size();++kn)
		//	ndr_to_clipboard_2d((double*)ex.n[kn].r.p, Xplaces, Yplaces);//
	}

	struct		Scale
	{
		double VX0, DX0, VX, DX, AR;
		bool logscale;
		int z_level,
			prec;//precision

		int Xplaces;//screen Xplaces (may be not divisible by 4)
		double Xstart, Xend,
			rXstart,//checkboard start
			logXstart, logXend, Xsample, inv_Xsample, Xstep, logXstep,
			Xstep_r;//Xstep*AR
		double steps[3];
		Scale(double VX, double DX):VX0(VX), DX0(DX), VX(VX), DX(DX), logscale(false),
			z_level(0), prec(3), Xplaces(0),
			Xstart(VX-DX*0.5), Xend(VX+DX*0.5),
		//	Xstart(0), Xend(0),
			rXstart(0), logXstart(0), logXend(0),
			Xsample(0), inv_Xsample(0), Xstep(0), logXstep(0)
		{
			steps[0]=steps[1]=steps[2]=0;
		}
		void toggle_logscale()
		{
			if(logscale)//log -> linear
			{
				DX/=logscale_factor, VX/=logscale_factor;
			//	DX=log10(DX)/logscale_factor, VX=log10(VX)/logscale_factor;
				Xstart=logXstart/logscale_factor, Xend=logXend/logscale_factor;
				Xsample/=logscale_factor;
			}
			else//linear -> log
			{
				DX*=logscale_factor, VX*=logscale_factor;
			//	DX=_10pow(DX*logscale_factor), VX=_10pow(VX*logscale_factor);
				logXstart=Xstart*logscale_factor, logXend=Xend*logscale_factor;
				Xstart=_10pow(logXstart), Xend=_10pow(logXstart);
				Xsample*=logscale_factor;
			}
			logscale=!logscale;
		}
		void set_Xplaces(int Xplaces)
		{
			this->Xplaces=Xplaces, Xsample=DX/Xplaces, inv_Xsample=1/Xsample;
			if(logscale)
			{
				logXstart=VX-DX*0.5, logXend=VX+DX*0.5;
				Xstart=_10pow(logXstart), Xend=_10pow(logXend);
			}
			else
				Xstart=VX-DX*0.5, Xend=VX+DX*0.5;
		}
		void reset_scale()
		{
			if(logscale)
				DX=DX0*logscale_factor;
			else
				DX=DX0;
		}
		void reset_position()
		{
			if(logscale)
				VX=VX0*logscale_factor;
			else
				VX=VX0;
		}
		void reset()
		{
			if(logscale)
				DX=DX0*logscale_factor, VX=VX0*logscale_factor;
			else
				DX=DX0, VX=VX0;
		}
		void ppVX(){++VX;}
		void mmVX(){--VX;}
		void setVX(double x){VX=x;}
		double getVX()
		{
			if(logscale)
				return _10pow(VX);
			return VX;
		}
		void shift(int dx){VX+=dx*Xsample;}
		void zoom(double inv_a){DX*=inv_a;}
		void zoom_x(double inv_a, int mx)
		{
			double dx=(mx-(Xplaces>>1))*Xsample;
			DX*=inv_a, VX+=dx-dx*inv_a;
		}
		void zoom_y(double inv_a, int my)
		{
			double dy=((Xplaces>>1)-my)*Xsample;
			DX*=inv_a, VX+=dy-dy*inv_a;
		}
		bool update_scale(double DX, double AR, int v)//v is different from Xplaces for 3D modes
		{
			this->DX=DX, this->AR=AR;
			double DX2=DX/AR;
			if(logscale)
			{
				prec=5;
				const int tick_px=100;
				double step_size=tick_px*DX2/v;
				int p=(int)floor(step_size);//how many decades are there in 100px?
				if(p<1)//step<10: mainstep=10, step=linstep
				{
				//	double inv_step_size=v/(DX2*tick_px);		//WHAT IS THE PRECISION HERE?
					int z_level0=z_level;
					z_level=-floor_log10(step_size*step_size*step_size);
				//	z_level=1+floor_log10(1/(step_size*step_size*step_size));
				//	z_level=1+floor_log10(inv_step_size*inv_step_size*inv_step_size);
					return z_level0!=z_level;
				}
				z_level=0;
				if(p>3)
					p+=2, p-=p%3;
				double Xstep0=Xstep;
				Xstep=_10pow(p), logXstep=p;
				return Xstep0!=Xstep;
			}
			double Xstep0=Xstep;//linear scale
			double R=100*DX2/v;//100 px in real units
			int p=floor_log10(R);//ndigits-1
			Xstep=_10pow(p), prec=-clamp_negative(p);
			static const double m[]={1, 2, 5};
			int msd=int(R/Xstep);//most significant digit
			Xstep*=m[(msd>=2)+(msd>=5)];
		//	switch(int(R/Xstep))
		//	{
		//	case 1:Xstep*=1;break;
		//	case 2:Xstep*=2;break;
		//	case 3:Xstep*=2;break;
		//	case 4:Xstep*=2;break;
		//	case 5:Xstep*=5;break;
		//	case 6:Xstep*=5;break;
		//	case 7:Xstep*=5;break;
		//	case 8:Xstep*=5;break;
		//	case 9:Xstep*=5;break;
		//	default:Xstep*=6;break;		//<-
		////	default:Xstep*=1;break;	//<-
		//	}
			return Xstep0!=Xstep;
		}
		bool is_not_origin(double x)
		{
			static const double tolerance=1e-10;//1e-14
			return abs(x-logscale)>tolerance;
		}
		void logscale_generate_trilinstep(int z_level)//s1, s2, s5
		{
			if(z_level==1)
				steps[0]=1, steps[1]=3, steps[2]=5;
			else if(z_level==2)
				steps[0]=steps[1]=steps[2]=1;
			else if(z_level==3)
				steps[0]=0.5, steps[1]=steps[2]=1;
			else
			{
				steps[0]=steps[1]=steps[2]=_10pow(-(z_level-1)/3);
				switch(z_level%3)					//110 cycles
				{
				case 0:steps[0]*=0.5, steps[2]+=steps[2];break;				//0.5 1   2
				case 1:steps[0]+=steps[0], steps[1]*=5, steps[2]*=10;break;	//2   5  10
				case 2:steps[1]+=steps[1], steps[2]*=5;break;				//1   2   5
				}
			}
		}
		//double snap2grid_AR(double x, double AR)
		//{
		//	this->AR=AR;
		//	if(logscale)
		//	{
		//		if(z_level)
		//		{
		//			int ticks=logscale_distance2ticks_v2(x/AR);//
		//			return logscale_ticks2distance(ticks)*AR;//
		//		}
		//		return _10pow(floor(log10(x/AR)/logXstep)*logXstep)*AR;//
		//	}
		//	double Xs_r=Xstep*AR;
		//	return floor(x/Xs_r)*Xs_r;
		//}
		double snap2grid_AR_ceil(double x, double AR)
		{
			this->AR=AR;
			if(logscale)
			{
				if(z_level)
				{
					int ticks=logscale_distance2ticks_v2(x/AR)+1;//
					return logscale_ticks2distance(ticks)*AR;//
				}
				return _10pow(ceil(log10(x/AR)/logXstep)*logXstep)*AR;//
			}
			double Xs_r=Xstep*AR;
			return ceil(x/Xs_r)*Xs_r;
		}
		//double snap2grid_ceil(double x)//call this before next()
		//{
		//	if(logscale)
		//	{
		//		if(z_level)
		//		{
		//			int ticks=logscale_distance2ticks_v2(x)+1;//
		//			return logscale_ticks2distance(ticks);//
		//		}
		//		return _10pow(ceil(log10(x)/logXstep)*logXstep);//
		//	}
		//	double Xs_r=Xstep;
		//	return ceil(x/Xs_r)*Xs_r;
		//}
		int dist2ticks(double x)
		{
			if(logscale)
			{
				if(z_level)
					return logscale_distance2ticks_v2(x);
				return (int)floor(log10(x)/logXstep);
			}
			return (int)floor(x/Xstep);
		}
		double ticks2dist(int x)
		{
			if(logscale)
			{
				if(z_level)
					return logscale_ticks2distance(x);
				return _10pow(x*logXstep);
			}
			return x*Xstep;
		}
		int logscale_distance2ticks_v2(double x)//{linsteptill2, linsteptill5, linsteptill10}
		{
			int p=floor_log10(x);
			double residue=x*_10pow(-p);//fractional msd
		//	return (int)std::round(1/steps[0]+3/steps[1]+5/steps[2])*p;//X incomplete	release 187 cycles
		//	double temp=residue-2+abs(residue-2);
		//	return (int)std::floor((p+(residue-abs(residue-2))*0.5)/steps[0]+((p<<1)+p+(temp+6-abs(temp-6))*0.25)/steps[1]+((p<<2)+p+(residue-5+abs(residue-5))*0.5)/steps[2]);//release 253 debug 1122
			return (int)std::floor((p+minimum(residue-1, 1.))/steps[0]+(3*p+clamp(0., residue-2, 3.))/steps[1]+(5*p+maximum(0., residue-5))/steps[2]);//release 242/253 //165 debug 1276
		//	return (int)std::round(1/s[0]+3/s[1]+5/s[2])*p + (int)std::floor(minimum(residue-1, 1.)/s[0] + clamp(0, residue-2, 3)/s[1] + maximum(0., residue-5)/s[2]);//release 253 debug 1562 cycles
		}
		double logscale_ticks2distance(int ticks)//{linsteptill2, linsteptill5, linsteptill10}
		{
			int ntickstill2=(int)std::round(1/steps[0]), ntickstill5=(int)std::round(3/steps[1]), ntickstill10=(int)std::round(5/steps[2]),
				tpd=ntickstill2+ntickstill5+ntickstill10;//ticks per decade
			int p=(int)floor((double)ticks/tpd),//signed floor division
				temp=ticks%tpd;
			temp+=tpd&-(temp<0);
			double residue;
			if(temp<=ntickstill2)
				residue=1+(double)temp/ntickstill2;
			else if(temp<=ntickstill2+ntickstill5)
				residue=2+3.*(temp-ntickstill2)/ntickstill5;
			else
				residue=5+5.*(temp-ntickstill2-ntickstill5)/ntickstill10;
			return residue*_10pow(p);
		}
		double start_checkboard()//prepare rXstart, logXstart/logXend, inv_Xsample
		{
			Xsample=DX/Xplaces, inv_Xsample=1/Xsample;
			if(logscale)
			{
				logXstart=VX-DX*0.5, logXend=VX+DX*0.5;
				Xstart=_10pow(logXstart), Xend=_10pow(logXend);
				if(z_level)
				{
					logscale_generate_trilinstep(z_level);
					int ticks=logscale_distance2ticks_v2(Xstart);
					ticks-=ticks&1;//multiple of 2, round to -inf
					rXstart=logscale_ticks2distance(ticks);
				}
				else
				{
					double logXstepx2=logXstep+logXstep;
					rXstart=_10pow(floor(logXstart/logXstepx2)*logXstepx2);
				}
			}
			else//linear scale
			{
				Xstart=VX-DX*0.5, Xend=VX+DX*0.5;
				double Xstepx2=Xstep+Xstep;
				rXstart=floor(Xstart/Xstepx2)*Xstepx2;
			}
			return rXstart;
		}
		double start_checkboard(int xi, bool y)
		{
			Xsample=DX/Xplaces, inv_Xsample=1/Xsample;
			if(logscale)
			{
				logXstart=VX-DX*0.5, logXend=VX+DX*0.5;
				Xstart=_10pow(logXstart), Xend=_10pow(logXend);
				double Xi=y?ifn_y(xi):ifn_x(xi);//initial x
				if(z_level)
				{
					logscale_generate_trilinstep(z_level);
					int ticks=logscale_distance2ticks_v2(Xi);
					ticks-=ticks&1;//multiple of 2, round to -inf
					rXstart=logscale_ticks2distance(ticks);
				}
				else
				{
					double logXstepx2=logXstep+logXstep;
					rXstart=_10pow(floor(log10(Xi)/logXstepx2)*logXstepx2);
				}
			}
			else//linear scale
			{
				Xstart=VX-DX*0.5, Xend=VX+DX*0.5;
				double Xstepx2=Xstep+Xstep;
				double Xi=y?ifn_y(xi):ifn_x(xi);//initial x
				rXstart=floor(Xi/Xstepx2)*Xstepx2;
			}
			return rXstart;
		}
		double start_grid()
		{
			Xsample=DX/Xplaces, inv_Xsample=1/Xsample;
			if(logscale)
			{
				logXstart=VX-DX*0.5, logXend=VX+DX*0.5;
				Xstart=_10pow(logXstart), Xend=_10pow(logXend);
				if(z_level)
				{
					logscale_generate_trilinstep(z_level);
					int ticks=logscale_distance2ticks_v2(Xstart);
					rXstart=logscale_ticks2distance(ticks);
				}
				else
					rXstart=_10pow(floor(logXstart/logXstep)*logXstep);
			}
			else//linear scale
			{
				Xstart=VX-DX*0.5, Xend=VX+DX*0.5;
				rXstart=floor(Xstart/Xstep)*Xstep;
			}
			return rXstart;
		}
		//double start_grid_y()
		//{
		//	Xsample=DX/Xplaces, inv_Xsample=1/Xsample;
		//	if(logscale)//unmodified
		//	{
		//		logXstart=VX-DX*0.5, logXend=VX+DX*0.5;
		//		Xstart=_10pow(logXstart), Xend=_10pow(logXend);
		//		if(z_level)
		//		{
		//			logscale_generate_trilinstep(z_level);
		//			int ticks=logscale_distance2ticks_v2(Xstart);
		//			rXstart=logscale_ticks2distance(ticks);
		//		}
		//		else
		//			rXstart=_10pow(floor(logXstart/logXstep)*logXstep);
		//	}
		//	else//linear scale
		//	{
		//		Xstart=VX-DX*0.5, Xend=VX+DX*0.5;
		//		rXstart=ceil(Xend/Xstep)*Xstep;
		//	}
		//	return rXstart;
		//}
		double ifn(double x){return logscale?_10pow(x):x;}//R -> R, for 3D
		double ifn_x(double xs)//screen -> R
		{
			if(logscale)
				return _10pow(logXstart+xs*Xsample);//Xstart is logXstart
			return Xstart+xs*Xsample;
		}
		double ifn_y(double ys)
		{
			if(logscale)
				return _10pow(logXend-ys*Xsample);
			return Xend-ys*Xsample;
		}

		double fn(double x){return logscale?log10(x):x;}//R -> R, for 3D space
		double fn_x(double x)//R -> screen
		{
			if(logscale)
				return (log10(x)-logXstart)*inv_Xsample;
			return (x-Xstart)*inv_Xsample;
		}
		double fn_y(double y)
		{
			if(logscale)
				return (logXend-log10(y))*inv_Xsample;
			return (Xend-y)*inv_Xsample;
		}
		int fn_x_int(double x){x=fn_x(x); return int(x)-(x<0);}
		int fn_y_int(double y){y=fn_y(y); return int(y)-(y<0);}
		bool next_linear(double &x)
		{
			double x0=x;
			x+=Xstep;
			return x0==x;
		}
		bool next_log(double &x)
		{
			double x0=x;
			x*=Xstep;
			return x0==x;
		}
		bool next_log_linstep(double &x)//only needs z-level
		{
			static const double tolerance=1e-14,
				m1[]={1, 3, 5}, m3[]={0.5, 1, 1}, m[]={1, 2, 5};
			double x0=x, msd;
			int p=floor_log10(x+tolerance), msd2, idx;
			if(z_level==1)
			{
				msd=(x+tolerance)*_10pow(-p);
				msd2=(msd>=2)+(msd>=5);
				x+=m1[msd2]*_10pow(p);
			}
			else if(z_level==2)
				x+=_10pow(p);
			else
			{
				msd=(x+tolerance)*_10pow(-p);
				msd2=(msd>=2)+(msd>=5);
				if(z_level==3)
					x+=m3[msd2]*_10pow(p);
				else
				{
					idx=msd2-(z_level-2);
					idx%=3, idx+=3&-(idx<0);
					x+=m[idx]*_10pow(p-(z_level-msd2)/3);
				}
			}

			//double x0=x;
			//static const double tolerance=1e-14, m[]={1, 2, 5};
			//int p=floor_log10(x+tolerance);
			//double msd=x*_10pow(-p);
			//int msd2=(msd>=2)+(msd>=5), idx=msd2-(z_level-2);
			//idx%=3, idx+=3&-(idx<0);
			//x+=m[idx]*_10pow(p-(z_level-msd2)/3);
			return x0==x;
		}
		bool next(double &x)
		{
			if(logscale)
			{
				if(z_level)
					return next_log_linstep(x);
				return next_log(x);
			}
			return next_linear(x);
		}
		//bool next_y(double &x)
		//{
		//	if(logscale)
		//	{
		//		if(z_level)
		//			return prev_log_linstep(x);
		//		return prev_log(x);
		//	}
		//	return prev_linear(x);
		//}
		bool next_AR(double &x)//call snap2grid_AR first to assign AR
		{
			bool change;
			x/=AR;
			if(logscale)
			{
				if(z_level)
					change=next_log_linstep(x);
				else
					change=next_log(x);
			}
			else
				change=next_linear(x);
			x*=AR;
			return change;
		}
	};
#define			ys_Ystart	ys.Xstart
#define			zs_Zstart	zs.Xstart
	void _2dMode_DrawCheckboard_range(PenBrush &penBrush, Scale &xs, Scale &ys, int xi, int xf, int yi, int yf)
//	void _2dMode_DrawCheckboard_range(HPEN__ *hPen, HBRUSH__ *hBrush, Scale &xs, Scale &ys, int xi, int xf, int yi, int yf)
	{
		xs.Xplaces=w, ys.Xplaces=h;
		penBrush.use();
	//	hPen=(HPEN__*)SelectObject(ghMemDC, hPen), hBrush=(HBRUSH__*)SelectObject(ghMemDC, hBrush);
		double
			rYstart=ys.start_checkboard(yi, true), Yend=ys.ifn_y(yf),
			rXstart=xs.start_checkboard(xi, false), Xend=xs.ifn_x(xf);
		int y1, y2, y3, x1, x2, x3;
		y1=ys.fn_y_int(rYstart);
		for(double y=rYstart;y<Yend;)
		{
			if(ys.next(y))
				break;
			y2=ys.fn_y_int(y);
			if(ys.next(y))
				break;
			y3=ys.fn_y_int(y);

			x1=xs.fn_x_int(rXstart);
			for(double x=rXstart;x<Xend;)
			{
				if(xs.next(x))
					break;
				x2=xs.fn_x_int(x);
				if(xs.next(x))
					break;
				x3=xs.fn_x_int(x);
				rectangle(x1, y1+1, x2, y2+1);
				rectangle(x2, y2+1, x3, y3+1);
				//Rectangle(ghMemDC, x1, y1+1, x2, y2+1);
				//Rectangle(ghMemDC, x2, y2+1, x3, y3+1);
				x1=x3;
			}
			y1=y3;
		}
		penBrush.drop();
	//	hPen=(HPEN__*)SelectObject(ghMemDC, hPen), hBrush=(HBRUSH__*)SelectObject(ghMemDC, hBrush);
	}
	class		Solve
	{
	public:
		long long Tstart;//current ticks
		double T_elapsed,//time from previous call to sync
			T;//time from count start
		void reset()
		{
			LARGE_INTEGER li;
			QueryPerformanceFrequency(&li);
			long long freq=li.QuadPart;
			QueryPerformanceCounter(&li);
			Tstart=li.QuadPart;
			T_elapsed=0;
		}
		void synchronize()
		{
			LARGE_INTEGER li;
			QueryPerformanceFrequency(&li);
			long long freq=li.QuadPart;
			QueryPerformanceCounter(&li);
			T=T_elapsed+double(li.QuadPart-Tstart)/freq;
		}
		void pause(){T_elapsed=T;}
		void resume()
		{
			LARGE_INTEGER li;
			QueryPerformanceFrequency(&li);
			long long freq=li.QuadPart;
			QueryPerformanceCounter(&li);
			Tstart=li.QuadPart;
		}
	};
	struct		MP_CallInfo
	{
		int i;//call address		index in instructions vector
		Expression *func;
		std::vector<MP::Quat> fData;
		MP_CallInfo(Expression *func, int i):func(func), i(i){}
	};
	void		mp_solve_userfunction(std::vector<MP::Quat> &ndata, MP::Instruction &in)
	{
		auto func=&userFunctionDefinitions[in.op1];
		std::vector<MP::Quat> fData(func->data.size());
		{
			int k=0;
			for(int kEnd=in.args.size();k<kEnd;++k)//copy args
				fData[k]=ndata[in.args[k].idx];
			for(int kEnd=func->data.size();k<kEnd;++k)//initialize const data
				fData[k]=func->data[k];
		}
		int startTime=clock(), expiryTime=startTime+userFunctionTimeLimit, offset=(startTime>0&&expiryTime<0)*userFunctionTimeLimit;
		std::stack<MP_CallInfo> callStack;
		for(int i2=0, nInstr=func->ni.size();;)
		{
			if(i2>=nInstr)//return nothing	unreachable
			{
				if(callStack.size())
				{
					auto &cst=callStack.top();
					func=cst.func;
					i2=cst.i, nInstr=func->ni.size();
					cst.fData[func->i[i2].result].setzero();
				//	cst.fData[func->i[i2].result]=fData[0];//
					std::swap(cst.fData, fData);
					callStack.pop();
					continue;
				}
				ndata[in.result].setzero();
				break;
			}
#ifndef _DEBUG
			if(clock()+offset>expiryTime)
			{
				func->functionStuck=true;//mark function
			
				//return nan
				if(callStack.size())
				{
					auto &cst=callStack.top();
					func=cst.func;
					i2=cst.i, nInstr=func->ni.size();
					cst.fData[func->i[i2].result].setnan();
					std::swap(cst.fData, fData);
					callStack.pop();
					++i2;
					continue;
				}
				ndata[in.result].setnan();
				break;
			}
#endif
			auto &in2=func->ni[i2];
		//	func_data_to_clipboard(fData);//
			switch(in2.type)
			{
			case 'c'://call user function
				if(markFunctionsStuck&&userFunctionDefinitions[in2.op1].functionStuck)//return nan without call
				{
					fData[in2.result].setnan();
					++i2;
				}
				else
				{
					callStack.push(MP_CallInfo(func, i2));
					auto &cst=callStack.top();
					cst.fData=std::move(fData);
				//	func=in2.function;
					func=&userFunctionDefinitions[in2.op1], i2=0;
					fData.resize(func->data.size());
					{
						int k=0;
						for(int kEnd=in2.args.size();k<kEnd;++k)//copy args
							fData[k]=cst.fData[in2.args[k].idx];
						//	fData[k]=cst.func->data[in2.args[k]];
						for(int kEnd=func->data.size();k<kEnd;++k)//initialize const data
							fData[k]=func->data[k];
					}
				}
				continue;
			case 'b'://branch if
				if(fData[in2.op1].q_isTrue())
					i2=in2.result;
				else
					++i2;
				continue;
			case 'B'://branch if not
				if(!fData[in2.op1].q_isTrue())
					i2=in2.result;
				else
					++i2;
				continue;
			case 'j'://jump
				i2=in2.result;
				continue;
			case 'r'://return
				if(callStack.size())
				{
					auto &cst=callStack.top();
					func=cst.func;
					i2=cst.i, nInstr=func->ni.size();
					cst.fData[func->i[i2].result]=fData[in2.result];
					std::swap(cst.fData, fData);
					callStack.pop();
					++i2;
					continue;
				}
				ndata[in.result]=fData[in2.result];
				break;
			case -1:
				fData[in2.result].setzero();
				++i2;
				continue;
			case SIG_R_R:
			case SIG_C_C:
			case SIG_Q_Q:
					
			case SIG_C_R:
			case SIG_C_Q:
			case SIG_R_C:
			case SIG_R_Q:
				in2.fp.uf(fData[in2.result], fData[in2.op1]);
				++i2;
				continue;

			case SIG_R_RR:
			case SIG_C_RC:
			case SIG_Q_RQ:
			case SIG_C_CR:
			case SIG_C_CC:
			case SIG_Q_CQ:
			case SIG_Q_QR:
			case SIG_Q_QC:
			case SIG_Q_QQ:

			case SIG_C_RR:

			case SIG_R_RC:
			case SIG_R_RQ:
			case SIG_R_CR:
			case SIG_R_CC:
			case SIG_R_CQ:
			case SIG_R_QR:
			case SIG_R_QC:
			case SIG_R_QQ:

			case SIG_C_QC:
				in2.fp.bf(fData[in2.result], fData[in2.op1], fData[in2.op2]);
				++i2;
				continue;
			case SIG_INLINE_IF:
				fData[in2.result]=fData[in2.op1].q_isTrue()?fData[in2.op2]:fData[in2.op3];
				++i2;
				continue;
			case SIG_VA:
				in2.fp.vf(fData, ArgIdx(in2.result, in2.r_ms), in2.args);
				++i2;
				break;
			}
			break;
		}
	}
	class		Solve_0D:public Solve
	{
	public:
		void full(Expression &ex)
		{
			std::vector<MP::Quat> ndata(ex.data.size());
			for(int kn=0, knEnd=ex.data.size();kn<knEnd;++kn)
			{
				auto &n=ex.n[kn];
				auto &ndk=ndata[kn];
				if(n.constant)
					ndk=ex.data[kn];
				else//only possible variable in n0d is time variable
					ndk.set(T, 0, 0, 0);
				ndk.set_prec(MP::bin_prec, n.mathSet);
			}
			for(int ki=0, kiEnd=ex.ni.size();ki<kiEnd;++ki)
			{
				auto &in=ex.ni[ki];
			//	auto &res=ndata[in.result], &op1=ndata[in.op1], &op2=ndata[in.is_binary()?in.op2:in.op1];
				switch(in.type)
				{
				case SIG_CALL:
					mp_solve_userfunction(ndata, in);
					break;
#ifdef MP_PURE_QUAT
				case SIG_R_R:
				case SIG_C_C:
				case SIG_Q_Q:
					
				case SIG_C_R:
				case SIG_C_Q:
				case SIG_R_C:
				case SIG_R_Q:
					in.fp.uf(ndata[in.result], ndata[in.op1]);
					break;

				case SIG_R_RR:
				case SIG_C_RC:
				case SIG_Q_RQ:
				case SIG_C_CR:
				case SIG_C_CC:
				case SIG_Q_CQ:
				case SIG_Q_QR:
				case SIG_Q_QC:
				case SIG_Q_QQ:

				case SIG_C_RR:

				case SIG_R_RC:
				case SIG_R_RQ:
				case SIG_R_CR:
				case SIG_R_CC:
				case SIG_R_CQ:
				case SIG_R_QR:
				case SIG_R_QC:
				case SIG_R_QQ:

				case SIG_C_QC:
					in.fp.bf(ndata[in.result], ndata[in.op1], ndata[in.op2]);
					break;
#else
				case 'c':
					break;
				case FP::_R_R_FUNCTION:
					{
						in.fp. r_r();
					}
					break;
				case FP::_C_C_FUNCTION:in.fp. c_c();break;
				case FP::_Q_Q_FUNCTION:in.fp. q_q();break;
				case FP::R_RR_FUNCTION:in.fp.r_rr();break;
				case FP::C_RC_FUNCTION:in.fp.c_rc();break;
				case FP::Q_RQ_FUNCTION:in.fp.q_rq();break;
				case FP::C_CR_FUNCTION:in.fp.c_cr();break;
				case FP::C_CC_FUNCTION:in.fp.c_cc();break;
				case FP::Q_CQ_FUNCTION:in.fp.q_cq();break;
				case FP::Q_QR_FUNCTION:in.fp.q_qr();break;
				case FP::Q_QC_FUNCTION:in.fp.q_qc();break;
				case FP::Q_QQ_FUNCTION:in.fp.q_qq();break;

				case FP::_C_R_FUNCTION:in.fp. c_r();break;
				case FP::_C_Q_FUNCTION:in.fp. c_q();break;
				case FP::_R_C_FUNCTION:in.fp. r_c();break;
				case FP::_R_Q_FUNCTION:in.fp. r_q();break;
				case FP::C_RR_FUNCTION:in.fp.c_rr();break;

				case FP::R_RC_FUNCTION:in.fp.r_rc();break;
				case FP::R_RQ_FUNCTION:in.fp.r_rq();break;
				case FP::R_CR_FUNCTION:in.fp.r_cr();break;
				case FP::R_CC_FUNCTION:in.fp.r_cc();break;
				case FP::R_CQ_FUNCTION:in.fp.r_cq();break;
				case FP::R_QR_FUNCTION:in.fp.r_qr();break;
				case FP::R_QC_FUNCTION:in.fp.r_qc();break;
				case FP::R_QQ_FUNCTION:in.fp.r_qq();break;

				case FP::C_QC_FUNCTION:in.fp.c_qc();break;
				//case FP::_R_R_FUNCTION:in.fp. r_r();break;
				//case FP::_C_C_FUNCTION:in.fp. c_c();break;
				//case FP::_Q_Q_FUNCTION:in.fp. q_q();break;
				//case FP::R_RR_FUNCTION:in.fp.r_rr();break;
				//case FP::C_RC_FUNCTION:in.fp.c_rc();break;
				//case FP::Q_RQ_FUNCTION:in.fp.q_rq();break;
				//case FP::C_CR_FUNCTION:in.fp.c_cr();break;
				//case FP::C_CC_FUNCTION:in.fp.c_cc();break;
				//case FP::Q_CQ_FUNCTION:in.fp.q_cq();break;
				//case FP::Q_QR_FUNCTION:in.fp.q_qr();break;
				//case FP::Q_QC_FUNCTION:in.fp.q_qc();break;
				//case FP::Q_QQ_FUNCTION:in.fp.q_qq();break;

				//case FP::_C_R_FUNCTION:in.fp. c_r();break;
				//case FP::_C_Q_FUNCTION:in.fp. c_q();break;
				//case FP::_R_C_FUNCTION:in.fp. r_c();break;
				//case FP::_R_Q_FUNCTION:in.fp. r_q();break;
				//case FP::C_RR_FUNCTION:in.fp.c_rr();break;

				//case FP::R_RC_FUNCTION:in.fp.r_rc();break;
				//case FP::R_RQ_FUNCTION:in.fp.r_rq();break;
				//case FP::R_CR_FUNCTION:in.fp.r_cr();break;
				//case FP::R_CC_FUNCTION:in.fp.r_cc();break;
				//case FP::R_CQ_FUNCTION:in.fp.r_cq();break;
				//case FP::R_QR_FUNCTION:in.fp.r_qr();break;
				//case FP::R_QC_FUNCTION:in.fp.r_qc();break;
				//case FP::R_QQ_FUNCTION:in.fp.r_qq();break;

				//case FP::C_QC_FUNCTION:in.fp.c_qc();break;
#endif
				case SIG_INLINE_IF:
					ndata[in.result]=ndata[in.op1].q_isTrue()?ndata[in.op2]:ndata[in.op3];
					break;
				case SIG_VA:
					in.fp.vf(ndata, ArgIdx(in.result, in.r_ms), in.args);
					break;
				}
			}
			ex.nresult=std::move(ndata[ex.resultTerm]);
			//modes::T=T;
			//modes::Xplaces=1, modes::Yplaces=1, modes::Zplaces=1, modes::ndrSize=1;
			//resize_terms(ex, 2);
			//fill_range(ex, choose_fill_fn, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, false, false, false);
			//solve(ex, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1);

		//	solve_disc(ex, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1,	0, 0, 0, 0, 0, 0);
		//	::solve_disc(ex, 0, 0, 2, 0, 1, 0, 1, 2, 1, 1,	0, 0, 0, 0, 0, 0);
		}
	};
	
	void solve_zerocross_1d(Expression &ex, int x1, int x2)
	{
		auto &n_res=ex.n[ex.resultTerm];//
		auto ndr_r=(double*)n_res.r.p, ndr_i=(double*)n_res.i.p, ndr_j=(double*)n_res.j.p, ndr_k=(double*)n_res.k.p;
		switch(ex.resultMathSet)
		{
		case 'R':
			for(int x=x1, vEnd=x2-2;x<vEnd;++x)//{x1,x2}={0,Xoffset2} or {Xplaces-Xoffset, Xplaces}		ndr.size()==Xplaces+2
		//	for(int x=0, vEnd=ndr.size()-2;x<vEnd;++x)//ndr.size()==Xplaces+2
			{
				auto &V0=ndr_r[x], &V1=ndr_r[x+1], &V2=ndr_r[x+2];//V0 <= cross(V0, V1, V2) = max(cross2(V1, V0), cross2(V1, V2)),		cross2(near, far) = near /| far, gradient from 0 to 1
				if(V1==0)
					V0=true;
				else if(!ex.discontinuities[x]&&std::signbit(V0)!=std::signbit(V1))//cross at L?
				{
				//	double d_min=V1/(V1-V0);
					double d_min=V0/(V0-V1);
					if(!ex.discontinuities[x+1]&&std::signbit(V1)!=std::signbit(V2))//cross at R?
					{
					//	double d=V1/(V1-V2);
						double d=V2/(V2-V1);
						d_min=(d_min+d+std::abs(d_min-d))/2;//max
					//	d_min=(std::abs(d_min+d)+std::abs(d_min-d))/2;
					}
					V0=d_min;
				}
				else
				{
					if(!ex.discontinuities[x+1]&&std::signbit(V1)!=std::signbit(V2))//cross at R?
					//	V1=V1/(V1-V2);
						V0=V2/(V2-V1);
					else
						V0=false;
				}
			}
			break;
		case 'c':
			{
				bool Tshade=false;//trans-pixel shade
				double Tx;
				if(!ex.discontinuities[x1])
				{
					CompRef V0(ndr_r[x1], ndr_i[x1]), V1(ndr_r[x1+1], ndr_i[x1+1]);
					double dr=V1.r-V0.r, di=V1.i-V0.i;
					double Tx=-.5*(V0.r*dr+V0.i*di)/(dr*dr+di*di);
					if(Tx>=0&&Tx<1)
					{
						double rx=V0.r+dr*Tx, ix=V0.i+di*Tx;
						Tshade=rx*rx+ix*ix<.25;
					}
				}
				for(int v=x1, vEnd=x2-2;v<vEnd;++v)
			//	for(int v=0, vEnd=ndr.size()-2;v<vEnd;++v)//the only difference w/ full
				{
					CompRef V0(ndr_r[v], ndr_i[v]), V1(ndr_r[v+1], ndr_i[v+1]), V2(ndr_r[v+2], ndr_i[v+2]);
				//	auto &V0=ndr[v], &V1=ndr[v+1], &V2=ndr[v+2];
					if(V1.r==0&&V1.i==0)
						V0.r=true;
					else
					{
						bool shade=false;
						double Rx=0;
						if(!ex.discontinuities[v+1])
						{
							double dr=V2.r-V1.r, di=V2.i-V1.i;
							double Rx=-.5*(V1.r*dr+V1.i*di)/(dr*dr+di*di);
							if(Rx>=0&&Rx<1)
							{
								double rx=V1.r+dr*Rx, ix=V1.i+di*Rx;
								shade=rx*rx+ix*ix<.25;//why 0.25?
							}
						}
						if(shade)//cross at R?
						{
							if(Tshade)//cross at L?		LR
								V0.r=(std::abs(Tx+Rx)+std::abs(Tx-Rx))/2;
							//	V0.r=(Tx+Rx+std::abs(Tx-Rx))/2;
							else//	R
								V0.r=Rx;
							Tx=1-Rx;
						}
						else
						{
							if(Tshade)
								V0.r=Tx;
							else
								V0.r=false;
						}
						Tshade=shade;
					}
				}
			}
			break;
		case 'h':
			{
				bool Tshade=false;//trans-pixel shade
				double Tx;
				if(!ex.discontinuities[x1])
				{
					QuatRef V0(ndr_r[x1], ndr_i[x1], ndr_j[x1], ndr_k[x1]), V1(ndr_r[x1+1], ndr_i[x1+1], ndr_j[x1+1], ndr_k[x1+1]);
				//	auto &V0=ndr[x1], &V1=ndr[x1+1];
					double dr=V1.r-V0.r, di=V1.i-V0.i, dj=V1.j-V0.j, dk=V1.k-V0.k;
					double Tx=-.5*(V0.r*dr+V0.i*di+V0.j*dj+V0.k*dk)/(dr*dr+di*di+dj*dj+dk*dk);
					if(Tx>=0&&Tx<1)
					{
						double rx=V0.r+dr*Tx, ix=V0.i+di*Tx, jx=V1.j+dj*Tx, kx=V1.k+dk*Tx;
						Tshade=rx*rx+ix*ix+jx*jx+kx*kx<.25;//why 0.25?
					}
				}
				for(int v=x1, vEnd=x2-2;v<vEnd;++v)
				{
					QuatRef V0(ndr_r[v], ndr_i[v], ndr_j[v], ndr_k[v]),
						V1(ndr_r[v+1], ndr_i[v+1], ndr_j[v+1], ndr_k[v+1]),
						V2(ndr_r[v+2], ndr_i[v+2], ndr_j[v+2], ndr_k[v+2]);
				//	auto &V0=ndr[v], &V1=ndr[v+1], &V2=ndr[v+2];
					if(V1.r==0&&V1.i==0)
						V0.r=true;
					else
					{
						bool shade=false;
						double Rx=0;
						if(!ex.discontinuities[v])
						{
							double dr=V2.r-V1.r, di=V2.i-V1.i, dj=V2.j-V1.j, dk=V2.k-V1.k;
							double Rx=-.5*(V1.r*dr+V1.i*di+V0.j*dj+V0.k*dk)/(dr*dr+di*di+dj*dj+dk*dk);
							if(Rx>=0&&Rx<1)
							{
								double rx=V1.r+dr*Rx, ix=V1.i+di*Rx, jx=V1.j+dj*Rx, kx=V1.k+dk*Rx;
								shade=rx*rx+ix*ix+jx*jx+kx*kx<.25;
							}
						}
						if(shade)//cross at R?
						{
							if(Tshade)//cross at L?		LR
								V0.r=(std::abs(Tx+Rx)+std::abs(Tx-Rx))/2;
							//	V0=(Tx+Rx+std::abs(Tx-Rx))/2;
							else//	R
								V0.r=Rx;
							Tx=1-Rx;
						}
						else
						{
							if(Tshade)
								V0.r=Tx;
							else
								V0.r=false;
						}
						Tshade=shade;
					}
				}
			}
			break;
		}
	}
	class		Solve_1D_Implicit:public Solve
	{
	public:
		Scale &xs;
		double Xsample, Xstart, Xstart_s, *aXstart;
		int Xplaces;
		Solve_1D_Implicit(Scale &xs):xs(xs){}
	private:
		int sa[6];//XsrcStart, XsrcEnd, XdestStart		+padded version
		int ra[4];//XsolveStart, XsolveEnd				+padded version
	public:
		void full_resize(int Xplaces)
		{
			this->Xplaces=Xplaces;
			Xsample=xs.DX/Xplaces;
			Xstart_s=xs.Xstart, Xstart=Xstart_s+Xsample;
		}
		void full(Expression &ex)
		{
			int aXplaces;
			if(ex.resultLogicType>=2)//2: equation, 3: anti-equation
				aXstart=&Xstart_s, aXplaces=Xplaces+2;
			else//1: logic/inequality
				aXstart=&Xstart, aXplaces=Xplaces;
			modes::Xstart=*aXstart, modes::Xsample=Xsample, modes::T=T;
			modes::Xplaces=aXplaces, modes::Yplaces=1, modes::Zplaces=1, modes::ndrSize=aXplaces;
			resize_terms(ex, aXplaces);
			fill_range(ex, choose_fill_fn, 0, 0, aXplaces, 0, 1, 0, 1, aXplaces, 1, 1, aXplaces, false, false, false);
			switch(ex.resultLogicType)
			{
			case 1://&& ## || < <= > >=		logic/inequality
				::solve_disc(ex, 0, 0, aXplaces, 0, 1, 0, 1, aXplaces, 1, 1,	0, 0, 0, 0, 0, 0);
				break;
			//ex.resultLogicType>=2		zero cross anti-aliasing
			case 2://=		equation
			case 3://!=		anti-equation
				{
					int Xplaces1=Xplaces+1, Xplaces2=Xplaces+2;
					ex.discontinuities.assign(Xplaces2, false);
					unsigned ndrSize=aXplaces;

					::solve_disc(ex, 0, 0, aXplaces, 0, 1, 0, 1, aXplaces, 1, 1,	disc_1d_in_u, disc_1d_in_b, disc_1d_in_t, disc_1d_out,		0, true);//
				//	::solve_disc(ex, 0, 0, aXplaces, 0, 1, 0, 1, aXplaces, 1, 1,	0, 0, 0, 0,		0, true);//
					subtract_NDRs(ex, 0, aXplaces, 0, 1, aXplaces, 1);
				//	auto &n_res=ex.n[ex.resultTerm];//
				//	int ndrSize=n_res.r.size()<<1;
				//	auto ndr_r=(double*)n_res.r.p, ndr_i=(double*)n_res.i.p, ndr_j=(double*)n_res.j.p, ndr_k=(double*)n_res.k.p;
					solve_zerocross_1d(ex, 0, ndrSize);
				}
				break;
			}
		}
	private:
		void shift_		(double *ndr, int *a, int)
		{
			int XSstart=a[0], XSend=a[1], XDstart=a[2];
			std::copy(ndr+XSstart, ndr+XSend, ndr+XDstart);
		}
		void shift_r	(double *ndr, int *a, int aXplaces)
		{
			int XSstart=a[0], XSend=a[1], XDstart=a[2];
			auto rb=std::reverse_iterator<double*>(ndr+aXplaces);
			std::copy(rb+aXplaces-1-XSstart, rb+aXplaces-1-XSend, rb+aXplaces-1-XDstart);
		//	auto rb=rbegin(ndr, aXplaces);
		//	std::copy(rb+aXplaces-1-XSstart, rb+aXplaces-1-XSend, rb+aXplaces-1-XDstart);
		}
		typedef void (modes::Solve_1D_Implicit::*Shift_fn)(double*, int*, int);

		Shift_fn shift;
	public:
		void partial_bounds(int Xoffset)
		{
			Xstart_s=xs.Xstart, Xstart=Xstart_s+Xsample;
			//Xsample=DX/Xplaces;
			//Xstart_s=VX-DX/2, Xstart=Xstart_s+Xsample;
			int Xoffset2=setXplaces(std::abs(Xoffset)+2);
		//	int Xoffset2=std::abs(Xoffset)+(1<<simd_method);
		//	int Xplaces2=Xplaces+(1<<simd_method);
			//int Xoffset2=std::abs(Xoffset)+2;
			int Xplaces2=setXplaces(w+2);
		//	int Xplaces2=Xplaces+2;
		//	this->Xstart=VX-DX/2, this->Xsample=DX/Xplaces;
				 if(Xoffset>0)					shift=(Shift_fn)&Solve_1D_Implicit::shift_,		sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,				ra[0]=Xplaces-Xoffset2,		ra[1]=Xplaces,
																								sa[3]=Xoffset,				sa[4]=Xplaces2,	sa[5]=0,				ra[2]=Xplaces2-Xoffset2,	ra[3]=Xplaces2;
			else if(Xoffset<0)Xoffset=-Xoffset,	shift=(Shift_fn)&Solve_1D_Implicit::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,		ra[0]=0,					ra[1]=Xoffset2,
																								sa[3]=Xplaces2-1-Xoffset,	sa[4]=-1,		sa[5]=Xplaces2-1,		ra[2]=0,					ra[3]=Xoffset2;
			//auto &n=expr[0].n[expr[0].resultTerm];
			//if(ra[0]&3||ra[2]&3)
			//	int LOL_2=0;
			//if((int)&n.r[ra[0]]&31||(int)&n.r[ra[2]]&31)
			//	int LOL_1=0;
		//		 if(Xoffset>0)					shift=&Solve_1D_Implicit::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,				ra[0]=Xplaces-Xoffset-1,	ra[1]=Xplaces;
		//	else if(Xoffset<0)Xoffset=-Xoffset,	shift=&Solve_1D_Implicit::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,		ra[0]=0,					ra[1]=Xoffset+1;
		}
		void partial(Expression &ex)
		{
			int saOffset, aXplaces;
			int x1, x2;
			double overlap[2];//because value ndr size = logic ndr size + 2
			{
				auto ndr=(double*)ex.n[ex.resultTerm].r.p;
				if(ex.resultLogicType==1)
					saOffset=0, aXplaces=Xplaces,	x1=ra[0], x2=ra[1];
				else
				{
					saOffset=3, aXplaces=Xplaces+2,	x1=ra[2], x2=ra[3];
					if(x1==0)
						overlap[0]=ndr[0], overlap[1]=ndr[1];
				}
				(this->*shift)(ndr, sa+saOffset, aXplaces);
			}

		//	auto &ndr0=ex.n[0].ndr;
		//	(this->*shift)(ndr0);
		//	int x1=ra[0], x2=ra[1]+(ex.resultLogicType>=2);

		//	double transient;
		//	if(ex.resultLogicType>=2&&x2!=ndr0.size())//= != equation, ndr.size()=Xplaces+1, shift right: {Xplaces-1-Xoffset, -1, Xplaces-1}, solve left: {0, Xoffset}
		//		transient=ndr0[x2-1];
			
			modes::Xstart=*aXstart, modes::Xsample=Xsample, modes::T=T;
			modes::Xplaces=aXplaces, modes::Yplaces=1, modes::Zplaces=1, modes::ndrSize=aXplaces;
			fill_range(ex, choose_fill_fn, 0, x1, x2, 0, 1, 0, 1, aXplaces, 1, 1, aXplaces, false, false, false);
			switch(ex.resultLogicType)
			{
			case 1://&& ## || < <= > >=
				solve_disc(ex, 0, x1, x2, 0, 1, 0, 1, Xplaces, 1, 1,	0, 0, 0, 0, 0, false);
				break;
			//ex.resultLogicType>=2		anti-aliasing
			case 2://=
			case 3://!=
				{
					int Xplaces1=Xplaces+1, Xplaces2=Xplaces+2;
					for(int x=x1, xEnd=x2-1;x<xEnd;++x)
						ex.discontinuities[x]=false;

					unsigned ndrSize=aXplaces;
					solve_disc(ex, 0, x1, x2, 0, 1, 0, 1, Xplaces, 1, 1,	disc_1d_in_u, disc_1d_in_b, disc_1d_in_t, disc_1d_out, 0, true);//
					subtract_NDRs(ex, x1, x2, 0, 1, Xplaces, 1);
					auto ndr_r=(double*)ex.n[ex.resultTerm].r.p;
					solve_zerocross_1d(ex, x1, x2);
					if(x1==0)
						ndr_r[x2-2]=overlap[0], ndr_r[x2-1]=overlap[1];
				}
				break;
			}
		}
	};
	class		Solve_1D:public Solve//t1d, t1d_c, t1d_h
	{
	public:
		Scale &xs;
		int Xplaces;//always divisible by 4, unlike in xs
		bool enable_disc;
		Disc_fn disc_in_u, disc_in_b, disc_in_t, disc_out;
		Solve_1D(bool enable_disc, Scale &xs):enable_disc(enable_disc),// xlogscale(false),
			disc_in_u(enable_disc?disc_1d_in_u:0), disc_in_b(enable_disc?disc_1d_in_b:0), disc_in_t(enable_disc?disc_1d_in_t:0), disc_out(enable_disc?disc_1d_out:0),
			xs(xs)
		{}
	private:
		int sa[3], ra[2];//sa: XSrcStart, XSrcEnd, XDestStart		ra: x1 x2
	public:
		void full_resize(int Xplaces)
		{
			this->Xplaces=setXplaces(Xplaces);
		}
		void full(Expression &ex)
		{
			modes::Xstart=xs.Xstart, modes::Xsample=xs.Xsample;
			modes::T=T;
			modes::Xplaces=Xplaces, modes::Yplaces=1, modes::Zplaces=1, modes::ndrSize=Xplaces;
			resize_terms(ex, Xplaces);
			fill_range(ex, choose_fill_fn, 0, 0, Xplaces, 0, 1, 0, 1, Xplaces, 1, 1, Xplaces, xs.logscale, false, false);
		//	ndr_to_clipboard_1d(ex, Xplaces);//

			if(enable_disc)
				ex.discontinuities.assign(Xplaces-1, false);
			::solve_disc(ex, 0, 0, Xplaces, 0, 1, 0, 1, Xplaces, 1, 1,		disc_in_u, disc_in_b, disc_in_t, disc_out, 0, false);//
		//	ndr_to_clipboard_1d(ex, Xplaces);//
		}
	private:
		void shift_		(double *ndr, std::vector<bool> &discontinuities)
		{
			int &XSstart=sa[0], &XSend=sa[1], &XDstart=sa[2];
			std::copy(ndr+XSstart, ndr+XSend, ndr+XDstart);
			if(enable_disc&&XSstart<Xplaces-1)
			{
				auto begin=discontinuities.begin();
				std::copy(begin+XSstart, begin+XSend-1, begin+XDstart);
			}
		}
		void shift_r	(double *ndr, std::vector<bool> &discontinuities)
		{
			int XSstart=sa[0], XSend=sa[1], XDstart=sa[2];
			{
				auto rb=std::reverse_iterator<double*>(ndr+Xplaces);
				std::copy(rb+Xplaces-1-XSstart, rb+Xplaces-1-XSend, rb+Xplaces-1-XDstart);
			}
			if(enable_disc&&XSstart>0)
			{
				auto rbegin=discontinuities.rbegin();
				std::copy(rbegin+Xplaces-2-(XSstart-1), rbegin+Xplaces-2-XSend, rbegin+Xplaces-2-(XDstart-1));
			}
		}
		typedef void(modes::Solve_1D::*Shift_fn)(double*, std::vector<bool>&);
		Shift_fn shift;
	public:
		void partial_bounds	(int Xoffset)
		{
		//	this->Xstart=VX-DX/2, this->Xsample=DX/Xplaces;
			int Xoffset2=setXplaces(std::abs(Xoffset));
		//	int Xoffset2=Xoffset+(1<<simd_method);
		//	int Xoffset2=Xoffset+1;
				 if(Xoffset>0)					shift=(Shift_fn)&Solve_1D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			ra[0]=Xplaces-Xoffset2,	ra[1]=Xplaces;
			else if(Xoffset<0)Xoffset=-Xoffset,	shift=(Shift_fn)&Solve_1D::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	ra[0]=0,				ra[1]=Xoffset2;
		}
		void partial(Expression &ex)
		{
			auto &n=ex.n[ex.resultTerm];
			(this->*shift)(n.r.p, ex.discontinuities);
			if(n.mathSet>='c')
			{
				(this->*shift)(n.i.p, ex.discontinuities);
				if(n.mathSet=='h')
				{
					(this->*shift)(n.j.p, ex.discontinuities);
					(this->*shift)(n.k.p, ex.discontinuities);
				}
			}
			int x1=ra[0], x2=ra[1];
			modes::Xstart=xs.Xstart, modes::Xsample=xs.Xsample;
			modes::T=T;
			modes::Xplaces=Xplaces, modes::Yplaces=1, modes::Zplaces=1, modes::ndrSize=Xplaces;
			fill_range(ex, choose_fill_fn, 0, x1, x2, 0, 1, 0, 1, Xplaces, 1, 1, Xplaces, xs.logscale, false, false);
			if(enable_disc)
			{
			//	std::fill(ex.discontinuities.begin()+x1, ex.discontinuities.begin()+x2-1, false);
				for(int v=x1;v<x2-1;++v)
					ex.discontinuities[v]=false;
			}
			::solve_disc(ex, 0, x1, x2, 0, 1, 0, 1, Xplaces, 1, 1,		disc_in_u, disc_in_b, disc_in_t, disc_out, 0, false);//
		//	::solve_disc(ex, 0, x1, x2, 0, 1, 0, 1, Xplaces, 1, 1,		0, 0, 0, 0, 0, false);//
		}
	};
	double exColorRA, exColorRB, exColorGA, exColorGB, exColorBA, exColorBB;
	void DimDIBPixelUnchecked_mono				(int **prgb, int x, int y, double a)
	{
	//	auto p=(unsigned char*)&prgb[0][(y-1)*w+x-1];
		auto p=(unsigned char*)&(*prgb)[(y-1)*w+x-1];
		p[0]=(unsigned char)(p[0]*a), p[1]=(unsigned char)(p[1]*a), p[2]=(unsigned char)(p[2]*a);
	}
	void DimDIBPixelUnchecked_mono_complement	(int **prgb, int x, int y, double a)
	{
		auto p=(unsigned char*)&(*prgb)[(y-1)*w+x-1];
		p[0]-=(unsigned char)(a*p[0])/2, p[1]-=(unsigned char)(a*p[1])/2, p[2]-=(unsigned char)(a*p[2])/2;
	}
	void DimDIBPixelUnchecked_color				(int **prgb, int x, int y, double a)
	{
		auto p=(unsigned char*)&(*prgb)[(y-1)*w+x-1];
			
	//	p[0]=(unsigned char(exColorBA*a)+exColorBB)*p[0]>>8;
	//	p[1]=(unsigned char(exColorGA*a)+exColorGB)*p[1]>>8;
	//	p[2]=(unsigned char(exColorRA*a)+exColorRB)*p[2]>>8;
		p[0]=(unsigned char)((exColorBA*a+exColorBB)*p[0]);
		p[1]=(unsigned char)((exColorGA*a+exColorGB)*p[1]);
		p[2]=(unsigned char)((exColorRA*a+exColorRB)*p[2]);
	}
	void DimDIBPixelUnchecked_color_complement	(int **prgb, int x, int y, double a)
	{
		a=1-a;
		auto p=(unsigned char*)&(*prgb)[(y-1)*w+x-1];
			
	//	p[0]=(unsigned char(exColorBA*a)+exColorBB)*p[0]>>8;
	//	p[1]=(unsigned char(exColorGA*a)+exColorGB)*p[1]>>8;
	//	p[2]=(unsigned char(exColorRA*a)+exColorRB)*p[2]>>8;
		p[0]=(unsigned char)((exColorBA*a+exColorBB)*p[0]);
		p[1]=(unsigned char)((exColorGA*a+exColorGB)*p[1]);
		p[2]=(unsigned char)((exColorRA*a+exColorRB)*p[2]);
	}
	void solve_zerocross_2d(Expression &ex, int **prgb, int x1, int x2, int y1, int y2, int Xplaces, int Yplaces)//inflated_range
	{
		switch(ex.resultLogicType)
		{
		case 1://logic/inequality	just evaluate
			{
				auto ndr=(double*)ex.n[ex.resultTerm].r.p;
				double A0, A1, A2;
				if(nExpr[11]==1)
					A0=A1=A2=.5;
				else
				{
					auto pp=(unsigned char*)&ex.getColor();
					A0=(0xFF-pp[0])/510., A1=(0xFF-pp[1])/510., A2=(0xFF-pp[2])/510.;
				//	A0=.5-pp[0]/510., A1=.5-pp[1]/510., A2=.5-pp[2]/510.;
				}
				for(int y=y1;y<y2;++y)
				{
					for(int p=w*y+x1, pn=Xplaces*y+x1, pEnd=w*y+x2;p<pEnd;++p, ++pn)
					{
						auto pp=(unsigned char*)&(*prgb)[p];
						auto &a=ndr[pn];
						pp[0]-=(unsigned char)(A0*a*pp[0]);
						pp[1]-=(unsigned char)(A1*a*pp[1]);
						pp[2]-=(unsigned char)(A2*a*pp[2]);//warning C4244
					}
				}
			}
			break;
		//ex.resultLogicType>=2		zero cross curve, anti-aliasing
		case 2:
			//zero cross	_/\_		= equation
		case 3:
			//				_  _
			//zero cross	 \/			!= anti-equation?
			{
				int Xplaces1=Xplaces+1, Yplaces1=Yplaces+1,
					Xplaces2=Xplaces+2, Yplaces2=Yplaces+2;
				unsigned yDiscOffset=Xplaces1*Yplaces2;
				switch(ex.resultMathSet)
				{
				case 'R':
					if(x2-x1>=3&&y2-y1>=3)//redundant check		Xoffset>0||Yoffset>0	x2-x1>2&&y2-y1>2
					{
						int x11=x1+1, y11=y1+1, x2_1=x2-1, y2_1=y2-1;
						auto ndr=(double*)ex.n[ex.resultTerm].r.p;

						const double aa_thickness=1,//
				
							_1_aa_thickness=1/aa_thickness;
						const int aa_bound=int(std::round(aa_thickness));

						//crossings
						int XCsize=Xplaces1*Yplaces2, YCsize=Xplaces2*Yplaces1,
							Xplaces3=Xplaces2+aa_bound;
						std::vector<double>
							Xcross(XCsize, -1),//._
							Ycross(YCsize, -1);//!
						std::vector<bool> shade(Xplaces3*(Yplaces2+aa_bound));
						{
							// _	top left
							//|_!
							auto&v00=ndr[Xplaces2*y1	+x1], &v01=ndr[Xplaces2*y1	+x11],
								&v10=ndr[Xplaces2*y11	+x1], &v11=ndr[Xplaces2*y11	+x11];
							BITREF corner=shade[Xplaces3*y11+x11];
							if(std::signbit(v00)!=std::signbit(v01)&&!ex.discontinuities[				Xplaces1*y1	+x1])
								corner=true, Xcross[Xplaces1*y1		+x1]=(0-v00)/(v01-v00);
							if(std::signbit(v10)!=std::signbit(v11)&&!ex.discontinuities[				Xplaces1*y11+x1])
								corner=true, Xcross[Xplaces1*y11	+x1]=(0-v10)/(v11-v10);
							if(std::signbit(v00)!=std::signbit(v10)&&!ex.discontinuities[yDiscOffset+	Xplaces2*y1	+x1])
								corner=true, Ycross[Xplaces2*y1		+x1]=(0-v00)/(v10-v00);
							if(std::signbit(v01)!=std::signbit(v11)&&!ex.discontinuities[yDiscOffset+	Xplaces2*y1+x11])
								corner=true, Ycross[Xplaces2*y1		+x11]=(0-v01)/(v11-v01);
							if(v11==0)
								corner=true, Xcross[Xplaces1*y11	+x1]=Ycross[Xplaces2*y1		+x11]=0.5;
						}
						{
							// _	top right
							//._|
							auto&v00=ndr[Xplaces2*y1	+x2_1-1], &v01=ndr[Xplaces2*y1	+x2_1],
								&v10=ndr[Xplaces2*y11	+x2_1-1], &v11=ndr[Xplaces2*y11	+x2_1];
							BITREF corner=shade[Xplaces3*y11+x2_1-1];
							if(std::signbit(v00)!=std::signbit(v01)&&!ex.discontinuities[				Xplaces1*y1		+x2_1-1])
								corner=true, Xcross[Xplaces1*y1		+x2_1-1]=(0-v00)/(v01-v00);
							if(std::signbit(v10)!=std::signbit(v11)&&!ex.discontinuities[				Xplaces1*y11	+x2_1-1])
								corner=true, Xcross[Xplaces1*y11	+x2_1-1]=(0-v10)/(v11-v10);
							if(std::signbit(v01)!=std::signbit(v11)&&!ex.discontinuities[yDiscOffset+	Xplaces2*y11	+x2_1])
								corner=true, Ycross[Xplaces2*y11	+x2_1]=(0-v01)/(v11-v01);
							if(v10==0)
								corner=true, Xcross[Xplaces1*y11	+x2_1-1]=Ycross[Xplaces2*y11	+x2_1]=0.5;
						}
						{
							//  .	bottom left
							//|_|
							auto&v00=ndr[Xplaces2*(y2_1-1)	+x1], &v01=ndr[Xplaces2*(y2_1-1)+x11],
								&v10=ndr[Xplaces2* y2_1		+x1], &v11=ndr[Xplaces2* y2_1	+x11];
							BITREF corner=shade[Xplaces3*(y2_1-1)+x11];
							if(std::signbit(v10)!=std::signbit(v11)&&!ex.discontinuities[				Xplaces1* y2_1		+x1])
								corner=true, Xcross[Xplaces1*y2_1		+x1]=(0-v10)/(v11-v10);
							if(std::signbit(v00)!=std::signbit(v10)&&!ex.discontinuities[yDiscOffset+	Xplaces2*(y2_1-1)	+x1])
								corner=true, Ycross[Xplaces2*(y2_1-1)	+x1]=(0-v00)/(v10-v00);
							if(std::signbit(v01)!=std::signbit(v11)&&!ex.discontinuities[yDiscOffset+	Xplaces2*(y2_1-1)	+x11])
								corner=true, Ycross[Xplaces2*(y2_1-1)	+x11]=(0-v01)/(v11-v01);
							if(v01==0)
								corner=true, Ycross[Xplaces2*(y2_1-1)	+x11]=0.5;
						}
						for(int x=x11, xEnd=x2_1-1;x<xEnd;++x)
						{
							// _	upper row
							//._!
							auto&v00=ndr[Xplaces2*y1	+x], &v01=ndr[Xplaces2*y1	+x+1],
								&v10=ndr[Xplaces2*y11	+x], &v11=ndr[Xplaces2*y11	+x+1];
							BITREF p0=shade[Xplaces3*y11+x];
							BITREF p1=shade[Xplaces3*y11+x+1];
							if(std::signbit(v00)!=std::signbit(v01)&&!ex.discontinuities[				Xplaces1*y1		+x])
								p0=p1=true, Xcross[Xplaces1*y1	+x]=(0-v00)/(v01-v00);
							if(std::signbit(v10)!=std::signbit(v11)&&!ex.discontinuities[				Xplaces1*y11	+x])
								p0=p1=true, Xcross[Xplaces1*y11	+x]=(0-v10)/(v11-v10);
							if(std::signbit(v01)!=std::signbit(v11)&&!ex.discontinuities[yDiscOffset+	Xplaces2*y1		+x+1])
								p0=p1=true, Ycross[Xplaces2*y1	+x+1]=(0-v01)/(v11-v01);
							if(v10==0)
								p0=true, Xcross[Xplaces1*y11	+x]=0.5;
							if(v11==0)
								p1=true, Xcross[Xplaces1*y11	+x]=0.5;
						}
						for(int y=y11, yEnd=y2_1-1;y<yEnd;++y)
						{
							//  .	left column
							//|_!
							auto&v00=ndr[Xplaces2* y   +x1], &v01=ndr[Xplaces2* y   +x11],
								&v10=ndr[Xplaces2*(y+1)+x1], &v11=ndr[Xplaces2*(y+1)+x11];
							BITREF p0=shade[Xplaces3* y   +x11];
							BITREF p1=shade[Xplaces3*(y+1)+x11];
							if(std::signbit(v10)!=std::signbit(v11)&&!ex.discontinuities[				Xplaces1*(y+1)	+x1])
								p0=p1=true, Xcross[Xplaces1*(y+1)	+x1]=(0-v10)/(v11-v10);
							if(std::signbit(v00)!=std::signbit(v10)&&!ex.discontinuities[yDiscOffset	+Xplaces2*y		+x1])
								p0=p1=true, Ycross[Xplaces2*y	+x1]=(0-v00)/(v10-v00);
							if(std::signbit(v01)!=std::signbit(v11)&&!ex.discontinuities[yDiscOffset	+Xplaces2*y		+x11])
								p0=p1=true, Ycross[Xplaces2*y	+x11]=(0-v01)/(v11-v01);
							if(v01==0)
								p0=true, Ycross[Xplaces2*y	+x11]=0.5;
							if(v11==0)
								p1=true, Ycross[Xplaces2*y	+x11]=0.5;
						}
			
						auto aa_straight=[&](double d){return d>aa_thickness?1:d*_1_aa_thickness;};
						auto aa_close=[&](double x, double y)->double//	!_
						{
							double d=x*y*inv_sqrt(x*x+y*y);
						//	double d=std::abs(x*y)*inv_sqrt(x*x+y*y);
							return d>aa_thickness?1:d*_1_aa_thickness;
						};
						auto aa_middle=[&](double a, double b)->double//	|. |
						{
							double b_a=b-a, d=a*inv_sqrt(1+b_a*b_a);
							return d>aa_thickness?1:d*_1_aa_thickness;
						};
						auto aa_far=[&](double x, double y)->double//	.7
						{
							if(x==1.||y==1.)
								return 1.;
							double x_1=x-1, y_1=y-1;
							double d=std::abs(x*y-1)*inv_sqrt(x_1*x_1+y_1*y_1);
							return d>aa_thickness?1:d*_1_aa_thickness;
						};

						//{
						//	auto p=(unsigned char*)&ex.color;
						//	exColorBA=1-p[0], exColorBB=p[0];
						//	exColorGA=1-p[1], exColorGB=p[1];
						//	exColorRA=1-p[2], exColorRB=p[2];
						//}
						{
							auto p=(unsigned char*)&ex.getColor();
							double a=p[0]/255.;
							exColorBA=1-a, exColorBB=a;
							a=p[1]/255.;
							exColorGA=1-a, exColorGB=a;
							a=p[2]/255.;
							exColorRA=1-a, exColorRB=a;
						}
						auto DimDIBPixelUnchecked=ex.resultLogicType==2?
								nExpr[11]==1?&DimDIBPixelUnchecked_mono				:&DimDIBPixelUnchecked_color
							:	nExpr[11]==1?&DimDIBPixelUnchecked_mono_complement	:&DimDIBPixelUnchecked_color_complement;
						double d=0, d_min=0;
						for(int y=y1+aa_bound, yEnd=y2_1;y<yEnd;++y)
						{
						//	for(int x=x1+aa_bound, xEnd=minimum(x2_1, w+1);x<xEnd;++x)
							for(int x=x1+aa_bound, xEnd=x2_1;x<xEnd;++x)
							{
							//	double a=.5+.5*tanh(ndr[Xplaces2*y+x]);
							////	auto a=.5+.5*tanh(Xcross[Xplaces1*y+x]);
							////	auto a=.5+.5*tanh(Ycross[Xplaces2*y+x]);
							////	auto a=shade[sp];
							//	auto p=(unsigned char*)&(*prgb)[w*(y-1)+x-1];
							////	p[0]=p[1]=p[2]=0xFF*a;
							//	p[0]*=a, p[1]*=a, p[2]*=a;

								int ndrP=Xplaces2*y+x;
								int sp=Xplaces3*y+x;
								{
									auto							&v01=ndr[ndrP			+1],
										&v10=ndr[ndrP+Xplaces2],	&v11=ndr[ndrP+Xplaces2	+1];
									//auto&v00=ndr[ndrP			],	&v01=ndr[ndrP			+1],
									//	&v10=ndr[ndrP+Xplaces2	],	&v11=ndr[ndrP+Xplaces2	+1];
									//if(v00==0)
									//{
									//	Xcross[Xplaces1*(y+1)+x]=0;
									//	shade[sp]=true;
									//}
									if(v10==0)
									{
										Xcross[Xplaces1*(y+1)+x]=0.5;
										shade[sp			]=true, shade[sp			+1]=true;
										shade[sp+Xplaces3	]=true, shade[sp+Xplaces3	+1]=true;
										shade[sp+Xplaces3*2	]=true, shade[sp+Xplaces3*2	+1]=true;
									}
								//	if(v10==0||std::signbit(v10)!=std::signbit(v11)&&!ex.discontinuities[Xplaces1*(y+1)+x])
									else if(std::signbit(v10)!=std::signbit(v11)&&!ex.discontinuities[Xplaces1*(y+1)+x])
									{
										Xcross[Xplaces1*(y+1)+x]=(0-v10)/(v11-v10);
										shade[sp			]=true, shade[sp			+1]=true;
										shade[sp+Xplaces3	]=true, shade[sp+Xplaces3	+1]=true;
										shade[sp+Xplaces3*2	]=true, shade[sp+Xplaces3*2	+1]=true;
									}
									if(v01==0)
									{
										Ycross[ndrP+1]=0.5;
										shade[sp			]=true, shade[sp			+1]=true, shade[sp			+2]=true;
										shade[sp+Xplaces3	]=true, shade[sp+Xplaces3	+1]=true, shade[sp+Xplaces3	+2]=true;
									}
								//	if(v01==0||std::signbit(v01)!=std::signbit(v11)&&!ex.discontinuities[yDiscOffset+ndrP+1])
									else if(std::signbit(v01)!=std::signbit(v11)&&!ex.discontinuities[yDiscOffset+ndrP+1])
									{
										Ycross[ndrP+1]=(0-v01)/(v11-v01);
										shade[sp			]=true, shade[sp			+1]=true, shade[sp			+2]=true;
										shade[sp+Xplaces3	]=true, shade[sp+Xplaces3	+1]=true, shade[sp+Xplaces3	+2]=true;
									}
								}
								if(shade[sp])
								{
									//	 	Dx
									//	Lx	+	Rx
									//		Ux  '
									auto		&Dx=Ycross[Xplaces2*(y-1)+x],
										&Lx=Xcross[Xplaces1*y+x-1],		&Rx=Xcross[Xplaces1*y+x],
												&Ux=Ycross[Xplaces2* y   +x];
									if(Ux!=-1)
									{
										if(Dx!=-1)
										{
											if(Lx!=-1)
											{
												if(Rx!=-1)	//udlr	>=2 lines	\+\	/+/
												{
													d_min=aa_close(Rx, Ux);
													if(d_min>(d=aa_close(Rx, 1-Dx)))
														d_min=d;
													if(d_min>(d=aa_close(1-Lx, 1-Dx)))
														d_min=d;
													if(d_min>(d=aa_close(1-Lx, Ux)))
														d_min=d;
													(*DimDIBPixelUnchecked)(prgb, x, y, d_min);
												}
												else		//udl	>=2 lines	<+
												{
													d_min=aa_close(1-Lx, 1-Dx);
													if(d_min>(d=aa_close(1-Lx, Ux)))
														d_min=d;
													(*DimDIBPixelUnchecked)(prgb, x, y, d_min);
												}
											}
											else
											{
												if(Rx!=-1)	//ud r	>=2 lines	+>
												{
													d_min=aa_close(Rx, Ux);
													if(d_min>(d=aa_close(Rx, 1-Dx)))
														d_min=d;
													(*DimDIBPixelUnchecked)(prgb, x, y, d_min);
												}
												else		//ud				_F_
												{
													d_min=Ux;
													if(d_min>(d=1-Dx))
														d_min=d;
													(*DimDIBPixelUnchecked)(prgb, x, y, d_min);
												}
											}
										}
										else
										{
											if(Lx!=-1)
											{
												if(Rx!=-1)	//u lr	>=2 lines	\+/
												{
													d_min=aa_close(Rx, 1-Dx);
													if(d_min>(d=aa_close(1-Lx, 1-Dx)))
														d_min=d;
													(*DimDIBPixelUnchecked)(prgb, x, y, d_min);
												}
												else		//u l	>=1 line	\+
													(*DimDIBPixelUnchecked)(prgb, x, y, aa_close(1-Lx, Ux));
											}
											else
											{
												if(Rx!=-1)	//u  r	>=1 line	+/
													(*DimDIBPixelUnchecked)(prgb, x, y, aa_close(Rx, Ux));
												else		//u		>=1 line	_+_
												{
													auto &LUx=Ycross[Xplaces2* y   +x-1], &RUx=Ycross[Xplaces2* y   +x+1];
													d_min=Ux;
													if(LUx!=-1&&LUx<Ux&&d_min>(d=aa_middle(Ux, LUx)))
														d_min=d;
													if(RUx!=-1&&RUx<Ux&&d_min>(d=aa_middle(Ux, RUx)))
														d_min=d;
													(*DimDIBPixelUnchecked)(prgb, x, y, d_min);
												}
											}
										}
									}
									else
									{
										if(Dx!=-1)
										{
											if(Lx!=-1)
											{
												if(Rx!=-1)	// dlr	>=2 lines	/+\ 	backslash can extend line comment
												{
													d_min=aa_close(Rx, Ux);
													if(d_min>(d=aa_close(1-Lx, Ux)))
														d_min=d;
													(*DimDIBPixelUnchecked)(prgb, x, y, d_min);
												}
												else		// dl	>=1 line	/+
													(*DimDIBPixelUnchecked)(prgb, x, y, aa_close(1-Lx, 1-Dx));
											}
											else
											{
												if(Rx!=-1)	// d r	>=1 line	+\ 		backslash can extend line comment
													(DimDIBPixelUnchecked)(prgb, x, y, aa_close(Rx, 1-Dx));
												else		// d	>=1 line	F
												{
													auto &LDx=Ycross[Xplaces2*(y-1)+x-1], &RDx=Ycross[Xplaces2*(y-1)+x+1];
													d_min=1-Dx;
													if(LDx!=-1&&LDx>Dx&&d_min>(d=aa_middle(1-Dx, 1-LDx)))
														d_min=d;
													if(RDx!=-1&&RDx>Dx&&d_min>(d=aa_middle(1-Dx, 1-RDx)))
														d_min=d;
													(*DimDIBPixelUnchecked)(prgb, x, y, d_min);
												}
											}
										}
										else
										{
											if(Lx!=-1)
											{
												if(Rx!=-1)	//  lr	>=1 line	|+|		//>=1 line	[-]
												{
													d_min=Rx;
													if(d_min>(d=1-Lx))
														d_min=d;
													(*DimDIBPixelUnchecked)(prgb, x, y, d_min);
												}
												else		//  l	>=1 line	|+
												{
													auto &DLx=Xcross[Xplaces1*(y-1)+x-1], &ULx=Xcross[Xplaces1*(y+1)+x-1];
													d_min=1-Lx;
													if(DLx!=-1&&DLx>Lx&&d_min>(d=aa_middle(1-Lx, 1-DLx)))
														d_min=d;
													if(ULx!=-1&&ULx>Lx&&d_min>(d=aa_middle(1-Lx, 1-ULx)))
														d_min=d;
													(*DimDIBPixelUnchecked)(prgb, x, y, d_min);
												}
											}
											else
											{
												if(Rx!=-1)	//   r	>=1 line	+|
												{
													auto &DRx=Xcross[Xplaces1*(y-1)+x  ], &URx=Xcross[Xplaces1*(y+1)+x  ];
													d_min=Rx;
													if(DRx!=-1&&DRx<Rx&&d_min>(d=aa_middle(Rx, DRx)))
														d_min=d;
													if(URx!=-1&&URx<Rx&&d_min>(d=aa_middle(Rx, URx)))
														d_min=d;
													(*DimDIBPixelUnchecked)(prgb, x, y, d_min);
												}
												else		//		>=0 lines
												{
													auto
														&DLx=Xcross[Xplaces1*(y-1)+x-1],	&LDx=Ycross[Xplaces2*(y-1)+x-1],//	 _    _
														&DRx=Xcross[Xplaces1*(y-1)+x  ],	&RDx=Ycross[Xplaces2*(y-1)+x+1],//	| 1  2 | D
														&ULx=Xcross[Xplaces1*(y+1)+x-1],	&LUx=Ycross[Xplaces2* y   +x-1],//	    .
														&URx=Xcross[Xplaces1*(y+1)+x  ],	&RUx=Ycross[Xplaces2* y   +x+1];//	|_3  4_| U
													d_min=_HUGE;
													if(DLx!=-1&&LDx!=-1&&d_min>(d=aa_far(1-DLx, 1-LDx)))//1
														d_min=d;
													if(DRx!=-1&&RDx!=-1&&d_min>(d=aa_far(  DRx, 1-RDx)))//2
														d_min=d;
													if(ULx!=-1&&LUx!=-1&&d_min>(d=aa_far(1-ULx,   LUx)))//3
														d_min=d;
													if(URx!=-1&&RUx!=-1&&d_min>(d=aa_far(  URx,   RUx)))//4
														d_min=d;
													if(d_min!=_HUGE)
														(*DimDIBPixelUnchecked)(prgb, x, y, d_min>aa_thickness?1:d_min*_1_aa_thickness);
												}
											}
										}
									}
								}
								else
									(*DimDIBPixelUnchecked)(prgb, x, y, 1);//*/
							}
						}
					}
					break;
				case 'c':
					break;
				case 'h':
					break;
				}
				break;
			}
		}
	//	bitmap_to_clipboard(*prgb, w, h);//
	}
	class		Solve_2D_Implicit:public Solve
	{
	public:
		Bitmap bitmap;
	//	HBITMAP hBitmap;
		int //*rgb,
			**prgb;
		Scale &xs, &ys;
		Solve_2D_Implicit(Scale &xs, Scale &ys):xs(xs), ys(ys){}
	//	Solve_2D_Implicit(Scale &xs, Scale &ys):rgb(0), xs(xs), ys(ys){}
		double
			Xsample, Xstart, Xstart_s, *aXstart,
			Ysample, Yend, Yend_s, *aYend;
		int ndrSize, Xplaces, Yplaces;
	private:
		int sa[12],//shift arguments: XSrcStart XSrcEnd XDstStart YSrcStart YSrcEnd YDstStart		x resultLogicType{1, 2/3}
			ra[16];//range arguments: x1 x2 y1 y2	up to 2 rectangles		x resultLogicType{1, 2/3}
	//	unsigned char exColorRA, exColorRB, exColorGA, exColorGB, exColorBA, exColorBB;
		double exColorRA, exColorRB, exColorGA, exColorGB, exColorBA, exColorBB;
	/*	void DimDIBPixelUnchecked_mono				(int x, int y, double a)
		{
		//	auto p=(unsigned char*)&prgb[0][(y-1)*w+x-1];
			auto p=(unsigned char*)&(*prgb)[(y-1)*w+x-1];
			p[0]=(unsigned char)(p[0]*a), p[1]=(unsigned char)(p[1]*a), p[2]=(unsigned char)(p[2]*a);
		}
		void DimDIBPixelUnchecked_mono_complement	(int x, int y, double a)
		{
			auto p=(unsigned char*)&(*prgb)[(y-1)*w+x-1];
			p[0]-=(unsigned char)(a*p[0])/2, p[1]-=(unsigned char)(a*p[1])/2, p[2]-=(unsigned char)(a*p[2])/2;
		}
		void DimDIBPixelUnchecked_color				(int x, int y, double a)
		{
			auto p=(unsigned char*)&(*prgb)[(y-1)*w+x-1];
			
		//	p[0]=(unsigned char(exColorBA*a)+exColorBB)*p[0]>>8;
		//	p[1]=(unsigned char(exColorGA*a)+exColorGB)*p[1]>>8;
		//	p[2]=(unsigned char(exColorRA*a)+exColorRB)*p[2]>>8;
			p[0]=(unsigned char)((exColorBA*a+exColorBB)*p[0]);
			p[1]=(unsigned char)((exColorGA*a+exColorGB)*p[1]);
			p[2]=(unsigned char)((exColorRA*a+exColorRB)*p[2]);
		}
		void DimDIBPixelUnchecked_color_complement	(int x, int y, double a)
		{
			a=1-a;
			auto p=(unsigned char*)&(*prgb)[(y-1)*w+x-1];
			
		//	p[0]=(unsigned char(exColorBA*a)+exColorBB)*p[0]>>8;
		//	p[1]=(unsigned char(exColorGA*a)+exColorGB)*p[1]>>8;
		//	p[2]=(unsigned char(exColorRA*a)+exColorRB)*p[2]>>8;
			p[0]=(unsigned char)((exColorBA*a+exColorBB)*p[0]);
			p[1]=(unsigned char)((exColorGA*a+exColorGB)*p[1]);
			p[2]=(unsigned char)((exColorRA*a+exColorRB)*p[2]);
		}//*/
	public:
		void full_resize(int Xplaces, int Yplaces)
		{
			this->Xplaces=Xplaces, this->Yplaces=Yplaces, ndrSize=Xplaces*Yplaces;
			Xsample=xs.DX/Xplaces, Xstart_s=xs.Xstart, Xstart=xs.Xstart+Xsample;
			Ysample=ys.DX/Yplaces, Yend_s=ys.Xend, Yend=ys.Xend+Ysample;
			//Xsample=DX/Xplaces;
			//Xstart_s=VX-DX/2, Xstart=Xstart_s+Xsample;
			//Ysample=DY/Yplaces, Yend=VY+DY/2, Yend_s=Yend+Ysample;
			
			bitmap.resize(w, h);
			//DeleteObject(hBitmap);
			//BITMAPINFO bmpInfo={{sizeof(BITMAPINFOHEADER), w, -h, 1, 32, BI_RGB, 0, 0, 0, 0, 0}};
			//hBitmap=CreateDIBSection(0, &bmpInfo, DIB_RGB_COLORS, (void**)&rgb, 0, 0);
		}
		void full(Expression &ex)
		{
			int aXplaces, aYplaces;
			if(ex.resultLogicType>=2)
				aXstart=&Xstart_s, aYend=&Yend_s, aXplaces=Xplaces+4, aYplaces=Yplaces+2;//unlike Yplaces, Xplaces is inflated by 4 to keep divisibility by 4
			//	aXstart=&Xstart_s, aYend=&Yend_s, aXplaces=Xplaces+2, aYplaces=Yplaces+2;
			else
				aXstart=&Xstart, aYend=&Yend, aXplaces=Xplaces, aYplaces=Yplaces;
			int aNDRsize=aXplaces*aYplaces;

			modes::Xstart=*aXstart, modes::Xsample=Xsample, modes::Yend=*aYend, modes::Ysample=Ysample, modes::T=T;
			modes::Xplaces=aXplaces, modes::Yplaces=aYplaces, modes::Zplaces=1, modes::ndrSize=aNDRsize;

			resize_terms(ex, aNDRsize);
			fill_range(ex, choose_fill_fn_2di, 0, 0, aXplaces, 0, aYplaces, 0, 1, aXplaces, aYplaces, 1, aNDRsize, false, false, false);

			switch(ex.resultLogicType)
			{
			case 1://&& || ## < > <= >=		logic expresion / inequality		logic
				//for(int kn=0;kn<ex.n.size();++kn)
				//	ndr_to_clipboard_2d((double*)ex.n[kn].r.p, Xplaces, Yplaces);//
				solve_disc(ex, 0, 0, Xplaces, 0, Yplaces, 0, 1, Xplaces, Yplaces, 1,	0, 0, 0, 0, 0, 0);
				break;

				//= !=		equation	ex.resultLogicType>=2		zero cross curve, anti-aliasing
			case 2:
				//zero cross	_/\_
			case 3:
				//				_  _
				//zero cross	 \/
				{
					int Xplaces1=Xplaces+3, Yplaces1=Yplaces+1,
						Xplaces2=Xplaces+4, Yplaces2=Yplaces+2;
					//int Xplaces1=Xplaces+1, Yplaces1=Yplaces+1,
					//	Xplaces2=Xplaces+2, Yplaces2=Yplaces+2;

					unsigned yDiscOffset=Yplaces2*Xplaces1;
					ex.discontinuities.assign(yDiscOffset+Yplaces1*Xplaces2, false);

					//if(ex.n[0].r.size()==(aXplaces*aYplaces>>1))
					//	ndr_to_clipboard_2d((double*)ex.n[0].r.p, aXplaces, aYplaces);//
					//if(ex.n[1].r.size()==(aXplaces*aYplaces>>1))
					//	ndr_to_clipboard_2d((double*)ex.n[1].r.p, aXplaces, aYplaces);//
					
				//	free(malloc(1));
					::solve_disc(ex, 0, 0, aXplaces, 0, aYplaces, 0, 1, aXplaces, aYplaces, 1,		disc_i2d_in_u, disc_i2d_in_b, disc_i2d_in_t, disc_i2d_out, yDiscOffset, true);
				//	::solve_disc(ex, 0, 0, aXplaces, 0, aYplaces, 0, 1, aXplaces, aYplaces, 1,		0, 0, 0, 0, 0, true);//
				//	free(malloc(1));
					//if(ex.n[0].r.size()==(aXplaces*aYplaces>>1))
					//	ndr_to_clipboard_2d((double*)ex.n[0].r.p, aXplaces, aYplaces);//

					subtract_NDRs(ex, 0, aXplaces, 0, aYplaces, aXplaces, aYplaces);
				//	subtract_NDRs(ex, 0, aXplaces, 0, aYplaces, Xplaces, Yplaces);

					//if(ex.n[0].r.size()==(aXplaces*aYplaces>>1))
					//	ndr_to_clipboard_2d((double*)ex.n[0].r.p, aXplaces, aYplaces);//
				}
				break;
			}
		}
		void draw(Expression &ex)
		{
			//1: && || ## < > <= >=		logic expresion / inequality		logic
			//2: =	3: !=				equation							zero cross curve, anti-aliasing		inflate by 2

			int inflate=(ex.resultLogicType>=2)<<1;
			modes::exColorRA=exColorRA, modes::exColorRB=exColorRB, modes::exColorGA=exColorGA, modes::exColorGB=exColorGB, modes::exColorBA=exColorBA, modes::exColorBB=exColorBB;
			solve_zerocross_2d(ex, prgb, 0, Xplaces+(inflate<<1), 0, Yplaces+inflate, Xplaces+inflate, Yplaces);//inflated range		unlike Yplaces, Xplaces is inflated by 4 to keep divisibility by 4, zerocross expects Xplaces=actualXplaces-2
		//	solve_zerocross_2d(ex, prgb, 0, w+inflate, 0, Yplaces+inflate, Xplaces, Yplaces);//inflated range
		//	solve_zerocross_2d(ex, prgb, 0, Xplaces+inflate, 0, Yplaces+inflate, Xplaces, Yplaces);//inflated range
			//if(ex.resultLogicType==1)
			//	solve_zerocross_2d(ex, prgb, 0, Xplaces, 0, Yplaces, Xplaces, Yplaces);
			//else
			//	solve_zerocross_2d(ex, prgb, 0, Xplaces+2, 0, Yplaces+2, Xplaces, Yplaces);
		}
	private:
		void drawCheckboard_range(PenBrush &penBrush, int *rDims, int clearScreen)
	//	void drawCheckboard_range(HPEN hPen, HBRUSH hBrush, int *rDims, int clearScreen)
	//	void drawCheckboard_range(HPEN hPen, HBRUSH hBrush, double VX, double DX, double VY, double DY, double Xstep, double Ystep, int *rDims, int clearScreen)
		{
			int x1=rDims[0]-(Xplaces-w), x2=rDims[1]+Xplaces-w, y1=rDims[2], y2=rDims[3];

			Region r;
			r.create(x1, y1, x2, y2);
			r.use();
		//	HRGN hRgn=CreateRectRgn(x1, y1, x2, y2);
		//	SelectClipRgn(ghMemDC, hRgn);

		/*	HGDIOBJ obj1, obj2, obj3, obj4;
			HPEN hWpen=CreatePen(PS_SOLID, 1, 0xFFFFFF);
			HBRUSH hWbrush=CreateSolidBrush(0xFFFFFF);
			obj1=SelectObject(ghMemDC, hWpen);
			obj2=SelectObject(ghMemDC, hWbrush);
			Rectangle(ghMemDC, x1, y1, x2, y2);
			obj4=SelectObject(ghMemDC, obj2);//returns brush
			obj3=SelectObject(ghMemDC, obj1);//returns pen		//order not necessary
			DeleteObject(SelectObject(ghMemDC, obj3));
			DeleteObject(SelectObject(ghMemDC, obj4));//*/
			{
				PenBrush pb(0xFFFFFF);
				pb.use();
			//	HPEN hWpen=(HPEN)SelectObject(ghMemDC, CreatePen(PS_SOLID, 1, 0xFFFFFF));//bgr
			//	HBRUSH hWbrush=(HBRUSH)SelectObject(ghMemDC, CreateSolidBrush(0xFFFFFF));
				rectangle(x1, y1, x2, y2);
			//	Rectangle(ghMemDC, x1, y1, x2, y2);
				pb.drop();
			//	DeleteObject(SelectObject(ghMemDC, hWpen));
			//	DeleteObject(SelectObject(ghMemDC, hWbrush));
			}

		//	if(!clearScreen)
		//	{
				_2dMode_DrawCheckboard_range(penBrush, xs, ys, x1, x2, y1, y2);
			//	_2dMode_DrawCheckboard_range(hPen, hBrush, xs, ys, x1, x2, y1, y2);

				//hPen=(HPEN)SelectObject(ghMemDC, hPen), hBrush=(HBRUSH)SelectObject(ghMemDC, hBrush);
				//double Ystart=VY-DY/2, Yend=VY+DY/2, Ystepx2=Ystep*2, Xstart=VX-DX/2, Xend=VX+DX/2, Xstepx2=Xstep*2;
				//for(double y=ceil((Yend-y1*DY/h)/Ystepx2)*Ystepx2, yEnd=floor((Yend-y2*DY/h)/Ystep)*Ystep;y>yEnd;y-=Ystepx2)
				//{
				//	for(double x=floor((Xstart+x1*DX/w)/Xstepx2)*Xstepx2, xEnd=ceil((Xstart+x2*DX/w)/Xstep)*Xstep;x<xEnd;x+=Xstepx2)
				//	{
				//		double
				//			ax1=(x+Xstep-Xstart)/DX*w, ay1=(Yend-y		)/DY*h, ax2=(x+Xstepx2	-Xstart)/DX*w, ay2=(Yend-y+Ystep	)/DY*h,
				//			bx1=(x		-Xstart)/DX*w, by1=(Yend-y+Ystep)/DY*h, bx2=(x+Xstep	-Xstart)/DX*w, by2=(Yend-y+Ystepx2	)/DY*h;
				//		Rectangle(ghMemDC, int(ax1)-(ax1<0), int(ay1)-(ay1<0)+1, int(ax2)-(ax2<0), int(ay2)-(ay2<0)+1);
				//		Rectangle(ghMemDC, int(bx1)-(bx1<0), int(by1)-(by1<0)+1, int(bx2)-(bx2<0), int(by2)-(by2<0)+1);
				//	}
				//}
				//hPen=(HPEN)SelectObject(ghMemDC, hPen), hBrush=(HBRUSH)SelectObject(ghMemDC, hBrush);
		//	}

			r.drop();
		//	SelectClipRgn(ghMemDC, 0);
		//	DeleteObject(hRgn);
		}
	public:
		void shiftAndCheckboard(PenBrush &penBrush, int clearScreen)
	//	void shiftAndCheckboard(HPEN hPen, HBRUSH hBrush, int clearScreen)
		{
		//	bitmap_to_clipboard(rgb, w, h);//
			if(shift==&Solve_2D_Implicit::shift_)
			{
				int XSstart=sa[0], XSend=sa[1], XDstart=sa[2], YSstart=sa[3], YSend=sa[4], YDstart=sa[5];
				if(XSend==Xplaces)
					XSend=w;
				auto _First=bitmap.rgb+XSstart, _Last=bitmap.rgb+XSend, _Dest=bitmap.rgb+XDstart;
				for(int ky=w*YSstart, kyEnd=w*YSend, kyStep=(ky<kyEnd?1:-1)*w, ky2=w*YDstart;ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
					std::copy(_First+ky, _Last+ky, _Dest+ky2);
				//for(int ky=Xplaces*YSstart, kyEnd=Xplaces*YSend, kyStep=(ky<kyEnd?1:-1)*Xplaces, ky2=Xplaces*YDstart;ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
				//	std::copy(_First+ky, _Last+ky, _Dest+ky2);
			}
			else if(shift==&Solve_2D_Implicit::shift_r)
			{
				int XSstart=sa[0], XSend=sa[1], XDstart=sa[2], YSstart=sa[3], YSend=sa[4], YDstart=sa[5];
				auto rb=std::reverse_iterator<int*>(bitmap.rgb+w*h);
				auto _First=rb+w-1-XSstart, _Last=rb+w-1-XSend, _Dest=rb+w-1-XDstart;
				for(int ky=w*(h-1-YSstart), kyEnd=w*(h-1-YSend), kyStep=(ky<kyEnd?1:-1)*w, ky2=w*(h-1-YDstart);ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
					std::copy(_First+ky,_Last+ky, _Dest+ky2);
				//int XSstart=sa[0], XSend=sa[1], XDstart=sa[2], YSstart=sa[3], YSend=sa[4], YDstart=sa[5];
				//auto rb=std::reverse_iterator<int*>(rgb+Xplaces*Yplaces);
				//auto _First=rb+Xplaces-1-XSstart, _Last=rb+Xplaces-1-XSend, _Dest=rb+Xplaces-1-XDstart;
				//for(int ky=Xplaces*(Yplaces-1-YSstart), kyEnd=Xplaces*(Yplaces-1-YSend), kyStep=(ky<kyEnd?1:-1)*Xplaces, ky2=Xplaces*(Yplaces-1-YDstart);ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
				//	std::copy(_First+ky,_Last+ky, _Dest+ky2);
			}
		//	bitmap_to_clipboard(rgb, w, h);//
			drawCheckboard_range(penBrush, ra, clearScreen);
		//	drawCheckboard_range(hPen, hBrush, ra, clearScreen);
			if(partial==&Solve_2D_Implicit::partial_2)
				drawCheckboard_range(penBrush, ra+4, clearScreen);
			//	drawCheckboard_range(hPen, hBrush, ra+4, clearScreen);
			//drawCheckboard_range(hPen, hBrush, VX, DX, VY, DY, Xstep, Ystep, ra, clearScreen);
			//if(partial==&Solve_2D_Implicit::partial_2)
			//	drawCheckboard_range(hPen, hBrush, VX, DX, VY, DY, Xstep, Ystep, ra+4, clearScreen);
		//	bitmap_to_clipboard(rgb, w, h);//
		}
	private:
		void shift_		(double *ndr, int *a, int aXplaces, int Yplaces)
		{
			int XSstart=a[0], XSend=a[1], XDstart=a[2], YSstart=a[3], YSend=a[4], YDstart=a[5];
		//	int XSstart=sa[0], XSend=sa[1], XDstart=sa[2], YSstart=sa[3], YSend=sa[4], YDstart=sa[5];
			auto _First=ndr+XSstart, _Last=ndr+XSend, _Dest=ndr+XDstart;
			for(int ky=aXplaces*YSstart, kyEnd=aXplaces*YSend, kyStep=(ky<kyEnd?1:-1)*aXplaces, ky2=aXplaces*YDstart;ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
				std::copy(_First+ky, _Last+ky, _Dest+ky2);
		}
		void shift_r	(double *ndr, int *a, int aXplaces, int aYplaces)
		{
			int XSstart=a[0], XSend=a[1], XDstart=a[2], YSstart=a[3], YSend=a[4], YDstart=a[5];
		//	int XSstart=sa[0], XSend=sa[1], XDstart=sa[2], YSstart=sa[3], YSend=sa[4], YDstart=sa[5];
			auto rb=std::reverse_iterator<double*>(ndr+aXplaces*aYplaces);
		//	auto rb=rbegin(ndr, aXplaces*aYplaces);
			auto _First=rb+aXplaces-1-XSstart, _Last=rb+aXplaces-1-XSend, _Dest=rb+aXplaces-1-XDstart;
			for(int ky=aXplaces*(aYplaces-1-YSstart), kyEnd=aXplaces*(aYplaces-1-YSend), kyStep=(ky<kyEnd?1:-1)*aXplaces, ky2=aXplaces*(aYplaces-1-YDstart);ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
				std::copy(_First+ky,_Last+ky, _Dest+ky2);
		}
		typedef void(modes::Solve_2D_Implicit::*Shift_fn)(double*, int*, int, int);
		Shift_fn shift;
		void solve_range	(Expression &ex, int *a)
		{
			int aXplaces, aYplaces;
			int x1, x2, y1, y2;
			if(ex.resultLogicType==1)
				aXstart=&Xstart,	aYend=&Yend,	aXplaces=Xplaces,	aYplaces=Yplaces,		x1=a[0], x2=a[1], y1=a[2], y2=a[3];
			else
				aXstart=&Xstart_s,	aYend=&Yend_s,	aXplaces=Xplaces+2,	aYplaces=Yplaces+2,		x1=a[8], x2=a[9], y1=a[10], y2=a[11];//x1=a[16], x2=a[17], y1=a[18], y2=a[19];//x1=a[8], x2=a[9], y1=a[10], y2=a[11];
			modes::Xstart=*aXstart, modes::Xsample=Xsample, modes::Yend=*aYend, modes::Ysample=Ysample, modes::T=T;
			modes::Xplaces=aXplaces, modes::Yplaces=aYplaces, modes::Zplaces=1, modes::ndrSize=aXplaces*aYplaces;
			fill_range(ex, choose_fill_fn_2di, 0, x1, x2, y1, y2, 0, 1, aXplaces, aYplaces, 1, modes::ndrSize, false, false, false);
			if(ex.resultLogicType==1)
				solve_disc(ex, 0, x1, x2, y1, y2, 0, 1, Xplaces, Yplaces, 1,	0, 0, 0, 0, 0, 0);
			else
			{
				int Xplaces1=Xplaces+1, Yplaces1=Yplaces+1,
					Xplaces2=Xplaces+2, Yplaces2=Yplaces+2;

				unsigned yDiscOffset=Xplaces1*Yplaces2;
				for(int y=y1;y<y2;++y)
					//for(auto it=ex.discontinuities.begin()+Xplaces1*y+x1, itEnd=ex.discontinuities.begin()+Xplaces1*y+x2-1;it!=itEnd;++it)
					//	*it=false;
					for(int x=x1;x<x2-1;++x)
						ex.discontinuities[Xplaces1*y+x]=false;
				for(int y=y1;y<y2-1;++y)
					//for(auto it=ex.discontinuities.begin()+yDiscOffset+Xplaces2*y+x1, itEnd=ex.discontinuities.begin()+Xplaces2*y+x2;it!=itEnd;++it)
					//	*it=false;
					for(int x=x1;x<x2;++x)
						ex.discontinuities[yDiscOffset+Xplaces2*y+x]=false;
			//	ndr_to_clipboard_2d(ex, aXplaces, aYplaces);//
			//	ndr_to_clipboard_2d((double*)ex.n[ex.resultTerm].r.p, aXplaces, aYplaces);//
				::solve_disc(ex, 0, x1, x2, y1, y2, 0, 1, Xplaces2, Yplaces, 1, disc_i2d_in_u, disc_i2d_in_b, disc_i2d_in_t, disc_i2d_out, yDiscOffset, true);
			//	::solve_disc(ex, 0, x1, x2, y1, y2, 0, 1, aXplaces, aYplaces, 1,		0, 0, 0, 0, 0, true);//
			//	ndr_to_clipboard_2d((double*)ex.n[ex.resultTerm].r.p, aXplaces, aYplaces);//
				subtract_NDRs(ex, x1, x2, y1, y2, aXplaces, aYplaces);
				//::solve_disc(ex, 0, x1, x2, y1, y2, 0, 1, Xplaces2, Yplaces, 1,		0, 0, 0, 0, 0, true);//
				//subtract_NDRs(ex, x1, x2, y1, y2, Xplaces, Yplaces);
			//	ndr_to_clipboard_2d(ex, aXplaces, aYplaces);//
			//	ndr_to_clipboard_2d((double*)ex.n[ex.resultTerm].r.p, aXplaces, aYplaces);//
			}
			modes::exColorRA=exColorRA, modes::exColorRB=exColorRB, modes::exColorGA=exColorGA, modes::exColorGB=exColorGB, modes::exColorBA=exColorBA, modes::exColorBB=exColorBB;
			//auto ndr=(double*)ex.n[ex.resultTerm].r.p;//
			//x1=0, x2=aXplaces, y1=0, y2=aYplaces;//
			//for(int y=y1+1, yEnd=y2-1;y<yEnd;++y)//
			//{
			//	for(int x=x1+1, xEnd=x2-1;x<xEnd;++x)//
			//	{
			//		double a=.5+.5*tanh(ndr[(Xplaces+2)*y+x]);//
			//		auto p=(unsigned char*)&(*prgb)[w*(y-1)+x-1];//
			//		p[0]=p[1]=p[2]=0xFF*a;
			//	//	p[0]*=a, p[1]*=a, p[2]*=a;
			//	}
			//}
			solve_zerocross_2d(ex, prgb, x1==0?x1:x1-(Xplaces-w), x2==aXplaces?x2:x2+Xplaces-w, y1, y2, Xplaces, Yplaces);
		//	ndr_to_clipboard_2d(ex, aXplaces, aYplaces);//
		//	ndr_to_clipboard_2d((double*)ex.n[ex.resultTerm].r.p, aXplaces, aYplaces);//
		//	bitmap_to_clipboard(rgb, w, h);//
		}
		void partial_		(Expression &ex){}
		void partial_1		(Expression &ex)
		{
			int saOffset, aXplaces, aYplaces;
			if(ex.resultLogicType==1)
				saOffset=0, aXplaces=Xplaces, aYplaces=Yplaces;
			else
				saOffset=6, aXplaces=Xplaces+2, aYplaces=Yplaces+2;
			(this->*shift)((double*)ex.n[ex.resultTerm].r.p, sa+saOffset, aXplaces, aYplaces);
			solve_range(ex, ra);
		}
		void partial_2		(Expression &ex)
		{
			int saOffset, aXplaces, aYplaces;
			if(ex.resultLogicType==1)
				saOffset=0, aXplaces=Xplaces, aYplaces=Yplaces;
			else
				saOffset=6, aXplaces=Xplaces+2, aYplaces=Yplaces+2;
			(this->*shift)((double*)ex.n[ex.resultTerm].r.p, sa+saOffset, aXplaces, aYplaces);
			solve_range(ex, ra), solve_range(ex, ra+4);
		}
	public:
		void partial_bounds(int Xoffset, int Yoffset)
	//	void partial_bounds(double VX, double DX, double VY, double DY, int Xoffset, int Yoffset)
		{
			//Xsample=DX/Xplaces;
			//Xstart_s=VX-DX/2, Xstart=Xstart_s+Xsample;
			//Ysample=DY/Yplaces, Yend=VY+DY/2, Yend_s=Yend+Ysample;
			partial=&Solve_2D_Implicit::partial_;
			int Xoffset2=setXplaces(std::abs(Xoffset)+2), Yoffset2=std::abs(Yoffset)+2;
		//	int Xoffset2=std::abs(Xoffset)+2, Yoffset2=std::abs(Yoffset)+2;
			int Xplaces2=Xplaces+2, Yplaces2=Yplaces+2;
				 if(Xoffset>0){							 if(Yoffset>0)					shift=&Solve_2D_Implicit::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,			sa[5]=Yplaces-1,			partial=&Solve_2D_Implicit::partial_2,	ra[0]=0,					ra[1]=Xplaces,		ra[ 2]=0,					ra[ 3]=Yoffset,							ra[ 4]=Xplaces-Xoffset2,	ra[ 5]=Xplaces,		ra[ 6]=Yoffset,				ra[ 7]=Yplaces,
																															sa[6]=Xoffset,				sa[7]=Xplaces2,	sa[8]=0,			sa[9]=Yplaces2-1-Yoffset,	sa[10]=-1,			sa[11]=Yplaces2-1,													ra[8]=0,					ra[9]=Xplaces2,		ra[10]=0,					ra[11]=Yoffset2,						ra[12]=Xplaces2-Xoffset2,	ra[13]=Xplaces2,	ra[14]=Yoffset,				ra[15]=Yplaces2;

													else if(Yoffset<0)Yoffset=-Yoffset,	shift=&Solve_2D_Implicit::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,		sa[5]=0,					partial=&Solve_2D_Implicit::partial_2,	ra[0]=Xplaces-Xoffset2,		ra[1]=Xplaces,		ra[ 2]=0,					ra[ 3]=Yplaces-Yoffset,					ra[ 4]=0,					ra[ 5]=Xplaces,		ra[ 6]=Yplaces-Yoffset,		ra[ 7]=Yplaces,
																															sa[6]=Xoffset,				sa[7]=Xplaces2,	sa[8]=0,			sa[9]=Yoffset,				sa[10]=Yplaces2,	sa[11]=0,															ra[8]=Xplaces2-Xoffset2,	ra[9]=Xplaces2,		ra[10]=0,					ra[11]=Yplaces2-Yoffset,				ra[12]=0,					ra[13]=Xplaces2,	ra[14]=Yplaces2-Yoffset2,	ra[15]=Yplaces2;

													else								shift=&Solve_2D_Implicit::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,		sa[5]=0,					partial=&Solve_2D_Implicit::partial_1,	ra[0]=Xplaces-Xoffset2,		ra[1]=Xplaces,		ra[ 2]=0,					ra[ 3]=Yplaces,
																															sa[6]=Xoffset,				sa[7]=Xplaces2,	sa[8]=0,			sa[9]=Yoffset,				sa[10]=Yplaces2,	sa[11]=0,															ra[8]=Xplaces2-Xoffset2,	ra[9]=Xplaces2,		ra[10]=0,					ra[11]=Yplaces2;}

			else if(Xoffset<0){Xoffset=-Xoffset;		 if(Yoffset>0)					shift=&Solve_2D_Implicit::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,			sa[5]=Yplaces-1,			partial=&Solve_2D_Implicit::partial_2,	ra[0]=0,					ra[1]=Xplaces,		ra[ 2]=0,					ra[ 3]=Yoffset,							ra[ 4]=0,					ra[ 5]=Xoffset2,	ra[ 6]=Yoffset,				ra[ 7]=Yplaces,
																															sa[6]=Xplaces2-1-Xoffset,	sa[7]=-1,		sa[8]=Xplaces2-1,	sa[9]=Yplaces2-1-Yoffset,	sa[10]=-1,			sa[11]=Yplaces2-1,													ra[8]=0,					ra[9]=Xplaces2,		ra[10]=0,					ra[11]=Yoffset2,						ra[12]=0,					ra[13]=Xoffset2,	ra[14]=Yoffset,				ra[15]=Yplaces2;

													else if(Yoffset<0)Yoffset=-Yoffset,	shift=&Solve_2D_Implicit::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yoffset,				sa[4]=Yplaces,		sa[5]=0,					partial=&Solve_2D_Implicit::partial_2,	ra[0]=0,					ra[1]=Xoffset2,		ra[ 2]=0,					ra[ 3]=Yplaces-Yoffset,					ra[ 4]=0,					ra[ 5]=Xplaces,		ra[ 6]=Yplaces-Yoffset,		ra[ 7]=Yplaces,
																															sa[6]=Xplaces2-1-Xoffset,	sa[7]=-1,		sa[8]=Xplaces2-1,	sa[9]=Yoffset,				sa[10]=Yplaces2,	sa[11]=0,															ra[8]=0,					ra[9]=Xoffset2,		ra[10]=0,					ra[11]=Yplaces2-Yoffset,				ra[12]=0,					ra[13]=Xplaces2,	ra[14]=Yplaces2-Yoffset2,	ra[15]=Yplaces2;

													else								shift=&Solve_2D_Implicit::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yoffset,				sa[4]=Yplaces,		sa[5]=0,					partial=&Solve_2D_Implicit::partial_1,	ra[0]=0,					ra[1]=Xoffset2,		ra[ 2]=0,					ra[ 3]=Yplaces,
																															sa[6]=Xplaces2-1-Xoffset,	sa[7]=-1,		sa[8]=Xplaces2-1,	sa[9]=Yoffset,				sa[10]=Yplaces2,	sa[11]=0,															ra[8]=0,					ra[9]=Xoffset2,		ra[10]=0,					ra[11]=Yplaces2;}

			else{										 if(Yoffset>0)					shift=&Solve_2D_Implicit::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,			sa[5]=Yplaces-1,			partial=&Solve_2D_Implicit::partial_1,	ra[0]=0,					ra[1]=Xplaces,		ra[ 2]=0,					ra[ 3]=Yoffset,
																															sa[6]=Xoffset,				sa[7]=Xplaces2,	sa[8]=0,			sa[9]=Yplaces2-1-Yoffset,	sa[10]=-1,			sa[11]=Yplaces2-1,													ra[8]=0,					ra[9]=Xplaces2,		ra[10]=0,					ra[11]=Yoffset2;

													else if(Yoffset<0)Yoffset=-Yoffset,	shift=&Solve_2D_Implicit::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,		sa[5]=0,					partial=&Solve_2D_Implicit::partial_1,	ra[0]=0,					ra[1]=Xplaces,		ra[ 2]=Yplaces-Yoffset,		ra[ 3]=Yplaces,
																															sa[6]=Xoffset,				sa[7]=Xplaces2,	sa[8]=0,			sa[9]=Yoffset,				sa[10]=Yplaces2,	sa[11]=0,															ra[8]=0,					ra[9]=Xplaces2,		ra[10]=Yplaces2-Yoffset2,	ra[11]=Yplaces2;
													else;}
		}
	//	decltype(&Solve_2D_Implicit::partial_) partial;
		typedef void(modes::Solve_2D_Implicit::*Partial_fn)(Expression&);
		Partial_fn partial;
	};
	class		Solve_2D:public Solve//t2d, t2d_h
	{
	public:
		Scale &xs, &ys;
	//	bool xlogscale, ylogscale;
	//	double Xstart, Xsample, Ystart, Ysample;
		int ndrSize, Xplaces, Yplaces;
		bool enable_disc;
		Disc_fn disc_in_u, disc_in_b, disc_in_t, disc_out;
		Solve_2D(bool enable_disc, Scale &xs, Scale &ys):xs(xs), ys(ys),//xlogscale(false), ylogscale(false),
			enable_disc(enable_disc),
			disc_in_u(enable_disc?disc_2d_in_u:0), disc_in_b(enable_disc?disc_2d_in_b:0), disc_in_t(enable_disc?disc_2d_in_t:0), disc_out(enable_disc?disc_2d_out:0)
		{}
//	private:
		int sa[6],//shift arguments:	XSstart XSend XDstart	YSstart YSend YDstart
			ra[8];//2 rectangles: x1 x2 y1 y2
	public:
		void full_resize(double VX, double DX, double VY, double DY, int Xplaces, int Yplaces)
		{
			this->Xplaces=Xplaces, this->Yplaces=Yplaces, ndrSize=Xplaces*Yplaces;//, this->Xstart=VX-DX/2, this->Xsample=DX/Xplaces, this->Ystart=VY-DY/2, this->Ysample=DY/Yplaces;
		}
		void full(Expression &ex)
		{
			modes::Xstart=xs.Xstart, modes::Xsample=xs.Xsample, modes::Ystart=ys_Ystart, modes::Ysample=ys.Xsample, modes::T=T;
			//modes::Xstart=Xstart, modes::Xsample=Xsample, modes::Ystart=Ystart, modes::Ysample=Ysample, modes::T=T;
			modes::Xplaces=Xplaces, modes::Yplaces=Yplaces, modes::Zplaces=1, modes::ndrSize=ndrSize;

			resize_terms(ex, ndrSize);
			fill_range(ex, choose_fill_fn, 0, 0, Xplaces, 0, Yplaces, 0, 1, Xplaces, Yplaces, 1, ndrSize, xs.logscale, ys.logscale, false);

			//Xdiscs:	(Xplaces-1) * Yplaces
			//Ydiscs:	(Yplaces-1) * Xplaces
			unsigned yDiscOffset=(Xplaces-1)*Yplaces;
			if(enable_disc)
				ex.discontinuities.assign(yDiscOffset+(Yplaces-1)*Xplaces, false);
			::solve_disc(ex, 0, 0, Xplaces, 0, Yplaces, 0, 1, Xplaces, Yplaces, 1,		disc_in_u, disc_in_b, disc_in_t, disc_out, yDiscOffset, false);
		//	::solve_disc(ex, 0, 0, Xplaces, 0, Yplaces, 0, 1, Xplaces, Yplaces, 1,		0, 0, 0, 0, 0, false);//
		}
	private:
		void shift_		(double *ndr, std::vector<bool> &discontinuities)
		{
			int &XSstart=sa[0], &XSend=sa[1], &XDstart=sa[2], &YSstart=sa[3], &YSend=sa[4], &YDstart=sa[5];
			{
				auto _First=ndr+XSstart, _Last=ndr+XSend, _Dest=ndr+XDstart;
				for(int ys=Xplaces*YSstart, ysEnd=Xplaces*YSend, yStep=(ys<ysEnd?1:-1)*Xplaces, yd=Xplaces*YDstart;ys!=ysEnd;ys+=yStep, yd+=yStep)
					std::copy(_First+ys, _Last+ys, _Dest+yd);
			}
			if(enable_disc)
			{
				if(XSstart<Xplaces-1)
				{
					auto _First=discontinuities.begin()+XSstart, _Last=discontinuities.begin()+XSend-1, _Dest=discontinuities.begin()+XDstart;
					for(int ys=YSstart*(Xplaces-1), ysEnd=YSend*(Xplaces-1), yStep=(ys<ysEnd?1:-1)*(Xplaces-1), yd=YDstart*(Xplaces-1);ys!=ysEnd;ys+=yStep, yd+=yStep)
						std::copy(_First+ys, _Last+ys, _Dest+yd);
				}
				if(YSstart<YSend)
				{
					if(YSstart<Yplaces-1)
					{
						unsigned yDiscOffset=(Xplaces-1)*Yplaces;
						auto _First=discontinuities.begin()+yDiscOffset+YSstart, _Last=discontinuities.begin()+yDiscOffset+YSend-1, _Dest=discontinuities.begin()+yDiscOffset+YDstart;
						for(int xs=XSstart*(Yplaces-1), xsEnd=XSend*(Yplaces-1), xStep=(xs<xsEnd?1:-1)*(Yplaces-1), xd=XDstart*(Yplaces-1);xs!=xsEnd;xs+=xStep, xd+=xStep)
							std::copy(_First+xs, _Last+xs, _Dest+xd);
					}
				}
				else
				{
					if(YSstart>0)
					{
						auto _First=discontinuities.rbegin()+Yplaces-2-(YSstart-1), _Last=discontinuities.rbegin()+Yplaces-2-YSend, _Dest=discontinuities.rbegin()+Yplaces-2-(YDstart-1);
						for(int xs=(Xplaces-1-XSstart)*(Yplaces-1), xsEnd=(Xplaces-1-XSend)*(Yplaces-1), xStep=(xs<xsEnd?1:-1)*(Yplaces-1), xd=(Xplaces-1-XDstart)*(Yplaces-1);xs!=xsEnd;xs+=xStep, xd+=xStep)
							std::copy(_First+xs, _Last+xs, _Dest+xd);
					}
				}
			}
		}
		void shift_r	(double *ndr, std::vector<bool> &discontinuities)
		{
			int XSstart=sa[0], XSend=sa[1], XDstart=sa[2], YSstart=sa[3], YSend=sa[4], YDstart=sa[5];//98 -1 99		0 100 0
			//if(YSstart>YSend)//98 -1 99		96 -1 99
			//	int LOL_1=0;
			//for(int ky=YSstart, ky2=YDstart, kyEnd=YSend, kyStep=ky<kyEnd?1:-1;ky<kyEnd;++ky, ++ky2)
			//{
			//	for(int kx=XSstart, kx2=XDstart, kxEnd=XSend;kx>kxEnd;--kx, --kx2)
			//	{
			//		ndr[Xplaces*ky2+kx2]=ndr[Xplaces*ky+kx];
			//		//if(expr.size()&&expr[0].n.size()&&expr[0].n[0].r.size())//
			//		//{
			//		//	auto &n=expr[0].n[0];
			//		//	AVector_v4d test=n.r;
			//		//	_aligned_free(n.r.p), n.r.p=0;
			//		//	n.r=test;
			//		//}
			//	}
			//}
			//{
			//	auto _First=ndr+XSstart, _Last=ndr+XSend, _Dest=ndr+XDstart;
			//	for(int ys=Xplaces*YSstart, ysEnd=Xplaces*YSend, yStep=(ys<ysEnd?1:-1)*Xplaces, yd=Xplaces*YDstart;ys!=ysEnd;ys+=yStep, yd+=yStep)
			//		memmove(_Dest+yd, _First+ys, XSend-XSstart+ys);
			//}
			{
				auto rb=std::reverse_iterator<double*>(ndr+ndrSize);
				auto _First=rb+Xplaces-1-XSstart, _Last=rb+Xplaces-1-XSend, _Dest=rb+Xplaces-1-XDstart;
				for(int ky=Xplaces*(Yplaces-1-YSstart), kyEnd=Xplaces*(Yplaces-1-YSend), kyStep=(ky<kyEnd?1:-1)*Xplaces, ky2=Xplaces*(Yplaces-1-YDstart);ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
				{
					std::copy(_First+ky, _Last+ky, _Dest+ky2);
					//auto start=&*(_First+ky), end=&*(_Last+ky), dst=&*(_Dest+ky2);
					//for(int kx=-1, kEnd=end-start;kx>=kEnd;--kx)
					//{
					//	dst[kx]=start[kx];
					////	if(ky==0&&kx==-1)
					//	if(ky==4300&&kx==-89)
					//		int LOL_1=0;
					//	if(expr.size()&&expr[0].n.size()&&expr[0].n[0].r.size())//
					//	{
					//		auto &n=expr[0].n[0];
					//		AVector_v4d test=n.r;
					//		_aligned_free(n.r.p), n.r.p=0;
					//		n.r=test;
					//	}
					//}
				}
			}
			if(enable_disc)
			{
				if(XSstart>0)
				{
					unsigned xDiscROffset=Xplaces*(Yplaces-1);
					auto _First=discontinuities.rbegin()+xDiscROffset+Xplaces-2-(XSstart-1), _Last=discontinuities.rbegin()+xDiscROffset+Xplaces-2-XSend, _Dest=discontinuities.rbegin()+xDiscROffset+Xplaces-2-(XDstart-1);
					for(int ys=(Yplaces-1-YSstart)*(Xplaces-1), ysEnd=(Yplaces-1-YSend)*(Xplaces-1), yStep=(ys<ysEnd?1:-1)*(Xplaces-1), yd=(Yplaces-1-YDstart)*(Xplaces-1);ys!=ysEnd;ys+=yStep, yd+=yStep)
						std::copy(_First+ys, _Last+ys, _Dest+yd);
				}
				if(YSstart<YSend)
				{
					if(YSstart<Yplaces-1)
					{
						unsigned yDiscOffset=(Xplaces-1)*Yplaces;
						auto _First=discontinuities.begin()+yDiscOffset+YSstart, _Last=discontinuities.begin()+yDiscOffset+YSend-1, _Dest=discontinuities.begin()+yDiscOffset+YDstart;
						for(int xs=XSstart*(Yplaces-1), xsEnd=XSend*(Yplaces-1), xStep=(xs<xsEnd?1:-1)*(Yplaces-1), xd=XDstart*(Yplaces-1);xs!=xsEnd;xs+=xStep, xd+=xStep)
							std::copy(_First+xs, _Last+xs, _Dest+xd);
					}
				}
				else
				{
					if(YSstart>0)
					{
						auto _First=discontinuities.rbegin()+Yplaces-2-(YSstart-1), _Last=discontinuities.rbegin()+Yplaces-2-YSend, _Dest=discontinuities.rbegin()+Yplaces-2-(YDstart-1);
						for(int xs=(Xplaces-1-XSstart)*(Yplaces-1), xsEnd=(Xplaces-1-XSend)*(Yplaces-1), xStep=(xs<xsEnd?1:-1)*(Yplaces-1), xd=(Xplaces-1-XDstart)*(Yplaces-1);xs!=xsEnd;xs+=xStep, xd+=xStep)
							std::copy(_First+xs, _Last+xs, _Dest+xd);
					}
				}
			}
		}
	//	decltype(&Solve_2D::shift_) shift;
		typedef void (modes::Solve_2D::*Shift_fn)(double*, std::vector<bool>&);
		Shift_fn shift;
		void solve_range	(Expression &ex, int *a)
		{
			int &x1=a[0], &x2=a[1], &y1=a[2], &y2=a[3];
			modes::Xstart=xs.Xstart, modes::Xsample=xs.Xsample, modes::Ystart=ys_Ystart, modes::Ysample=ys.Xsample, modes::T=T;
		//	modes::Xstart=Xstart, modes::Xsample=Xsample, modes::Ystart=Ystart, modes::Ysample=Ysample, modes::T=T;
			modes::Xplaces=Xplaces, modes::Yplaces=Yplaces, modes::Zplaces=1, modes::ndrSize=ndrSize;
			fill_range(ex, choose_fill_fn, 0, x1, x2, y1, y2, 0, 1, Xplaces, Yplaces, 1, Xplaces*Yplaces, xs.logscale, ys.logscale, false);
			unsigned yDiscOffset=(Xplaces-1)*Yplaces;
			if(enable_disc)
			{
				for(int y=y1;y<y2;++y)
					for(int x=x1;x<x2-1;++x)
						ex.discontinuities[(Xplaces-1)*y+x]=false;
				for(int x=x1;x<x2;++x)
					for(int y=y1;y<y2-1;++y)
						ex.discontinuities[yDiscOffset+(Yplaces-1)*x+y]=false;
			}
			::solve_disc(ex, 0, x1, x2, y1, y2, 0, 1, Xplaces, Yplaces, 1,		disc_in_u, disc_in_b, disc_in_t, disc_out, yDiscOffset, false);
		}
		void partial_		(Expression&){}
		void partial_1		(Expression &ex)
		{
			auto &n=ex.n[ex.resultTerm];
			(this->*shift)(n.r.p, ex.discontinuities);
			if(n.mathSet>='c')
			{
				(this->*shift)(n.i.p, ex.discontinuities);
				if(n.mathSet=='h')
				{
					(this->*shift)(n.j.p, ex.discontinuities);
					(this->*shift)(n.k.p, ex.discontinuities);
				}
			}
			solve_range(ex, ra);
		}
		void partial_2		(Expression &ex)
		{
			auto &n=ex.n[ex.resultTerm];
			(this->*shift)(n.r.p, ex.discontinuities);
			if(n.mathSet>='c')
			{
				(this->*shift)(n.i.p, ex.discontinuities);
				if(n.mathSet=='h')
				{
					(this->*shift)(n.j.p, ex.discontinuities);
					(this->*shift)(n.k.p, ex.discontinuities);
				}
			}
			solve_range(ex, ra);
			solve_range(ex, ra+4);
		}
	public:
		void partial_bounds	(double VX, double DX, double VY, double DY, int Xoffset, int Yoffset)
		{
		//	this->Xstart=VX-DX/2, this->Xsample=DX/Xplaces, this->Ystart=VY-DY/2, this->Ysample=DY/Yplaces;
			partial=&Solve_2D::partial_;
			int Xoffset2=setXplaces(std::abs(Xoffset)+1), Yoffset2=std::abs(Yoffset)+1;//+1 probably due to discontinuities
				 if(Xoffset>0){							 if(Yoffset>0)					shift=&Solve_2D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,					partial=&Solve_2D::partial_2,	ra[0]=Xplaces-Xoffset2,	ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces-Yoffset2,			ra[4]=0,				ra[5]=Xplaces,	ra[6]=Yplaces-Yoffset2,	ra[7]=Yplaces;
													else if(Yoffset<0)Yoffset=-Yoffset,	shift=&Solve_2D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,		sa[5]=Yplaces-1,			partial=&Solve_2D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yoffset2,					ra[4]=Xplaces-Xoffset2,	ra[5]=Xplaces,	ra[6]=Yoffset2,			ra[7]=Yplaces;
													else								shift=&Solve_2D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,					partial=&Solve_2D::partial_1,	ra[0]=Xplaces-Xoffset2,	ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces;}
			else if(Xoffset<0){Xoffset=-Xoffset;		 if(Yoffset>0)					shift=&Solve_2D::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,					partial=&Solve_2D::partial_2,	ra[0]=0,				ra[1]=Xoffset2,	ra[2]=0,				ra[3]=Yplaces-Yoffset2,			ra[4]=0,				ra[5]=Xplaces,	ra[6]=Yplaces-Yoffset2,	ra[7]=Yplaces;
													else if(Yoffset<0)Yoffset=-Yoffset,	shift=&Solve_2D::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,		sa[5]=Yplaces-1,			partial=&Solve_2D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yoffset2,					ra[4]=0,				ra[5]=Xoffset2,	ra[6]=Yoffset2,			ra[7]=Yplaces;
													else								shift=&Solve_2D::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,					partial=&Solve_2D::partial_1,	ra[0]=0,				ra[1]=Xoffset2,	ra[2]=0,				ra[3]=Yplaces;}
			else{										 if(Yoffset>0)					shift=&Solve_2D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,					partial=&Solve_2D::partial_1,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=Yplaces-Yoffset2,	ra[3]=Yplaces;
													else if(Yoffset<0)Yoffset=-Yoffset,	shift=&Solve_2D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,		sa[5]=Yplaces-1,			partial=&Solve_2D::partial_1,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yoffset2;
													else;}
		}
	//	decltype(&Solve_2D::partial_) partial;
		typedef void(modes::Solve_2D::*Partial_fn)(Expression&);
		Partial_fn partial;
	};
	class		Solve_C2D:public Solve
	{
		enum ColorScheme{BCW, BC_L};
	public:
		bool xlogscale, ylogscale;
		int *rgb, colorScheme;
		Solve_C2D():xlogscale(false), ylogscale(false), rgb(0), colorScheme(BCW){}
		double Xstart, Xsample, Yend, Ysample;
		int ndrSize, Xplaces, Yplaces;
	private:
		int sa[6],//shift arguments:	XSstart XSend XDstart	YSstart YSend YDstart
			ra[8];//2 rectangles: x1 x2 y1 y2
	public:
		void full_resize(double VX, double DX, double VY, double DY, int Xplaces, int Yplaces)
		{
			this->Xplaces=Xplaces, this->Yplaces=Yplaces, ndrSize=Xplaces*Yplaces, this->Xstart=VX-DX/2, this->Xsample=DX/Xplaces, this->Yend=VY+DY/2, this->Ysample=DY/Yplaces;
			rgb=(int*)realloc(rgb, Xplaces*Yplaces*sizeof(int));
		}
		void full(Expression &ex)
		{
			modes::Xstart=Xstart, modes::Xsample=Xsample, modes::Yend=Yend, modes::Ysample=Ysample, modes::T=T;
			modes::Xplaces=Xplaces, modes::Yplaces=Yplaces, modes::Zplaces=1, modes::ndrSize=ndrSize;

//#ifdef PROFILER
//			prof_start();
//#endif
			resize_terms(ex, ndrSize);
#ifdef PROFILER
			prof_add("Resize terms");
#endif
			fill_range(ex, choose_fill_fn_2di, 0, 0, Xplaces, 0, Yplaces, 0, 1, Xplaces, Yplaces, 1, ndrSize, xlogscale, ylogscale, false);
		//	ndr_to_clipboard_2d(ex, Xplaces, Yplaces);//
#ifdef PROFILER
			prof_add("Fill range");
#endif
			solve(ex, 0, 0, Xplaces, 0, Yplaces, 0, 1, Xplaces, Yplaces, 1);
		//	solve_disc(ex, 0, 0, Xplaces, 0, Yplaces, 0, 1, Xplaces, Yplaces, 1,	0, 0, 0, 0, 0, 0);
		//	ndr_to_clipboard_2d(ex, Xplaces, Yplaces);//
#ifdef PROFILER
			prof_add("Solve");
#endif
		}
		void toggleColorScheme(){colorScheme^=1;}
		void updateRGB(Term &n)
		{
//#ifdef PROFILER
//			prof_start();
//#endif
		//	Concurrency::parallel_transform(ndr.begin(), ndr.end(), rgb, (int(*)(Value&))colorFunction);
			auto prgb=&rgb;
			void (*cf)(CompP const&, int*);
			int idxShift=0, workSize=0;
			if(colorScheme==BCW)
			{
#ifdef AVX_H
					 if(simd_method>=2)			cf=colorFunction_bcw_avx,	idxShift=2, workSize=n.r.size()>>2;
				else
#endif
					 if(simd_method>=1&&SSE4_1)	cf=colorFunction_bcw_sse2,	idxShift=1, workSize=n.r.size()>>1;
				else							cf=colorFunction_bcw,		idxShift=0, workSize=n.r.size();
			}
			else//if(colorScheme==BC_L)
			{
#ifdef AVX_H
					 if(simd_method>=2)			cf=colorFunction_bc_l_avx,	idxShift=2, workSize=n.r.size()>>2;
				else
#endif
					 if(simd_method>=1&&SSE4_1)	cf=colorFunction_bc_l_sse2,	idxShift=1, workSize=n.r.size()>>1;
				else							cf=colorFunction_bc_l,		idxShift=0, workSize=n.r.size();
			}
#if defined _DEBUG || defined __GNUC__
			for(int k=0;k<workSize;++k)
#else
			Concurrency::parallel_for(0, workSize, [&](int k)
#endif
			{
				int k2=k<<idxShift;
				cf(CompP(n.r.p+k2, n.i.p+k2), (*prgb)+k2);
			}
#if !defined _DEBUG && !defined __GNUC__
			);
#endif
#ifdef PROFILER
			prof_add("Update RGB");
#endif
		}
	private:
		void shift_		(double *ndr_r, double *ndr_i)
		{
			int XSstart=sa[0], XSend=sa[1], XDstart=sa[2], YSstart=sa[3], YSend=sa[4], YDstart=sa[5];
			auto _First=ndr_r+XSstart, _Last=ndr_r+XSend, _Dest=ndr_r+XDstart;
			auto _First2=ndr_i+XSstart, _Last2=ndr_i+XSend, _Dest2=ndr_i+XDstart;
			auto _First3=rgb+XSstart, _Last3=rgb+XSend, _Dest3=rgb+XDstart;
			for(int ky=Xplaces*YSstart, kyEnd=Xplaces*YSend, kyStep=(ky<kyEnd?1:-1)*Xplaces, ky2=Xplaces*YDstart;ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
			{
				std::copy(_First+ky, _Last+ky, _Dest+ky2);
				std::copy(_First2+ky, _Last2+ky, _Dest2+ky2);
				std::copy(_First3+ky, _Last3+ky, _Dest3+ky2);
			}
		}
		void shift_r	(double *ndr_r, double *ndr_i)
		{
			int ndrSize=Xplaces*Yplaces;
			int XSstart=sa[0], XSend=sa[1], XDstart=sa[2], YSstart=sa[3], YSend=sa[4], YDstart=sa[5];
			auto rb_r=std::reverse_iterator<double*>(ndr_r+ndrSize), rb_i=std::reverse_iterator<double*>(ndr_i+ndrSize);
			auto _First=rb_r+Xplaces-1-XSstart, _Last=rb_r+Xplaces-1-XSend, _Dest=rb_r+Xplaces-1-XDstart;
			auto _First2=rb_i+Xplaces-1-XSstart, _Last2=rb_i+Xplaces-1-XSend, _Dest2=rb_i+Xplaces-1-XDstart;
			auto rb_rgb=std::reverse_iterator<int*>(rgb+ndrSize);
			auto _First3=rb_rgb+Xplaces-1-XSstart, _Last3=rb_rgb+Xplaces-1-XSend, _Dest3=rb_rgb+Xplaces-1-XDstart;
			for(int ky=Xplaces*(Yplaces-1-YSstart), kyEnd=Xplaces*(Yplaces-1-YSend), kyStep=(ky<kyEnd?1:-1)*Xplaces, ky2=Xplaces*(Yplaces-1-YDstart);ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
			{
				std::copy(_First+ky,_Last+ky, _Dest+ky2);
				std::copy(_First2+ky,_Last2+ky, _Dest2+ky2);
				std::copy(_First3+ky,_Last3+ky, _Dest3+ky2);
			}
		}
	//	decltype(&Solve_C2D::shift_) shift;
		typedef void(modes::Solve_C2D::*Shift_fn)(double*, double*);
		Shift_fn shift;
		void solve_range	(Expression &ex, int *a, bool contourOnly)
		{
			int x1=a[0], x2=a[1], y1=a[2], y2=a[3];
			modes::Xstart=Xstart, modes::Xsample=Xsample, modes::Yend=Yend, modes::Ysample=Ysample, modes::T=T;
			modes::Xplaces=Xplaces, modes::Yplaces=Yplaces, modes::Zplaces=1, modes::ndrSize=ndrSize;
			fill_range(ex, choose_fill_fn_2di, 0, x1, x2, y1, y2, 0, 1, Xplaces, Yplaces, 1, Xplaces*Yplaces, xlogscale, ylogscale, false);
			solve(ex, 0, x1, x2, y1, y2, 0, 1, Xplaces, Yplaces, 1);
		//	solve_disc(ex, 0, x1, x2, y1, y2, 0, 1, Xplaces, Yplaces, 1,	0, 0, 0, 0, 0, 0);
			auto &n=ex.n[ex.resultTerm];
			auto ndr_r=(double*)n.r.p, ndr_i=(double*)n.i.p;
			if(contourOnly)
			{
				for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
					for(int kx=ky+x1, kxEnd=ky+x2;kx<kxEnd;++kx)
						rgb[kx]=0xFFFFFF;
			}
			else
			{
				void (*cf)(CompP const&, int*)=colorScheme==BCW?
						colorFunction_bcw
					:	colorFunction_bc_l;
				for(int ky=Xplaces*y1, kyEnd=Xplaces*y2;ky<kyEnd;ky+=Xplaces)
					for(int kx=ky+x1, kxEnd=ky+x2;kx<kxEnd;++kx)
						cf(CompP(ndr_r+kx, ndr_i+kx), rgb+kx);
					//	rgb[kx]=colorFunction(ndr_r[kx], ndr_i[kx]);
			}
		}
		void partial_		(Expression &ex, bool contourOnly){}
		void partial_1		(Expression &ex, bool contourOnly)
		{
			sa[3]=Yplaces-1-sa[3], sa[4]=Yplaces-1-sa[4], sa[5]=Yplaces-1-sa[5];
			auto &n=ex.n[ex.resultTerm];
			(this->*shift)((double*)n.r.p, (double*)n.i.p);
			int	temp=ra[2];	ra[2]=Yplaces-ra[3], ra[3]=Yplaces-temp;
			solve_range(ex, ra, contourOnly);
		}
		void partial_2		(Expression &ex, bool contourOnly)
		{
			sa[3]=Yplaces-1-sa[3], sa[4]=Yplaces-1-sa[4], sa[5]=Yplaces-1-sa[5];
			auto &n=ex.n[ex.resultTerm];
			(this->*shift)((double*)n.r.p, (double*)n.i.p);
			int	temp=ra[2];	ra[2]=Yplaces-ra[3], ra[3]=Yplaces-temp;
				temp=ra[6], ra[6]=Yplaces-ra[7], ra[7]=Yplaces-temp;
			solve_range(ex, ra, contourOnly), solve_range(ex, ra+4, contourOnly);
		}
	public:
		void partial_bounds(double VX, double DX, double VY, double DY, int Xoffset, int Yoffset)
		{
			this->Xstart=VX-DX/2, this->Xsample=DX/Xplaces, this->Yend=VY+DY/2, this->Ysample=DY/Yplaces;
			partial=&Solve_C2D::partial_;
			int Xoffset2=setXplaces(std::abs(Xoffset)), Yoffset2=std::abs(Yoffset);
				 if(Xoffset>0){							 if(Yoffset>0)					shift=&Solve_C2D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,					partial=&Solve_C2D::partial_2,	ra[0]=Xplaces-Xoffset2,	ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces-Yoffset2,			ra[4]=0,				ra[5]=Xplaces,	ra[6]=Yplaces-Yoffset2,	ra[7]=Yplaces;
													else if(Yoffset<0)Yoffset=-Yoffset,	shift=&Solve_C2D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,		sa[5]=Yplaces-1,			partial=&Solve_C2D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yoffset2,					ra[4]=Xplaces-Xoffset2,	ra[5]=Xplaces,	ra[6]=Yoffset2,			ra[7]=Yplaces;
													else								shift=&Solve_C2D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,					partial=&Solve_C2D::partial_1,	ra[0]=Xplaces-Xoffset2,	ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces;}
			else if(Xoffset<0){Xoffset=-Xoffset;		 if(Yoffset>0)					shift=&Solve_C2D::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,					partial=&Solve_C2D::partial_2,	ra[0]=0,				ra[1]=Xoffset2,	ra[2]=0,				ra[3]=Yplaces-Yoffset2,			ra[4]=0,				ra[5]=Xplaces,	ra[6]=Yplaces-Yoffset2,	ra[7]=Yplaces;
													else if(Yoffset<0)Yoffset=-Yoffset,	shift=&Solve_C2D::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,		sa[5]=Yplaces-1,			partial=&Solve_C2D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yoffset2,					ra[4]=0,				ra[5]=Xoffset2,	ra[6]=Yoffset2,			ra[7]=Yplaces;
													else								shift=&Solve_C2D::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,					partial=&Solve_C2D::partial_1,	ra[0]=0,				ra[1]=Xoffset2,	ra[2]=0,				ra[3]=Yplaces;}
			else{										 if(Yoffset>0)					shift=&Solve_C2D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,					partial=&Solve_C2D::partial_1,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=Yplaces-Yoffset2,	ra[3]=Yplaces;
													else if(Yoffset<0)Yoffset=-Yoffset,	shift=&Solve_C2D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,		sa[5]=Yplaces-1,			partial=&Solve_C2D::partial_1,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yoffset2;
													else;}
		}
	//	decltype(&Solve_C2D::partial_) partial;
		void (modes::Solve_C2D::*partial)(Expression&, bool);
	};
	class		Solve_L2D:public Solve
	{
	public:
		Scale &xs, &ys;
		int nX, nY, old_nX, old_nY, ndrSize;//Xplaces*nX+Yplaces*nY
		//double
		//	XXstart, XXstep, XYstart,// XYstep,
		//	YYstart, YYstep, YXstart;// YXstep;
		//int Xplaces, Yplaces, nX, nY, old_nX, old_nY, ndrSize;
		bool enable_disc;
		Disc_fn
			disc_X_in_u, disc_X_in_b, disc_X_in_t, disc_X_out,
			disc_Y_in_u, disc_Y_in_b, disc_Y_in_t, disc_Y_out;
		Solve_L2D(bool enable_disc, Scale &xs, Scale &ys):xs(xs), ys(ys), enable_disc(enable_disc),
			disc_X_in_u(enable_disc?disc_l2d_X_in_u:0), disc_X_in_b(enable_disc?disc_l2d_X_in_b:0), disc_X_in_t(enable_disc?disc_l2d_X_in_t:0), disc_X_out(enable_disc?disc_l2d_X_out:0),
			disc_Y_in_u(enable_disc?disc_l2d_Y_in_u:0), disc_Y_in_b(enable_disc?disc_l2d_Y_in_b:0), disc_Y_in_t(enable_disc?disc_l2d_Y_in_t:0), disc_Y_out(enable_disc?disc_l2d_Y_out:0)
		{}
	private:
		int sa[12],//shift arguments	2 buffers:		XSstart XSend XDstart	YSstart YSend YDstart
			ra[16];//range arguments	2 buffers x 2 rectangles:	x1 x2 y1 y2
	public:
		void full_resize(int Xplaces, int Yplaces)
	//	void full_resize(double VX, double DX, double VY, double DY, double Xsample, double Ysample, int Xplaces, int Yplaces)
		{
			//XYstep=YXstep=step;
			//XXstart=VX-DX/2, XXend=VX+DX/2, XYstart=ceil((VY-DY/2)/XYstep)*XYstep, XYend=floor((VY+DY/2)/XYstep)*XYstep;
			//YYstart=VY-DY/2, YYend=VY+DY/2, YXstart=ceil((VX-DX/2)/YXstep)*YXstep, YXend=floor((VX+DX/2)/YXstep)*YXstep;
			//nX=int(floor(YYend/XYstep)-floor(YYstart/XYstep)), nY=int(floor(XXend/YXstep)-floor(XXstart/YXstep));

		//	this->Xplaces=Xplaces, this->Yplaces=Yplaces;
			XXstart=xs.Xstart, XXstep=xs.Xsample;//, XYstep=ys.Xstep;
			YYstart=ys_Ystart, YYstep=ys.Xsample;//, YXstep=xs.Xstep;
			int XYstart_t=ys.dist2ticks(YYstart), YXstart_t=xs.dist2ticks(XXstart);
			XYstart=ys.ticks2dist(XYstart_t);
			YXstart=xs.ticks2dist(YXstart_t);
			nX=ys.dist2ticks(ys.Xend)+1-XYstart_t, nY=xs.dist2ticks(xs.Xend)+1-YXstart_t, ndrSize=Xplaces*nX+Yplaces*nY;
			//this->Xplaces=Xplaces, this->Yplaces=Yplaces;
			//XYstep=Ysample, YXstep=Xsample;
			//XXstart=VX-DX/2, XXstep=DX/Xplaces;
			//YYstart=VY-DY/2, YYstep=DY/Yplaces;
			//int Xstart=int(ceil(YYstart/XYstep)), Ystart=int(ceil(XXstart/YXstep));
			//XYstart=Xstart*XYstep;
			//YXstart=Ystart*YXstep;
			//nX=int(ceil((VY+DY/2)/XYstep))-Xstart, nY=int(ceil((VX+DX/2)/YXstep))-Ystart, ndrSize=Xplaces*nX+Yplaces*nY;

			//XYstep=YXstep=step;
			//XXstart=VX-DX/2, XXstep=DX/Xplaces;
			//YYstart=VY-DY/2, YYstep=DY/Yplaces;
			//XYstart=ceil(YYstart/XYstep)*XYstep;
			//YXstart=ceil(XXstart/YXstep)*YXstep;
			//nX=int(ceil((VY+DY/2)/XYstep)-ceil(YYstart/XYstep)), nY=int(ceil((VX+DX/2)/YXstep)-ceil(XXstart/YXstep)), ndrSize=Xplaces*nX+Yplaces*nY;
		//	Xdiscs.clear(), Ydiscs.clear();
		}
		void full(Expression &ex)
		{
			unsigned yPos=xs.Xplaces*nX;
			modes::XXstart=xs.Xstart, modes::XXstep=xs.Xsample, modes::XYstart=ys.rXstart, modes::XYstep=ys.Xstep;
			modes::YXstart=xs.rXstart, modes::YXstep=xs.Xstep, modes::YYstart=ys_Ystart, modes::YYstep=ys.Xsample, modes::T=T;
			modes::Xplaces=xs.Xplaces, modes::Yplaces=ys.Xplaces, modes::Zplaces=Zplaces, modes::ndrSize=ndrSize;
			//modes::XXstart=XXstart, modes::XXstep=XXstep, modes::XYstart=XYstart, modes::XYstep=XYstep, modes::T=T;
			//modes::YXstart=YXstart, modes::YXstep=YXstep, modes::YYstart=YYstart, modes::YYstep=YYstep;
			//modes::Xplaces=Xplaces, modes::Yplaces=Yplaces, modes::Zplaces=Zplaces, modes::ndrSize=ndrSize;
			resize_terms(ex, ndrSize);
			fill_range(ex, choose_fill_fn_l2d_X, 0,		0, xs.Xplaces, 0, nX, 0, 1, xs.Xplaces, nX, 1, yPos,			false, false, false);
			fill_range(ex, choose_fill_fn_l2d_Y, yPos,	0, ys.Xplaces, 0, nY, 0, 1, ys.Xplaces, nY, 1, ys.Xplaces*nY,	false, false, false);
			//Xdiscs:	(Xplaces-1) * nX
			//Ydiscs:	(Yplaces-1) * nY
			unsigned yDiscOffset=(xs.Xplaces-1)*nX;
			if(enable_disc)
				ex.discontinuities.assign(yDiscOffset+(ys.Xplaces-1)*nY, false);
			::solve_disc(ex, 0,				0, xs.Xplaces, 0, nX, 0, 1, xs.Xplaces, nX, 1,	disc_X_in_u, disc_X_in_b, disc_X_in_t, disc_X_out, 0, false);
			::solve_disc(ex, xs.Xplaces*nX,	0, ys.Xplaces, 0, nY, 0, 1, ys.Xplaces, nY, 1,	disc_Y_in_u, disc_Y_in_b, disc_Y_in_t, disc_Y_out, (xs.Xplaces-1)*nX, false);
		}
	private:
		void shift_		(double*, double*, std::vector<bool>&){}
		void shift_x	(double *ndr_r, double *ndr_i, std::vector<bool> &discontinuities)
		{
			int &XSstart=sa[0], &XSend=sa[1], &XDstart=sa[2], &YSstart=sa[3], &YSend=sa[4], &YDstart=sa[5];
			{
				auto _First=ndr_r+XSstart, _Last=ndr_r+XSend, _Dest=ndr_r+XDstart;
				auto _First2=ndr_i+XSstart, _Last2=ndr_i+XSend, _Dest2=ndr_i+XDstart;
				for(int ys=xs.Xplaces*YSstart, ysEnd=xs.Xplaces*YSend, yStep=(ys<ysEnd?1:-1)*xs.Xplaces, yd=xs.Xplaces*YDstart;ys!=ysEnd;ys+=yStep, yd+=yStep)
				{
					std::copy(_First+ys, _Last+ys, _Dest+yd);
					std::copy(_First2+ys, _Last2+ys, _Dest2+yd);
				}
			}
			if(XSstart<xs.Xplaces-1)
			{
				auto _First=discontinuities.begin()+XSstart, _Last=discontinuities.begin()+XSend-1, _Dest=discontinuities.begin()+XDstart;
				for(int ys=YSstart*(xs.Xplaces-1), ysEnd=YSend*(xs.Xplaces-1), yStep=(ys<ysEnd?1:-1)*(xs.Xplaces-1), yd=YDstart*(xs.Xplaces-1);ys!=ysEnd;ys+=yStep, yd+=yStep)
					std::copy(_First+ys, _Last+ys, _Dest+yd);
			}
		}
		void shift_xr	(double *ndr_r, double *ndr_i, std::vector<bool> &discontinuities)
		{
			int &XSstart=sa[0], &XSend=sa[1], &XDstart=sa[2], &YSstart=sa[3], &YSend=sa[4], &YDstart=sa[5];
			{
				auto rb_r=std::reverse_iterator<double*>(ndr_r+ndrSize), rb_i=std::reverse_iterator<double*>(ndr_i+ndrSize);
				auto _First=rb_r+ys.Xplaces*nY+xs.Xplaces-1-XSstart, _Last=rb_r+ys.Xplaces*nY+xs.Xplaces-1-XSend, _Dest=rb_r+ys.Xplaces*nY+xs.Xplaces-1-XDstart;
				auto _First2=rb_i+ys.Xplaces*nY+xs.Xplaces-1-XSstart, _Last2=rb_i+ys.Xplaces*nY+xs.Xplaces-1-XSend, _Dest2=rb_i+ys.Xplaces*nY+xs.Xplaces-1-XDstart;
				for(int ys=xs.Xplaces*(nX-1-YSstart), ysEnd=xs.Xplaces*(nX-1-YSend), yStep=xs.Xplaces*(ys<ysEnd?1:-1), yd=xs.Xplaces*(nX-1-YDstart);ys!=ysEnd;ys+=yStep, yd+=yStep)
				{
					std::copy(_First+ys,_Last+ys, _Dest+yd);
					std::copy(_First2+ys,_Last2+ys, _Dest2+yd);
				}
			}
			if(XSstart>0)
			{
				unsigned xDiscROffset=(ys.Xplaces-1)*nY;
				auto _First=discontinuities.rbegin()+xs.Xplaces-2-(XSstart-1), _Last=discontinuities.rbegin()+xs.Xplaces-2-XSend, _Dest=discontinuities.rbegin()+xs.Xplaces-2-(XDstart-1);
				for(int ys=(nX-1-YSstart)*(xs.Xplaces-1), ysEnd=(nX-1-YSend)*(xs.Xplaces-1), yStep=(ys<ysEnd?1:-1)*(xs.Xplaces-1), yd=(nX-1-YDstart)*(xs.Xplaces-1);ys!=ysEnd;ys+=yStep, yd+=yStep)
					std::copy(_First+ys, _Last+ys, _Dest+yd);
			}
		}
		void shift_y	(double *ndr_r, double *ndr_i, std::vector<bool> &discontinuities)
		{
			int &XSstart=sa[6], &XSend=sa[7], &XDstart=sa[8], &YSstart=sa[9], &YSend=sa[10], &YDstart=sa[11];
			{
				auto _First=ndr_r+xs.Xplaces*nX+YSstart, _Last=ndr_r+xs.Xplaces*nX+YSend, _Dest=ndr_r+xs.Xplaces*nX+YDstart;
				auto _First2=ndr_i+xs.Xplaces*nX+YSstart, _Last2=ndr_i+xs.Xplaces*nX+YSend, _Dest2=ndr_i+xs.Xplaces*nX+YDstart;
				for(int xs=ys.Xplaces*XSstart, xsEnd=ys.Xplaces*XSend, xStep=(xs<xsEnd?1:-1)*ys.Xplaces, xd=ys.Xplaces*XDstart;xs!=xsEnd;xs+=xStep, xd+=xStep)
				{
					std::copy(_First+xs, _Last+xs, _Dest+xd);
					std::copy(_First2+xs, _Last2+xs, _Dest2+xd);
				}
			}
			if(YSstart<ys.Xplaces-1)
			{
				unsigned yDiscOffset=(xs.Xplaces-1)*nX;
				auto _First=discontinuities.begin()+yDiscOffset+YSstart, _Last=discontinuities.begin()+yDiscOffset+YSend-1, _Dest=discontinuities.begin()+yDiscOffset+YDstart;
				for(int xs=(ys.Xplaces-1)*XSstart, xsEnd=(ys.Xplaces-1)*XSend, xStep=(xs<xsEnd?1:-1)*(ys.Xplaces-1), xd=(ys.Xplaces-1)*XDstart;xs!=xsEnd;xs+=xStep, xd+=xStep)
					std::copy(_First+xs, _Last+xs, _Dest+xd);
			}
		}
		void shift_yr	(double *ndr_r, double *ndr_i, std::vector<bool> &discontinuities)
		{
			int &XSstart=sa[6], &XSend=sa[7], &XDstart=sa[8], &YSstart=sa[9], &YSend=sa[10], &YDstart=sa[11];
			{
				auto rb_r=std::reverse_iterator<double*>(ndr_r+ndrSize), rb_i=std::reverse_iterator<double*>(ndr_i+ndrSize);
				auto _First=rb_r+ys.Xplaces-1-YSstart, _Last=rb_r+ys.Xplaces-1-YSend, _Dest=rb_r+ys.Xplaces-1-YDstart;
				auto _First2=rb_i+ys.Xplaces-1-YSstart, _Last2=rb_i+ys.Xplaces-1-YSend, _Dest2=rb_i+ys.Xplaces-1-YDstart;
				for(int xs=ys.Xplaces*(nY-1-XSstart), xsEnd=ys.Xplaces*(nY-1-XSend), xStep=(xs<xsEnd?1:-1)*ys.Xplaces, xd=ys.Xplaces*(nY-1-XDstart);xs!=xsEnd;xs+=xStep, xd+=xStep)
				{
					std::copy(_First+xs, _Last+xs, _Dest+xd);
					std::copy(_First2+xs, _Last2+xs, _Dest2+xd);
				}
			}
			if(YSstart>0)
			{
				auto _First=discontinuities.rbegin()+ys.Xplaces-2-(YSstart-1), _Last=discontinuities.rbegin()+ys.Xplaces-2-YSend, _Dest=discontinuities.rbegin()+ys.Xplaces-2-(YDstart-1);
				for(int xs=(ys.Xplaces-1)*(nY-1-XSstart), xsEnd=(ys.Xplaces-1)*(nY-1-XSend), xStep=(xs<xsEnd?1:-1)*(ys.Xplaces-1), xd=(ys.Xplaces-1)*(nY-1-XDstart);xs!=xsEnd;xs+=xStep, xd+=xStep)
					std::copy(_First+xs, _Last+xs, _Dest+xd);
			}
		}
	//	decltype(&Solve_L2D::shift_) shift_X, shift_Y;
		typedef void(modes::Solve_L2D::*Shift_fn)(double*, double*, std::vector<bool>&);
		Shift_fn shift_X, shift_Y;
		void modify_	(Term&, std::vector<bool>&){}
		void modify_Yi	(Term &n, std::vector<bool> &discontinuities)
		{
			n.r.erase(xs.Xplaces*old_nX, ys.Xplaces);
			n.i.erase(xs.Xplaces*old_nX, ys.Xplaces);

			unsigned yDiscOffset=(xs.Xplaces-1)*old_nX;
			discontinuities.erase(
				discontinuities.begin()+yDiscOffset,
				discontinuities.begin()+yDiscOffset+ys.Xplaces-1);
		}
		void modify_YI	(Term &n, std::vector<bool> &discontinuities)
		{
			n.r.insert(xs.Xplaces*old_nX, 0, ys.Xplaces);
			n.i.insert(xs.Xplaces*old_nX, 0, ys.Xplaces);

			unsigned yDiscOffset=(xs.Xplaces-1)*old_nX;
			discontinuities.insert(discontinuities.begin()+yDiscOffset, ys.Xplaces-1, false);
		}
		void modify_Yf	(Term &n, std::vector<bool> &discontinuities)
		{
			n.r.erase((xs.Xplaces*old_nX+ys.Xplaces*(old_nY-1)), ys.Xplaces);
			n.i.erase((xs.Xplaces*old_nX+ys.Xplaces*(old_nY-1)), ys.Xplaces);

			unsigned yDiscOffset=(xs.Xplaces-1)*old_nX;
			discontinuities.erase(
				discontinuities.begin()+yDiscOffset+(ys.Xplaces-1)*(old_nY-1),
				discontinuities.begin()+yDiscOffset+(ys.Xplaces-1)*old_nY);
		}
		void modify_YF	(Term &n, std::vector<bool> &discontinuities)
		{
			n.r.insert((xs.Xplaces*old_nX+ys.Xplaces*old_nY), 0, ys.Xplaces);
			n.i.insert((xs.Xplaces*old_nX+ys.Xplaces*old_nY), 0, ys.Xplaces);

			discontinuities.insert(discontinuities.end(), ys.Xplaces-1, false);
		}
		void modify_Xi	(Term &n, std::vector<bool> &discontinuities)
		{
			n.r.erase(0, xs.Xplaces);
			n.i.erase(0, xs.Xplaces);

			discontinuities.erase(
				discontinuities.begin(),
				discontinuities.begin()+xs.Xplaces-1);
		}
		void modify_XI	(Term &n, std::vector<bool> &discontinuities)
		{
			n.r.insert(0, 0, xs.Xplaces);
			n.i.insert(0, 0, xs.Xplaces);

			discontinuities.insert(discontinuities.begin(), xs.Xplaces-1, false);
		}
		void modify_Xf	(Term &n, std::vector<bool> &discontinuities)
		{
			n.r.erase(xs.Xplaces*(old_nX-1), xs.Xplaces);
			n.i.erase(xs.Xplaces*(old_nX-1), xs.Xplaces);

			discontinuities.erase(
				discontinuities.begin()+(xs.Xplaces-1)*(old_nX-1),
				discontinuities.begin()+(xs.Xplaces-1)*old_nX);
		}
		void modify_XF	(Term &n, std::vector<bool> &discontinuities)
		{
		//	ndr_to_clipboard_l2d(expr[0].n[expr[0].resultTerm], xs.Xplaces, old_nX, ys.Xplaces, old_nY);//
			n.r.insert(xs.Xplaces*old_nX, 0, xs.Xplaces);
			n.i.insert(xs.Xplaces*old_nX, 0, xs.Xplaces);
		//	ndr_to_clipboard_l2d(expr[0].n[expr[0].resultTerm], xs.Xplaces, nX, ys.Xplaces, nY);//

			discontinuities.insert(discontinuities.begin()+(xs.Xplaces-1)*old_nX, xs.Xplaces-1, false);
		}
		typedef void(modes::Solve_L2D::*Modify_fn)(Term&, std::vector<bool>&);
		Modify_fn modify_X, modify_Y;
		void solve_range_X(Expression &ex, int *a)
		{
			int &x1=a[0], &x2=a[1], &y1=a[2], &y2=a[3];
			modes::XXstart=xs.Xstart, modes::XXstep=xs.Xsample, modes::XYstart=ys.rXstart, modes::XYstep=ys.Xstep, modes::T=T;
		//	modes::XXstart=XXstart, modes::XXstep=XXstep, modes::XYstart=XYstart, modes::XYstep=XYstep, modes::T=T;
			fill_range(ex, choose_fill_fn_l2d_X, 0, x1, x2, y1, y2, 0, 1, xs.Xplaces, nX, 1, xs.Xplaces*nX, false, false, false);
			if(enable_disc)
				for(int y=y1;y<y2;++y)
					for(int x=x1;x<x2-1;++x)
						ex.discontinuities[(xs.Xplaces-1)*y+x]=false;
			::solve_disc(ex, 0, x1, x2, y1, y2, 0, 1, xs.Xplaces, nY, 1,		disc_X_in_u, disc_X_in_b, disc_X_in_t, disc_X_out, 0, false);
		}
		void solve_range_Y(Expression &ex, int *a)
		{
			int &x1=a[0], &x2=a[1], &y1=a[2], &y2=a[3];
			modes::YXstart=xs.rXstart, modes::YXstep=xs.Xstep, modes::YYstart=ys_Ystart, modes::YYstep=ys.Xsample, modes::T=T;
		//	modes::YXstart=YXstart, modes::YXstep=YXstep, modes::YYstart=YYstart, modes::YYstep=YYstep, modes::T=T;
			fill_range(ex, choose_fill_fn_l2d_Y, xs.Xplaces*nX, y1, y2, x1, x2, 0, 1, ys.Xplaces, nY, 1, ys.Xplaces*nY, false, false, false);
			int yPos=xs.Xplaces*nX, yDiscPos=(xs.Xplaces-1)*nX;
			if(enable_disc)
				for(int x=x1;x<x2;++x)
					for(int y=y1;y<y2-1;++y)
						ex.discontinuities[yDiscPos+(ys.Xplaces-1)*x+y]=false;
			::solve_disc(ex, yPos, y1, y2, x1, x2, 0, 1, ys.Xplaces, nY, 1,	disc_Y_in_u, disc_Y_in_b, disc_Y_in_t, disc_Y_out, yDiscPos, false);//x and y swapped
		}
		void range_		(Expression&){}
		void range_xx	(Expression &ex){solve_range_X(ex, ra), solve_range_X(ex, ra+4);}
		void range_x	(Expression &ex){solve_range_X(ex, ra);}
		void range_yy	(Expression &ex){solve_range_Y(ex, ra+8), solve_range_Y(ex, ra+12);}
		void range_y	(Expression &ex){solve_range_Y(ex, ra+8);}
	//	decltype(&Solve_L2D::range_) range_X, range_Y;
		typedef void(modes::Solve_L2D::*Range_fn)(Expression&);
		Range_fn range_X, range_Y;
	public:
		void partial_bounds(double VX, double DX, double VY, double DY, int Xoffset, int Yoffset)
		{
			int XDstart, XDend, YDstart, YDend;
			auto &Xplaces=xs.Xplaces, &Yplaces=ys.Xplaces;
			{
				old_nX=nX, old_nY=nY;
				int old_Xstart=int(ceil(YYstart/XYstep)), old_Ystart=int(ceil(XXstart/YXstep));

				XXstart=VX-DX/2, XXstep=DX/Xplaces;
				YYstart=VY-DY/2, YYstep=DY/Yplaces;
				int Xstart=int(ceil(YYstart/XYstep)), Ystart=int(ceil(XXstart/YXstep));
				XYstart=Xstart*XYstep;
				YXstart=Ystart*YXstep;
				nX=int(ceil((VY+DY/2)/XYstep))-Xstart, nY=int(ceil((VX+DX/2)/YXstep))-Ystart;

				XDstart=abs(Xstart-old_Xstart), XDend=abs(Xstart+nX-(old_Xstart+old_nX)), YDstart=abs(Ystart-old_Ystart), YDend=abs(Ystart+nY-(old_Ystart+old_nY));//*/
			}

		/*	shift_Y
				shift_																	!nY
				shift_y																	nY	Yoffset>0
				shift_yr																nY	Yoffset<0

			shift_X
				shift_																	!nX
				shift_x																	nX	Xoffset>0
				shift_xr																nX	Xoffset<0

			modify_Y
				modify_																	YDstart==	YDend		||	Xoffset==0
				modify_Yi																YDstart>	YDend		&&	Xoffset>0
				modify_YF																YDstart<	YDend		&&	Xoffset>0
				modify_YI																YDstart>	YDend		&&	Xoffset<0
				modify_Yf																YDstart<	YDend		&&	Xoffset<0

			modify_X
				modify_																	XDstart==	XDend		||	Yoffset==0
				modify_Xi																XDstart>	XDend		&&	Yoffset>0
				modify_XF																XDstart<	XDend		&&	Yoffset>0
				modify_XI																XDstart>	XDend		&&	Yoffset<0
				modify_Xf																XDstart<	XDend		&&	Yoffset<0

			sa[0], sa[1], sa[2]
				Xoffset,			Xplaces,	0										Xoffset>0	&&	nX
				Xplaces-1-Xoffset,	-1,			Xplaces-1								Xoffset<0	&&	nX
				0,					Xplaces,	0										Xoffset==0	&&	nX	&&	(Yoffset>0	&&	(XDstart>	XDend	&&	XDstart-1	||	XDstart)	||	Yoffset<0	&&	(XDstart<	XDend	&&	XDend-1	||	XDend))

			sa[3], sa[4], sa[5]
				XDstart,			nX,			0										Xoffset!=0	&&	Yoffset>0	&&	nX	&&	XDstart==	XDend	||	Yoffset>0	&&	XDstart==	XDend	&&	XDstart
				XDstart-1,			nX,			0										Xoffset!=0	&&	Yoffset>0	&&	nX	&&	XDstart>	XDend	||	Yoffset>0	&&	XDstart>	XDend	&&	XDstart-1
				XDstart,			nX-1,		0										Xoffset!=0	&&	Yoffset>0	&&	nX	&&	XDstart<	XDend	||	Yoffset>0	&&	XDstart<	XDend	&&	XDstart
				nX-1-XDend,			-1,			nX-1									Xoffset!=0	&&	Yoffset<0	&&	nX	&&	XDstart==	XDend	||	Yoffset<0	&&	XDstart==	XDend	&&	XDend
				nX-1-XDend,			0,			nX-1									Xoffset!=0	&&	Yoffset<0	&&	nX	&&	XDstart>	XDend	||	Yoffset<0	&&	XDstart>	XDend	&&	XDend
				nX-1-(XDend-1),		-1,			nX-1									Xoffset!=0	&&	Yoffset<0	&&	nX	&&	XDstart<	XDend	||	Yoffset<0	&&	XDstart<	XDend	&&	XDend-1

			sa[6], sa[7], sa[8]
				YDstart,			nY,			0										Yoffset!=0	&&	Xoffset>0	&&	nY	&&	YDstart==	YDend	||	Xoffset>0	&&	YDstart==	YDend	&&	YDstart
				YDstart-1,			nY,			0										Yoffset!=0	&&	Xoffset>0	&&	nY	&&	YDstart>	YDend	||	Xoffset>0	&&	YDstart>	YDend	&&	YDstart-1
				YDstart,			nY-1,		0										Yoffset!=0	&&	Xoffset>0	&&	nY	&&	YDstart<	YDend	||	Xoffset>0	&&	YDstart<	YDend	&&	YDstart
				nY-1-YDend,			-1,			nY-1									Yoffset!=0	&&	Xoffset<0	&&	nY	&&	YDstart==	YDend	||	Xoffset<0	&&	YDstart==	YDend	&&	YDend
				nY-1-YDend,			0,			nY-1									Yoffset!=0	&&	Xoffset<0	&&	nY	&&	YDstart>	YDend	||	Xoffset<0	&&	YDstart>	YDend	&&	YDend
				nY-1-(YDend-1),		-1,			nY-1									Yoffset!=0	&&	Xoffset<0	&&	nY	&&	YDstart<	YDend	||	Xoffset<0	&&	YDstart<	YDend	&&	YDend-1

			sa[9], sa[10], sa[11]
				Yoffset,			Yplaces,	0										Yoffset>0	&&	nY
				Yplaces-1-Yoffset,	-1,			Yplaces-1								Yoffset<0	&&	nY
				0,					Yplaces,	0										Yoffset==0	&&	nY	&&	(Xoffset>0	&&	(YDstart>	YDend	&&	YDstart-1	||	YDstart)	||	Xoffset<0	&&	(YDstart<	YDend	&&	YDend-1	||	YDend))

			ra[0], ra[1], ra[2], ra[3], ra[4], ra[5], ra[6], ra[7]
				Xplaces-Xoffset,	Xplaces,	0,					nX-XDend		0,					Xplaces,	nX-XDend,			nX					nX	&&	Xoffset>0	&&	Yoffset>0	&&	XDend
				0,					Xplaces,	0,					XDstart			Xplaces-Xoffset,	Xplaces,	XDstart,			nX					nX	&&	Xoffset>0	&&	Yoffset<0	&&	XDstart
				Xplaces-Xoffset,	Xplaces,	0,					nX																						nX	&&	Xoffset>0	&&	(Yoffset>0	&&	!XDend	||	Yoffset<0	&&	!XDstart	||	!Yoffset)
				0,					Xoffset,	0,					nX-XDend		0,					Xplaces,	nX-XDend,			nX					nX	&&	Xoffset<0	&&	Yoffset>0	&&	XDend
				0,					Xplaces,	0,					XDstart			0,					Xoffset,	XDstart,			nX					nX	&&	Xoffset<0	&&	Yoffset<0	&&	XDstart
				0,					Xoffset,	0,					nX																						nX	&&	Xoffset<0	&&	(Yoffset>0	&&	!XDend	||	Yoffset<0	&&	!XDstart	||	!Yoffset)
				0,					Xplaces,	nX-XDend,			nX																								!Xoffset	&&	Yoffset>0	&&	XDend
				0,					Xplaces,	0,					XDstart																							!Xoffset	&&	Yoffset<0	&&	XDstart

			ra[8], ra[9], ra[10], ra[11], ra[12], ra[13], ra[14], ra[15]
				0,					nY-YDend,	Yplaces-Yoffset,	Yplaces			nY-YDend,			nY,			0,					Yplaces				nY	&&	Xoffset>0	&&	Yoffset>0	&&	YDend
				0,					nY,			Yplaces-Yoffset,	Yplaces																					nY	&&	Xoffset>0	&&	Yoffset>0	&&	!YDend
				0,					nY-YDend,	0,					Yoffset			nY-YDend,			nY,			0,					Yplaces				nY	&&	Xoffset>0	&&	Yoffset<0	&&	YDend
				0,					nY,			0,					Yoffset																					nY	&&	Xoffset>0	&&	Yoffset<0	&&	!YDend
				nY-YDend,			nY,			0,					Yplaces																							Xoffset>0	&&	!Yoffset	&&	YDend
				0,					YDstart,	0,					Yplaces			YDstart,			nY,			Yplaces-Yoffset,	Yplaces				nY	&&	Xoffset<0	&&	Yoffset>0	&&	YDstart
				0,					nY,			Yplaces-Yoffset,	Yplaces																					nY	&&	Xoffset<0	&&	Yoffset>0	&&	!YDstart
				0,					YDstart,	0,					Yplaces			YDstart,			nY,			0,					Yoffset				nY	&&	Xoffset<0	&&	Yoffset<0	&&	YDstart
				0,					nY,			0,					Yplaces																					nY	&&	Xoffset<0	&&	Yoffset<0	&&	!YDstart
				0,					YDstart,	0,					Yplaces																							Xoffset<0	&&	!Yoffset	&&	YDstart
				0,					nY,			Yplaces-Yoffset,	Yplaces																					nY	&&	!Xoffset	&&	Yoffset>0
				0,					nY,			0,					Yoffset																					nY	&&	!Xoffset	&&	Yoffset<0
			*/
				 if(Xoffset>0)	{						 if(Yoffset>0)	{						 if(nY)	{	shift_Y=(Shift_fn)&Solve_L2D::shift_y;		 if(YDstart==	YDend)				modify_Y=&Solve_L2D::modify_,																sa[6]=YDstart,				sa[7]=nY,			sa[8]=0,			sa[9]=Yoffset,				sa[10]=Yplaces,	sa[11]=0;
																																					else if(YDstart>	YDend)				modify_Y=&Solve_L2D::modify_Yi,															sa[6]=YDstart-1,			sa[7]=nY,			sa[8]=0,			sa[9]=Yoffset,				sa[10]=Yplaces,	sa[11]=0;
																																					else if(YDstart<	YDend)				modify_Y=&Solve_L2D::modify_YF,															sa[6]=YDstart,				sa[7]=nY-1,			sa[8]=0,			sa[9]=Yoffset,				sa[10]=Yplaces,	sa[11]=0;
																																																																																																							if(YDend)	range_Y=&Solve_L2D::range_yy,		++Yoffset,	ra[8]=0,				ra[9]=nY-YDend,	ra[10]=Yplaces-Yoffset,	ra[11]=Yplaces,		ra[12]=nY-YDend,		ra[13]=nY,		ra[14]=0,				ra[15]=Yplaces;
																																																																																																						else			range_Y=&Solve_L2D::range_y,		++Yoffset,	ra[8]=0,				ra[9]=nY,		ra[10]=Yplaces-Yoffset,	ra[11]=Yplaces;																							}
																							else		{	shift_Y=(Shift_fn)&Solve_L2D::shift_;		 if(YDstart==	YDend)				modify_Y=&Solve_L2D::modify_;
																																					else if(YDstart>	YDend)				modify_Y=&Solve_L2D::modify_Yi;
																																					else if(YDstart<	YDend)				modify_Y=&Solve_L2D::modify_YF;																																																				range_Y=&Solve_L2D::range_;																																												}
																								 if(nX)	{	shift_X=(Shift_fn)&Solve_L2D::shift_x;		 if(XDstart==	XDend)		modify_X=&Solve_L2D::modify_,																		sa[0]=Xoffset,				sa[1]=Xplaces,		sa[2]=0,			sa[3]=XDstart,				sa[4]=nX,		sa[5]=0;
																																					else if(XDstart>	XDend)		modify_X=&Solve_L2D::modify_Xi,																	sa[0]=Xoffset,				sa[1]=Xplaces,		sa[2]=0,			sa[3]=XDstart-1,			sa[4]=nX,		sa[5]=0;
																																					else if(XDstart<	XDend)		modify_X=&Solve_L2D::modify_XF,																	sa[0]=Xoffset,				sa[1]=Xplaces,		sa[2]=0,			sa[3]=XDstart,				sa[4]=nX-1,		sa[5]=0;
																																																																																																							if(XDend)	range_X=&Solve_L2D::range_xx,		++Xoffset,	ra[0]=Xplaces-Xoffset,	ra[1]=Xplaces,	ra[2]=0,				ra[3]=nX-XDend,		ra[4]=0,				ra[5]=Xplaces,	ra[6]=nX-XDend,			ra[7]=nX;
																																																																																																						else			range_X=&Solve_L2D::range_x,		++Xoffset,	ra[0]=Xplaces-Xoffset,	ra[1]=Xplaces,	ra[2]=0,				ra[3]=nX;																								}
																							else		{	shift_X=(Shift_fn)&Solve_L2D::shift_;		 if(XDstart==	XDend)		modify_X=&Solve_L2D::modify_;
																																					else if(XDstart>	XDend)		modify_X=&Solve_L2D::modify_Xi;
																																					else if(XDstart<	XDend)		modify_X=&Solve_L2D::modify_XF;																																																						range_X=&Solve_L2D::range_;																																												}}
													else if(Yoffset<0)	{Yoffset=-Yoffset;		 if(nY)	{	shift_Y=(Shift_fn)&Solve_L2D::shift_yr;		 if(YDstart==	YDend)				modify_Y=&Solve_L2D::modify_,																sa[6]=YDstart,				sa[7]=nY,			sa[8]=0,			sa[9]=Yplaces-1-Yoffset,	sa[10]=-1,		sa[11]=Yplaces-1;
																																					else if(YDstart>	YDend)				modify_Y=&Solve_L2D::modify_Yi,															sa[6]=YDstart-1,			sa[7]=nY,			sa[8]=0,			sa[9]=Yplaces-1-Yoffset,	sa[10]=-1,		sa[11]=Yplaces-1;
																																					else if(YDstart<	YDend)				modify_Y=&Solve_L2D::modify_YF,															sa[6]=YDstart,				sa[7]=nY-1,			sa[8]=0,			sa[9]=Yplaces-1-Yoffset,	sa[10]=-1,		sa[11]=Yplaces-1;
																																																																																																							if(YDend)	range_Y=&Solve_L2D::range_yy,		++Yoffset,	ra[8]=0,				ra[9]=nY-YDend,	ra[10]=0,				ra[11]=Yoffset,		ra[12]=nY-YDend,		ra[13]=nY,		ra[14]=0,				ra[15]=Yplaces;
																																																																																																						else			range_Y=&Solve_L2D::range_y,		++Yoffset,	ra[8]=0,				ra[9]=nY,		ra[10]=0,				ra[11]=Yoffset;																							}
																							else		{	shift_Y=(Shift_fn)&Solve_L2D::shift_;		 if(YDstart==	YDend)				modify_Y=&Solve_L2D::modify_;
																																					else if(YDstart>	YDend)				modify_Y=&Solve_L2D::modify_Yi;
																																					else if(YDstart<	YDend)				modify_Y=&Solve_L2D::modify_YF;																																																				range_Y=&Solve_L2D::range_;																																												}
																								 if(nX)	{	shift_X=(Shift_fn)&Solve_L2D::shift_x;		 if(XDstart==	XDend)		modify_X=&Solve_L2D::modify_,																		sa[0]=Xoffset,				sa[1]=Xplaces,		sa[2]=0,			sa[3]=nX-1-XDend,			sa[4]=-1,		sa[5]=nX-1;
																																					else if(XDstart>	XDend)		modify_X=&Solve_L2D::modify_XI,																	sa[0]=Xoffset,				sa[1]=Xplaces,		sa[2]=0,			sa[3]=nX-1-XDend,			sa[4]=0,		sa[5]=nX-1;
																																					else if(XDstart<	XDend)		modify_X=&Solve_L2D::modify_Xf,																	sa[0]=Xoffset,				sa[1]=Xplaces,		sa[2]=0,			sa[3]=nX-1-(XDend-1),		sa[4]=-1,		sa[5]=nX-1;
																																																																																																							if(XDstart)	range_X=&Solve_L2D::range_xx,		++Xoffset,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=XDstart,		ra[4]=Xplaces-Xoffset,	ra[5]=Xplaces,	ra[6]=XDstart,			ra[7]=nX;
																																																																																																						else			range_X=&Solve_L2D::range_x,		++Xoffset,	ra[0]=Xplaces-Xoffset,	ra[1]=Xplaces,	ra[2]=0,				ra[3]=nX;																								}
																							else		{	shift_X=(Shift_fn)&Solve_L2D::shift_;		 if(XDstart==	XDend)		modify_X=&Solve_L2D::modify_;
																																					else if(XDstart>	XDend)		modify_X=&Solve_L2D::modify_XI;
																																					else if(XDstart<	XDend)		modify_X=&Solve_L2D::modify_Xf;																																																					range_X=&Solve_L2D::range_;																																												}}
													else				{																												modify_X=&Solve_L2D::modify_;				 if(nX)			shift_X=&Solve_L2D::shift_x,	sa[0]=Xoffset,				sa[1]=Xplaces,		sa[2]=0,			sa[3]=0,					sa[4]=nX,		sa[5]=0,						range_X=&Solve_L2D::range_x,		++Xoffset,	ra[0]=Xplaces-Xoffset,	ra[1]=Xplaces,	ra[2]=0,				ra[3]=nX;
																																																								else				shift_X=&Solve_L2D::shift_,																																						range_X=&Solve_L2D::range_;
																																						 if(YDstart==	YDend)	{			modify_Y=&Solve_L2D::modify_;			 if(YDstart)	shift_Y=&Solve_L2D::shift_y,	sa[6]=YDstart,				sa[7]=nY,			sa[8]=0,			sa[9]=0,					sa[10]=Yplaces,	sa[11]=0;
																																																								else				shift_Y=&Solve_L2D::shift_;																																																																																									}
																																					else if(YDstart>	YDend)	{			modify_Y=&Solve_L2D::modify_Yi;			 if(YDstart-1)	shift_Y=&Solve_L2D::shift_y,	sa[6]=YDstart-1,			sa[7]=nY,			sa[8]=0,			sa[9]=0,					sa[10]=Yplaces,	sa[11]=0;
																																																								else				shift_Y=&Solve_L2D::shift_;																																																																																									}
																																					else if(YDstart<	YDend)	{			modify_Y=&Solve_L2D::modify_YF;			 if(YDstart)	shift_Y=&Solve_L2D::shift_y,	sa[6]=YDstart,				sa[7]=nY-1,			sa[8]=0,			sa[9]=0,					sa[10]=Yplaces,	sa[11]=0;
																																																								else				shift_Y=&Solve_L2D::shift_;																																																																																									}
																																																																																																							 if(YDend)	range_Y=&Solve_L2D::range_y,					ra[8]=nY-YDend,			ra[9]=nY,		ra[10]=0,				ra[11]=Yplaces;
																																																																																																						else			range_Y=&Solve_L2D::range_;																																												}}
			else if(Xoffset<0)	{Xoffset=-Xoffset;		 if(Yoffset>0)	{						 if(nY)	{	shift_Y=(Shift_fn)&Solve_L2D::shift_y;		 if(YDstart==	YDend)				modify_Y=&Solve_L2D::modify_,																sa[6]=nY-1-YDend,			sa[7]=-1,			sa[8]=nY-1,			sa[9]=Yoffset,				sa[10]=Yplaces,	sa[11]=0;
																																					else if(YDstart>	YDend)				modify_Y=&Solve_L2D::modify_YI,															sa[6]=nY-1-YDend,			sa[7]=0,			sa[8]=nY-1,			sa[9]=Yoffset,				sa[10]=Yplaces,	sa[11]=0;
																																					else if(YDstart<	YDend)				modify_Y=&Solve_L2D::modify_Yf,															sa[6]=nY-1-(YDend-1),		sa[7]=-1,			sa[8]=nY-1,			sa[9]=Yoffset,				sa[10]=Yplaces,	sa[11]=0;																																																									
																																																																																																							 if(YDstart)range_Y=&Solve_L2D::range_yy,		++Yoffset,	ra[8]=0,				ra[9]=YDstart,	ra[10]=0,				ra[11]=Yplaces,		ra[12]=YDstart,			ra[13]=nY,		ra[14]=Yplaces-Yoffset,	ra[15]=Yplaces;
																																																																																																						else			range_Y=&Solve_L2D::range_y,		++Yoffset,	ra[8]=0,				ra[9]=nY,		ra[10]=Yplaces-Yoffset,	ra[11]=Yplaces;																							}
																							else		{	shift_Y=(Shift_fn)&Solve_L2D::shift_;		 if(YDstart==	YDend)				modify_Y=&Solve_L2D::modify_;
																																					else if(YDstart>	YDend)				modify_Y=&Solve_L2D::modify_YI;
																																					else if(YDstart<	YDend)				modify_Y=&Solve_L2D::modify_Yf;																																																			range_Y=&Solve_L2D::range_;																																												}
																								 if(nX)	{	shift_X=(Shift_fn)&Solve_L2D::shift_xr;		 if(XDstart==	XDend)		modify_X=&Solve_L2D::modify_,																		sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,			sa[2]=Xplaces-1,	sa[3]=XDstart,				sa[4]=nX,		sa[5]=0;
																																					else if(XDstart>	XDend)		modify_X=&Solve_L2D::modify_Xi,																	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,			sa[2]=Xplaces-1,	sa[3]=XDstart-1,			sa[4]=nX,		sa[5]=0;
																																					else if(XDstart<	XDend)		modify_X=&Solve_L2D::modify_XF,																	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,			sa[2]=Xplaces-1,	sa[3]=XDstart,				sa[4]=nX-1,		sa[5]=0;																																																									
																																																																																																							 if(XDend)	range_X=&Solve_L2D::range_xx,		++Xoffset,	ra[0]=0,				ra[1]=Xoffset,	ra[2]=0,				ra[3]=nX-XDend,		ra[4]=0,				ra[5]=Xplaces,	ra[6]=nX-XDend,			ra[7]=nX;
																																																																																																						else			range_X=&Solve_L2D::range_x,		++Xoffset,	ra[0]=0,				ra[1]=Xoffset,	ra[2]=0,				ra[3]=nX;																								}
																							else		{	shift_X=(Shift_fn)&Solve_L2D::shift_;		 if(XDstart==	XDend)		modify_X=&Solve_L2D::modify_;
																																					else if(XDstart>	XDend)		modify_X=&Solve_L2D::modify_Xi;
																																					else if(XDstart<	XDend)		modify_X=&Solve_L2D::modify_XF;																																																					range_X=&Solve_L2D::range_;																																												}}
													else if(Yoffset<0)	{Yoffset=-Yoffset;		 if(nY)	{	shift_Y=(Shift_fn)&Solve_L2D::shift_yr;		 if(YDstart==	YDend)				modify_Y=&Solve_L2D::modify_,																sa[6]=nY-1-YDend,			sa[7]=-1,			sa[8]=nY-1,			sa[9]=Yplaces-1-Yoffset,	sa[10]=-1,		sa[11]=Yplaces-1;
																																					else if(YDstart>	YDend)				modify_Y=&Solve_L2D::modify_YI,															sa[6]=nY-1-YDend,			sa[7]=0,			sa[8]=nY-1,			sa[9]=Yplaces-1-Yoffset,	sa[10]=-1,		sa[11]=Yplaces-1;
																																					else if(YDstart<	YDend)				modify_Y=&Solve_L2D::modify_Yf,															sa[6]=nY-1-(YDend-1),		sa[7]=-1,			sa[8]=nY-1,			sa[9]=Yplaces-1-Yoffset,	sa[10]=-1,		sa[11]=Yplaces-1;																																																							
																																																																																																							 if(YDstart)range_Y=&Solve_L2D::range_yy,		++Yoffset,	ra[8]=0,				ra[9]=YDstart,	ra[10]=0,				ra[11]=Yplaces,		ra[12]=YDstart,			ra[13]=nY,		ra[14]=0,				ra[15]=Yoffset;
																																																																																																						else			range_Y=&Solve_L2D::range_y,					ra[8]=0,				ra[9]=nY,		ra[10]=0,				ra[11]=Yplaces;																							}
																							else		{	shift_Y=(Shift_fn)&Solve_L2D::shift_;		 if(YDstart==	YDend)				modify_Y=&Solve_L2D::modify_;
																																					else if(YDstart>	YDend)				modify_Y=&Solve_L2D::modify_YI;
																																					else if(YDstart<	YDend)				modify_Y=&Solve_L2D::modify_Yf;																																																			range_Y=&Solve_L2D::range_;																																												}
																								 if(nX)	{	shift_X=(Shift_fn)&Solve_L2D::shift_xr;		 if(XDstart==	XDend)		modify_X=&Solve_L2D::modify_,																		sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,			sa[2]=Xplaces-1,	sa[3]=nX-1-XDend,			sa[4]=-1,		sa[5]=nX-1;
																																					else if(XDstart>	XDend)		modify_X=&Solve_L2D::modify_XI,																	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,			sa[2]=Xplaces-1,	sa[3]=nX-1-XDend,			sa[4]=0,		sa[5]=nX-1;
																																					else if(XDstart<	XDend)		modify_X=&Solve_L2D::modify_Xf,																	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,			sa[2]=Xplaces-1,	sa[3]=nX-1-(XDend-1),		sa[4]=-1,		sa[5]=nX-1;																																																									
																																																																																																							 if(XDstart)range_X=&Solve_L2D::range_xx,		++Xoffset,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=XDstart,		ra[4]=0,				ra[5]=Xoffset,	ra[6]=XDstart,			ra[7]=nX;
																																																																																																						else			range_X=&Solve_L2D::range_x,		++Xoffset,	ra[0]=0,				ra[1]=Xoffset,	ra[2]=0,				ra[3]=nX;																								}
																							else		{	shift_X=(Shift_fn)&Solve_L2D::shift_;		 if(XDstart==	XDend)		modify_X=&Solve_L2D::modify_;
																																					else if(XDstart>	XDend)		modify_X=&Solve_L2D::modify_XI;
																																					else if(XDstart<	XDend)		modify_X=&Solve_L2D::modify_Xf;																																																					range_X=&Solve_L2D::range_;																																												}}
													else				{																										modify_X=&Solve_L2D::modify_;					 if(nX)			shift_X=&Solve_L2D::shift_xr,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,			sa[2]=Xplaces-1,	sa[3]=0,					sa[4]=nX,		sa[5]=0,						range_X=&Solve_L2D::range_x,		++Xoffset,	ra[0]=0,				ra[1]=Xoffset,	ra[2]=0,				ra[3]=nX;
																																																							else				shift_X=&Solve_L2D::shift_,																																						range_X=&Solve_L2D::range_;
																																						 if(YDstart==	YDend)	{			modify_Y=&Solve_L2D::modify_;		 if(YDend)		shift_Y=&Solve_L2D::shift_y,	sa[6]=nY-1-YDend,			sa[7]=-1,			sa[8]=nY-1,			sa[9]=0,					sa[10]=Yplaces,	sa[11]=0;
																																																							else				shift_Y=&Solve_L2D::shift_;																																																																																									}
																																					else if(YDstart>	YDend)	{			modify_Y=&Solve_L2D::modify_YI;		 if(YDend)		shift_Y=&Solve_L2D::shift_y,	sa[6]=nY-1-YDend,			sa[7]=0,			sa[8]=nY-1,			sa[9]=0,					sa[10]=Yplaces,	sa[11]=0;
																																																							else				shift_Y=&Solve_L2D::shift_;																																																																																									}
																																					else if(YDstart<	YDend)	{			modify_Y=&Solve_L2D::modify_Yf;		 if(YDend-1)	shift_Y=&Solve_L2D::shift_y,	sa[6]=nY-1-(YDend-1),		sa[7]=-1,			sa[8]=nY-1,			sa[9]=0,					sa[10]=Yplaces,	sa[11]=0;
																																																							else				shift_Y=&Solve_L2D::shift_;																																																																																									}
																																																																																																							 if(YDstart)range_Y=&Solve_L2D::range_y,					ra[8]=0,				ra[9]=YDstart,	ra[10]=0,				ra[11]=Yplaces;
																																																																																																						else			range_Y=&Solve_L2D::range_;																																												}}
			else				{																																						modify_Y=&Solve_L2D::modify_;
															if(Yoffset>0)	{																																					 if(nY)			shift_Y=&Solve_L2D::shift_y,	sa[6]=0,					sa[7]=nY,			sa[8]=0,			sa[9]=Yoffset,				sa[10]=Yplaces,	sa[11]=0,						range_Y=&Solve_L2D::range_y,		++Yoffset,	ra[8]=0,				ra[9]=nY,		ra[10]=Yplaces-Yoffset,	ra[11]=Yplaces;
																																																							else				shift_Y=&Solve_L2D::shift_,																																					range_Y=&Solve_L2D::range_;
																																						 if( XDstart==	XDend)	{	modify_X=&Solve_L2D::modify_;				 if(XDstart)	shift_X=&Solve_L2D::shift_x,	sa[0]=0,					sa[1]=Xplaces,		sa[2]=0,			sa[3]=XDstart,				sa[4]=nX,		sa[5]=0;
																																																							else				shift_X=&Solve_L2D::shift_;																																																																																									}
																																					else if( XDstart>	XDend)	{	modify_X=&Solve_L2D::modify_Xi;				 if(XDstart-1)	shift_X=&Solve_L2D::shift_x,	sa[0]=0,					sa[1]=Xplaces,		sa[2]=0,			sa[3]=XDstart-1,			sa[4]=nX,		sa[5]=0;
																																																							else				shift_X=&Solve_L2D::shift_;																																																																																									}
																																					else if( XDstart<	XDend)	{	modify_X=&Solve_L2D::modify_XF;				 if(XDstart)	shift_X=&Solve_L2D::shift_x,	sa[0]=0,					sa[1]=Xplaces,		sa[2]=0,			sa[3]=XDstart,				sa[4]=nX-1,		sa[5]=0;
																																																							else				shift_X=&Solve_L2D::shift_;																																																																																									}
																																																																																																							 if(XDend)	range_X=&Solve_L2D::range_x,					ra[0]=0,				ra[1]=Xplaces,	ra[2]=nX-XDend,			ra[3]=nX;
																																																																																																						else			range_X=&Solve_L2D::range_;																																												}
													else if(Yoffset<0)	{Yoffset=-Yoffset;																																		 if(nY)			shift_Y=&Solve_L2D::shift_yr,	sa[6]=0,					sa[7]=nY,			sa[8]=0,			sa[9]=Yplaces-1-Yoffset,	sa[10]=-1,		sa[11]=Yplaces-1,				range_Y=&Solve_L2D::range_y,		++Yoffset,	ra[8]=0,				ra[9]=nY,		ra[10]=0,				ra[11]=Yoffset;
																																																							else				shift_Y=&Solve_L2D::shift_,																																					range_Y=&Solve_L2D::range_;
																																						 if( XDstart==	XDend)	{	modify_X=&Solve_L2D::modify_;				 if(XDend)		shift_X=&Solve_L2D::shift_x,	sa[0]=0,					sa[1]=Xplaces,		sa[2]=0,			sa[3]=nX-1-XDend,			sa[4]=-1,		sa[5]=nX-1;
																																																							else				shift_X=&Solve_L2D::shift_;																																																																																									}
																																					else if( XDstart>	XDend)	{	modify_X=&Solve_L2D::modify_XI;				 if(XDend)		shift_X=&Solve_L2D::shift_x,	sa[0]=0,					sa[1]=Xplaces,		sa[2]=0,			sa[3]=nX-1-XDend,			sa[4]=0,		sa[5]=nX-1;
																																																							else				shift_X=&Solve_L2D::shift_;																																																																																									}
																																					else if( XDstart<	XDend)	{	modify_X=&Solve_L2D::modify_Xf;				 if(XDend-1)	shift_X=&Solve_L2D::shift_x,	sa[0]=0,					sa[1]=Xplaces,		sa[2]=0,			sa[3]=nX-1-(XDend-1),		sa[4]=-1,		sa[5]=nX-1;
																																																							else				shift_X=&Solve_L2D::shift_;																																																																																									}
																																																																																																							 if(XDstart)range_X=&Solve_L2D::range_x,					ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=XDstart;
																																																																																																						else			range_X=&Solve_L2D::range_;																																												}}
			
			partial=modify_X==&Solve_L2D::modify_&&modify_Y==&Solve_L2D::modify_?&Solve_L2D::partial_:&Solve_L2D::partial_m;
		}
	private:
		void partial_(Expression &ex)
		{
			auto &n=ex.n[ex.resultTerm];
			(this->*shift_X)((double*)n.r.p, (double*)n.i.p, ex.discontinuities);
			(this->*shift_Y)((double*)n.r.p, (double*)n.i.p, ex.discontinuities);
			
		//	ndr_to_clipboard_l2d(ex.n[ex.resultTerm], xs.Xplaces, nX, ys.Xplaces, nY);//
			(this->*range_X)(ex);
			(this->*range_Y)(ex);
		}
		void partial_m(Expression &ex)
		{
			auto &n=ex.n[ex.resultTerm];
		//	ndr_to_clipboard_l2d(ex.n[ex.resultTerm], xs.Xplaces, old_nX, ys.Xplaces, old_nY);//
			(this->*modify_Y)(n, ex.discontinuities);
			(this->*modify_X)(n, ex.discontinuities);
		//	ndr_to_clipboard_l2d(ex.n[ex.resultTerm], xs.Xplaces, nX, ys.Xplaces, nY);//
			resize_terms(ex, ndrSize=xs.Xplaces*nX+ys.Xplaces*nY);
							
			(this->*shift_X)((double*)n.r.p, (double*)n.i.p, ex.discontinuities);
			(this->*shift_Y)((double*)n.r.p, (double*)n.i.p, ex.discontinuities);
		//	ndr_to_clipboard_l2d(ex.n[ex.resultTerm], xs.Xplaces, nX, ys.Xplaces, nY);//
			
			(this->*range_X)(ex);
			(this->*range_Y)(ex);
		}
	public:
	//	decltype(&Solve_L2D::partial_) partial;
		void (modes::Solve_L2D::*partial)(Expression&);
	};
	class		Solve_3D:public Solve
	{
	public:
		Scale &xs, &ys, &zs;
		int *ndr_rgb,
			*ndr_rgb_i, *ndr_rgb_j, *ndr_rgb_k;
		Solve_3D(Scale &xs, Scale &ys, Scale &zs):xs(xs), ys(ys), zs(zs),//xlogscale(false), ylogscale(false), zlogscale(false),
			ndr_rgb(0), ndr_rgb_i(0), ndr_rgb_j(0), ndr_rgb_k(0){}
		double Xstart, Xsample, Ystart, Ysample, Zstart, Zsample;
		int Xplaces, Yplaces, Zplaces, ndrSize;
	private:
		int sa[9],//shift arguments:	XSstart XSend XDstart	YSstart YSend YDstart	ZSstart ZSend ZDstart
			ra[12];//2 cuboids: x1 x2 y1 y2 z1 z2
	public:
		void full_resize(double VX, double DX, double VY, double DY, double VZ, double DZ, int Xplaces, int Yplaces, int Zplaces)
		{
			this->Xplaces=Xplaces, this->Yplaces=Yplaces, this->Zplaces=Zplaces, ndrSize=Xplaces*Yplaces*Zplaces, kzStep=Yplaces*Xplaces;
			Xstart=VX-DX/2, Xsample=DX/Xplaces, Ystart=VY-DY/2, Ysample=DY/Yplaces, Zstart=VZ-DZ/2, Zsample=DZ/Zplaces;
			ndr_rgb=(int*)realloc(ndr_rgb, ndrSize*sizeof(int));
			ndr_rgb_i=(int*)realloc(ndr_rgb_i, ndrSize*sizeof(int));
			ndr_rgb_j=(int*)realloc(ndr_rgb_j, ndrSize*sizeof(int));
			ndr_rgb_k=(int*)realloc(ndr_rgb_k, ndrSize*sizeof(int));
		}
		void full(Expression &ex)
		{
			modes::Xstart=Xstart, modes::Xsample=Xsample, modes::Ystart=Ystart, modes::Ysample=Ysample, modes::Zstart=Zstart, modes::Zsample=Zsample, modes::T=T;
			modes::Xplaces=Xplaces, modes::Yplaces=Yplaces, modes::Zplaces=Zplaces, modes::ndrSize=ndrSize;

			resize_terms(ex, ndrSize);
			fill_range(ex, choose_fill_fn, 0, 0, Xplaces, 0, Yplaces, 0, Zplaces, Xplaces, Yplaces, Zplaces, Xplaces*Yplaces, xs.logscale, ys.logscale, zs.logscale);
			solve(ex, 0, 0, Xplaces, 0, Yplaces, 0, Zplaces, Xplaces, Yplaces, Zplaces);
		//	solve_disc(ex, 0, 0, Xplaces, 0, Yplaces, 0, Zplaces, Xplaces, Yplaces, Zplaces,	0, 0, 0, 0, 0, 0);
		}
		void updateRGB(Expression &ex)
	//	void updateRGB(Expression::Term &n)
		{
			auto &n=ex.n[ex.resultTerm];
			auto ndr_r=(double*)n.r.p, ndr_i=(double*)n.i.p, ndr_j=(double*)n.j.p, ndr_k=(double*)n.k.p;
			if(ex.resultMathSet=='R')
			{
				std::transform(ndr_r, ndr_r+ndrSize, ndr_rgb, [&](double x){return colorFunction_r(x);});
			}
			else if(ex.resultMathSet=='c')
			{
				//void (*cf)(CompP const&, int*);
				//	 if(colorScheme==BCW)	cf=colorFunction_bcw;
				//else if(colorScheme==BC_L)	cf=colorFunction_bc_l;
				for(int k=0;k<ndrSize;++k)
					colorFunction_bcw(CompP(ndr_r+k, ndr_i+k), ndr_rgb+k);
			}
			else
			{
				for(int k=0;k<ndrSize;++k)
					colorFunction_q(Value(ndr_r[k], ndr_i[k], ndr_j[k], ndr_k[k]), ndr_rgb[k], ndr_rgb_i[k], ndr_rgb_j[k], ndr_rgb_k[k]);
			}
		}
	private:
		int kzStep;
		void shift_component(double *ndr)
		{
			int XSstart=sa[0], XSend=sa[1], XDstart=sa[2], YSstart=sa[3], YSend=sa[4], YDstart=sa[5], ZSstart=sa[6], ZSend=sa[7], ZDstart=sa[8];
			auto _First=ndr+XSstart, _Last=ndr+XSend, _Dest=ndr+XDstart;
			for(int kz=Xplaces*Yplaces*ZSstart, kzEnd=Xplaces*Yplaces*ZSend, kzStep=(kz<kzEnd?1:-1)*Xplaces*Yplaces, kz2=Xplaces*Yplaces*ZDstart;kz!=kzEnd;kz+=kzStep, kz2+=kzStep)
				for(int ky=kz+Xplaces*YSstart, kyEnd=kz+Xplaces*YSend, kyStep=(ky<kyEnd?1:-1)*Xplaces, ky2=kz2+Xplaces*YDstart;ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
					std::copy(_First+ky, _Last+ky, _Dest+ky2);
		}
		void shift_		(Expression &ex)
		{
			auto &n=ex.n[ex.resultTerm];
			shift_component(n.r.p);
			if(ex.resultMathSet>='c')
			{
				shift_component(n.i.p);
				if(ex.resultMathSet=='h')
				{
					shift_component(n.j.p);
					shift_component(n.k.p);
				}
			}
		}
		void shift_r_component(double *ndr)
		{
			int XSstart=sa[0], XSend=sa[1], XDstart=sa[2], YSstart=sa[3], YSend=sa[4], YDstart=sa[5], ZSstart=sa[6], ZSend=sa[7], ZDstart=sa[8];
			auto rb=std::reverse_iterator<double*>(ndr+ndrSize);
			auto _First=rb+Xplaces-1-XSstart, _Last=rb+Xplaces-1-XSend, _Dest=rb+Xplaces-1-XDstart;
			for(int kz=Xplaces*Yplaces*(Zplaces-1-ZSstart), kzEnd=Xplaces*Yplaces*(Zplaces-1-ZSend), kzStep=(kz<kzEnd?1:-1)*Xplaces*Yplaces, kz2=Xplaces*Yplaces*(Zplaces-1-ZDstart);kz!=kzEnd;kz+=kzStep, kz2+=kzStep)
				for(int ky=kz+Xplaces*(Yplaces-1-YSstart), kyEnd=kz+Xplaces*(Yplaces-1-YSend), kyStep=(ky<kyEnd?1:-1)*Xplaces, ky2=kz2+Xplaces*(Yplaces-1-YDstart);ky!=kyEnd;ky+=kyStep, ky2+=kyStep)
					std::copy(_First+ky, _Last+ky, _Dest+ky2);
		}
		void shift_r	(Expression &ex)
		{
			auto &n=ex.n[ex.resultTerm];
			shift_r_component(n.r.p);
			if(ex.resultMathSet>='c')
			{
				shift_r_component(n.i.p);
				if(ex.resultMathSet=='h')
				{
					shift_r_component(n.j.p);
					shift_r_component(n.k.p);
				}
			}
		}
		void (modes::Solve_3D::*shift)(Expression&);
		void solve_range	(Expression &ex, int *a)
		{
			int x1=a[0], x2=a[1], y1=a[2], y2=a[3], z1=a[4], z2=a[5];
			modes::Xstart=Xstart, modes::Xsample=Xsample, modes::Ystart=Ystart, modes::Ysample=Ysample, modes::Zstart=Zstart, modes::Zsample=Zsample, modes::T=T;
			modes::Xplaces=Xplaces, modes::Yplaces=Yplaces, modes::Zplaces=Zplaces, modes::ndrSize=ndrSize;
			fill_range(ex, choose_fill_fn, 0, x1, x2, y1, y2, z1, z2, Xplaces, Yplaces, Zplaces, kzStep, xs.logscale, ys.logscale, zs.logscale);
			solve(ex, 0, x1, x2, y1, y2, z1, z2, Xplaces, Yplaces, Zplaces);
		//	solve_disc(ex, 0, x1, x2, y1, y2, z1, z2, Xplaces, Yplaces, Zplaces,	0, 0, 0, 0, 0, 0);
		}
	public:
		void partial_bounds	(double VX, double DX, double VY, double DY, double VZ, double DZ, int Xoffset, int Yoffset, int Zoffset)
		{
			partial=&Solve_3D::partial_;
			Xstart=VX-DX/2, Xsample=DX/Xplaces, Ystart=VY-DY/2, Xsample=DY/Yplaces, Zstart=VZ-DZ/2, Xsample=DZ/Zplaces;
			int Xoffset2=setXplaces(std::abs(Xoffset)), Yoffset2=std::abs(Yoffset), Zoffset2=std::abs(Zoffset);
				 if(Xoffset>0){							 if(Yoffset>0){							 if(Zoffset>0);
																							else if(Zoffset<0);
																							else								shift=&Solve_3D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,			sa[6]=Zoffset,				sa[7]=Zplaces,	sa[8]=0,					partial=&Solve_3D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=Yplaces-Yoffset,	ra[3]=Yplaces, ra[4]=0,					ra[5]=Zplaces,				ra[6]=Xplaces-Xoffset2,	ra[7]=Xplaces, ra[8]=0,					ra[9]=Yplaces-Yoffset,	ra[10]=0,				ra[11]=Zplaces;			}
													else if(Yoffset<0){Yoffset=-Yoffset;		 if(Zoffset>0);
																							else if(Zoffset<0);
																							else								shift=&Solve_3D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,		sa[5]=Yplaces-1,	sa[6]=Zoffset,				sa[7]=Zplaces,	sa[8]=0,					partial=&Solve_3D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yoffset, ra[4]=0,					ra[5]=Zplaces,				ra[6]=Xplaces-Xoffset2,	ra[7]=Xplaces, ra[8]=Yoffset,			ra[9]=Yplaces,			ra[10]=0,				ra[11]=Zplaces;			}
													else{										 if(Zoffset>0)					shift=&Solve_3D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,			sa[6]=Zoffset,				sa[7]=Zplaces,	sa[8]=0,					partial=&Solve_3D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces, ra[4]=Zplaces-Zoffset,	ra[5]=Zplaces,				ra[6]=Xplaces-Xoffset2,	ra[7]=Xplaces, ra[8]=0,					ra[9]=Yplaces,			ra[10]=0,				ra[11]=Zplaces-Zoffset;
																							else if(Zoffset<0)Zoffset=-Zoffset,	shift=&Solve_3D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,			sa[6]=Zplaces-1-Zoffset,	sa[7]=-1,		sa[8]=Zplaces-1,			partial=&Solve_3D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces, ra[4]=0,					ra[5]=Zoffset,				ra[6]=Xplaces-Xoffset2,	ra[7]=Xplaces, ra[8]=0,					ra[9]=Yplaces,			ra[10]=Zoffset,			ra[11]=Zplaces;
																							else								shift=&Solve_3D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,			sa[6]=Zoffset,				sa[7]=Zplaces,	sa[8]=0,					partial=&Solve_3D::partial_1,	ra[0]=Xplaces-Xoffset2,	ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces, ra[4]=0,					ra[5]=Zplaces;																																						}}
			else if(Xoffset<0){Xoffset=-Xoffset;		 if(Yoffset>0){							 if(Zoffset>0);
																							else if(Zoffset<0);
																							else								shift=&Solve_3D::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,			sa[6]=Zoffset,				sa[7]=Zplaces,	sa[8]=0,					partial=&Solve_3D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=Yplaces-Yoffset,	ra[3]=Yplaces, ra[4]=0,					ra[5]=Zplaces,				ra[6]=0,				ra[7]=Xoffset2, ra[8]=0,				ra[9]=Yplaces-Yoffset,	ra[10]=0,				ra[11]=Zplaces;			}
													else if(Yoffset<0){Yoffset=-Yoffset;		 if(Zoffset>0);
																							else if(Zoffset<0);
																							else								shift=&Solve_3D::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,		sa[5]=Yplaces-1,	sa[6]=Zoffset,				sa[7]=Zplaces,	sa[8]=0,					partial=&Solve_3D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yoffset, ra[4]=0,					ra[5]=Zplaces,				ra[6]=0,				ra[7]=Xoffset2, ra[8]=Yoffset,			ra[9]=Yplaces,			ra[10]=0,				ra[11]=Zplaces;			}
													else{										 if(Zoffset>0)					shift=&Solve_3D::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,			sa[6]=Zoffset,				sa[7]=Zplaces,	sa[8]=0,					partial=&Solve_3D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces, ra[4]=Zplaces-Zoffset,	ra[5]=Zplaces,				ra[6]=0,				ra[7]=Xoffset2, ra[8]=0,				ra[9]=Yplaces,			ra[10]=0,				ra[11]=Zplaces-Zoffset;
																							else if(Zoffset<0)Zoffset=-Zoffset,	shift=&Solve_3D::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,			sa[6]=Zplaces-Zoffset-1,	sa[7]=-1,		sa[8]=Zplaces-1,			partial=&Solve_3D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces, ra[4]=0,					ra[5]=Zoffset,				ra[6]=0,				ra[7]=Xoffset2, ra[8]=0,				ra[9]=Yplaces,			ra[10]=Zoffset,			ra[11]=Zplaces;
																							else								shift=&Solve_3D::shift_r,	sa[0]=Xplaces-1-Xoffset,	sa[1]=-1,		sa[2]=Xplaces-1,	sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,			sa[6]=Zoffset,				sa[7]=Zplaces,	sa[8]=0,					partial=&Solve_3D::partial_1,	ra[0]=0,				ra[1]=Xoffset2,	ra[2]=0,				ra[3]=Yplaces, ra[4]=0,					ra[5]=Zplaces;																																						}}
			else{										if(Yoffset>0){							 if(Zoffset>0)					shift=&Solve_3D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,			sa[6]=Zoffset,				sa[7]=Zplaces,	sa[8]=0,					partial=&Solve_3D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces, ra[4]=Zplaces-Zoffset,	ra[5]=Zplaces,				ra[6]=0,				ra[7]=Xplaces, ra[8]=Yplaces-Yoffset,	ra[9]=Yplaces,			ra[10]=0,				ra[11]=Zplaces-Zoffset;
																							else if(Zoffset<0)Zoffset=-Zoffset,	shift=&Solve_3D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,			sa[6]=Zplaces-Zoffset-1,	sa[7]=-1,		sa[8]=Zplaces-1,			partial=&Solve_3D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces, ra[4]=0,					ra[5]=Zoffset,				ra[6]=0,				ra[7]=Xplaces, ra[8]=Yplaces-Yoffset,	ra[9]=Yplaces,			ra[10]=Zoffset,			ra[11]=Zplaces;
																							else								shift=&Solve_3D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,			sa[6]=Zoffset,				sa[7]=Zplaces,	sa[8]=0,					partial=&Solve_3D::partial_1,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=Yplaces-Yoffset,	ra[3]=Yplaces, ra[4]=0,					ra[5]=Zplaces;																																						}
													else if(Yoffset<0){Yoffset=-Yoffset;		 if(Zoffset>0)					shift=&Solve_3D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,		sa[5]=Yplaces-1,	sa[6]=Zoffset,				sa[7]=Zplaces,	sa[8]=0,					partial=&Solve_3D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces, ra[4]=Zplaces-Zoffset,	ra[5]=Zplaces,				ra[6]=0,				ra[7]=Xplaces, ra[8]=0,					ra[9]=Yplaces,			ra[10]=Zplaces-Zoffset,	ra[11]=Zplaces;
																							else if(Zoffset<0)Zoffset=-Zoffset,	shift=&Solve_3D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,		sa[5]=Yplaces-1,	sa[6]=Zplaces-Zoffset-1,	sa[7]=-1,		sa[8]=Zplaces-1,			partial=&Solve_3D::partial_2,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces, ra[4]=0,					ra[5]=Zoffset,				ra[6]=0,				ra[7]=Xplaces, ra[8]=0,					ra[9]=Yoffset,			ra[10]=Zplaces-Zoffset,	ra[11]=Zplaces;
																							else								shift=&Solve_3D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yplaces-1-Yoffset,	sa[4]=-1,		sa[5]=Yplaces-1,	sa[6]=Zoffset,				sa[7]=Zplaces,	sa[8]=0,					partial=&Solve_3D::partial_1,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yoffset, ra[4]=0,					ra[5]=Zplaces;																																						}
													else{										 if(Zoffset>0)					shift=&Solve_3D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,			sa[6]=Zoffset,				sa[7]=Zplaces,	sa[8]=0,					partial=&Solve_3D::partial_1,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces, ra[4]=Zplaces-Zoffset,	ra[5]=Zplaces;
																							else if(Zoffset<0)Zoffset=-Zoffset,	shift=&Solve_3D::shift_,	sa[0]=Xoffset,				sa[1]=Xplaces,	sa[2]=0,			sa[3]=Yoffset,				sa[4]=Yplaces,	sa[5]=0,			sa[6]=Zplaces-Zoffset-1,	sa[7]=-1,		sa[8]=Zplaces-1,			partial=&Solve_3D::partial_1,	ra[0]=0,				ra[1]=Xplaces,	ra[2]=0,				ra[3]=Yplaces, ra[4]=0,					ra[5]=Zoffset;
																							else;}}
		}
	private:
		void partial_		(Expression &ex){}
		void partial_1		(Expression &ex){(this->*shift)(ex), solve_range(ex, ra);}
		void partial_2		(Expression &ex){(this->*shift)(ex), solve_range(ex, ra), solve_range(ex, ra+6);}
	public:
		void (modes::Solve_3D::*partial)(Expression&);
	};
	int swap_rb(int color)
	{
		auto p=(unsigned char*)&color;
		std::swap(p[0], p[2]);
		return color;
	}
	void _3dMode_DrawGridNAxes(_3D &_3d, Scale &xs, Scale &ys, Scale &zs, double AR_Y, double AR_Z)
//	void _3dMode_DrawGridNAxes(_3D &_3d, Scale &xs, Scale &ys, Scale &zs)
	{
		double &VX=xs.VX, &VY=ys.VX, &VZ=zs.VX;
	//	double VX=xs.fn(xs.getVX()), VY=ys.fn(ys.getVX()), VZ=zs.fn(zs.getVX());
		xs.start_grid(), ys.start_grid(), zs.start_grid();
		double
			Xstart=xs.fn(xs.Xstart), Xend=xs.fn(xs.Xend),
			Ystart=ys.fn(ys_Ystart), Yend=ys.fn(ys.Xend),
			Zstart=zs.fn(zs_Zstart), Zend=zs.fn(zs.Xend);
		_3d.lineColor=_3dGridColor;
	//	for(double x=xs.snap2grid_ceil(xs.Xstart);x<=xs.Xend;)
		for(double x=xs.snap2grid_AR_ceil(xs.Xstart, 1);x<=xs.Xend;)
		{
			double x2=xs.fn(x);
			_3d.line(dvec3(x2, Ystart, VZ), dvec3(x2, Yend, VZ)), _3d.line(dvec3(x2, VY, Zstart), dvec3(x2, VY, Zend));
		//	if(xs.next(x))
			if(xs.next_AR(x))
				break;
		}
	//	for(double y=ys.snap2grid_ceil(ys_Ystart);y<=ys.Xend;)
		for(double y=ys.snap2grid_AR_ceil(ys_Ystart, AR_Y);y<=ys.Xend;)
		{
			double y2=ys.fn(y);
			_3d.line(dvec3(Xstart, y2, VZ), dvec3(Xend, y2, VZ)), _3d.line(dvec3(VX, y2, Zstart), dvec3(VX, y2, Zend));
		//	if(ys.next(y))
			if(ys.next_AR(y))
				break;
		}
	//	for(double z=zs.snap2grid_ceil(zs_Zstart);z<=zs.Xend;)
		for(double z=zs.snap2grid_AR_ceil(zs_Zstart, AR_Z);z<=zs.Xend;)
		{
			double z2=zs.fn(z);
			_3d.line(dvec3(Xstart, VY, z2), dvec3(Xend, VY, z2)), _3d.line(dvec3(VX, Ystart, z2), dvec3(VX, Yend, z2));
		//	if(zs.next(z))
			if(zs.next_AR(z))
				break;
		}
		_3d.lineColor=0;//draw the origin
		dvec3
			p0(0, 0, 0),
		//	pf(xs.fn(10), ys.fn(10), zs.fn(10));
			pf(xs.fn(10), ys.fn(AR_Y*10), zs.fn(AR_Z*10));
		_3d.line(p0, dvec3(pf.x, p0.y, p0.z));
		_3d.line(p0, dvec3(p0.x, pf.y, p0.z));
		_3d.line(p0, dvec3(p0.x, p0.y, pf.z));
	}
	void _3dMode_NumberAxes(_3D &_3d, Scale &xs, Scale &ys, Scale &zs, double AR_Y, double AR_Z)
//	void _3dMode_NumberAxes(_3D &_3d, Scale &xs, Scale &ys, Scale &zs)
	{
		double &VX=xs.VX, &VY=ys.VX, &VZ=zs.VX;
	//	double VX=xs.fn(xs.getVX()), VY=ys.fn(ys.getVX()), VZ=zs.fn(zs.getVX());
	//	for(double X=xs.snap2grid_ceil(xs.Xstart);X<=xs.Xend;)
		//const char *labels[]=
		//{
		//	//"number x",
		//	"num. x: world2cam",
		//	"num. x: cam2screen",
		//	"num. x: insert text",
		//	"next x",
		//};
		//prof_loop_start(labels, sizeof(labels)/sizeof(char*));
		for(double X=xs.snap2grid_AR_ceil(xs.Xstart, 1);X<=xs.Xend;)
		{
			if(xs.is_not_origin(X))
				_3d.label(xs.fn(X), VY, VZ, "%g", X);
		//	if(xs.next(X))
			if(xs.next_AR(X))
				break;
		//	prof_add_loop(3);
		}
	//	prof_add("number x-axis");
	//	for(double Y=ys.snap2grid_ceil(ys_Ystart);Y<=ys.Xend;)
		for(double Y=ys.snap2grid_AR_ceil(ys_Ystart, AR_Y);Y<=ys.Xend;)
		{
			if(ys.is_not_origin(Y))
			//	_3d.label(VX, ys.fn(Y), VZ, "%g", Y);
				_3d.label(VX, ys.fn(Y), VZ, "%g", Y/AR_Y);
		//	if(ys.next(Y))
			if(ys.next_AR(Y))
				break;
		}
		prof_add("number y-axis");
	//	for(double Z=zs.snap2grid_ceil(zs_Zstart);Z<=zs.Xend;)
		for(double Z=zs.snap2grid_AR_ceil(zs_Zstart, AR_Z);Z<=zs.Xend;)
		{
			if(zs.is_not_origin(Z))
			//	_3d.label(VX, VY, zs.fn(Z), "%g", Z);
				_3d.label(VX, VY, zs.fn(Z), "%g", Z/AR_Z);
		//	if(zs.next(Z))
			if(zs.next_AR(Z))
				break;
		}
		prof_add("number z-axis");
	}
	void _2dMode_NumberAxes(int &H, int &V, int &VT, Scale &xs, Scale &ys)
	{
		xs.start_checkboard(), ys.start_checkboard();
		POINT origin={(int)xs.logscale, (int)ys.logscale};
		H=int(ys_Ystart>origin.y?h:ys.Xend<origin.y?-1:ys.fn_y_int(ys.logscale));
		int HT=H+(H>h-30?-18:2);
		V=int(xs.Xstart>origin.x?-1:xs.Xend<origin.x?w:xs.fn_x_int(xs.logscale));
		VT=V+int(V>w-24-ys.prec*8?-24-ys.prec*8:2);
	//	H=int(VY-DY/2>0?h:VY+DY/2<0?-1:h*(VY/DY+.5)); int HT=H+(H>h-30?-18:2); V=int(VX-DX/2>0?-1:VX+DX/2<0?w:w*(-VX+DX/2)/DX), VT=V+int(V>w-24-prec*8?-24-prec*8:2);
		setBkMode(TRANSPARENT);
	//	SetBkMode(ghMemDC, TRANSPARENT);
		static const double tolerance=1e-14;//1e-10
		for(double x=xs.rXstart;x<xs.Xend;)
		{
			if(xs.is_not_origin(x))//omit origin
				GUIPrint(xs.fn_x_int(x)+2, HT, "%g", x);
			if(xs.next(x))
				break;
		}
		for(double y=ys.rXstart;y<ys.Xend;)
		{
			if(ys.is_not_origin(y))//omit origin
				GUIPrint(VT, ys.fn_y_int(y)+2, "%g", y);
			if(ys.next(y))
				break;
		}

		//H=int(VY-DY/2>0?h:VY+DY/2<0?-1:h*(VY/DY+.5)); int HT=H+(H>h-30?-18:2); V=int(VX-DX/2>0?-1:VX+DX/2<0?w:w*(-VX+DX/2)/DX), VT=V+int(V>w-24-prec*8?-24-prec*8:2);
		//SetBkMode(ghMemDC, TRANSPARENT);
		//for(double x=floor((VX-DX/2)/Xstep)*Xstep, xEnd=ceil((VX+DX/2)/Xstep)*Xstep, Xstep_2=Xstep/2;x<xEnd&&x+Xstep!=x;x+=Xstep)
		//{
		//	if(x>-Xstep_2&&x<Xstep_2)
		//		continue;
		//	int linelen=sprintf_s(g_buf, 128, "%g", x);
		//	double X=w*(x-(VX-DX/2))/DX;
		//	TextOutA(ghMemDC, int(X)-(X<0)+2, HT, g_buf, linelen);
		//}
		//for(double y=ceil((VY+DY/2)/Ystep)*Ystep, yEnd=floor((VY-DY/2)/Ystep)*Ystep, Ystep_2=Ystep/2;y>yEnd&&y-Ystep!=y;y-=Ystep)
		//{
		//	if(y>-Ystep_2&&y<Ystep_2)
		//		continue;
		//	int linelen=sprintf_s(g_buf, 128, "%g", y);
		//	double Y=h*((VY+DY/2)-y)/DY;
		//	TextOutA(ghMemDC, VT, int(Y)-(Y<0)+2, g_buf, linelen);
		//}
	}

	class		Mode
	{
	public:
		static const int arrow_label_offset_X=50, const_label_offset_X=150;
		bool ready;
		bool toSolve;
		int bpx, bpy, bw, bh;
		bool time_variance, paused;
		Mode():ready(false), toSolve(false), bpx(0), bpy(0), bw(0), bh(0), time_variance(false), paused(false){}

		virtual void enter()=0;//mode becomes active or inactive
		virtual void exit()=0;
		virtual void pause()=0;//mode goes away
		virtual void resume()=0;
		virtual void appDeactivate()=0;//application deactivated
		virtual void appActivate()=0;

		virtual void setDimensions(int x, int y, int w, int h)=0;
		virtual void messagePaint(int x, int y, int w, int h)=0;
		virtual void messageTimer()=0;
		virtual int inputLButtonDown(int lParam)=0;
		virtual int inputMouseMove(int lParam)=0;
		virtual void inputLButtonUp(int lParam)=0;
		virtual int inputMouseWheel(int wParam)=0;
		virtual int inputKeyDown(int wParam, int lParam)=0;
		virtual int inputKeyUp(int wParam)=0;
		virtual void a_draw()=0;
		virtual void i_draw()=0;
	} *mode, *old_mode=nullptr;
	class		_2D_Mode:public Mode//ti2d		t1d, t1d_h, c2d, l2d, ti2d
	{
	public:
		int shiftOnly;//0 full, 1 partial, 2 no change yet
		
		Scale xs, ys;
		double AR_Y;
		//double VX, VY, DX, AR_Y, Xstep, Ystep;
		//int prec;
		Solve &solver;

		bool timer, drag, m_bypass;
		int kp;
		_2D_Mode(Solve &solver):
			shiftOnly(2),// xlogscale(false), ylogscale(false),
			xs(0, 20), ys(0, 0),
			AR_Y(1),
		//	VX(0), VY(0), DX(20), AR_Y(1),
			solver(solver),
			timer(false), drag(false), m_bypass(false), kp(0)
		{}
		void enter()
		{
			if(kb[VK_LBUTTON])
			{
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
			//	SetCapture(ghWnd);
				drag=1;
			}
			kp=kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}
		void exit()
		{
			if(drag)
			{
				drag=0;
			//	ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
			}
			if(!time_variance&&timer)
				KillTimer(ghWnd, 0), timer=false;
		}
		void pause()
		{
			if(time_variance&&!paused)
			{
				solver.pause();
				KillTimer(ghWnd, 0);
				paused=true;
			}
		}
		void resume()
		{
			if(time_variance)
			{
				SetTimer(ghWnd, 0, 10, 0);
				solver.resume();
				paused=false;
			}
		}
		void appDeactivate()
		{
			if(drag)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
			}
			kp=0, timer=false;
			if(!time_variance)
				KillTimer(ghWnd, 0);
		}
		void appActivate()
		{
			kp=kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}
		
		void setDimensions(int x, int y, int w, int h)
		{
			bpx=x, bpy=y, bw=w, bh=h;
			function1();
			toSolve=true, shiftOnly=0;
			ready=true;
		}
		void messagePaint(int x, int y, int w, int h)
		{
			setDimensions(x, y, w, h);
			toSolve=true, shiftOnly=0;
			if(!time_variance&&!timer)
				a_draw();
		}

		int inputMouseWheel(int wParam)
		{
			//t1d, t1d_h, c2d, l2d, ti2d
			bool mw_forward=((short*)&wParam)[1]>0;
			int mx=((short*)&oldMouse)[0], my=((short*)&oldMouse)[1];
			if(kb['X'])
			{
					 if(mw_forward)	AR_Y/=1.1, xs.zoom_x(1/1.1, mx);//stretch x
				else				AR_Y*=1.1, xs.zoom_x(1.1, mx);//compress x
			}
			else if(kb['Y'])
			{
					 if(mw_forward)	AR_Y*=1.1, ys.zoom_y(1/1.1, mx);//stretch y
				else				AR_Y/=1.1, ys.zoom_y(1.1, mx);//compress y
			}
			else
			{
					 if(mw_forward)	xs.zoom_x(1/1.1, mx), ys.zoom_y(1/1.1, my);//zoom in
				else				xs.zoom_x(1.1, mx), ys.zoom_y(1.1, my);//zoom out
			}
			function1();
			toSolve=true, shiftOnly=0;
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}

		int inputKeyUp(int wParam)
		{
			switch(wParam)
			{
			case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
			case VK_ADD:case VK_SUBTRACT://numpad
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(kp)//start+key
					--kp;
				break;
			}
			return 0;
		}
		void function1()
		{
			xs.update_scale(xs.DX, 1, w);
			ys.update_scale(xs.DX*h/w, AR_Y, h);
		}
	};
	class		_3D_Mode:public Mode
	{
	public:
		int shiftOnly;//0 full, 1 partial, 2 no change yet
		
		Scale xs, ys, zs;
		double AR_Y, AR_Z;
	//	double VX, VY, VZ, DX, AR_Y, AR_Z, Xstep, Ystep, Zstep;
		int prec;
		Solve &solver;

		bool timer, drag, m_bypass, shift;
		int kp;

		_3D_Mode(Solve &solver):
			shiftOnly(2),
			xs(0, 20), ys(0, 20), zs(0, 20),
		//	VX(0), VY(0), VZ(0), DX(20),
			AR_Y(1), AR_Z(1),
			solver(solver),
			timer(false), m_bypass(false), drag(false), shift(false), kp(0)
		{}

		void enter()
		{
			if(kb[VK_LBUTTON])
			{
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
			//	SetCapture(ghWnd);
				drag=1;
			}
			kp=kb['W']+kb['A']+kb['S']+kb['D']+kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}
		void exit()
		{
			if(drag||shift)
			{
				drag=0, shift=0;
			//	ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
			}
			if(!time_variance&&timer)
				KillTimer(ghWnd, 0), timer=false;
		}
		void pause()
		{
			if(time_variance&&!paused)
			{
				solver.pause();
				KillTimer(ghWnd, 0);
				paused=true;
			}
		}
		void resume()
		{
			if(time_variance)
			{
				SetTimer(ghWnd, 0, 10, 0);
				solver.resume();
				paused=false;
			}
		}
		void appDeactivate()
		{
			if(drag)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
			}
			kp=0, timer=false;
			if(!time_variance)
				KillTimer(ghWnd, 0);
		}
		void appActivate()
		{
			kp=kb['W']+kb['A']+kb['S']+kb['D']+kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}

		void messagePaint(int x, int y, int w, int h)
		{
			setDimensions(x, y, w, h);//t1d_c, t2d, t2d_h, c3d
			if(!time_variance&&!timer)
				a_draw();
		}
		int inputKeyUp(int wParam)
		{
			switch(wParam)
			{
			case 'W':case 'A':case 'S':case 'D':case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:case 'T':case 'G':
				if(kp>0)
					--kp;
				return 0;
			case VK_ADD:case VK_SUBTRACT://numpad
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(!kb[VK_CONTROL]&&kp>0)
					--kp;
				return 0;
			case 'X':
				if(!kb['Y']&&!kb['Z']&&shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;
			case 'Y':
				if(!kb['X']&&!kb['Z']&&shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;
			case 'Z':
				if(!kb['X']&&!kb['Y']&&shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;
		/*	case 'X':case 'Y':case 'Z':
				if(shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;*/
			}
			return 0;
		}
		void function1()
		{
			xs.update_scale(xs.DX, 1, w);
			ys.update_scale(xs.DX, AR_Y, w);
			zs.update_scale(xs.DX, AR_Z, w);
		}
		void function1(bool &XstepChanged, bool &YstepChanged, bool &ZstepChanged)
		{
			XstepChanged=xs.update_scale(xs.DX, 1, w);
			YstepChanged=ys.update_scale(xs.DX, AR_Y, w);
			ZstepChanged=zs.update_scale(xs.DX, AR_Z, w);
		}
	};
	
	void fft_1d_forward(double *ndr_r, double *ndr_i, int Xplaces, unsigned &fft_N, double &fft_sqrt_N, fftw_complex *&fft_in, fftw_complex *&fft_out, fftw_plan &fft_p, fftw_plan &ifft_p)
	{
		if(fft_N!=Xplaces)
		{
			if(fft_N)
			{
				fftw_destroy_plan(fft_p), fftw_destroy_plan(ifft_p);
				fftw_free(fft_in), fftw_free(fft_out);
			}
			fft_in=(fftw_complex*)fftw_malloc((fft_N=Xplaces)*sizeof(fftw_complex)), fft_out=(fftw_complex*)fftw_malloc(fft_N*sizeof(fftw_complex));
			fft_sqrt_N=std::sqrt((double)fft_N);
			fft_p=fftw_plan_dft_1d(fft_N, fft_in, fft_out, FFTW_FORWARD, FFTW_ESTIMATE), ifft_p=fftw_plan_dft_1d(fft_N, fft_in, fft_out, FFTW_BACKWARD, FFTW_ESTIMATE);
		}
		for(unsigned k=0;k<fft_N;++k)
			fft_in[k][0]=ndr_r[k], fft_in[k][1]=ndr_i[k];
		fftw_execute(fft_p);

		int fft_N_2=fft_N/2;
		double _1_fft_sqrt_N=1/fft_sqrt_N;
		for(int k=0, k2=fft_N-fft_N_2;k<fft_N_2;++k, ++k2)
			ndr_r[k]=fft_out[k2][0]*_1_fft_sqrt_N, ndr_i[k]=fft_out[k2][1]*_1_fft_sqrt_N;
		for(unsigned k=fft_N_2, k2=0;k<fft_N;++k, ++k2)
			ndr_r[k]=fft_out[k2][0]*_1_fft_sqrt_N, ndr_i[k]=fft_out[k2][1]*_1_fft_sqrt_N;
	}
	void fft_1d_inverse(double *ndr_r, double *ndr_i, int Xplaces, unsigned &fft_N, double &fft_sqrt_N, fftw_complex *&fft_in, fftw_complex *&fft_out, fftw_plan &fft_p, fftw_plan &ifft_p)
	{
		if(fft_N!=Xplaces)
		{
			if(fft_N)
			{
				fftw_destroy_plan(fft_p), fftw_destroy_plan(ifft_p);
				fftw_free(fft_in), fftw_free(fft_out);
			}
			fft_in=(fftw_complex*)fftw_malloc((fft_N=Xplaces)*sizeof(fftw_complex)), fft_out=(fftw_complex*)fftw_malloc(fft_N*sizeof(fftw_complex));
			fft_sqrt_N=std::sqrt((double)fft_N);
			fft_p=fftw_plan_dft_1d(fft_N, fft_in, fft_out, FFTW_FORWARD, FFTW_ESTIMATE), ifft_p=fftw_plan_dft_1d(fft_N, fft_in, fft_out, FFTW_BACKWARD, FFTW_ESTIMATE);
		}

		int fft_N_2=fft_N/2;
		for(int k=0, k2=fft_N-fft_N_2;k<fft_N_2;++k, ++k2)
			fft_in[k2][0]=ndr_r[k], fft_in[k2][1]=ndr_i[k];
		for(unsigned k=fft_N_2, k2=0;k<fft_N;++k, ++k2)
			fft_in[k2][0]=ndr_r[k], fft_in[k2][1]=ndr_i[k];
		fftw_execute(ifft_p);
		double _1_fft_sqrt_N=1/fft_sqrt_N;
		for(unsigned k=0;k<fft_N;++k)
			ndr_r[k]=fft_out[k][0]*_1_fft_sqrt_N, ndr_i[k]=fft_out[k][1]*_1_fft_sqrt_N;
	/*	std::vector<std::complex<double>> t0(ndr.size());
		for(unsigned k=0;k<ndr.size();++k)
			t0[k]=(std::complex<double>)ndr[k];
		std::vector<std::complex<double>> t1(t0.size());
		for(unsigned k=0;k<t0.size();++k)
		{
			std::complex<double> p=2*G2::_pi*std::complex<double>(0, 1)*double(k)/double(t0.size());
			for(unsigned k2=0;k2<t0.size();++k2)
				t1[k]+=t0[k2]*std::exp(p*double(k2));
		}
		for(unsigned k=0;k<ndr.size();++k)
			ndr[k]=t1[k];*/
	}
	void fft_2d_forward(double *ndr_r, double *ndr_i, int Xplaces, int Yplaces, unsigned &fft_N0, unsigned &fft_N1, double &fft_sqrt_N, fftw_complex *&fft_in, fftw_complex *&fft_out, fftw_plan &fft_p, fftw_plan &ifft_p)
	{
		int ndrSize=Xplaces*Yplaces;
		if(fft_N0!=Yplaces||fft_N1!=Xplaces)
		{
			if(fft_N0||fft_N1)
			{
				fftw_destroy_plan(fft_p), fftw_destroy_plan(ifft_p);
				fftw_free(fft_in), fftw_free(fft_out);
			}
			fft_N0=Yplaces, fft_N1=Xplaces;
			fft_in=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex)), fft_out=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex));
			fft_sqrt_N=std::sqrt((double)ndrSize);
			fft_p=fftw_plan_dft_2d(fft_N0, fft_N1, fft_in, fft_out, FFTW_FORWARD, FFTW_ESTIMATE), ifft_p=fftw_plan_dft_2d(fft_N0, fft_N1, fft_in, fft_out, FFTW_BACKWARD, FFTW_ESTIMATE);
		}
		for(int k=0;k<ndrSize;++k)
		{
			unsigned x=k%Xplaces, y=k/Xplaces;
			int sign=1-((x%2^y%2)<<1);
			fft_in[k][0]=ndr_r[k]*sign, fft_in[k][1]=ndr_i[k]*sign;
		}
		fftw_execute(fft_p);
		double _1_fft_sqrt_N=1/fft_sqrt_N;
		for(int k=0;k<ndrSize;++k)
			ndr_r[k]=fft_out[k][0]*_1_fft_sqrt_N, ndr_i[k]=fft_out[k][1]*_1_fft_sqrt_N;
	}
	void fft_2d_inverse(double *ndr_r, double *ndr_i, int Xplaces, int Yplaces, unsigned &fft_N0, unsigned &fft_N1, double &fft_sqrt_N, fftw_complex *&fft_in, fftw_complex *&fft_out, fftw_plan &fft_p, fftw_plan &ifft_p)
	{
		int ndrSize=Xplaces*Yplaces;
		if(fft_N0!=Yplaces||fft_N1!=Xplaces)
		{
			if(fft_N0||fft_N1)
			{
				fftw_destroy_plan(fft_p), fftw_destroy_plan(ifft_p);
				fftw_free(fft_in), fftw_free(fft_out);
			}
			fft_N0=Yplaces, fft_N1=Xplaces;
			fft_in=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex)), fft_out=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex));
			fft_sqrt_N=std::sqrt((double)ndrSize);
			fft_p=fftw_plan_dft_2d(fft_N0, fft_N1, fft_in, fft_out, FFTW_FORWARD, FFTW_ESTIMATE), ifft_p=fftw_plan_dft_2d(fft_N0, fft_N1, fft_in, fft_out, FFTW_BACKWARD, FFTW_ESTIMATE);
		}
		for(int k=0;k<ndrSize;++k)
			fft_in[k][0]=ndr_r[k], fft_in[k][1]=ndr_i[k];
		fftw_execute(ifft_p);
		double _1_fft_sqrt_N=1/fft_sqrt_N;
		for(int k=0;k<ndrSize;++k)
		{
			unsigned x=k%Xplaces, y=k/Xplaces;
			int sign=1-((x%2^y%2)<<1);
			ndr_r[k]=fft_out[k][0]*sign*_1_fft_sqrt_N, ndr_i[k]=fft_out[k][1]*sign*_1_fft_sqrt_N;
		}
	}
	void lpf_1d_real(Term &n)
	{
		double *ndr_r=(double*)n.r.p;
		int N=n.r.size()<<1, T=11;
		double sum(0);
		std::vector<double> t0(T);
		for(int k=-T/2;k<T/2;++k)
			sum+=t0[(k+T)%T]=ndr_r[(k+N)%N];
		std::vector<double> t1(t0);
		for(int k=0;k<N-T/2;++k)
		{
			t0[k%T]=ndr_r[k];
			ndr_r[k]=sum/double(T);
			sum+=ndr_r[(k+T/2)%N]-t0[(k-T/2+T)%T];
		}
		for(int k=N-T/2;k<N;++k)
			ndr_r[k]=sum/double(T), sum+=t1[(k-(N-T/2)+N+T)%T]-t0[(k-T/2+T)%T];
	}
	void lpf_1d_complex(Term &n)
	{
		double *ndr_r=(double*)n.r.p, *ndr_i=(double*)n.i.p;
		int N=n.r.size()<<1, T=11;
		std::complex<double> sum(0);
		std::vector<std::complex<double>> t0(T);
		for(int k=-T/2;k<T/2;++k)
			sum+=t0[(k+T)%T]=std::complex<double>(ndr_r[(k+N)%N], ndr_i[(k+N)%N]);
		std::vector<std::complex<double>> t1(t0);
		for(int k=0;k<N-T/2;++k)
		{
			t0[k%T]=std::complex<double>(ndr_r[k], ndr_i[k]);
			auto temp=sum/double(T);
			ndr_r[k]=temp.real(), ndr_i[k]=temp.imag();
			sum+=std::complex<double>(ndr_r[(k+T/2)%N], ndr_i[(k+T/2)%N])-t0[(k-T/2+T)%T];
		}
		for(int k=N-T/2;k<N;++k)
		{
			std::complex<double> temp=sum/double(T);
			ndr_r[k]-=temp.real(), ndr_i[k]-=temp.imag(), sum+=t1[(k-(N-T/2)+N+T)%T]-t0[(k-T/2+T)%T];
		}
	}
	void hpf_1d_real(Term &n)
	{
		double *ndr_r=(double*)n.r.p;
		int N=n.r.size()<<1, T=11;
		double sum(0);
		std::vector<double> t0(T);
		for(int k=-T/2;k<T/2;++k)
			sum+=t0[(k+T)%T]=ndr_r[(k+N)%N];
		std::vector<double> t1(t0);
		for(int k=0;k<N-T/2;++k)
		{
			t0[k%T]=ndr_r[k];
			ndr_r[k]-=sum/double(T);
			sum+=ndr_r[(k+T/2)%N]-t0[(k-T/2+T)%T];
		}
		for(int k=N-T/2;k<N;++k)
			ndr_r[k]-=sum/double(T), sum+=t1[(k-(N-T/2)+N+T)%T]-t0[(k-T/2+T)%T];
	}
	void hpf_1d_complex(Term &n)
	{
		double *ndr_r=(double*)n.r.p, *ndr_i=(double*)n.i.p;
		int N=n.r.size()<<1, T=11;
		std::complex<double> sum(0);
		std::vector<std::complex<double>> t0(T);
		for(int k=-int(T)/2;k<T/2;++k)
			sum+=t0[k%T]=std::complex<double>(ndr_r[k%N], ndr_i[k%N]);
		std::vector<std::complex<double>> t1(t0);
		for(int k=0;k<N-T/2;++k)
		{
			t0[k%T]=std::complex<double>(ndr_r[k], ndr_i[k]);
			auto temp=sum/double(T);
			ndr_r[k]-=temp.real(), ndr_i[k]-=temp.imag();
			sum+=std::complex<double>(ndr_r[(k+T/2)%N], ndr_i[(k+T/2)%N])-t0[(k-T/2)%T];
		}
		for(int k=N-T/2;k<N;++k)
		{
			auto temp=sum/double(T);
			ndr_r[k]-=temp.real(), ndr_i[k]-=temp.imag(), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
	}
	void lpf_2d(Term &n, int Xplaces, int Yplaces)
	{
		auto ndr_r=(double*)n.r.p, ndr_i=(double*)n.i.p;
		int ndrSize=n.r.size()<<1;
		std::vector<double> r(ndr_r, ndr_r+ndrSize), i(ndr_i, ndr_i+ndrSize);
		const double normal=1./9;
		for(int ky=0;ky<Yplaces;++ky)
		{
			for(int kx=0;kx<Xplaces;++kx)
			{
				int idx=ky*Xplaces+kx;
				int ky_1=ky-1+Yplaces, ky1=ky+1,
					kx_1=kx-1+Xplaces, kx1=kx+1;
				ky_1-=Yplaces&-(ky_1>=Yplaces), ky1-=Yplaces&-(ky1>=Yplaces);
				kx_1-=Xplaces&-(kx_1>=Xplaces), kx1-=Xplaces&-(kx1>=Xplaces);
					ky_1*=Xplaces;
				int ky_0=ky*Xplaces;
					ky1*=Xplaces;
				ndr_r[idx]=(
					r[ky_1+kx_1]+r[ky_1+kx]+r[ky_1+kx1]+
					r[ky_0+kx_1]+r[ky_0+kx]+r[ky_0+kx1]+
					r[ky1 +kx_1]+r[ky1 +kx]+r[ky1 +kx1])*normal;
				ndr_i[idx]=(
					i[ky_1+kx_1]+i[ky_1+kx]+i[ky_1+kx1]+
					i[ky_0+kx_1]+i[ky_0+kx]+i[ky_0+kx1]+
					i[ky1 +kx_1]+i[ky1 +kx]+i[ky1 +kx1])*normal;
			}
		}
	}
	void hpf_2d(Term &n, int Xplaces, int Yplaces)
	{
		auto ndr_r=(double*)n.r.p, ndr_i=(double*)n.i.p;
		int ndrSize=n.r.size()<<1;
		std::vector<double> r(ndr_r, ndr_r+ndrSize), i(ndr_i, ndr_i+ndrSize);
		const double normal=1./4;
		for(int ky=0;ky<Yplaces;++ky)
		{
			for(int kx=0;kx<Xplaces;++kx)
			{
				int idx=ky*Xplaces+kx;
				int ky_1=ky-1+Yplaces, ky1=ky+1,
					kx_1=kx-1+Xplaces, kx1=kx+1;
				ky_1-=Yplaces&-(ky_1>=Yplaces), ky1-=Yplaces&-(ky1>=Yplaces);
				kx_1-=Xplaces&-(kx_1>=Xplaces), kx1-=Xplaces&-(kx1>=Xplaces);
					ky_1*=Xplaces;
				int ky_0=ky*Xplaces;
					ky1*=Xplaces;
				ndr_r[idx]=(	   -r[ky_1+kx]
					-r[ky_0+kx_1]+8*r[ky_0+kx]-r[ky_0+kx1]+
								   -r[ky1 +kx])*0.25;
				ndr_i[idx]=(	   -i[ky_1+kx]
					-i[ky_0+kx_1]+8*i[ky_0+kx]-i[ky_0+kx1]+
								   -i[ky1 +kx])*0.25;
			}
		}
	}

	class		Numeric_0D:public Mode
	{
		TextBox tb;
	public:
		int toPrint;
		Solve_0D solver;
		int base;
		
		Labels_0D labels;
		static const int modes[], nmodes;

		bool drag;

		Numeric_0D():toPrint(false), drag(false), base(10){}
		void enter()
		{
			tb.active=true;
			tb.setDimensions(bpx, bpy, bw, bh);
			if(kb[VK_LBUTTON])
			{
				if(tb.switchToWithMouseOn(oldMouse))
					a_draw();
			}
		}
		void exit()
		{
			if(kb[VK_LBUTTON])
			{
			//	ReleaseCapture();
				tb.inputLButtonUp();
			}
			tb.active=false;
			tb.setDimensions(bpx+bw/2, bpy, bw/2, bh);
		}
		void pause()
		{
			if(time_variance&&!paused)
			{
				solver.pause();
				KillTimer(ghWnd, 0);
				paused=true;
			}
		}
		void resume()
		{
			if(!toSolve)//toCheck?
			{
				time_variance=0;

				labels.clear();

				tb.text=(char*)realloc(tb.text, ((tb.textlen=0)+1)*sizeof(char));
				//const int aSize=1024;
				//char a[aSize];
				int length;

				solver.synchronize();
				for(unsigned k=0;k<expr.size();++k)
				{
					auto &ex=expr[k];
					if(ex.rmode[0]==1)
					{
						time_variance|=ex.nITD;
						labels.fill(k);

						length=0;
#ifdef MULTIPRECISION
						ex.nresult.print(g_buf, length, ex.resultMathSet, base);
					//	ex.ndata[ex.resultTerm].print(g_buf, length, ex.resultMathSet, base);
#else
						print_value(ex.n[ex.resultTerm], 0, g_buf, length, ex.resultMathSet, base);
#endif
						append(tb.text, tb.textlen, g_buf, length);
						for(++k;k<expr.size();++k)
						{
							auto &ex=expr[k];
							if(ex.rmode[0]==1)
							{
								time_variance|=ex.nITD;
								labels.fill(k);

								length=sprintf_s(g_buf, "\r\n");
#ifdef MULTIPRECISION
								ex.nresult.print(g_buf, length, ex.resultMathSet, base);
							//	ex.ndata[ex.resultTerm].print(g_buf, length, ex.resultMathSet, base);
#else
								print_value(ex.n[ex.resultTerm], 0, g_buf, length, ex.resultMathSet, base);
#endif

								append(tb.text, tb.textlen, g_buf, length);
							}
						}
						break;
					}
				}
			}
			if(time_variance)
			{
				SetTimer(ghWnd, 0, 10, 0);
				solver.resume();
				paused=false;
			}
		}
		void appDeactivate()
		{
			if(drag)
			{
				drag=0;
				ReleaseCapture();
				tb.inputLButtonUp();
			}
		}
		void appActivate(){}

		void setDimensions(int x, int y, int w, int h)
		{
			bpx=x, bpy=y, bw=w, bh=h, ready=true;
			if(active)
				tb.setDimensions(bpx, bpy, bw, bh);
			else
				tb.setDimensions(bpx+bw/2, bpy, bw/2, bh);
		}
		void messagePaint(int x, int y, int w, int h)
		{
			setDimensions(x, y, w, h);
			if(!time_variance)
				a_draw();
		}
		void messageTimer(){a_draw();}
		int inputLButtonDown(int lParam)
		{
			drag=1;
			SetCapture(ghWnd);
			if(tb.inputLButtonDown(lParam))
				a_draw();
			return 0;
		}
		int inputMouseMove(int lParam)
		{
			if(tb.inputMouseMove(lParam))
				a_draw();
			return 0;
		}
		void inputLButtonUp(int lParam)
		{
			drag=0;
			ReleaseCapture();
			tb.inputLButtonUp();
		}
		int inputMouseWheel(int wParam)
		{
			if(tb.inputMouseWheel(wParam))
				a_draw();
			return 0;
		}
		void reassign_constants()
		{
			for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)
			{
				auto &ex=expr[ke];
				for(int k=0, kEnd=ex.decimals.size();k<kEnd;++k)//re-read decimal numbers
				{
					int idx=ex.decimals[k].first;
					auto &text=ex.decimals[k].second;
					ex.data[idx]=MP::Real(text.c_str(), MP::bin_prec, 10);
				/*	for(int k2=0;k2<=itb.textlen;++k2)//0: number start, k2: mantissa end
					{
						if(text[k2]!='.'&&(!commasInNumbers||text[k2]!=','))
						{
							bool E_notation=(text[k2]=='e'||text[k2]=='E')
								&&(text[k2+1]>='0'&&text[k2+1]<='9'||text[k2+1]=='.'
									||(text[k2+1]=='+'||text[k2+1]=='-')&&(text[k2+2]>='0'&&text[k2+2]<='9'||text[k2+2]=='.'));
							if(!E_notation)
								for(;text[k2-1]==',';--k2);

							const double ln10_ln2=G2::_ln10/G2::_ln2;
							//int bin_prec=int((k2-(0+2)+2)*ln10_ln2);//+2 reserve digits
							//if(bin_prec>MP::bin_prec)
							//	MP::set_prec(bin_prec, 2);
							char temp=text[k2];
							text[k2]='\0';
							MP::Real val(&text[0], MP::bin_prec, 10);
							text[k2]=temp;
							if(E_notation)
							{
								int sign=text[k2+1]=='-'?-1:1;
								for(int k3=k2+1+(text[k2+1]=='+'||text[k2+1]=='-'), k4=k3;k4<=itb.textlen;++k4)//k3: exp start, k4: exp end
								{
									if(text[k4]!='.')
									{
										double p=1;
										for(int k5=k3;k5<k4;++k5)
										{
											if(text[k5]=='.')
											{
												for(int k6=k5+1;k6<k4;++k6)
													if(text[k6]!='.')
														p/=10;
												break;
											}
										}
										double val2=0;
										for(int k5=k4-1;k5>=k3;--k5)
											if(text[k5]!='.')
												val2+=(text[k5]-'0')*p, p*=10;
										val*=pow(MP::Real(10), MP::Real(sign*val2));
									//	const double logBase=G2::_ln10;
									//	val*=std::exp(sign*val2*logBase);
										k2=k4;
										break;
									}
								}
							}
							break;
						}
					}//*/
				}
				for(int k=0, kEnd=ex.pi_idx.size();k<kEnd;++k)
				{
					int idx=ex.pi_idx[k];
					ex.data[idx]=MP::m_pi;
				}
				for(int k=0, kEnd=ex.e_idx.size();k<kEnd;++k)
				{
					int idx=ex.e_idx[k];
					ex.data[idx]=MP::m_e;
				}
			}
		}
		int inputKeyDown(int wParam, int lParam)
		{
			const int dprec=53;//16
			switch(wParam)
			{
			case '1':
				if(base!=2)
				{
					base=2;
					if(!toSolve)
						print();
					a_draw();
				}
				return 0;
			case '2':
				if(base!=8)
				{
					base=8;
					if(!toSolve)
						print();
					a_draw();
				}
				return 0;
			case '3':case '0':
				if(base!=10)
				{
					base=10;
					if(!toSolve)
						print();
					a_draw();
				}
				return 0;
			case '4':
				if(base!=16)
				{
					base=16;
					if(!toSolve)
						print();
					a_draw();
				}
				return 0;
			case VK_RETURN:
				MP::set_prec(MP::bin_prec+dprec, 2);
				reassign_constants();
				//for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)
				//{
				//	auto &ex=expr[ke];
				//	if(ex.rmode[0]==1)
				//	{
				//		for(int kn=0, knEnd=
				//	}
				//}
				toSolve=true;
				a_draw();
				break;
			case VK_BACK:
				if(MP::bin_prec>53)
				{
					MP::set_prec(MP::bin_prec-dprec, 2);
					reassign_constants();
					toSolve=true;
					a_draw();
				}
				break;
			case 'R':
				MP::set_prec(DEFAULT_PREC, 2);
				reassign_constants();
				toSolve=true;
				a_draw();
				break;
		/*	case 'D':
				if(kb[VK_CONTROL])//copy with results
				{
					if(tb.cursor!=tb.selcur)
					{
						int k=tb.cursor<tb.selcur?tb.cursor:tb.selcur, k2=tb.cursor>tb.selcur?tb.cursor:tb.selcur;
						char *clipboard=(char*)LocalAlloc(LMEM_FIXED, (k2-k+1)*sizeof(char));
						memcpy(clipboard, &tb.text[k], (k2-k)*sizeof(char));
						clipboard[k2-k]='\0';
						OpenClipboard(ghWnd), EmptyClipboard(), SetClipboardData(CF_OEMTEXT, (void*)clipboard), CloseClipboard();
					}
				}
				return 0;//*/
			}
			if(tb.inputKeyDown(wParam, lParam)||wParam==VK_ESCAPE&&modes::ready||wParam==VK_F1)
				a_draw();
			return 0;
		}
		int inputKeyUp(int wParam){return 0;}
		void print()
		{
			tb.text=(char*)realloc(tb.text, ((tb.textlen=0)+1)*sizeof(char));
#ifndef MULTIPRECISION
			const int aSize=1024;
			char a[aSize];
#endif
			if(!paused)
				solver.synchronize();
			for(unsigned k=0;k<expr.size();++k)
			{
				auto &ex=expr[k];
				if(ex.rmode[0]==1)
				{
					int length=0;
#ifdef MULTIPRECISION
					ex.nresult.print(g_buf, length, ex.resultMathSet, base);
#else
					print_value(ex.n[ex.resultTerm], 0, g_buf, length, ex.resultMathSet, base);
#endif
					append(tb.text, tb.textlen, g_buf, length);
					for(++k;k<expr.size();++k)
					{
						auto &ex=expr[k];
						if(ex.rmode[0]==1)
						{
							length=sprintf_s(g_buf, "\r\n");
#ifdef MULTIPRECISION
							ex.nresult.print(g_buf, length, ex.resultMathSet, base);
#else
							print_value(ex.n[ex.resultTerm], 0, g_buf, length, ex.resultMathSet, base);
#endif
							append(tb.text, tb.textlen, g_buf, length);
						}
					}
					break;
				}
			}
		}
		void draw()
		{
			if(toSolve)
			{
				auto old_time_variance=time_variance;
				time_variance=false;
			//	std::fill(nExpr.begin(), nExpr.end(), 0);
				labels.clear();
			//	print();
				tb.text=(char*)realloc(tb.text, ((tb.textlen=0)+1)*sizeof(char));
				//const int aSize=65536;
				//char *a=new char[aSize];
			//	const int aSize=1024;
			//	char a[aSize];
				int length;
				if(!paused)
					solver.synchronize();
				for(unsigned k=0;k<expr.size();++k)
				{
					auto &ex=expr[k];
				//	++nExpr[ex.rmode[0]];
					if(ex.rmode[0]==1)
					{
						time_variance|=ex.nITD;
						solver.full(ex);
						labels.fill(k);
						length=0;
#ifdef MULTIPRECISION
						ex.nresult.print(g_buf, length, ex.resultMathSet, base);
#else
						print_value(ex.n[ex.resultTerm], 0, g_buf, length, ex.resultMathSet, base);
#endif
						append(tb.text, tb.textlen, g_buf, length);
						for(++k;k<expr.size();++k)
						{
							auto &ex=expr[k];
						//	++nExpr[ex.rmode[0]];
							if(ex.rmode[0]==1)
							{
								time_variance|=ex.nITD;
								solver.full(ex);
								labels.fill(k);
								length=sprintf_s(g_buf, "\r\n");
#ifdef MULTIPRECISION
								ex.nresult.print(g_buf, length, ex.resultMathSet, base);
#else
								print_value(ex.n[ex.resultTerm], 0, g_buf, length, ex.resultMathSet, base);
#endif
								append(tb.text, tb.textlen, g_buf, length);
							}
						}
						break;
					}
				}//*/
				if(time_variance)
				{
					if(!paused)
						SetTimer(ghWnd, 0, 10, 0);
				}
				else if(old_time_variance)
					KillTimer(ghWnd, 0);
				toSolve=false;
			//	if(tb.cursor>tb.textlen)
					tb.cursor=tb.selcur=0;
			//	delete[] a;
			}
			else if(time_variance)
			{
			//	print();
				tb.text=(char*)realloc(tb.text, ((tb.textlen=0)+1)*sizeof(char));
				//const int aSize=1024;
				//char a[aSize];
				int length=0;
				if(!paused)
					solver.synchronize();
				for(unsigned k=0;k<expr.size();++k)
				{
					auto &ex=expr[k];
					if(ex.rmode[0]==1)
					{
						if(ex.nITD)
							solver.full(ex);
#ifdef MULTIPRECISION
						length=0;
						ex.nresult.print(g_buf, length, ex.resultMathSet, base);
#else
						print_value(ex.n[ex.resultTerm], 0, g_buf, length=0, ex.resultMathSet, base);
#endif
						append(tb.text, tb.textlen, g_buf, length);
						for(++k;k<expr.size();++k)
						{
							auto &ex=expr[k];
							if(ex.rmode[0]==1)
							{
								if(ex.nITD)
									solver.full(ex);
								length=sprintf_s(g_buf, "\r\n");
#ifdef MULTIPRECISION
								ex.nresult.print(g_buf, length, ex.resultMathSet, base);
#else
								print_value(ex.n[ex.resultTerm], 0, g_buf, length, ex.resultMathSet, base);
#endif
								append(tb.text, tb.textlen, g_buf, length);
							}
						}
						break;
					}
				}//*/
				if(tb.cursor>tb.textlen)
					tb.cursor=tb.selcur=0;
			}
			else if(toPrint)
				print();
			toPrint=false;
			selectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			if(active)
			//	tb.setDimensions(bpx, bpy, bw, bh);
				tb.draw();
			else
			{
			//	tb.setDimensions(bpx+bw/2, bpy, bw/2, bh);
				setTextColor(0x00777777);
			//	SetTextColor(ghMemDC, 0x00777777);
				PenBrush pb(0x00777777);
				pb.use();
			//	HPEN__ *hPen=(HPEN__*)SelectObject(ghMemDC, CreatePen(PS_SOLID, 1, 0x00777777));
				if(labels.colored)
					tb.draw_corresponding_color(modes, nmodes, &::itb);
				else
					tb.draw_corresponding(modes, nmodes, &::itb);
				pb.drop();
			//	DeleteObject(SelectObject(ghMemDC, hPen));
				setTextColor(0);
			//	SetTextColor(ghMemDC, 0);
			}
			deselectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			{
				int Ys=0;
				auto colorCondition=nExpr[1]>1;
				int textColor;
				if(colorCondition)
					textColor=getTextColor();
				//	textColor=GetTextColor(ghMemDC);
				for(int kl=0, klEnd=labels.Clabels.size();kl<klEnd;++kl)
				{
					auto &label=labels.Clabels[kl];
					if(colorCondition)
						setTextColor(expr[label.exNo].winColor);
					//	SetTextColor(ghMemDC, expr[label.exNo].winColor);
					int linelen=sprintf_s(g_buf, g_buf_size, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
					::print(w-const_label_offset_X, Ys, g_buf, linelen);
				//	TextOutA(ghMemDC, w-const_label_offset_X, Ys, g_buf, linelen);
					Ys+=16;
				}
				if(colorCondition)
					setTextColor(textColor);
				//	SetTextColor(ghMemDC, textColor);
			}
			GUIPrint(w-const_label_offset_X, h-16, "Precision: %d bit", mpfr::mpreal::get_default_prec());
			switch(base)
			{
			case 2:
				GUIPrint(w-const_label_offset_X, h-32, "Binary");
				break;
			case 8:
				GUIPrint(w-const_label_offset_X, h-32, "Octal");
				break;
			case 16:
				GUIPrint(w-const_label_offset_X, h-32, "Hexadecimal");
				break;
			}
		}
		void i_draw();
		void a_draw();
	} n0d;
	const int		Numeric_0D::modes[]={1}, Numeric_0D::nmodes=sizeof(modes)>>2;
	void			Numeric_0D::i_draw()
	{
		if(modes::ready)
		{
			draw();
			if(showLastModeOnIdle)
				capture_window(modeRGB);
			//	std::copy(rgb, rgb+w*h, modeRGB);
			
			selectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			{
				int bkMode=getBkMode();
			//	int bkMode=GetBkMode(ghMemDC);
				setBkMode(OPAQUE);
			//	SetBkMode(ghMemDC, OPAQUE);
				itb.draw();
				setBkMode(bkMode);
			//	SetBkMode(ghMemDC, bkMode);
			}
			deselectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);

			if(showBenchmark)
				Performance(0, h-32);//
#ifndef BUILD_1_7
			BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
#endif
		}
		else
		{
			display_texture_fullwindow(modeRGB);
		//	std::copy(modeRGB, modeRGB+w*h, rgb);
			if(showBenchmark)
				Performance(0, h-32);//
		}
	}
	void			Numeric_0D::a_draw()
	{
		newframe();
	//	rectangle(bpx-1, bpy-1, bw+1, bh+1);
	//	Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);

		draw();

		if(contextHelp)
		{
			const char *help[]=
			{
				"1: binary",
				"2: octal",
				"3/0: decimal",
				"4: hexadecimal",
				"Enter/Backspace: change precision",
				"R: reset precision",
				"Esc: back to text editor",
			};
			print_contextHelp(help, sizeof(help)>>2, 240);
		}
	/*	{
			short X0=w>>1, Y0=h>>1, dx=107, dy=68;
			short xs=X0-dx, ys=Y0-dy;
			Rectangle(ghMemDC, xs-1, ys-1, X0+dx, Y0+dy);
			GUIPrint(ghMemDC, xs, ys, "1: binary");
			GUIPrint(ghMemDC, xs, ys+18, "2: octal");
			GUIPrint(ghMemDC, xs, ys+18*2, "3/0: decimal");
			GUIPrint(ghMemDC, xs, ys+18*3, "4: hexadecimal");
		}//*/
		if(showBenchmark)
			Performance(0, h-32);//
		show();
	//	BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
		report_error();
	}
	class		Implicit_1D:public Mode
	{
	public:
		Scale xs;
		int shiftOnly;//0 full, 1 partial, 2 no change yet
		int Xoffset, exprRemoved;

		int Xplaces;
	//	double VX, DX, step;
	//	int prec;
		Solve_1D_Implicit solver;
		
		_2D _2d;
		bool clearScreen;
		Labels_1D labels;
		static const int modes[], nmodes;
		PenBrush penBrush;
		//HPEN__ *hPen;
		//HBRUSH__ *hBrush;

		bool timer, drag, m_bypass;
		int kp;

		Implicit_1D():
			xs(0 , 20), solver(xs),// VX(0), DX(20),
			timer(false), drag(false), m_bypass(false), kp(0),
			shiftOnly(2), Xoffset(0), exprRemoved(0),
			clearScreen(false),
			penBrush(_2dCheckColor)
		{
		//	hPen=CreatePen(PS_SOLID, 1, _2dCheckColor), hBrush=CreateSolidBrush(_2dCheckColor);
		}
		~Implicit_1D()
		{
		//	DeleteObject(hPen), DeleteObject(hBrush);
		}

		void enter()
		{
			if(kb[VK_LBUTTON])
			{
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
			//	SetCapture(ghWnd);
				drag=1;
			}
			kp=kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}
		void exit()
		{
			if(drag)
			{
				drag=0;
			//	ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
			}
			if(!time_variance&&timer)
				KillTimer(ghWnd, 0), timer=false;
		}
		void pause()
		{
			if(time_variance&&!paused)
			{
				solver.pause();
				KillTimer(ghWnd, 0);
				paused=true;
			}
		}
		void resume()
		{
			if(time_variance)
			{
				SetTimer(ghWnd, 0, 10, 0);
				solver.resume();
				paused=false;
			}
		}
		void appDeactivate()
		{
			if(drag)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
			}
			kp=0, timer=false;
			if(!time_variance)
				KillTimer(ghWnd, 0);
		}
		void appActivate()
		{
			kp=kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}
		
		void setDimensions(int x, int y, int w, int h)
		{
			bpx=x, bpy=y, bw=w, bh=h;
			function1();
			toSolve=true, shiftOnly=0;
			ready=true;
		}
		void messagePaint(int x, int y, int w, int h)
		{
			setDimensions(x, y, w, h);
			toSolve=true, shiftOnly=0;
			if(!time_variance&&!timer)
				a_draw();
		}
		void messageTimer()
		{
			int dx=conditional_negate(10, _2d_drag_graph_not_window);
			if(kb[VK_LEFT		]){	xs.shift(-dx), toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=dx;}
			if(kb[VK_RIGHT		]){	xs.shift(+dx), toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=dx;}
			if(kb[VK_UP			]){	itb.tpy-=dx;	if(itb.tpy<0		)itb.tpy=0;}//VY+=DX*10/w;
			if(kb[VK_DOWN		]){	itb.tpy+=dx;	if(itb.tpy>itb.th-h	)itb.tpy=itb.th-h;}//VY-=DX*10/w;
			if(kb[VK_ADD		]||kb[VK_OEM_PLUS	]||kb[VK_RETURN	])	xs.zoom(1/1.05), function1(), toSolve=true, shiftOnly=0;
			if(kb[VK_SUBTRACT	]||kb[VK_OEM_MINUS	]||kb[VK_BACK	])	xs.zoom(  1.05), function1(), toSolve=true, shiftOnly=0;
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
		}
		int inputLButtonDown(int lParam)
		{
			if(!drag)
			{
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
				SetCapture(ghWnd);
				drag=1;
				if(!time_variance&&!timer)
				{
					POINT p=centerP;
					ScreenToClient(ghWnd, &p), ((short*)&oldMouse)[0]=short(p.x), ((short*)&oldMouse)[1]=short(p.y);
					a_draw();
				}
			}
			return 0;
		}
		int inputMouseMove(int lParam)
		{
			bool draw=false;
			if(drag)
			{
				if(!m_bypass)
				{
					int dx=((short*)&lParam)[0]-w/2, dy=h/2-((short*)&lParam)[1];
					if(_2d_drag_graph_not_window)
						dx=-dx, dy=-dy;
					xs.shift(dx);
					toSolve=true;
					if(shiftOnly)
						shiftOnly=1, Xoffset+=dx;
					SetCursorPos(centerP.x, centerP.y);
					if(!time_variance&&!timer)
						draw=true;
				}
				m_bypass=!m_bypass;
			}
			if(draw)
				a_draw();
			return 0;
		}
		void inputLButtonUp(int lParam)
		{
			if(drag)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
				if(!time_variance&&!timer)
				{
					POINT p=mouseP0;
					ScreenToClient(ghWnd, &p), ((short*)&oldMouse)[0]=(short)p.x, ((short*)&oldMouse)[1]=(short)p.y;
					a_draw();
				}
			}
		}
		int inputMouseWheel(int wParam)
		{
			int mx=((short*)&oldMouse)[0], my=((short*)&oldMouse)[1];
			bool mw_forward=((short*)&wParam)[1]>0;
				 if(mw_forward)	xs.zoom_x(1/1.1, mx);
			else				xs.zoom_x(  1.1, mx);
			function1();
			toSolve=true, shiftOnly=0;
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyDown(int wParam, int lParam)
		{
			auto &VX=xs.VX, &DX=xs.DX;
			switch(wParam)
			{
			case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
			case VK_ADD:case VK_SUBTRACT:
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(!kb[wParam])
					++kp;
				if(!time_variance&&!timer)
					SetTimer(ghWnd, 0, 10, 0), timer=true;
				return 0;
			case 'C':
				clearScreen=!clearScreen;
				break;
			case 'R':
				if(!kb[VK_CONTROL])
					xs.reset_scale(), function1();
				xs.reset_position();
				//	DX=20, function1();
				//VX=0;
				toSolve=true, shiftOnly=0;
				break;
			default:
				if(lParam&1<<30)
					return 0;
				break;
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyUp(int wParam)
		{
			switch(wParam)
			{
			case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
			case VK_ADD:case VK_SUBTRACT://numpad
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(kp)//start+key
					--kp;
				return 0;
			}
			return 0;
		}
		void function1(){xs.update_scale(xs.DX, 1, w);}
		void draw()
		{
			auto &VX=xs.VX, &DX=xs.DX;
		//	double Xr=w/DX;
			if(usingOpenGL)
				gl_disabledepthtest();
			if(!clearScreen)//draw 1D checkboard
			{
				penBrush.use();
			//	hPen=(HPEN__*)SelectObject(ghMemDC, hPen), hBrush=(HBRUSH__*)SelectObject(ghMemDC, hBrush);
				{
					xs.set_Xplaces(w);
					double rXstart=xs.start_checkboard();
					int x1, x2, x3;
					x1=xs.fn_x_int(rXstart);
					for(double x=rXstart;x<xs.Xend;)
					{
						if(xs.next(x))
							break;
						x2=xs.fn_x_int(x);
						if(xs.next(x))
							break;
						x3=xs.fn_x_int(x);
					//	Rectangle(ghMemDC, x1+1, 0, x2+1, h);
						rectangle(x1, 0, x2, h);
					//	Rectangle(ghMemDC, x1, 0, x2, h);
						x1=x3;
					}
				}
				penBrush.drop();
			//	hPen=(HPEN__*)SelectObject(ghMemDC, hPen), hBrush=(HBRUSH__*)SelectObject(ghMemDC, hBrush);
			}
			if(toSolve)
			{
				if(shiftOnly==1&&abs(Xoffset)<Xplaces)
				{
					if(Xoffset)
					{
						solver.partial_bounds(Xoffset);
						solver.synchronize();
						for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)
						{
							auto &ex=expr[ke];
							if(ex.rmode[0]==10)
							{
								if(ex.nITD)
									solver.full(ex);
								else
									solver.partial(ex);
							}
						}
					}
				}
				else
				{
					auto old_time_variance=time_variance;
					time_variance=false;
					labels.clear();
					xs.set_Xplaces(w);
					solver.full_resize(Xplaces=setXplaces(w));
					if(!paused)
						solver.synchronize();
					for(unsigned e=0;e<expr.size();++e)
					{
						auto &ex=expr[e];
						if(ex.rmode[0]==10)
						{
							time_variance|=ex.nITD;
							labels.fill(e);
							solver.full(ex);
						}
					}
					if(time_variance)
					{
						if(!paused)
							SetTimer(ghWnd, 0, 10, 0);
					}
					else if(old_time_variance&&!timer)
						KillTimer(ghWnd, 0);
				}
				toSolve=false, shiftOnly=2, Xoffset=0;
				exprRemoved=false;
			}
			else if(exprRemoved)
			{
				auto old_time_variance=time_variance;
				time_variance=false;
				labels.clear();
				for(unsigned e=0;e<expr.size();++e)
				{
					auto &ex=expr[e];
					if(ex.rmode[0]==10)
					{
						time_variance|=ex.nITD;
						labels.fill(e);
					}
				}
				if(old_time_variance&&!time_variance&&!timer)
					KillTimer(ghWnd, 0);
				exprRemoved=false;
			}
			else if(time_variance)
			{
				if(!paused)
					solver.synchronize();
				for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)
				{
					auto &ex=expr[ke];
					if(ex.rmode[0]==10&&ex.nITD)
						solver.full(ex);
				}
			}
			int colorCondition=nExpr[10]>1;
			if(!clearScreen)
			{
				int H=(h>>1)+1;
			//	int H=h/2;
			//	int H=h*3/4;
			//	int H=!drag&&((short*)&oldMouse)[1]>h/2?h/4:h*3/4;
				int bkMode=getBkMode();
			//	int bkMode=GetBkMode(ghMemDC);
				setBkMode(TRANSPARENT);
			//	SetBkMode(ghMemDC, TRANSPARENT);
				for(double x=xs.rXstart, xEnd=xs.Xend;x<xEnd;)
				{
					int linelen=xs.is_not_origin(x)?
							sprintf_s(g_buf, 128, "%g", x)
						:	sprintf_s(g_buf, 128, "0");
					int X=xs.fn_x_int(x);
					print(X+2, H, g_buf, linelen);
				//	TextOutA(ghMemDC, X+2, H, g_buf, linelen);
					if(xs.next(x))
						break;
				}
				{
					int textColor=0;
					if(colorCondition)
						textColor=getTextColor();
					//	textColor=GetTextColor(ghMemDC);
					int Ys=H+(H>h-46?-34:18)-2, Ys0=Ys;
				//	int Ys=H+(H>h-46?-34:18), Ys0=Ys;
					for(int kl=0, klEnd=labels.Xlabels.size();kl<klEnd;++kl)
					{
						auto &label=labels.Xlabels[kl];
						if(colorCondition)
							setTextColor(expr[label.exNo].winColor);
						//	SetTextColor(ghMemDC, expr[label.exNo].winColor);
						print(w-arrow_label_offset_X, Ys, label.label.c_str(), label.label.size()), Ys+=16;
					//	TextOutA(ghMemDC, w-arrow_label_offset_X, Ys, label.label.c_str(), label.label.size()), Ys+=16;
					}
					Ys=Ys0>h/3?0:h-16*labels.Clabels.size();
					for(int kl=0, klEnd=labels.Clabels.size();kl<klEnd;++kl)
					{
						auto &label=labels.Clabels[kl];
						if(colorCondition)
							setTextColor(expr[label.exNo].winColor);
						//	SetTextColor(ghMemDC, expr[label.exNo].winColor);
						int linelen=sprintf_s(g_buf, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
						print(w-const_label_offset_X, Ys, g_buf, linelen);
					//	TextOutA(ghMemDC, w-const_label_offset_X, Ys, g_buf, linelen);
						Ys+=16;
					}
					if(colorCondition)
						setTextColor(textColor);
					//	SetTextColor(ghMemDC, textColor);
				}
				setBkMode(bkMode);
			//	SetBkMode(ghMemDC, bkMode);
			}
#if 1
		//	prof_start();//
			if(colorCondition)//draw the solutions
			{
				for(int e=0, eEnd=expr.size();e<eEnd;++e)
				{
					auto &ex=expr[e];
					if(ex.rmode[0]==10)
					{
						auto ndr=(double*)ex.n[ex.resultTerm].r.p;
						int y_eStart=ex.lineNo*fontH-itb.tpy, y_eEnd=(ex.endLineNo+1)*fontH;
					//	int yStart=ex.lineNo*font.H-itb.tpy, yEnd=(e+1<(signed)expr.size()?expr[e+1].lineNo:nLines)*font.H;
					//	int yStart=ex.lineNo*font.H-itb.tpy, yEnd=yStart+font.H;
						y_eStart=clamp_positive(y_eStart);
						y_eEnd=minimum(clamp_positive(y_eEnd), h);
						auto color=(unsigned char*)&ex.getColor();
						const double inv510=1./510;
						double Ab=(0xFF-color[0])*inv510, Ag=(0xFF-color[1])*inv510, Ar=(0xFF-color[2])*inv510;
						if(ex.resultLogicType==2)//= equations aa		several color
						{
							for(int x=0;x<w;++x)
						//	for(int x=0, xEnd=ndr.size()-2;x<xEnd;++x)
							{
								auto a=ndr[x];
								vertical_line_equation(x, y_eStart, y_eEnd, Ar, Ag, Ab, a);
							//	for(int y=y_eStart;y<h;++y)
								//for(int y=y_eStart;y<y_eEnd;++y)
								//{
								//	auto px=(unsigned char*)&rgb[w*y+x];
								//	px[0]-=(unsigned char)(Ab*a*px[0]);
								//	px[1]-=(unsigned char)(Ag*a*px[1]);
								//	px[2]-=(unsigned char)(Ar*a*px[2]);
								//}
								a*=0.5;
								vertical_line_equation(x, y_eEnd, h, a);
								//for(int y=y_eEnd;y<h;++y)
								//{
								//	auto px=(unsigned char*)&rgb[w*y+x];
								//	px[0]-=(unsigned char)(a*px[0]);
								//	px[1]-=(unsigned char)(a*px[1]);
								//	px[2]-=(unsigned char)(a*px[2]);
								//}
							}
						}
						else if(ex.resultLogicType==3)//!=		aa inverted		several color
						{
							double Bb=1-Ab, Bg=1-Ag, Br=1-Ar;
							for(int x=0;x<w;++x)
						//	for(int x=0, xEnd=ndr.size()-2;x<xEnd;++x)
							{
								auto a=ndr[x];
							//	for(int y=y_eStart;y<h;++y)
								vertical_line_antiequation(x, y_eStart, y_eEnd, Ar, Ag, Ab, a, Br, Bg, Bb);
								//for(int y=y_eStart;y<y_eEnd;++y)
								//{
								//	auto px=(unsigned char*)&rgb[w*y+x];
								//	px[0]=(unsigned char)((Bb+Ab*a)*px[0]);
								//	px[1]=(unsigned char)((Bg+Ag*a)*px[1]);
								//	px[2]=(unsigned char)((Br+Ar*a)*px[2]);
								//}
								a=(1+a)*0.5;
								vertical_line_antiequation(x, y_eEnd, h, a);
								//for(int y=y_eEnd;y<h;++y)
								//{
								//	auto px=(unsigned char*)&rgb[w*y+x];
								//	px[0]=(unsigned char)(a*px[0]);
								//	px[1]=(unsigned char)(a*px[1]);
								//	px[2]=(unsigned char)(a*px[2]);
								//}
							}
						}
						else//&& ## || < <= > >= logic/inequality		several color
						{
							for(int x=0;x<w;++x)
						//	for(int x=0, xEnd=ndr.size();x<xEnd;++x)
							{
								if(ndr[x])
								{
								//	for(int y=y_eStart;y<h;++y)
									vertical_line_logic_inequality(x, y_eStart, y_eEnd, Ar, Ag, Ab);
									//for(int y=y_eStart;y<y_eEnd;++y)
									//{
									//	auto px=(unsigned char*)&rgb[w*y+x];
									//	px[0]-=(unsigned char)(Ab*px[0]);
									//	px[1]-=(unsigned char)(Ag*px[1]);
									//	px[2]-=(unsigned char)(Ar*px[2]);
									//}
									vertical_line_logic_inequality(x, y_eEnd, h);
									//for(int y=y_eEnd;y<h;++y)
									//{
									//	auto px=(unsigned char*)&rgb[w*y+x];
									//	px[0]>>=1;
									//	px[1]>>=1;
									//	px[2]>>=1;
									//}
								}
							}
						}
					}
				}
			}
			else//single greyscale expression
			{
				for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)
				{
					auto &ex=expr[ke];
					if(ex.rmode[0]==10)
					{
						auto ndr=(double*)ex.n[ex.resultTerm].r.p;
						if(ex.resultLogicType==2)//= equation aa	one greyscale
					//	if(ex.resultLogicType>=2)
						{
							for(int x=0;x<w;++x)
						//	for(int x=0, xEnd=ndr.size()-2;x<xEnd;++x)
							{
								auto &a=ndr[x];
								vertical_line_equation(x, 0, h, a*0.5);
								//for(int y=0;y<h;++y)
								//{
								//	auto p0=(unsigned char*)&rgb[w*y+x];
								//	p0[0]-=(unsigned char)(p0[0]*a)>>1;
								//	p0[1]-=(unsigned char)(p0[1]*a)>>1;
								//	p0[2]-=(unsigned char)(p0[2]*a)>>1;
								//}
							}
						}
						else if(ex.resultLogicType==3)//!=	aa inverted	one greyscale
						{
							for(int x=0;x<w;++x)
						//	for(int x=0, xEnd=ndr.size()-2;x<xEnd;++x)
							{
								auto a=(1+ndr[x])/2;
								vertical_line_antiequation(x, 0, h, a);
								//for(int y=0;y<h;++y)
								//{
								//	auto p0=(unsigned char*)&rgb[w*y+x];
								//	p0[0]=(unsigned char)(p0[0]*a);
								//	p0[1]=(unsigned char)(p0[1]*a);
								//	p0[2]=(unsigned char)(p0[2]*a);
								//}
							}
						}
						else//&& ## || < <= > >= logic/inequality	one greyscale
						{
							for(int x=0;x<w;++x)
						//	for(int x=0, xEnd=ndr.size();x<xEnd;++x)
							{
								if(ndr[x])
								{
									vertical_line_logic_inequality(x, 0, h);
									//for(int y=0;y<h;++y)
									//{
									//	auto p0=(unsigned char*)&rgb[w*y+x];
									//	p0[0]>>=1;
									//	p0[1]>>=1;
									//	p0[2]>>=1;
									//}
								}
							}
						}
					}
				}
			}
		//	prof_add("draw solution");//
		//	prof_print();//
			//debug test
			//if(usingOpenGL)
			//{
			//	for(int kx=0;kx<w;++kx)
			//	{
			//		if(kx==451)
			//			int LOL_1=0;
			//		byte a=kx*255/w;
			//		Pen pen(a);
			//		pen.use();
			//		line(kx, 0, kx, h);
			//		pen.drop();
			//	}
			//}
#endif
		}
		void i_draw();
		void a_draw();
	} ti1d;
	const int		Implicit_1D::modes[]={10}, Implicit_1D::nmodes=sizeof(modes)>>2;
	void			Implicit_1D::i_draw()
	{
		if(modes::ready)
		{
			draw();
			if(showLastModeOnIdle)
				capture_window(modeRGB);
			//	std::copy(rgb, rgb+w*h, modeRGB);

			selectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			{
				int bkMode=getBkMode();
			//	int bkMode=GetBkMode(ghMemDC);
				setBkMode(OPAQUE);
			//	SetBkMode(ghMemDC, OPAQUE);
				if(nExpr[10]>1)
					itb.draw_color(modes, nmodes);
				else
					itb.draw();
				setBkMode(bkMode);
			//	SetBkMode(ghMemDC, bkMode);
			}
			deselectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	
			if(showBenchmark)
				Performance(0, h-32);//
	//	GUIPrint(ghMemDC, w/2, 0, "tpy=%d", itb.tpy);//
#ifndef BUILD_1_7
			BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
#endif
		}
		else
		{
			display_texture_fullwindow(modeRGB);
		//	std::copy(modeRGB, modeRGB+w*h, rgb);
			if(showBenchmark)
				Performance(0, h-32);//
		}
	}
	void			Implicit_1D::a_draw()
	{
		newframe();
	//	rectangle(bpx-1, bpy-1, bw+1, bh+1);
	//	Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);

		draw();
		
		if(contextHelp)
		{
			const char *help[]=
			{
				"left/right/drag: move",
				"+/-/enter/backspace/wheel: zoom",
				"E: reset scale",
				"R: reset scale & view",
				"C: toggle clear screen",
				"Tab/Shift Tab: switch renderer",
				"Esc: back to text editor"
			};
			print_contextHelp(help, sizeof(help)>>2, 218);
		}
		if(showBenchmark&&!clearScreen)
			Performance(0, h-32);//
	//	GUIPrint(ghMemDC, w/2, 0, "tpy=%d", itb.tpy);//
		show();
	//	BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
		report_error();
	}
	class		Numeric_1D:public Mode
	{
		TextBox tb;
	public:
		Scale xs;
		Solve_1D solver;
		int base;

		bool drag;

		Numeric_1D():xs(0, 20), solver(false, xs), base(10), drag(false){}

		void enter(){}
		void exit(){}
		void pause()
		{
			if(time_variance&&!paused)
			{
				solver.pause();
				KillTimer(ghWnd, 0);
				paused=true;
			}
		}
		void resume()
		{
			if(time_variance)
			{
				SetTimer(ghWnd, 0, 10, 0);
				solver.resume();
				paused=false;
			}
		}
		void appDeactivate()
		{
			if(drag)
			{
				ReleaseCapture();
				tb.inputLButtonUp();
			}
		}
		void appActivate(){}

		void setDimensions(int x, int y, int w, int h){tb.setDimensions(x, y, w, h);}
		void messagePaint(){}
		void messageTimer(){}
		int inputLButtonDown(int lParam)		{return 0;}
		int inputMouseMove(int lParam)			{return 0;}
		void inputLButtonUp(int lParam)			{}
		int inputMouseWheel(int wParam)			{return 0;}
		int inputKeyDown(int wParam, int lParam){return 0;}
		int inputKeyUp(int wParam)				{return 0;}
		void draw()
		{
			tb.textlen=0, tb.text=(char*)realloc(tb.text, (tb.textlen+1)*sizeof(char));
			//const int aSize=1024;
			//char a[aSize];
			int length;
			Expression *exprk=&expr[cursorEx];
			auto &n=exprk->n[exprk->resultTerm];
			if(n.r.size())
			{
				length=0;
				print_value(n, 0, g_buf, length, exprk->resultMathSet, base);
				append(tb.text, tb.textlen, g_buf, length);
				for(unsigned k=1;k<n.r.size();++k)
				{
					length=0;
					length+=sprintf_s(g_buf+length, g_buf_size-length, "\r\n");
					print_value(n, k, g_buf, length, exprk->resultMathSet, base);
					append(tb.text, tb.textlen, g_buf, length);
				}
			}
			selectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			if(active)
				tb.draw();
			else
			{
				setTextColor(0x00777777);
			//	SetTextColor(ghMemDC, 0x00777777);
				Pen pen(0x00777777);
				pen.use();
			//	HPEN__ *hPen=(HPEN__*)SelectObject(ghMemDC, CreatePen(PS_SOLID, 1, 0x00777777));
				tb.draw();
				pen.drop();
			//	DeleteObject(SelectObject(ghMemDC, hPen));
				setTextColor(0);
			//	SetTextColor(ghMemDC, 0);
			}
			deselectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
		}
		void i_draw();
		void a_draw();
	};
	void			Numeric_1D::i_draw()
	{
		if(modes::ready)
		{
			draw();
			if(showLastModeOnIdle)
				capture_window(modeRGB);
			//	std::copy(rgb, rgb+w*h, modeRGB);

			selectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			{
				int bkMode=getBkMode();
			//	int bkMode=GetBkMode(ghMemDC);
				setBkMode(OPAQUE);
			//	SetBkMode(ghMemDC, OPAQUE);
				itb.draw();
				setBkMode(bkMode);
			//	SetBkMode(ghMemDC, bkMode);
			}
			deselectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	
			if(showBenchmark)
				Performance(0, h-32);//
#ifndef BUILD_1_7
			BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
#endif
		}
		else
		{
			display_texture_fullwindow(modeRGB);
		//	std::copy(modeRGB, modeRGB+w*h, rgb);
			if(showBenchmark)
				Performance(0, h-32);//
		}
	}
	void			Numeric_1D::a_draw()
	{
		newframe();
	//	rectangle(bpx-1, bpy-1, bw+1, bh+1);
	//	Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);

		draw();
		
		if(showBenchmark)
			Performance(0, h-32);//
		show();
	//	BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
		report_error();
	}

	bool		difference_t1d_t1dc();
	inline void	sort(double v1, double v2, int si1, int si2, double &dd1, double &dd2, int &di1, int &di2)
	{
		if(v1<v2)
			dd1=v1, di1=si1, dd2=v2, di2=si2;
		else
			dd1=v2, di1=si2, dd2=v1, di2=si1;
	}
	class		Transverse_1D:public _2D_Mode
	{
	public:
		int Xoffset, exprRemoved;

	//	int Xplaces;
		Solve_1D solver;
		std::list<int> operations;
		bool drawImag;
		
		int contourOn, contourOnly;
		//contours[e]=contour, contour[y level (y/step)]=points, *points.begin()=x pos
		std::map<unsigned, std::unordered_map<int, std::list<double>>> contours;

		_2D _2d;
		bool clearScreen;
		Labels_1D labels;
		static const int modes[], nmodes;
		PenBrush penBrush;
		//HPEN__ *hPen;
		//HBRUSH__ *hBrush;

		friend bool difference_t1d_t1dc();

		Transverse_1D():
			solver(true, xs), _2D_Mode(solver),
			Xoffset(0), exprRemoved(0),
			drawImag(false),
			contourOnly(false),
			clearScreen(false),
			penBrush(_2dCheckColor)
		{
		//	hPen=CreatePen(PS_SOLID, 1, _2dCheckColor), hBrush=CreateSolidBrush(_2dCheckColor);
		}
		//~Transverse_1D(){DeleteObject(hPen), DeleteObject(hBrush);}
		
		void doContour(unsigned e)
		{
			auto &ndr=expr[e].n[expr[e].resultTerm].r;
			auto &contour=contours[e];
			int YLstart_t=ys.dist2ticks(ys_Ystart), YLend_t=ys.dist2ticks(ys.Xend)+1;
			for(int v=0, vEnd=ndr.size()-1;v<vEnd;++v)
			{
				auto &V1=ndr[v], &V2=ndr[v+1];
				int V1t, V2t;
				if(V1==V1&&V2==V2&&(V1t=ys.dist2ticks(V1))!=(V2t=ys.dist2ticks(V2)))//both are numbers & on different stripes
				{
					double Y1, Y2;
					int Y1t, Y2t;
					sort(V1, V2, V1t, V2t, Y1, Y2, Y1t, Y2t);
					for(int y=maximum(Y1t, YLstart_t), yEnd=minimum(Y2t, YLend_t);y!=0x80000000&&y<=yEnd;++y)
					{
						double YL=ys.ticks2dist(y);
						contour[y].push_back(xs.ifn_x(v+(YL-V1)/(V2-V1)));
					}
				}
			}
		}
		void differentiate						(Term &n)
		{
			auto ndr_r=n.r.p;
			double step=xs.Xsample, _1_step=xs.inv_Xsample;
			for(int k=0;k<Xplaces-1;++k)
				ndr_r[k]=(ndr_r[k+1]-ndr_r[k])*_1_step;
			ndr_r[n.r.size()-1]/=-step;
		}
		void integrate							(Term &n)
		{
			auto ndr_r=n.r.p;
			double step=xs.Xsample, sum=0;
			for(int k=0;k<Xplaces;++k)
				sum+=ndr_r[k], ndr_r[k]=sum*step;
		}
		fftw_complex *fft_in, *fft_out;
		fftw_plan fft_p, ifft_p;
		unsigned fft_N;
		double fft_sqrt_N;
		void discreteFourrierTransform			(Term &n)
		{
			if(n.i.size()!=n.r.size())
				n.i.resize(n.r.size());
			fft_1d_forward((double*)n.r.p, (double*)n.i.p, Xplaces, fft_N, fft_sqrt_N, fft_in, fft_out, fft_p, ifft_p);
		}
		void inverseDiscreteFourrierTransform	(Term &n)
		{
			if(n.i.size()!=n.r.size())
				n.i.resize(n.r.size());
			fft_1d_inverse((double*)n.r.p, (double*)n.i.p, Xplaces, fft_N, fft_sqrt_N, fft_in, fft_out, fft_p, ifft_p);
		}
		void lowPassFilter						(Term &n){lpf_1d_real(n);}
		void highPassFilter						(Term &n){hpf_1d_real(n);}

		void messageTimer()
		{
			if(_2d_drag_graph_not_window)
			{
				if(kb[VK_LEFT		]){	xs.shift( 10), toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=10;}
				if(kb[VK_RIGHT		]){	xs.shift(-10), toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=10;}
				if(kb[VK_UP			])	ys.shift(-10);
				if(kb[VK_DOWN		])	ys.shift( 10);
			}
			else
			{
				if(kb[VK_LEFT		]){	xs.shift(-10), toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=10;}
				if(kb[VK_RIGHT		]){	xs.shift( 10), toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=10;}
				if(kb[VK_UP			])	ys.shift( 10);
				if(kb[VK_DOWN		])	ys.shift(-10);
			}
			if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])
			{
					 if(kb['X'])xs.zoom(1/1.05), AR_Y/=1.05;
				else if(kb['Y'])AR_Y*=1.05;
				else			xs.zoom(1/1.05);
				function1(), toSolve=true, shiftOnly=0;
			}
			if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])
			{
					 if(kb['X'])xs.zoom(1.05), AR_Y*=1.05;
				else if(kb['Y'])AR_Y/=1.05;
				else			xs.zoom(1.05);
				function1(), toSolve=true, shiftOnly=0;
			}
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
		}
		int inputLButtonDown(int lParam)
		{
			if(!drag)
			{
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
				SetCapture(ghWnd);
				drag=1;
				if(contourOn&&!time_variance&&!timer)
				{
					POINT p=centerP;
					ScreenToClient(ghWnd, &p), ((short*)&oldMouse)[0]=short(p.x), ((short*)&oldMouse)[1]=short(p.y);
					a_draw();
				}
			}
			return 0;
		}
		int inputMouseMove(int lParam)
		{
			bool draw=false;
			if(drag)
			{
				if(!m_bypass)
				{
					int dx=((short*)&lParam)[0]-w/2, dy=h/2-((short*)&lParam)[1];
					if(_2d_drag_graph_not_window)
						dx=-dx, dy=-dy;
					xs.shift(dx), ys.shift(dy);
					toSolve=true;
					if(shiftOnly)
						shiftOnly=1, Xoffset+=dx;
					SetCursorPos(centerP.x, centerP.y);
					if(!time_variance&&!timer)
						draw=true;
				}
				m_bypass=!m_bypass;
			}
			if(contourOn&&!time_variance&&!timer)
				oldMouse=lParam, draw=true;
			if(draw)
				a_draw();
			return 0;
		}
		void inputLButtonUp(int lParam)
		{
			if(drag)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
				if(contourOn&&!time_variance&&!timer)
				{
					POINT p=mouseP0;
					ScreenToClient(ghWnd, &p), ((short*)&oldMouse)[0]=(short)p.x, ((short*)&oldMouse)[1]=(short)p.y;
					a_draw();
				}
			}
		}
		int inputKeyDown(int wParam, int lParam)
		{
			switch(wParam)
			{
			case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
			case VK_ADD:case VK_SUBTRACT://numpad
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(!kb[wParam])
					++kp;
				if(!time_variance&&!timer)
					SetTimer(ghWnd, 0, 10, 0), timer=true;
				return 0;
			case VK_OEM_3://~	contour
				if(contourOn)//was on
				{
					if(kb[VK_CONTROL])
						contourOnly=!contourOnly;
					else
						contourOn=false;
				}
				else//was off
				{
					contourOn=true, contourOnly=false;//turn contour on
					if(!toSolve)
					{
						contours.clear();
						for(unsigned e=0;e<expr.size();++e)
							if(expr[e].rmode[0]==2)
								doContour(e);
					}
				}
				break;
			case '0':case VK_NUMPAD0://reset
				if(operations.size())
					toSolve=true, shiftOnly=0;
				operations.clear();
				drawImag=false;
				break;
			case '1':case VK_NUMPAD1:
			case '2':case VK_NUMPAD2:
			case '3':case VK_NUMPAD3:
			case '4':case VK_NUMPAD4:
			case '5':case VK_NUMPAD5:
			case '6':case VK_NUMPAD6:
				contours.clear();
				{
					auto op=&Transverse_1D::differentiate;
					switch(wParam)
					{
					case '1':case VK_NUMPAD1:operations.push_back(1), op=&Transverse_1D::differentiate;										break;
					case '2':case VK_NUMPAD2:operations.push_back(2), op=&Transverse_1D::integrate;											break;
					case '3':case VK_NUMPAD3:operations.push_back(3), op=&Transverse_1D::discreteFourrierTransform,			drawImag=true;	break;
					case '4':case VK_NUMPAD4:operations.push_back(4), op=&Transverse_1D::inverseDiscreteFourrierTransform,	drawImag=true;	break;
					case '5':case VK_NUMPAD5:operations.push_back(5), op=&Transverse_1D::lowPassFilter;										break;
					case '6':case VK_NUMPAD6:operations.push_back(6), op=&Transverse_1D::highPassFilter;									break;
					}
					for(unsigned e=0;e<expr.size();++e)
					{
						auto &ex=expr[e];
						if(ex.rmode[0]==2)
						{
							(this->*op)(ex.n[ex.resultTerm]);
							if(contourOn)
								doContour(e);
						}
					}
				}
				break;
			case 'C':
				clearScreen=!clearScreen;
				break;
			case 'L':case 'S':
				{
					bool xlogscale0=xs.logscale, ylogscale0=ys.logscale,
						xlogscale=xs.logscale, ylogscale=ys.logscale;
						 if(!kb['X']&&!kb['Y'])	xlogscale=ylogscale=!xlogscale;
					else						(char&)xlogscale^=kb['X'], (char&)ylogscale^=kb['Y'];
					if(xlogscale!=xlogscale0)
						xs.toggle_logscale();
					if(ylogscale!=ylogscale0)
						ys.toggle_logscale();
					function1(), toSolve=true, shiftOnly=0;
				}
				break;
			case 'E':
				xs.reset_scale(), ys.reset_scale(), AR_Y=1, function1();
				toSolve=true, shiftOnly=0;
				break;
			case 'R':
				if(!kb[VK_CONTROL])
					xs.reset_scale(), ys.reset_scale(), AR_Y=1, function1();
				xs.reset_position(), ys.reset_position();
				toSolve=true, shiftOnly=0;
				break;
			default:
				if(lParam&1<<30)
					return 0;
				break;
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		double (*scale_fn_y)(double y, double Yend, double inv_Ysample);
		void draw_curve(double *ndr, int Yoffset)
		{
			if(usingOpenGL)
				GL2_2D::curve_begin();
			_2d.curve_start();
			for(int v=0, vEnd=Xplaces;v<vEnd;++v)
				_2d.curve_point(bpx+v, ys.fn_y(ndr[v])+Yoffset);
			_2d.set_point();
			if(usingOpenGL)
				GL2_2D::draw_curve();
		}
		void draw_curve_disc(double *ndr, std::vector<bool> const &discontinuities)
		{
			if(usingOpenGL)
				GL2_2D::curve_begin();
			_2d.curve_start();
			for(int v=0, vEnd=solver.Xplaces-1;v<vEnd;++v)
			{
				_2d.curve_point(bpx+v, ys.fn_y(ndr[v]));
				if(discontinuities[v])
					_2d.curve_start();
			}
			_2d.curve_point(bpx+Xplaces-1, ys.fn_y(ndr[Xplaces-1]));
			_2d.set_point();
			if(usingOpenGL)
				GL2_2D::draw_curve();
		}
		void draw()
		{
		//	prof_start();//
			if(usingOpenGL)
				gl_disabledepthtest();
			ys.DX=xs.DX*h/(w*AR_Y);
			if(ys.DX<=0)
				ys.DX=1;
			prof_add("disable depth test");
			_2dMode_DrawCheckboard_range(penBrush, xs, ys, 0, w, h, 0);
			prof_add("draw checkboard");
		//	_2dMode_DrawCheckboard_range(hPen, hBrush, xs, ys, 0, w, h, 0);
			if(toSolve)
			{
				if(!operations.size()&&shiftOnly==1&&abs(Xoffset)<Xplaces)
				{
					if(Xoffset)
					{
						solver.partial_bounds(Xoffset);
						solver.synchronize();
						for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)
						{
							auto &ex=expr[ke];
							if(ex.rmode[0]==2)
							{
								if(ex.nITD)
									solver.full(ex);
								else
									solver.partial(ex);
							}
						}
					}
				}
				else
				{
					auto old_time_variance=time_variance;
					time_variance=false;
					labels.clear();
					xs.set_Xplaces(w), ys.set_Xplaces(h);
					solver.full_resize(w);
					if(!paused)
						solver.synchronize();
					for(unsigned e=0;e<expr.size();++e)
					{
						auto &ex=expr[e];
						if(ex.rmode[0]==2)
						{
							time_variance|=ex.nITD;
							labels.fill(e);
							solver.full(ex);
							for(auto it=operations.begin();it!=operations.end();++it)
							{
								auto &operation=*it;
								switch(operation)
								{
								case 1:differentiate					(ex.n[ex.resultTerm]);break;
								case 2:integrate						(ex.n[ex.resultTerm]);break;
								case 3:discreteFourrierTransform		(ex.n[ex.resultTerm]);break;
								case 4:inverseDiscreteFourrierTransform	(ex.n[ex.resultTerm]);break;
								case 5:lowPassFilter					(ex.n[ex.resultTerm]);break;
								case 6:highPassFilter					(ex.n[ex.resultTerm]);break;
								}
							}
						}
					}
					if(time_variance)
					{
						if(!paused)
							SetTimer(ghWnd, 0, 10, 0);
					}
					else if(old_time_variance&&!timer)
						KillTimer(ghWnd, 0);
				}
				if(contourOn)
				{
					contours.clear();
					for(unsigned e=0;e<expr.size();++e)
						if(expr[e].rmode[0]==2)
							doContour(e);
				}
				toSolve=false, shiftOnly=2, Xoffset=0;
			}
			else if(exprRemoved)
			{
				auto old_time_variance=time_variance;
				time_variance=false;
				labels.clear();
				for(unsigned e=0;e<expr.size();++e)
				{
					auto &ex=expr[e];
					if(ex.rmode[0]==2)
					{
						time_variance|=ex.nITD;
						labels.fill(e);
					}
				}
				if(old_time_variance&&!time_variance&&!timer)
					KillTimer(ghWnd, 0);
				exprRemoved=false;
			}
			else if(time_variance)
			{
				if(!paused)
					solver.synchronize();
				for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)
				{
					auto &ex=expr[ke];
					if(ex.rmode[0]==2&&ex.nITD)
					{
						solver.full(ex);
						for(auto it=operations.begin();it!=operations.end();++it)
						{
							auto &operation=*it;
							switch(operation)
							{
							case 1:differentiate					(ex.n[ex.resultTerm]);break;
							case 2:integrate						(ex.n[ex.resultTerm]);break;
							case 3:discreteFourrierTransform		(ex.n[ex.resultTerm]);break;
							case 4:inverseDiscreteFourrierTransform	(ex.n[ex.resultTerm]);break;
							case 5:lowPassFilter					(ex.n[ex.resultTerm]);break;
							case 6:highPassFilter					(ex.n[ex.resultTerm]);break;
							}
						}
					}
				}
				if(contourOn)
				{
					for(unsigned e=0;e<expr.size();++e)
					{
						auto &ex=expr[e];
						if(ex.rmode[0]==2&&ex.nITD)
							doContour(e);
					}
				}
			}
			else if(nExpr[3]&&difference_t1d_t1dc())
			{
				for(unsigned e=0;e<expr.size();++e)
				{
					auto &ex=expr[e];
					if(ex.rmode[0]==2&&!ex.nITD)
					{
						solver.full(ex);
						for(auto it=operations.begin();it!=operations.end();++it)
						{
							auto &operation=*it;
							switch(operation)
							{
							case 1:differentiate					(ex.n[ex.resultTerm]);break;
							case 2:integrate						(ex.n[ex.resultTerm]);break;
							case 3:discreteFourrierTransform		(ex.n[ex.resultTerm]);break;
							case 4:inverseDiscreteFourrierTransform	(ex.n[ex.resultTerm]);break;
							case 5:lowPassFilter					(ex.n[ex.resultTerm]);break;
							case 6:highPassFilter					(ex.n[ex.resultTerm]);break;
							}
						}
					}
				}
			}
			prof_add("solve");
			int colorCondition=nExpr[2]>1;
			if(!clearScreen)
			{
				int bkMode=getBkMode();
			//	int bkMode=GetBkMode(ghMemDC);
				int H=0, V=0, VT=0;
				_2dMode_NumberAxes(H, V, VT, xs, ys);
				line(0, H, w, H), line(V, 0, V, h);
			//	MoveToEx(ghMemDC, 0, H, 0), LineTo(ghMemDC, w, H), MoveToEx(ghMemDC, V, 0, 0), LineTo(ghMemDC, V, h);
				{
					int textColor;
					if(colorCondition)
						textColor=getTextColor();
					//	textColor=GetTextColor(ghMemDC);
					int Ys=H+(H>h-46?-34:18), Ys0=Ys;
					for(int kl=0, klEnd=labels.Xlabels.size();kl<klEnd;++kl)
					{
						auto &label=labels.Xlabels[kl];
						if(colorCondition)
							setTextColor(expr[label.exNo].winColor);
						//	SetTextColor(ghMemDC, expr[label.exNo].winColor);
						print(w-arrow_label_offset_X, Ys, label.label.c_str(), label.label.size()), Ys+=16;
					//	TextOutA(ghMemDC, w-arrow_label_offset_X, Ys, label.label.c_str(), label.label.size()), Ys+=16;
					}
					Ys=Ys0>h/3?0:h-16*labels.Clabels.size();
					for(int kl=0, klEnd=labels.Clabels.size();kl<klEnd;++kl)
					{
						auto &label=labels.Clabels[kl];
						if(colorCondition)
							setTextColor(expr[label.exNo].winColor);
						//	SetTextColor(ghMemDC, expr[label.exNo].winColor);
						int linelen=sprintf_s(g_buf, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
						print(w-const_label_offset_X, Ys, g_buf, linelen);
					//	TextOutA(ghMemDC, w-const_label_offset_X, Ys, g_buf, linelen);
						Ys+=16;
					}
					if(colorCondition)
						setTextColor(textColor);
					//	SetTextColor(ghMemDC, textColor);
				}
				setBkMode(bkMode);
			//	SetBkMode(ghMemDC, bkMode);
			}
			prof_add("number axes");
			Pen gPen;
		//	HPEN hGPen=0;
			int colored=0;
			if(!contourOnly)//draw the curves
			{
				if(operations.size())
				{
					for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)
					{
						auto &ex=expr[ke];
						if(ex.rmode[0]==2)
						{
							if(colorCondition)
								gPen.set(ex.winColor), gPen.use(), _2d.lineColor=ex.getColor(), colored=1;
							//	hGPen=(HPEN)SelectObject(ghMemDC, CreatePen(PS_SOLID, 1, ex.winColor)), _2d.lineColor=ex.color, colored=1;
							auto &n=ex.n[ex.resultTerm];
							draw_curve(n.r.p, 0);
							if(drawImag)
							{
								draw_curve(n.i.p, 0);
								draw_curve(n.i.p, 1);
							}
							if(colored)
								gPen.drop(), gPen.destroy();
							//	DeleteObject(SelectObject(ghMemDC, hGPen)), _2d.lineColor=0, colored=0;
						}
					}
				}
				else
				{
					for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)
					{
						auto &ex=expr[ke];
						if(ex.rmode[0]==2)
						{
							if(colorCondition)
								gPen.set(ex.winColor), gPen.use(), _2d.lineColor=ex.getColor(), colored=1;
							//	hGPen=(HPEN)SelectObject(ghMemDC, CreatePen(PS_SOLID, 1, ex.winColor)), _2d.lineColor=ex.color, colored=1;
							auto &n=ex.n[ex.resultTerm];
							draw_curve_disc(n.r.p, ex.discontinuities);

							if(colored)
								gPen.drop(), gPen.destroy(), _2d.lineColor=0, colored=0;
							//	DeleteObject(SelectObject(ghMemDC, hGPen)), _2d.lineColor=0, colored=0;
						}
					}
				}
			}
			prof_add("draw curves");
			if(contourOn)//draw contour
			{
				int mrX1=-60, mrX2=60, mrY1=-60, mrY2=60;
				auto &mx=((short*)&oldMouse)[0], &my=((short*)&oldMouse)[1];
				for(unsigned e=0;e<expr.size();++e)
				{
					auto &ex=expr[e];
					if(ex.rmode[0]==2)
					{
						if(colorCondition)
							gPen.set(ex.winColor), gPen.use(), _2d.lineColor=ex.getColor(), colored=1;
						//	hGPen=(HPEN)SelectObject(ghMemDC, CreatePen(PS_SOLID, 1, ex.winColor)), _2d.lineColor=ex.color, colored=1;
						auto &contour=contours[e];
						for(auto cit=contour.begin();cit!=contour.end();++cit)
						{
							auto &L=*cit;
							double Y=ys.ticks2dist(L.first);
							int y=ys.fn_y_int(Y);
							for(auto xit=L.second.begin();xit!=L.second.end();++xit)
							{
								auto &X=*xit;
								int x=xs.fn_x_int(X);
							//	int x=int((X-Xstart)*w/DX);
								line(x-5, y, x+5, y);
								line(x, y-5, x, y+5);
								if(active&&x>=mx+mrX1&&x<mx+mrX2&&y>=my+mrY1&&y<my+mrY2)
									GUIPrint(x, y, "%g, %g", X, Y);
							}
						}
						if(colored)
							gPen.drop(), gPen.destroy(), _2d.lineColor=0, colored=0;
						//	DeleteObject(SelectObject(ghMemDC, hGPen)), _2d.lineColor=0, colored=0;
					}
				}
				{
				//	auto ClearDIBPixel=[&](int x, int y){if(x>=0&&x<w&&y>=0&&y<h)rgb[y*w+x]=0;};
					if(active)
					{
						if(drag)
						{
							int w_2=w/2, h_2=h/2;
							setPixel(w_2+mrX1, h_2+mrY1, 0), setPixel(w_2+mrX2, h_2+mrY1, 0);
							setPixel(w_2+mrX1, h_2+mrY2, 0), setPixel(w_2+mrX2, h_2+mrY2, 0);
							//ClearDIBPixel(w_2+mrX1, h_2+mrY1), ClearDIBPixel(w_2+mrX2, h_2+mrY1);
							//ClearDIBPixel(w_2+mrX1, h_2+mrY2), ClearDIBPixel(w_2+mrX2, h_2+mrY2);
						}
						else
						{
							setPixel(mx+mrX1, my+mrY1, 0), setPixel(mx+mrX2, my+mrY1, 0);
							setPixel(mx+mrX1, my+mrY2, 0), setPixel(mx+mrX2, my+mrY2, 0);
							//ClearDIBPixel(mx+mrX1, my+mrY1), ClearDIBPixel(mx+mrX2, my+mrY1);
							//ClearDIBPixel(mx+mrX1, my+mrY2), ClearDIBPixel(mx+mrX2, my+mrY2);
						}
					}
				}
			}
			{
				int k=0, Y=h-operations.size()*16;
				for(auto it=operations.begin();it!=operations.end();++it)
				{
					auto &operation=*it;
					char const *a=0;
					switch(operation)
					{
					case 1:a="%d: Differentiate";break;
					case 2:a="%d: Integrate";break;
					case 3:a="%d: DFT";break;
					case 4:a="%d: IDFT";break;
					case 5:a="%d: LPF";break;
					case 6:a="%d: HPF";break;
					}
					GUIPrint(w-const_label_offset_X, Y, a, k);
					++k, Y+=16;
				}
			}
			prof_add("end");
		}
		void i_draw();
		void a_draw();
	} t1d;
	const int		Transverse_1D::modes[]={2}, Transverse_1D::nmodes=sizeof(modes)>>2;
	void			Transverse_1D::i_draw()
	{
		if(modes::ready)
		{
			draw();
			if(showLastModeOnIdle)
				capture_window(modeRGB);
			//	std::copy(rgb, rgb+w*h, modeRGB);
		
			selectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			{
				int bkMode=getBkMode();
			//	int bkMode=GetBkMode(ghMemDC);
				setBkMode(OPAQUE);
			//	SetBkMode(ghMemDC, OPAQUE);
				if(nExpr[2]>1)
					itb.draw_color(modes, nmodes);
				else
					itb.draw();
				setBkMode(bkMode);
			//	SetBkMode(ghMemDC, bkMode);
			}
			deselectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	
			if(showBenchmark)
				Performance(0, h-32);//
#ifndef BUILD_1_7
			BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
#endif
		}
		else
		{
			display_texture_fullwindow(modeRGB);
		//	std::copy(modeRGB, modeRGB+w*h, rgb);
			if(showBenchmark)
				Performance(0, h-32);//
		}
	}
	void			Transverse_1D::a_draw()
	{
		newframe();
	//	rectangle(bpx-1, bpy-1, bw+1, bh+1);
	//	Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);

		draw();
		
		if(contextHelp)
		{
			const char *help[]=
			{
				"arrows/drag: move",
				"+/-/enter/backspace/wheel: zoom",
				"X/Y +/-/enter/backspace/wheel: scale x/y",
				"X/Y L/S: switch to log scale",
				"E: reset scale",
				"R: reset scale & view",
				"C: toggle clear screen",
				"1: differentiate",
				"2: integrate",
				"3: DFT",
				"4: Inverse DFT",
				"5: LPF",
				"6: HPF",
				"0: reset operations",
				"`: contour",
				"Tab/Shift Tab: switch renderer",
				"Esc: back to text editor"
			};
			print_contextHelp(help, sizeof(help)>>2, 265);
		}
		if(showBenchmark&&!clearScreen)
			Performance(0, h-32);//
		show();
	//	BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
		report_error();
	}
	namespace contour
	{
		struct Double_x_i
		{
			double x, i;
			Double_x_i(double x, double i):x(x), i(i){}
		};
		struct Double_x_r
		{
			double x, r;
			Double_x_r(double x, double r):x(x), r(r){}
		};
	}
	class		Transverse_1D_C:public _3D_Mode
	{
	public:
		int Xoffset, exprRemoved;
		int X0, Y0;

		int Xplaces;
		int KXplaces;
		Solve_1D solver;
		std::list<int> operations;

		bool contourOn, contourOnly;
		//Rcontours[e]=Rcontour, Rcontour[r level (r/rStep)]=points, *points.begin()=(x,i)
		std::map<unsigned, std::unordered_map<int, std::list<contour::Double_x_i>>> Rcontours;
		//Icontours[e]=Icontour, Icontour[i level (i/iStep)]=points, *points.begin()=(x,r)
		std::map<unsigned, std::unordered_map<int, std::list<contour::Double_x_r>>> Icontours;
		
		_3D _3d;
		bool clearScreen, kb_VK_F6_msg;
		Labels_1D labels;
		int gridColor;
		static const int modes[], nmodes;
		
		friend bool difference_t1d_t1dc();

		Transverse_1D_C():
			solver(true, xs), _3D_Mode(solver),
			_3d(4, 4, 4, 225*G2::_pi/180, 324.7356103172454*G2::_pi/180, 1),
			gridColor(_3dGridColor),
			Xoffset(0), exprRemoved(0),
			fft_N(0),
			contourOnly(false),
			clearScreen(false), kb_VK_F6_msg(false)
		{}
		~Transverse_1D_C()
		{
			if(fft_N)
			{
				fftw_destroy_plan(fft_p), fftw_destroy_plan(ifft_p);
				fftw_free(fft_in), fftw_free(fft_out);
			}
		}
		
		void doContour(unsigned e)
		{
			using namespace contour;
			auto &ex=expr[e];
			auto &n=ex.n[ex.resultTerm];
			auto ndr_r=(double*)n.r.p, ndr_i=(double*)n.i.p;
			auto &Rcontour=Rcontours[e];
			auto &Icontour=Icontours[e];
			Rcontour.clear(), Icontour.clear();
			int RLstart=ys.dist2ticks(ys_Ystart-10*ys.Xsample), RLend=ys.dist2ticks(ys.Xend+25*ys.Xsample)+1;
			int ILstart=zs.dist2ticks(zs_Zstart-10*zs.Xsample), ILend=zs.dist2ticks(zs.Xend+25*zs.Xsample)+1;
			//double RLstart=ys.ticks2dist(ys.dist2ticks(ys_Ystart-10*ys.Xsample)), RLend=ys.ticks2dist(ys.dist2ticks(ys.Xend+25*ys.Xsample)+1);
			//double ILstart=zs.ticks2dist(zs.dist2ticks(zs_Zstart-10*zs.Xsample)), ILend=zs.ticks2dist(zs.dist2ticks(zs.Xend+25*zs.Xsample)+1);
		//	double RLstart=std::ceil((Rstart-10*Xs)/Rstep)*Rstep, RLend=std::ceil((Rend+25*Xs)/Rstep)*Rstep;
		//	double ILstart=std::ceil((Istart-10*Xs)/Istep)*Istep, ILend=std::ceil((Iend+25*Xs)/Istep)*Istep;
			for(unsigned v=0, vEnd=Xplaces-1;v<vEnd;++v)
			{
				CompRef V1(ndr_r[v], ndr_i[v]), V2(ndr_r[v+1], ndr_i[v+1]);
				int V1t, V2t;
				if(V1.r==V1.r&&V2.r==V2.r&&(V1t=ys.dist2ticks(V1.r))!=(V2t=ys.dist2ticks(V2.r)))//both are numbers & on different stripes
				{
					double R1, R2;
					int R1t, R2t;
					sort(V1.r, V2.r, V1t, V2t, R1, R2, R1t, R2t);
					for(int r=maximum(R1t, RLstart), rEnd=minimum(R2t, RLend);r<=rEnd;++r)
					{
						double RL=ys.ticks2dist(r);
					//	double RL=Rstep*r;
						if(R1<RL&&RL<=R2)
					//	if(R1<=RL&&RL<R2)
						{
							double M=(RL-V1.r)/(V2.r-V1.r);
							Rcontour[r].push_back(Double_x_i(xs.ifn_x(v+M), V1.i+(V2.i-V1.i)*M));
						}
					}
				}
				if(V1.i==V1.i&&V2.i==V2.i&&(V1t=ys.dist2ticks(V1.i))!=(V2t=ys.dist2ticks(V2.i)))
				{
					double I1, I2;
					int I1t, I2t;
					sort(V1.i, V2.i, V1t, V2t, I1, I2, I1t, I2t);
					for(int i=maximum(I1t, ILstart), iEnd=minimum(I2t, ILend);i<=iEnd;++i)
					{
						double IL=zs.ticks2dist(i);
					//	double IL=Istep*i;
						if(I1<IL&&IL<=I2)
					//	if(I1<=IL&&IL<I2)
						{
							double M=(IL-V1.i)/(V2.i-V1.i);
							Icontour[i].push_back(Double_x_r(xs.ifn_x(v+M), V1.r+(V2.r-V1.r)*M));
						}
					}
				}
			}
		}
		void differentiate						(Term &n)
		{
			auto ndr_r=n.r.p, ndr_i=n.i.p;
			double step=xs.Xsample, inv_step=1/step;
			for(int k=0;k<Xplaces-1;++k)
			{
				CompRef V0(ndr_r[k], ndr_i[k]), V1(ndr_r[k+1], ndr_i[k+1]);
				V0=(V1-V0)*inv_step;
			}
			ndr_r[n.r.size()-1]*=-inv_step, ndr_i[n.i.size()-1]*=-inv_step;
		}
		void integrate							(Term &n)
		{
			auto ndr_r=n.r.p, ndr_i=n.i.p;
			double step=xs.Xsample;
			std::complex<double> sum;
			for(int k=0;k<Xplaces;++k)
			{
				sum+=std::complex<double>(ndr_r[k], ndr_i[k]);
				auto temp=sum*step;
				ndr_r[k]=temp.real(), ndr_i[k]=temp.imag();
			}
		}
		fftw_complex *fft_in, *fft_out;
		fftw_plan fft_p, ifft_p;
		unsigned fft_N;
		double fft_sqrt_N;
		void discreteFourrierTransform			(Term &n)
		{
			if(n.i.size()!=n.r.size())
				n.i.resize(n.r.size());
			fft_1d_forward((double*)n.r.p, (double*)n.i.p, Xplaces, fft_N, fft_sqrt_N, fft_in, fft_out, fft_p, ifft_p);
		}
		void inverseDiscreteFourrierTransform	(Term &n)
		{
			if(n.i.size()!=n.r.size())
				n.i.resize(n.r.size());
			fft_1d_inverse((double*)n.r.p, (double*)n.i.p, Xplaces, fft_N, fft_sqrt_N, fft_in, fft_out, fft_p, ifft_p);
		}
		void lowPassFilter						(Term &n){lpf_1d_complex(n);}
		void highPassFilter						(Term &n){hpf_1d_complex(n);}

		void setDimensions(int x, int y, int w, int h)
		{
			bpx=x, bpy=y, bw=w, bh=h, X0=bpx+bw/2, Y0=bpy+bh/2;
			_3d.setDimensions(x, y, w, h);
			bool XstepChanged, YstepChanged, ZstepChanged;
			function1(XstepChanged, YstepChanged, ZstepChanged);
			//double old_Ystep=Ystep, old_Zstep=Zstep;
			//function1();
			//if(!toSolve&&contourOn&&(old_Ystep!=Ystep||old_Zstep!=Zstep))
			if(!toSolve&&contourOn&&(YstepChanged||ZstepChanged))
			{
				Rcontours.clear(), Icontours.clear();
				for(unsigned e=0;e<expr.size();++e)
					if(expr[e].rmode[0]==2||expr[e].rmode[0]==3)
						doContour(e);
			}
			ready=true;
		}
		void messageTimer()
		{
				 if(kb[VK_SHIFT	]){	 if(kb['W'])	_3d.cam.moveFastForward();
									 if(kb['A'])	_3d.cam.moveFastLeft();
									 if(kb['S'])	_3d.cam.moveFastBack();
									 if(kb['D'])	_3d.cam.moveFastRight();
									 if(kb['T'])	_3d.cam.moveFastUp();
									 if(kb['G'])	_3d.cam.moveFastDown();}
			else				  {	 if(kb['W'])	_3d.cam.moveForward();
									 if(kb['A'])	_3d.cam.moveLeft();
									 if(kb['S'])	_3d.cam.moveBack();
									 if(kb['D'])	_3d.cam.moveRight();
									 if(kb['T'])	_3d.cam.moveUp();
									 if(kb['G'])	_3d.cam.moveDown();}
			double dVD=KXplaces*xs.Xsample;
			if(kb['X'])
			{
				if(kb['Y'])
				{
					if(kb['Z'])
					{
					}
					else		//xy
					{
						if(kb[VK_UP])		ys.VX+=dVD, _3d.cam.p.y+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])		ys.VX-=dVD, _3d.cam.p.y-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT]){	xs.VX+=dVD, _3d.cam.p.x+=_3d_shift_move_cam*dVD, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset+=KXplaces;}
						if(kb[VK_LEFT]){	xs.VX-=dVD, _3d.cam.p.x-=_3d_shift_move_cam*dVD, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset-=KXplaces;}
					}
				}
				else
				{
					if(kb['Z'])	//xz
					{
						if(kb[VK_UP])		zs.VX+=dVD, _3d.cam.p.z+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])		zs.VX-=dVD, _3d.cam.p.z-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT]){	xs.VX+=dVD, _3d.cam.p.x+=_3d_shift_move_cam*dVD, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset+=KXplaces;}
						if(kb[VK_LEFT]){	xs.VX-=dVD, _3d.cam.p.x-=_3d_shift_move_cam*dVD, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset-=KXplaces;}
					}
					else		//x
					{
						if(kb[VK_UP]||kb[VK_RIGHT]){	xs.VX+=dVD, _3d.cam.p.x+=_3d_shift_move_cam*dVD, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset+=KXplaces;}
						if(kb[VK_DOWN]||kb[VK_LEFT]){	xs.VX-=dVD, _3d.cam.p.x-=_3d_shift_move_cam*dVD, toSolve=true;	if(shiftOnly)shiftOnly=1, Xoffset-=KXplaces;}
					}
				}
			}
			else
			{
				if(kb['Y'])
				{
					if(kb['Z'])	//yz
					{
						if(kb[VK_UP])		zs.VX+=dVD, _3d.cam.p.z+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])		zs.VX-=dVD, _3d.cam.p.z-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT])	ys.VX+=dVD, _3d.cam.p.y+=_3d_shift_move_cam*dVD;
						if(kb[VK_LEFT])		ys.VX-=dVD, _3d.cam.p.y-=_3d_shift_move_cam*dVD;
					}
					else		//y
					{
						if(kb[VK_UP]||kb[VK_RIGHT])		ys.VX+=dVD, _3d.cam.p.y+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN]||kb[VK_LEFT])	ys.VX-=dVD, _3d.cam.p.y-=_3d_shift_move_cam*dVD;
					}
				}
				else
				{
					if(kb['Z'])	//z
					{
						if(kb[VK_UP]||kb[VK_RIGHT])		zs.VX+=dVD, _3d.cam.p.x+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN]||kb[VK_LEFT])	zs.VX-=dVD, _3d.cam.p.x-=_3d_shift_move_cam*dVD;
					}
					else
					{
						if(kb[VK_UP])	_3d.cam.turnUp();
						if(kb[VK_DOWN])	_3d.cam.turnDown();
						if(kb[VK_RIGHT])_3d.cam.turnRight();
						if(kb[VK_LEFT])	_3d.cam.turnLeft();
					}
				}
			}
		/*	bool plus, minus;
			if((plus=kb[VK_ADD]||kb[VK_RETURN]||kb[VK_OEM_PLUS])||(minus=kb[VK_SUBTRACT]||kb[VK_BACK]||kb[VK_OEM_MINUS]))
			{
				double A=1, B=0;
				if(plus)
					A*=1/1.1, B+=;
				if(minus)
					A*=1.1;
				if(kb[VK_MENU])//alt+
				{
					if(_3d_zoom_move_cam)//zoom in
						xs.DX*=A, _3d.cam.scaleXYZabout(xs.VX, ys.VX, zs.VX, A);
					//	xs.DX/=1.1, _3d.cam.scaleXYZabout(xs.VX, ys.VX, zs.VX, 1/1.1);
					else//zoom out
						xs.DX/=A;
					//	xs.DX*=1.1;
					function1();
					toSolve=true, shiftOnly=0;
				}
				else if(kb['X'])//x+ stretch (zoom in (stretch), compress y, z)
				{
					if(_3d_stretch_move_cam)
						_3d.cam.scaleXabout(xs.VX, A);
					//	_3d.cam.scaleXabout(xs.VX, 1/1.1);
					//	_3d.cam.p.x=xs.VX+(_3d.cam.p.x-xs.VX)/1.1;
					else
						_3d.cam.p.x*=A;
					//	_3d.cam.p.x/=1.1;
					_3d.cam.p.y*=A, _3d.cam.p.z*=A, _3d.cam.dcam*=A;
					xs.DX*=A, AR_Y*=A, AR_Z*=A, function1();
					ys.VX*=A, zs.VX*=A;
					//_3d.cam.p.y/=1.1, _3d.cam.p.z/=1.1, _3d.cam.dcam/=1.1;
					//xs.DX/=1.1, AR_Y/=1.1, AR_Z/=1.1, function1();
					//ys.VX/=1.1, zs.VX/=1.1;
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Y'])//y+ stretch
				{
					if(_3d_stretch_move_cam)
						_3d.cam.p.y+=ys.VX*0.1;
					ys.VX*=1.1;//move cube
					AR_Y*=1.1, function1();
					if(contourOn)//
						toSolve=true, shiftOnly=0;//
				}
				else if(kb['Z'])//z+ stretch
				{
					if(_3d_stretch_move_cam)
						_3d.cam.p.z+=zs.VX*0.1;
					zs.VX*=1.1;//move cube
					AR_Z*=1.1, function1();
					if(contourOn)//
						toSolve=true, shiftOnly=0;//
				}
				else if(!kb[VK_CONTROL])
					_3d.cam.zoomIn();
			}//*/
			if(kb[VK_ADD]||kb[VK_RETURN]||kb[VK_OEM_PLUS])
			{
				if(kb[VK_MENU])//alt+
				{
					if(_3d_zoom_move_cam)//zoom in
						xs.DX/=1.1, _3d.cam.scaleXYZabout(xs.VX, ys.VX, zs.VX, 1/1.1);
					//	xs.DX/=1.1, _3d.cam.p.x=xs.VX+(_3d.cam.p.x-xs.VX)/1.1, _3d.cam.p.y=ys.VX+(_3d.cam.p.y-ys.VX)/1.1, _3d.cam.p.z=zs.VX+(_3d.cam.p.z-zs.VX)/1.1, _3d.cam.dcam/=1.1;
					else//zoom out
						xs.DX*=1.1;
					function1();
					toSolve=true, shiftOnly=0;
				}
				else if(kb['X'])//x+ stretch (zoom in (stretch), compress y, z)
				{
					if(_3d_stretch_move_cam)
						_3d.cam.scaleXabout(xs.VX, 1/1.1);
					//	_3d.cam.p.x=xs.VX+(_3d.cam.p.x-xs.VX)/1.1;
					else
						_3d.cam.p.x/=1.1;
					_3d.cam.p.y/=1.1, _3d.cam.p.z/=1.1, _3d.cam.dcam/=1.1;
					xs.DX/=1.1, AR_Y/=1.1, AR_Z/=1.1, function1();
					ys.VX/=1.1, zs.VX/=1.1;
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Y'])//y+ stretch
				{
					if(_3d_stretch_move_cam)
						_3d.cam.p.y+=ys.VX*0.1;
					ys.VX*=1.1;//move cube
					AR_Y*=1.1, function1();
					if(contourOn)//
						toSolve=true, shiftOnly=0;//
				}
				else if(kb['Z'])//z+ stretch
				{
					if(_3d_stretch_move_cam)
						_3d.cam.p.z+=zs.VX*0.1;
					zs.VX*=1.1;//move cube
					AR_Z*=1.1, function1();
					if(contourOn)//
						toSolve=true, shiftOnly=0;//
				}
				else if(!kb[VK_CONTROL])
					_3d.cam.zoomIn();
			}
			if(kb[VK_SUBTRACT]||kb[VK_BACK]||kb[VK_OEM_MINUS])
			{
				if(kb[VK_MENU])//alt-
					xs.DX/=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(kb['X'])//x- compress (zoom out (compress), stretch y z)
				{
					if(_3d_stretch_move_cam)
						_3d.cam.scaleXabout(xs.VX, 1.1);
					//	_3d.camx=xs.VX+(_3d.camx-xs.VX)*1.1;
					else
						_3d.cam.p.x*=1.1;
					_3d.cam.p.y*=1.1, _3d.cam.p.z*=1.1, _3d.cam.dcam*=1.1;
					xs.DX*=1.1, AR_Y*=1.1, AR_Z*=1.1, function1();
					ys.VX*=1.1, zs.VX*=1.1;
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Y'])//y- compress
				{
					if(_3d_stretch_move_cam)
						_3d.cam.p.y-=ys.VX/11.;//[sic]
					ys.VX/=1.1;//move cube
					AR_Y/=1.1, function1();
					if(contourOn)//
						toSolve=true, shiftOnly=0;//
				}
				else if(kb['Z'])//z- compress
				{
					if(_3d_stretch_move_cam)
						_3d.cam.p.z-=zs.VX/11.;
					zs.VX/=1.1;//move cube
					AR_Z/=1.1, function1();
					if(contourOn)//
						toSolve=true, shiftOnly=0;//
				}
				else if(!kb[VK_CONTROL])
					_3d.cam.zoomOut();
			}//*/
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
		}
		int inputLButtonDown(int lParam)
		{
			if(!drag)
			{
				if(!shift)
				{
					ShowCursor(0);
					GetCursorPos(&mouseP0);
					SetCursorPos(centerP.x, centerP.y);
					SetCapture(ghWnd);
				}
				drag=1;
				if(contourOn&&!time_variance&&!timer)
				{
					POINT p=centerP;
					ScreenToClient(ghWnd, &p), ((short*)&oldMouse)[0]=(short)p.x, ((short*)&oldMouse)[1]=(short)p.y;
					a_draw();
				}
			}
			return 0;
		}
		int inputMouseMove(int lParam)
		{
			int draw=0;
			if(!m_bypass)
			{
				int dmx=((short*)&lParam)[0]-w/2, dmy=h/2-((short*)&lParam)[1];
				auto &VX=xs.VX, &VY=ys.VX, &VZ=zs.VX;
				if(kb['X'])
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//xyz	mx my mw
						{
							double dVD=xs.Xsample, dVX=dmx*dVD, dVY=dmy*dVD;
							VX+=dVX, _3d.cam.p.x+=dVX*_3d_shift_move_cam;
							VY+=dVY, _3d.cam.p.y+=dVY*_3d_shift_move_cam;
							toSolve=true;
							if(shiftOnly)
								shiftOnly=1, Xoffset+=dmx;
							draw=1;
						}
						else		//xy	mx my
						{
							double dVD=xs.Xsample, dVX=dmx*dVD, dVY=dmy*dVD;
							VX+=dVX, _3d.cam.p.x+=dVX*_3d_shift_move_cam;
							VY+=dVY, _3d.cam.p.y+=dVY*_3d_shift_move_cam;
							toSolve=true;
							if(shiftOnly)
								shiftOnly=1, Xoffset+=dmx;
							draw=1;
						}
					}
					else
					{
						if(kb['Z'])	//xz	mx my
						{
							double dVD=xs.Xsample, dVX=dmx*dVD, dVZ=dmy*dVD;
							VX+=dVX, _3d.cam.p.x+=dVX*_3d_shift_move_cam;
							VZ+=dVZ, _3d.cam.p.z+=dVZ*_3d_shift_move_cam;
							toSolve=true;
							if(shiftOnly)
								shiftOnly=1, Xoffset+=dmx;
						}
						else		//x		mx
						{
							double dVX=dmx*xs.Xsample;
							VX+=dVX, _3d.cam.p.x+=dVX*_3d_shift_move_cam;
							toSolve=true;
							if(shiftOnly)
								shiftOnly=1, Xoffset+=dmx;
						}
						draw=1;
					}
				}
				else
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//yz	mx my
						{
							double dVD=xs.Xsample, dVY=dmx*dVD, dVZ=dmy*dVD;
							VY+=dVY, _3d.cam.p.y+=dVY*_3d_shift_move_cam;
							VZ+=dVZ, _3d.cam.p.z+=dVZ*_3d_shift_move_cam;
						}
						else		//y		mx
						{
							double dVY=dmx*xs.Xsample;
							VY+=dVY, _3d.cam.p.y+=dVY*_3d_shift_move_cam;
						}
						draw=1;
					}
					else
					{
						if(kb['Z'])	//z		my
						{
							double dVZ=dmy*xs.Xsample;
							VZ+=dVZ, _3d.cam.p.z+=dVZ*_3d_shift_move_cam;
							draw=1;
						}
						else if(drag)
						{
							_3d.cam.turnMouse(lParam);
							draw=1;
						}
					}
				}
			}
			if(draw)
			{
				SetCursorPos(centerP.x, centerP.y);
				if(!time_variance&&!timer)
					a_draw();
			}
			else if(contourOn&&!time_variance&&!timer)
				oldMouse=lParam, a_draw();
			m_bypass=!m_bypass;
			return 0;
		}
		void inputLButtonUp(int lParam)
		{
			if(drag)
			{
				if(!shift)
				{
					ReleaseCapture();
					SetCursorPos(mouseP0.x, mouseP0.y);
					ShowCursor(1);
				}
				drag=0;
				if(contourOn&&!time_variance&&!timer)
				{
					POINT p=mouseP0;
					ScreenToClient(ghWnd, &p), ((short*)&oldMouse)[0]=(short)p.x, ((short*)&oldMouse)[1]=(short)p.y;
				//	oldMouse=p.y<<16|p.x;
					a_draw();
				}
			}
		}
		int inputMouseWheel(int wParam)
		{
			bool mw_forward=((short*)&wParam)[1]>0;
			auto &VX=xs.VX, &DX=xs.DX, &VY=ys.VX, &DY=ys.DX, &VZ=zs.VX, &DZ=zs.DX;
			if(kb['X']&&kb['Y']&&kb['Z'])
			{
					 if(mw_forward)	VZ+=KXplaces*xs.Xsample;
				else				VZ-=KXplaces*xs.Xsample;
			}
			else if(kb[VK_MENU])//alt wheel
			{
					 if(mw_forward)	DX*=1.1;
				else				DX/=1.1;
				function1();
				if(_3d_zoom_move_cam)
				{
						 if(mw_forward)	_3d.cam.p.x=VX+(_3d.cam.p.x-VX)*1.1, _3d.cam.p.y=VY+(_3d.cam.p.y-VY)*1.1, _3d.cam.p.z=VZ+(_3d.cam.p.z-VZ)*1.1, _3d.cam.dcam*=1.1;
					else				_3d.cam.p.x=VX+(_3d.cam.p.x-VX)/1.1, _3d.cam.p.y=VY+(_3d.cam.p.y-VY)/1.1, _3d.cam.p.z=VZ+(_3d.cam.p.z-VZ)/1.1, _3d.cam.dcam/=1.1;
				}
				toSolve=true, shiftOnly=0;
			}
			else if(kb['X'])//x wheel
			{
				if(mw_forward)
				{
					if(_3d_stretch_move_cam)
						_3d.cam.p.x=VX+(_3d.cam.p.x-VX)/1.1;
					else
						_3d.cam.p.x/=1.1;
					_3d.cam.p.y/=1.1, _3d.cam.p.z/=1.1, _3d.cam.dcam/=1.1;
					DX/=1.1, AR_Y/=1.1, AR_Z/=1.1;
					VY/=1.1, VZ/=1.1;
				}
				else
				{
					if(_3d_stretch_move_cam)
						_3d.cam.p.x=VX+(_3d.cam.p.x-VX)*1.1;
					else
						_3d.cam.p.x*=1.1;
					_3d.cam.p.y*=1.1, _3d.cam.p.z*=1.1, _3d.cam.dcam*=1.1;
					DX*=1.1, AR_Y*=1.1, AR_Z*=1.1;
					VY*=1.1, VZ*=1.1;
				}
				function1();
				toSolve=true, shiftOnly=0;
			}
			else if(kb['Y'])
			{
					 if(mw_forward)	AR_Y*=1.1, _3d.cam.p.y+=VY*0.1*_3d_stretch_move_cam, VY*=1.1;
				else				AR_Y/=1.1, _3d.cam.p.y-=VY/11.*_3d_stretch_move_cam, VY/=1.1;
				function1();
				toSolve=true, shiftOnly=0;
			}
			else if(kb['Z'])
			{
					 if(mw_forward)	AR_Z*=1.1, _3d.cam.p.z+=VZ*0.1*_3d_stretch_move_cam, VZ*=1.1;
				else				AR_Z/=1.1, _3d.cam.p.z-=VZ/11.*_3d_stretch_move_cam, VZ/=1.1;
				function1();
				toSolve=true, shiftOnly=0;
			}
			else if(kb[VK_CONTROL])
			{
					 if(mw_forward)	_3d.cam.faster();
				else				_3d.cam.slower();
			}
			else
			{
					 if(mw_forward)	_3d.cam.zoomIn();
				else				_3d.cam.zoomOut();
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyDown(int wParam, int lParam)
		{
			switch(wParam)
			{
			case 'W':case 'A':case 'S':case 'D':case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:case 'T':case 'G':
				if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case VK_ADD:case VK_OEM_PLUS:case VK_RETURN:
				if(kb[VK_CONTROL])
					_3d.cam.faster();
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case VK_SUBTRACT:case VK_OEM_MINUS:case VK_BACK:
				if(kb[VK_CONTROL])
					_3d.cam.slower();
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case 'X':case 'Y':case 'Z':
				if(kb[VK_CONTROL])
				{
					if(wParam=='X')
						_3d.teleport_degrees(20, 0, 0, 180, 0, 1);
					else if(wParam=='Y')
						_3d.teleport_degrees(0, 20, 0, -90, 0, 1);
					else
						_3d.teleport_degrees(0, 0, 20, 0, -90, 1);
					break;
				}
				else if(!(lParam&1<<30)&&!shift)
				{
					if(!drag)
					{
						GetCursorPos(&mouseP0);
						ShowCursor(0);
						SetCursorPos(centerP.x, centerP.y);
						SetCapture(ghWnd);
					}
					shift=1;
				}
				return 0;
			case VK_OEM_3://contour
				if(contourOn)
				{
					if(kb[VK_CONTROL])
						contourOnly=!contourOnly;//toggle contour with / without the curves
					else
						contourOn=false;
				}
				else
				{
					contourOn=true, contourOnly=false;//turn contour on
					if(!toSolve)
					{
						Rcontours.clear(), Icontours.clear();
						for(unsigned e=0;e<expr.size();++e)
							if(expr[e].rmode[0]==2||expr[e].rmode[0]==3)
								doContour(e);
					}
				}
				break;
			case '0':case VK_NUMPAD0:
				if(operations.size())
					toSolve=true, shiftOnly=0;
				operations.clear();
				break;
			case '1':case VK_NUMPAD1:
			case '2':case VK_NUMPAD2:
			case '3':case VK_NUMPAD3:
			case '4':case VK_NUMPAD4:
			case '5':case VK_NUMPAD5:
			case '6':case VK_NUMPAD6:
				Rcontours.clear(), Icontours.clear();
				{
					auto op=&Transverse_1D_C::differentiate;
					switch(wParam)
					{
					case '1':case VK_NUMPAD1:operations.push_back(1), op=&Transverse_1D_C::differentiate;					break;
					case '2':case VK_NUMPAD2:operations.push_back(2), op=&Transverse_1D_C::integrate;						break;
					case '3':case VK_NUMPAD3:operations.push_back(3), op=&Transverse_1D_C::discreteFourrierTransform;		break;
					case '4':case VK_NUMPAD4:operations.push_back(4), op=&Transverse_1D_C::inverseDiscreteFourrierTransform;break;
					case '5':case VK_NUMPAD5:operations.push_back(5), op=&Transverse_1D_C::lowPassFilter;					break;
					case '6':case VK_NUMPAD6:operations.push_back(6), op=&Transverse_1D_C::highPassFilter;					break;
					}
					if(!toSolve)//lazy solve?
					{
						for(unsigned e=0;e<expr.size();++e)
						{
							auto &ex=expr[e];
							if(ex.rmode[0]==2||ex.rmode[0]==3)
								(this->*op)(ex.n[ex.resultTerm]);
						}
						if(contourOn)
						{
							for(unsigned e=0;e<expr.size();++e)
							{
								auto &ex=expr[e];
								if(ex.rmode[0]==2||ex.rmode[0]==3)
									doContour(e);
							}
						}
					}
				}
				break;
			case 'C':
				clearScreen=!clearScreen;
				break;
			case 'L':
				{
					bool xlogscale0=xs.logscale, ylogscale0=ys.logscale, zlogscale0=zs.logscale,
						xlogscale=xs.logscale, ylogscale=ys.logscale, zlogscale=zs.logscale;
						 if(!kb['X']&&!kb['Y'])	xlogscale=ylogscale=zlogscale=!xlogscale;
					else						(char&)xlogscale^=kb['X'], (char&)ylogscale^=kb['Y'], (char&)zlogscale^=kb['Z'];
					if(xlogscale!=xlogscale0)
						xs.toggle_logscale();
					if(ylogscale!=ylogscale0)
						ys.toggle_logscale();
					if(zlogscale!=zlogscale0)
						zs.toggle_logscale();
					function1(), toSolve=true, shiftOnly=0;
				}
				break;
			case 'E':
				{
					double r=20/xs.DX;
					xs.VX*=r, ys.VX*=r, zs.VX*=r;
					_3d.cam.p.x*=r, _3d.cam.p.y*=r, _3d.cam.p.z*=r, _3d.cam.dcam*=r;
					xs.reset_scale(), ys.reset_scale(), zs.reset_scale(), AR_Y=1, AR_Z=1, function1();
					toSolve=true, shiftOnly=0;
				}
				break;
			case 'R':
				_3d.cam.dcam=.04, _3d.cam.tanfov=1;
				if(!kb[VK_CONTROL])
					xs.reset_scale(), ys.reset_scale(), zs.reset_scale(), AR_Y=1, AR_Z=1, function1();
				xs.reset_position(), ys.reset_position(), zs.reset_position();
				toSolve=true, shiftOnly=0;
				if(kb['X'])
					_3d.teleport_degrees(20, 0, 0, 180, 0, 1);
				else if(kb['Y'])
					_3d.teleport_degrees(0, 20, 0, 270, 0, 1);
				else if(kb['Z'])
					_3d.teleport_degrees(0, 0, 20, 90, 270, 1);
				else
					_3d.teleport_degrees(4, 4, 4, 225, 324.7356103172454, 1);
			//	if(kb[VK_CONTROL])
			//	{
			//		_3d.cam.dcam=.04;
			//		DX=20, AR_Y=1, AR_Z=1, function1();
			//		toSolve=true, shiftOnly=0;
			//	}
			//	if(VX!=0||VY!=0||VZ!=0)
			//	{
			//		VX=VY=VZ=0;
			//		toSolve=true, shiftOnly=0;
			//	}
			//	if(kb[VK_CONTROL])
			//		_3d.teleport_degrees(20, 0, 0, 180, 0, 1);
			//	else
			//		_3d.teleport_degrees(4, 4, 4, 225, 324.7356103172454, 1);
				break;
			case VK_F6:
				if(!(lParam&1<<30))
				{
					kb_VK_F6_msg=true;
					if(!_3d_stretch_move_cam&!_3d_shift_move_cam&!_3d_zoom_move_cam)
						_3d_stretch_move_cam=true;
					else if(!_3d_shift_move_cam&!_3d_zoom_move_cam)
						_3d_shift_move_cam=true;
					else if(!_3d_zoom_move_cam)
						_3d_zoom_move_cam=true;
					else
						_3d_stretch_move_cam=_3d_shift_move_cam=_3d_zoom_move_cam=false;
				}
				break;
			default:
				if(lParam&1<<30)
					return 0;
				break;
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		void draw()
		{
			if(usingOpenGL)
				gl_enabledepthtest();
			xs.set_Xplaces(1000), ys.set_Xplaces(1000), zs.set_Xplaces(1000);
			if(toSolve)
			{
				if(!operations.size()&&shiftOnly==1&&abs(Xoffset)<Xplaces)
				{
					if(Xoffset)
					{
						solver.partial_bounds(Xoffset);
						if(time_variance)
							solver.synchronize();
						for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)
						{
							auto &ex=expr[ke];
							if(ex.rmode[0]==2||ex.rmode[0]==3)
							{
								if(ex.nITD)
									solver.full(ex);
								else
									solver.partial(ex);
							}
						}
					}
				}
				else
				{
					int old_time_variance=time_variance;
					time_variance=0;
					labels.clear();
					Xplaces=1000, xs.set_Xplaces(Xplaces), ys.set_Xplaces(Xplaces);
					solver.full_resize(Xplaces), KXplaces=Xplaces/100?Xplaces/100:1;//Xplaces multiple of 4
					if(!paused)
						solver.synchronize();
					for(unsigned e=0;e<expr.size();++e)
					{
						auto &ex=expr[e];
						if(ex.rmode[0]==2||ex.rmode[0]==3)
						{
							time_variance|=ex.nITD;
							labels.fill(e);
							solver.full(ex);
							for(auto it=operations.begin();it!=operations.end();++it)
							{
								auto &operation=*it;
								switch(operation)
								{
								case 1:differentiate					(ex.n[ex.resultTerm]);break;
								case 2:integrate						(ex.n[ex.resultTerm]);break;
								case 3:discreteFourrierTransform		(ex.n[ex.resultTerm]);break;
								case 4:inverseDiscreteFourrierTransform	(ex.n[ex.resultTerm]);break;
								case 5:lowPassFilter					(ex.n[ex.resultTerm]);break;
								case 6:highPassFilter					(ex.n[ex.resultTerm]);break;
								}
							}
						}
					}
					if(time_variance)
					{
						if(!paused)
							SetTimer(ghWnd, 0, 10, 0);
					}
					else if(old_time_variance&&!timer)
						KillTimer(ghWnd, 0);
				}
				if(contourOn)
				{
					Rcontours.clear(), Icontours.clear();
					for(unsigned e=0;e<expr.size();++e)
						if(expr[e].rmode[0]==2||expr[e].rmode[0]==3)
							doContour(e);
				}
				toSolve=false, shiftOnly=2, Xoffset=0;
				exprRemoved=false;
			}
			else if(exprRemoved)
			{
				auto old_time_variance=time_variance;
				time_variance=false;
				labels.clear();
				for(unsigned e=0;e<expr.size();++e)
				{
					auto &ex=expr[e];
					if(ex.rmode[0]==2||ex.rmode[0]==3)
					{
						time_variance|=ex.nITD;
						labels.fill(e);
					}
				}
				if(old_time_variance&&!time_variance&&!timer)
					KillTimer(ghWnd, 0);
				exprRemoved=false;
			}
			else if(time_variance)
			{
				if(!paused)
					solver.synchronize();
				for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)
				{
					auto &ex=expr[ke];
					if((ex.rmode[0]==2||ex.rmode[0]==3)&&ex.nITD)
					{
						solver.full(ex);
						for(auto it=operations.begin();it!=operations.end();++it)
						{
							auto &operation=*it;
							switch(operation)
							{
							case 1:differentiate					(ex.n[ex.resultTerm]);break;
							case 2:integrate						(ex.n[ex.resultTerm]);break;
							case 3:discreteFourrierTransform		(ex.n[ex.resultTerm]);break;
							case 4:inverseDiscreteFourrierTransform	(ex.n[ex.resultTerm]);break;
							case 5:lowPassFilter					(ex.n[ex.resultTerm]);break;
							case 6:highPassFilter					(ex.n[ex.resultTerm]);break;
							}
						}
					}
				}
				if(contourOn)
				{
					for(unsigned e=0;e<expr.size();++e)//contour
					{
						auto &ex=expr[e];
						if((ex.rmode[0]==2||ex.rmode[0]==3)&&ex.nITD)
							doContour(e);
					}
				}
			}
			else if(difference_t1d_t1dc())
			{
				for(unsigned e=0;e<expr.size();++e)
				{
					auto &ex=expr[e];
					if(ex.rmode[0]==2&&!ex.nITD)
					{
						solver.full(ex);
						for(auto it=operations.begin();it!=operations.end();++it)
						{
							auto &operation=*it;
							switch(operation)
							{
							case 1:differentiate					(ex.n[ex.resultTerm]);break;
							case 2:integrate						(ex.n[ex.resultTerm]);break;
							case 3:discreteFourrierTransform		(ex.n[ex.resultTerm]);break;
							case 4:inverseDiscreteFourrierTransform	(ex.n[ex.resultTerm]);break;
							case 5:lowPassFilter					(ex.n[ex.resultTerm]);break;
							case 6:highPassFilter					(ex.n[ex.resultTerm]);break;
							}
						}
					}
				}
			}

		//	_3dMode_FrameStart(_3d, xs, ys, zs, AR_Y, AR_Z);
			clear_depth_buffer();
			if(usingOpenGL)
				GL2_3D::begin();
			_3dMode_DrawGridNAxes(_3d, xs, ys, zs, AR_Y, AR_Z);
			int colorCondition=nExpr[2]+nExpr[3]>1;
#if 1
			if(!contourOnly)//draw the curves
			{
				if(ys.logscale&&zs.logscale)
				{
					double angle_mul=AR_Y;
				//	double angle_mul=AR_Y*180/G2::_pi;
					for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)
					{
						auto &ex=expr[ke];
						switch(ex.rmode[0])
						{
						case 2:
						case 3:
							{
								if(colorCondition)
									_3d.lineColor=ex.getColor();
								auto &n=ex.n[ex.resultTerm];
								auto ndr_r=(double*)n.r.p, ndr_i=(double*)n.i.p;
								_3d.curve_start();
								if(n.i.size()==Xplaces)
								{
									for(int x=0, xEnd=Xplaces-1;x<xEnd;++x)		//Y: ARG(Z), Z: LOG|Z|
									{
										_3d.curve_point(xs.fn(xs.ifn_x(x)), angle_mul*atan2(ndr_i[x], ndr_r[x]), zs.fn(AR_Z*sqrt(ndr_r[x]*ndr_r[x]+ndr_i[x]*ndr_i[x])));
									//	_3d.curve_point(xs.ifn_x(x), ys.fn(angle_mul*atan2(ndr_i[x], ndr_r[x])), zs.fn(AR_Z*sqrt(ndr_r[x]*ndr_r[x]+ndr_i[x]*ndr_i[x])));
										if(!operations.size()&&ex.discontinuities[x])
											_3d.curve_start();
									}
									_3d.curve_point(xs.fn(xs.ifn_x(Xplaces-1)), angle_mul*atan2(ndr_i[Xplaces-1], ndr_i[Xplaces-1]), zs.fn(AR_Z*sqrt(ndr_r[Xplaces-1]*ndr_r[Xplaces-1]+ndr_i[Xplaces-1]*ndr_i[Xplaces-1])));
								}
								else
								{
									for(int x=0, xEnd=Xplaces-1;x<xEnd;++x)
									{
										_3d.curve_point(xs.fn(xs.ifn_x(x)), angle_mul*(ndr_r[x]<0), zs.fn(AR_Z*abs(ndr_r[x])));
										if(!operations.size()&&ex.discontinuities[x])
											_3d.curve_start();
									}
									_3d.curve_point(xs.fn(xs.ifn_x(Xplaces-1)), angle_mul*(ndr_r[Xplaces-1]<0), zs.fn(AR_Z*abs(ndr_r[Xplaces-1])));
								}

								_3d.lineColor=0;
							}
							break;
						}
					}
				}
				else
				{
					for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)
					{
						auto &ex=expr[ke];
						switch(ex.rmode[0])
						{
						case 2:
						case 3:
							{
								if(colorCondition)
									_3d.lineColor=ex.getColor();
								auto &n=ex.n[ex.resultTerm];
								auto ndr_r=(double*)n.r.p, ndr_i=(double*)n.i.p;
								_3d.curve_start();
								if(n.i.size()==Xplaces)
								{
									for(int x=0, xEnd=Xplaces-1;x<xEnd;++x)
									{
										_3d.curve_point(xs.fn(xs.ifn_x(x)), ys.fn(AR_Y*ndr_r[x]), zs.fn(AR_Z*ndr_i[x]));
										if(!operations.size()&&ex.discontinuities[x])
											_3d.curve_start();
									}
									_3d.curve_point(xs.fn(xs.ifn_x(Xplaces-1)), ys.fn(AR_Y*ndr_r[Xplaces-1]), zs.fn(AR_Z*ndr_i[Xplaces-1]));
								}
								else if(!zs.logscale)
								{
									for(int x=0, xEnd=Xplaces-1;x<xEnd;++x)
									{
										_3d.curve_point(xs.fn(xs.ifn_x(x)), ys.fn(AR_Y*ndr_r[x]), 0);
										if(!operations.size()&&ex.discontinuities[x])
											_3d.curve_start();
									}
									_3d.curve_point(xs.fn(xs.ifn_x(Xplaces-1)), ys.fn(AR_Y*ndr_r[Xplaces-1]), 0);
								}

								_3d.lineColor=0;
							}
							break;
						}
					}
				}
			}
			if(contourOn)//draw contour
			{
				int mrX1=-60, mrX2=60, mrY1=-60, mrY2=60;
				int mx=((short*)&oldMouse)[0], my=((short*)&oldMouse)[1];
				double cross=5*xs.DX/w;
				for(unsigned e=0;e<expr.size();++e)
				{
					auto &ex=expr[e];
					if(ex.rmode[0]==2||ex.rmode[0]==3)
					{
						if(colorCondition)
							_3d.lineColor=ex.getColor();
						auto &Rcontour=Rcontours[e];
						for(auto cit=Rcontour.begin();cit!=Rcontour.end();++cit)
						{
							auto &L=*cit;
							double RL=AR_Y*ys.ticks2dist(L.first);
							for(auto xit=L.second.begin();xit!=L.second.end();++xit)
							{
								auto &X_I=*xit;
								_3d.line(dvec3(X_I.x-cross	, RL			, AR_Z* X_I.i		), dvec3(X_I.x+cross	, RL			, AR_Z* X_I.i));
							//	_3d.line(dvec3(X_I.x		, RL-AR_Y*cross	, AR_Z* X_I.i		), dvec3(X_I.x			, RL+AR_Y*cross	, AR_Z* X_I.i));
								_3d.line(dvec3(X_I.x		, RL			, AR_Z*(X_I.i-cross)), dvec3(X_I.x			, RL			, AR_Z*(X_I.i+cross)));
								int x, y;
								if(active&&_3d.pointCoordinates3dText(X_I.x, RL, X_I.i, x, y)&&x>=mx+mrX1&&x<mx+mrX2&&y>=my+mrY1&&y<my+mrY2)
									_3d.textIn3D_screenCoord(x, y, OPAQUE, "%g, %g + %g i", X_I.x, RL, X_I.i);
							}
						}
						auto Icontour=Icontours[e];
						for(auto lit=Icontour.begin();lit!=Icontour.end();++lit)
						{
							auto &L=*lit;
							double IL=AR_Z*zs.ticks2dist(L.first);
							for(auto xit=L.second.begin();xit!=L.second.end();++xit)
							{
								auto &X_R=*xit;
								_3d.line(dvec3(X_R.x-cross	, AR_Y* X_R.r		, IL			), dvec3(X_R.x+cross	, AR_Y* X_R.r		, IL));
								_3d.line(dvec3(X_R.x		, AR_Y*(X_R.r-cross), IL			), dvec3(X_R.x			, AR_Y*(X_R.r+cross), IL));
							//	_3d.line(dvec3(X_R.x		, AR_Y* X_R.r		, IL-AR_Z*cross	), dvec3(X_R.x			, AR_Y* X_R.r		, IL+AR_Z*cross));
								int x, y;
								if(active&&_3d.pointCoordinates3dText(X_R.x, X_R.r, IL, x, y)&&x>=mx+mrX1&&x<mx+mrX2&&y>=my+mrY1&&y<my+mrY2)
									_3d.textIn3D_screenCoord(x, y, OPAQUE, "%g, %g + %g i", X_R.x, X_R.r, IL);
							}
						}
						if(colorCondition)
							_3d.lineColor=0;
					}
				}
				if(active)
				{
				//	auto ClearDIBPixel=[&](int x, int y){if(x>=0&&x<w&&y>=0&&y<h)rgb[y*w+x]=0;};
					if(drag)
					{
						int X0=w/2, Y0=h/2;
						setPixel(X0+mrX1, Y0+mrY1, 0), setPixel(X0+mrX2, Y0+mrY1, 0);
						setPixel(X0+mrX1, Y0+mrY2, 0), setPixel(X0+mrX2, Y0+mrY2, 0);
						//ClearDIBPixel(X0+mrX1, Y0+mrY1), ClearDIBPixel(X0+mrX2, Y0+mrY1);
						//ClearDIBPixel(X0+mrX1, Y0+mrY2), ClearDIBPixel(X0+mrX2, Y0+mrY2);
					}
					else
					{
						setPixel(mx+mrX1, my+mrY1, 0), setPixel(mx+mrX2, my+mrY1, 0);
						setPixel(mx+mrX1, my+mrY2, 0), setPixel(mx+mrX2, my+mrY2, 0);
						//ClearDIBPixel(mx+mrX1, my+mrY1), ClearDIBPixel(mx+mrX2, my+mrY1);
						//ClearDIBPixel(mx+mrX1, my+mrY2), ClearDIBPixel(mx+mrX2, my+mrY2);
					}
				}
			}
			if(usingOpenGL)
			{
				GL2_3D::end();
				GL2_3D::draw(_3d.cam);
			}
#endif
			if(!clearScreen)//number axes, label axes, print operations
			{
				int bkMode=getBkMode();
			//	int bkMode=GetBkMode(ghMemDC);
				setBkMode(TRANSPARENT);
			//	SetBkMode(ghMemDC, TRANSPARENT);
				_3dMode_NumberAxes(_3d, xs, ys, zs, AR_Y, AR_Z);
				if(colorCondition)
					_3d.arrowLabelsColor(0, 0, 0, 1, 0, 0, labels.Xlabels);
				else
					_3d.arrowLabels		(0, 0, 0, 1, 0, 0, labels.Xlabels);
				{
					int textColor;
					if(colorCondition)
						textColor=getTextColor();
					//	textColor=GetTextColor(ghMemDC);
					int Ys=0;
					for(int kl=0, klEnd=labels.Clabels.size();kl<klEnd;++kl)
					{
						auto &label=labels.Clabels[kl];
						int linelen=sprintf_s(g_buf, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
						if(colorCondition)
							setTextColor(expr[label.exNo].winColor);
						//	SetTextColor(ghMemDC, expr[label.exNo].winColor);
						print(w-const_label_offset_X, Ys, g_buf, linelen), Ys+=16;
					//	TextOutA(ghMemDC, w-const_label_offset_X, Ys, g_buf, linelen), Ys+=16;
					}
					if(colorCondition)
						setTextColor(textColor);
					//	SetTextColor(ghMemDC, textColor);
				}
				if(ys.logscale&&zs.logscale)
				{
					_3d.arrowLabel(0, 0, 0, 0, 1, 0, "Arg()");
					_3d.arrowLabel(0, 0, 0, 0, 0, 1, "Log(Abs())");
				}
				else
				{
					_3d.arrowLabel(0, 0, 0, 0, 1, 0, "Re()");
					_3d.arrowLabel(0, 0, 0, 0, 0, 1, "Im()");
				}
				setBkMode(bkMode);
			//	SetBkMode(ghMemDC, bkMode);
				{
					int k=0, Y=h-operations.size()*16;
					for(auto it=operations.begin();it!=operations.end();++it)
					{
						auto &operation=*it;
						char const *a=0;
						switch(operation)
						{
						case 1:a="%d: Differentiate";break;
						case 2:a="%d: Integrate";break;
						case 3:a="%d: DFT";break;
						case 4:a="%d: IDFT";break;
						case 5:a="%d: LPF";break;
						case 6:a="%d: HPF";break;
						}
						GUIPrint(w-const_label_offset_X, Y, a, k);
						++k, Y+=16;
					}
				}
			}
			//HFONT hFont=(HFONT)SelectObject(ghMemDC, GetStockObject(DEFAULT_GUI_FONT));//debug test
			//for(int k=0, nlabels=_3d.LOL_text.size(), x=w>>1, y=0;k<nlabels;++k)
			//{
			//	GUIPrint(x, y, "%s", _3d.LOL_text[k].second.str.c_str());
			//	y+=13;
			//	if(y>=h-13)
			//		x+=100, y=0;
			//}
			//(HFONT)SelectObject(ghMemDC, hFont);//end debug test
			_3d.text_show();
			if(kb_VK_F6_msg||kb[VK_F6])
			{
				int bkMode=setBkMode(OPAQUE);
			//	int kb_mode=SetBkMode(ghMemDC, OPAQUE);
				kb_VK_F6_msg=false;
				if(!_3d_stretch_move_cam&!_3d_shift_move_cam&!_3d_zoom_move_cam)
					GUIPrint(0, h-18*3, "move cam: [-] scale, [-] shift, [-] zoom");
				else if(!_3d_shift_move_cam&!_3d_zoom_move_cam)
					GUIPrint(0, h-18*3, "move cam: [v] scale, [-] shift, [-] zoom");
				else if(!_3d_zoom_move_cam)
					GUIPrint(0, h-18*3, "move cam: [v] scale, [v] shift, [-] zoom");
				else
					GUIPrint(0, h-18*3, "move cam: [v] scale, [v] shift, [v] zoom");
				setBkMode(bkMode);
			//	SetBkMode(ghMemDC, kb_mode);
			}
		}
		void i_draw();
		void a_draw();
	} t1d_c;
	const int		Transverse_1D_C::modes[]={2, 3}, Transverse_1D_C::nmodes=sizeof(modes)>>2;
	void			Transverse_1D_C::i_draw()
	{
		if(modes::ready)
		{
			draw();
			if(showLastModeOnIdle)
				capture_window(modeRGB);
			//	std::copy(rgb, rgb+w*h, modeRGB);

			selectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			{
				int bkMode=getBkMode();
			//	int bkMode=GetBkMode(ghMemDC);
				setBkMode(OPAQUE);
			//	SetBkMode(ghMemDC, OPAQUE);
				if(nExpr[2]+nExpr[3]>1)
					itb.draw_color(modes, nmodes);
				else
					itb.draw();
				setBkMode(bkMode);
			//	SetBkMode(ghMemDC, bkMode);
			}
			deselectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	
			if(showBenchmark)
				Performance(0, h-32);//
#ifndef BUILD_1_7
			BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
#endif
		}
		else
		{
			display_texture_fullwindow(modeRGB);
		//	std::copy(modeRGB, modeRGB+w*h, rgb);
			if(showBenchmark)
				Performance(0, h-32);//
		}
	}
	void			Transverse_1D_C::a_draw()
	{
		newframe();
	//	rectangle(bpx-1, bpy-1, bw+1, bh+1);
	//	Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);

		draw();
		
		if(contextHelp)
		{
			const char *help[]=
			{
				"W/A/S/D/T/G: move",
				"arrows: turn",
				"+/-/enter/backspace/wheel: change FOV",
				"X/Y/Z arrows/mouse move: shift x/y/z",
				"X/Y/Z +/-/enter/backspace/wheel: scale x/y/z",
				"alt +/-/enter/backspace/wheel: zoom",
				"X/Y L: switch to log scale",
				"E: reset scale",
				"R: reset scale & view",
				"C: toggle clear screen",
				"F6: change camera settings",
				"1: differentiate",
				"2: integrate",
				"3: DFT",
				"4: Inverse DFT",
				"5: LPF",
				"6: HPF",
				"0: reset operations",
				"`: contour",
				"Tab/Shift Tab: switch renderer",
				"Esc: back to text editor"
			};
			print_contextHelp(help, sizeof(help)>>2, 294);
		}
		if(showBenchmark&&!clearScreen)
			Performance(0, h-32);//
		show();
	//	BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
		report_error();
	}
	bool		difference_t1d_t1dc(){return t1d.xs.VX!=t1d_c.xs.VX||t1d.xs.DX!=t1d_c.xs.DX||t1d.solver.Xplaces!=t1d_c.solver.Xplaces;}

	namespace contour
	{
		struct Vector4d
		{
			double a, b, c, d;
			Vector4d(double a, double b, double c, double d):a(a), b(b), c(c), d(d){}
			virtual void print(int x, int y, double e)=0;
		};
		struct Double_x_i_j_k:public Vector4d
		{
			Double_x_i_j_k(double x, double i, double j, double k):Vector4d(x, i, j, k){}
			void print(int x, int y, double R){GUIPrint(x, y, "%g, %g+%gi+%gj+%gk", a, R, b, c, d);}//use Value::print
		};
		struct Double_x_r_j_k:public Vector4d
		{
			Double_x_r_j_k(double x, double r, double j, double k):Vector4d(x, r, j, k){}
			void print(int x, int y, double I){GUIPrint(x, y, "%g, %g+%gi+%gj+%gk", a, b, I, c, d);}
		};
		struct Double_x_r_i_k:public Vector4d
		{
			Double_x_r_i_k(double x, double r, double i, double k):Vector4d(x, r, i, k){}
			void print(int x, int y, double J){GUIPrint(x, y, "%g, %g+%gi+%gj+%gk", a, b, c, J, d);}
		};
		struct Double_x_r_i_j:public Vector4d
		{
			Double_x_r_i_j(double x, double r, double i, double j):Vector4d(x, r, i, j){}
			void print(int x, int y, double K){GUIPrint(x, y, "%g, %g+%gi+%gj+%gk", a, b, c, d, K);}
		};
		//struct Double_x_i_j_k
		//{
		//	double x, i, j, k;
		//	Double_x_i_j_k(double x, double i, double j, double k):x(x), i(i), j(j), k(k){}
		//};
		//struct Double_x_r_j_k
		//{
		//	double x, r, j, k;
		//	Double_x_r_j_k(double x, double r, double j, double k):x(x), r(r), j(j), k(k){}
		//};
		//struct Double_x_r_i_k
		//{
		//	double x, r, i, k;
		//	Double_x_r_i_k(double x, double r, double i, double k):x(x), r(r), i(i), k(k){}
		//};
		//struct Double_x_r_i_j
		//{
		//	double x, r, i, j;
		//	Double_x_r_i_j(double x, double r, double i, double j):x(x), r(r), i(i), j(j){}
		//};
	}
	class		Transverse_1D_H:public _2D_Mode
	{
	public:
		int Xoffset;

	//	int Xplaces;
		Solve_1D solver;
		std::list<int> operations;

		bool contourOn, contourOnly;
		std::map<unsigned, std::unordered_map<int, std::list<contour::Double_x_i_j_k>>> Rcontours;
		//Rcontours[e]=Rcontour, Rcontour[r level (r/step)]=points, *points.begin()=(x,i,j,k)
		std::map<unsigned, std::unordered_map<int, std::list<contour::Double_x_r_j_k>>> Icontours;
		//Icontours[e]=Icontour, Icontour[i level (i/step)]=points, *points.begin()=(x,r,j,k)
		std::map<unsigned, std::unordered_map<int, std::list<contour::Double_x_r_i_k>>> Jcontours;
		//Jcontours[e]=Jcontour, Jcontour[j level (j/step)]=points, *points.begin()=(x,r,i,k)
		std::map<unsigned, std::unordered_map<int, std::list<contour::Double_x_r_i_j>>> Kcontours;
		//Kcontours[e]=Kcontour, Kcontour[k level (k/step)]=points, *points.begin()=(x,r,i,j)
		
		_2D _2d;
		bool clearScreen;
		Labels_1D labels;
		static const int rColor=0, iColor=0x00EF0000, jColor=0x0000EF00, kColor=0x000000EF;
		PenBrush penGrid;
		Pen penR, penI, penJ, penK;
		//HPEN__ *hPenGrid, *hPenR, *hPenI, *hPenJ, *hPenK;
		//HBRUSH__ *hBrush;
		static const int modes[], nmodes;


		Transverse_1D_H():
			solver(true, xs), _2D_Mode(solver),
			Xoffset(0),
			clearScreen(false),
			penGrid(_2dCheckColor), penR(rColor), penI(iColor), penJ(jColor), penK(kColor)
		{
			//hPenGrid=CreatePen(PS_SOLID, 1, _2dCheckColor), hBrush=CreateSolidBrush(_2dCheckColor);
			//hPenR=CreatePen(PS_SOLID, 1, rColor), hPenI=CreatePen(PS_SOLID, 1, iColor), hPenJ=CreatePen(PS_SOLID, 1, jColor), hPenK=CreatePen(PS_SOLID, 1, kColor);
		}
		//~Transverse_1D_H()
		//{
		//	DeleteObject(hPenGrid), DeleteObject(hBrush);
		//	DeleteObject(hPenR), DeleteObject(hPenI), DeleteObject(hPenJ), DeleteObject(hPenK);
		//}
		
		void doContour(unsigned e)
		{
			using namespace contour;
			auto &n=expr[e].n[expr[e].resultTerm];
			auto ndr_r=(double*)n.r.p, ndr_i=(double*)n.i.p, ndr_j=(double*)n.j.p, ndr_k=(double*)n.k.p;
			auto &Rcontour=Rcontours[e];
			auto &Icontour=Icontours[e];
			auto &Jcontour=Jcontours[e];
			auto &Kcontour=Kcontours[e];
			int YLstart=ys.dist2ticks(Ystart-10*ys.Xsample), YLend=ys.dist2ticks(Yend+25*ys.Xsample);
		//	double YLstart=std::ceil((Ystart-10*Xs)/Ystep)*Ystep, YLend=std::ceil((Yend+25*Xs)/Ystep)*Ystep;
			for(int v=0;v<xs.Xplaces-1;++v)
			{
				QuatRef V1(ndr_r[v], ndr_i[v], ndr_j[v], ndr_k[v]), V2(ndr_r[v+1], ndr_i[v+1], ndr_j[v+1], ndr_k[v+1]);
				int V1t, V2t;
				if(V1.r==V1.r&&V2.r==V2.r&&(V1t=ys.dist2ticks(V1.r))!=(V2t=ys.dist2ticks(V2.r)))
				{
					double R1, R2;
					int R1t, R2t;//ticks
					sort(V1.r, V2.r, V1t, V2t, R1, R2, R1t, R2t);
					for(int r=maximum(R1t, YLstart), rEnd=minimum(R2t, YLend);r<=rEnd;++r)
					{
						double RL=ys.ticks2dist(r);
						if(R1<=RL&&RL<R2)
						{
							double M=(RL-V1.r)/(V2.r-V1.r);
							Rcontour[r].push_back(Double_x_i_j_k(xs.ifn_x(v+M), V1.i+(V2.i-V1.i)*M, V1.j+(V2.j-V1.j)*M, V1.k+(V2.k-V1.k)*M));
						}
					}
				}
				if(V1.i==V1.i&&V2.i==V2.i&&(V1t=ys.dist2ticks(V1.i))!=(V2t=ys.dist2ticks(V2.i)))
				{
					double I1, I2;
					int I1t, I2t;
					sort(V1.i, V2.i, V1t, V2t, I1, I2, I1t, I2t);
					for(int i=maximum(I1t, YLstart), iEnd=minimum(I2t, YLend);i<=iEnd;++i)
					{
						double IL=ys.ticks2dist(i);
						if(I1<=IL&&IL<I2)
						{
							double M=(IL-V1.i)/(V2.i-V1.i);
							Icontour[i].push_back(Double_x_r_j_k(xs.ifn_x(v+M), V1.r+(V2.r-V1.r)*M, V1.j+(V2.j-V1.j)*M, V1.k+(V2.k-V1.k)*M));
						}
					}
				}
				if(V1.j==V1.j&&V2.j==V2.j&&(V1t=ys.dist2ticks(V1.j))!=(V2t=ys.dist2ticks(V2.j)))
				{
					double J1, J2;
					int J1t, J2t;
					sort(V1.j, V2.j, V1t, V2t, J1, J2, J1t, J2t);
					for(int j=maximum(J1t, YLstart), jEnd=minimum(J2t, YLend);j<=jEnd;++j)
					{
						double JL=ys.ticks2dist(j);
						if(J1<=JL&&JL<J2)
						{
							double M=(JL-V1.j)/(V2.j-V1.j);
							Jcontour[j].push_back(Double_x_r_i_k(xs.ifn_x(v+M), V1.r+(V2.r-V1.r)*M, V1.i+(V2.i-V1.i)*M, V1.k+(V2.k-V1.k)*M));
						}
					}
				}
				if(V1.k==V1.k&&V2.k==V2.k&&(V1t=ys.dist2ticks(V1.k))!=(V2t=ys.dist2ticks(V2.k)))
				{
					double K1, K2;
					int K1t, K2t;
					sort(V1.k, V2.k, V1t, V2t, K1, K2, K1t, K2t);
					if(V1.k<V2.k)
						K1=V1.k, K2=V2.k;
					else
						K1=V2.k, K2=V1.k;
					for(int k=maximum(K1t, YLstart), kEnd=minimum(K2t, YLend);k<=kEnd;++k)
					{
						double KL=ys.ticks2dist(k);
						if(K1<=KL&&KL<K2)
						{
							double M=(KL-V1.k)/(V2.k-V1.k);
							Kcontour[k].push_back(Double_x_r_i_j(xs.ifn_x(v+M), V1.r+(V2.r-V1.r)*M, V1.i+(V2.i-V1.i)*M, V1.j+(V2.j-V1.j)*M));
						}
					}
				}
			}
		}
		void differentiate						(Term &n)
		{
			auto ndr_r=(double*)n.r.p, ndr_i=(double*)n.i.p, ndr_j=(double*)n.j.p, ndr_k=(double*)n.k.p;
			double step=xs.Xsample, _1_step=1/step;
			for(int k=0;k<xs.Xplaces-1;++k)
				ndr_r[k]=(ndr_r[k+1]-ndr_r[k])*_1_step, ndr_i[k]=(ndr_i[k+1]-ndr_i[k])*_1_step, ndr_j[k]=(ndr_j[k+1]-ndr_j[k])*_1_step, ndr_k[k]=(ndr_k[k+1]-ndr_k[k])*_1_step;
			//	ndr[k]=((boost::math::quaternion<double>)ndr[k+1]-(boost::math::quaternion<double>)ndr[k])/step;
			ndr_r[xs.Xplaces-1]*=-_1_step, ndr_i[xs.Xplaces-1]*=-_1_step, ndr_j[xs.Xplaces-1]*=-_1_step, ndr_k[xs.Xplaces-1]*=-_1_step;
			//ndr.rbegin()->r/=-step, ndr.rbegin()->i/=-step, ndr.rbegin()->j/=-step, ndr.rbegin()->k/=-step;
		}
		void integrate							(Term &n)
		{
			auto ndr_r=(double*)n.r.p, ndr_i=(double*)n.i.p, ndr_j=(double*)n.j.p, ndr_k=(double*)n.k.p;
			double step=xs.Xsample;
			boost::math::quaternion<double> sum;
			for(int k=0;k<xs.Xplaces;++k)
			{
				sum+=boost::math::quaternion<double>(ndr_r[k], ndr_i[k], ndr_j[k], ndr_k[k]);
				QuatRef(ndr_r[k], ndr_i[k], ndr_j[k], ndr_k[k])=sum*step;
			}
		}
		void discreteFourrierTransform			(Term &n)
		{
			auto ndr_r=(double*)n.r.p, ndr_i=(double*)n.i.p, ndr_j=(double*)n.j.p, ndr_k=(double*)n.k.p;
			std::vector<boost::math::quaternion<double>> t0(xs.Xplaces);
			for(int k=0;k<xs.Xplaces;++k)
				t0[k]=boost::math::quaternion<double>(ndr_r[k], ndr_i[k], ndr_j[k], ndr_k[k]);
			std::vector<boost::math::quaternion<double>> t1(xs.Xplaces);
			for(unsigned k=0;k<t0.size();++k)
			{
				boost::math::quaternion<double> p=-2*G2::_pi*boost::math::quaternion<double>(0, 1)*double(k)/double(t0.size());
				for(unsigned k2=0;k2<t0.size();++k2)
					t1[k]+=t0[k2]*boost::math::exp(p*double(k2));
				t1[k]/=t0.size();
			}
			for(int k=0;k<xs.Xplaces;++k)
				QuatRef(ndr_r[k], ndr_i[k], ndr_j[k], ndr_k[k])=t1[k];
		}
		void inverseDiscreteFourrierTransform	(Term &n)
		{
			auto ndr_r=(double*)n.r.p, ndr_i=(double*)n.i.p, ndr_j=(double*)n.j.p, ndr_k=(double*)n.k.p;
			std::vector<boost::math::quaternion<double>> t0(xs.Xplaces);
			for(int k=0;k<xs.Xplaces;++k)
				t0[k]=boost::math::quaternion<double>(ndr_r[k], ndr_i[k], ndr_j[k], ndr_k[k]);
			std::vector<boost::math::quaternion<double>> t1(xs.Xplaces);
			for(int k=0;k<xs.Xplaces;++k)
			{
				boost::math::quaternion<double> p=2*G2::_pi*boost::math::quaternion<double>(0, 1)*double(k)/double(t0.size());
				for(unsigned k2=0;k2<t0.size();++k2)
					t1[k]+=t0[k2]*boost::math::exp(p*double(k2));
			}
			for(int k=0;k<xs.Xplaces;++k)
				QuatRef(ndr_r[k], ndr_i[k], ndr_j[k], ndr_k[k])=t1[k];
		}
		void lowPassFilter						(Term &n)
		{
			auto ndr_r=(double*)n.r.p, ndr_i=(double*)n.i.p, ndr_j=(double*)n.j.p, ndr_k=(double*)n.k.p;
			unsigned N=xs.Xplaces, T=11;
			boost::math::quaternion<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=boost::math::quaternion<double>(ndr_r[k%N], ndr_i[k%N], ndr_j[k%N], ndr_k[k%N]);
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
			{
				t0[k%T]=boost::math::quaternion<double>(ndr_r[k], ndr_i[k], ndr_j[k], ndr_k[k]);
				QuatRef(ndr_r[k], ndr_i[k], ndr_j[k], ndr_k[k])=sum/double(T);
				int idx=(k+T/2)%N;
				sum+=boost::math::quaternion<double>(ndr_r[idx], ndr_i[idx], ndr_j[idx], ndr_k[idx])-t0[(k-T/2)%T];
			}
			for(unsigned k=N-T/2;k<N;++k)
				QuatRef(ndr_r[k], ndr_i[k], ndr_j[k], ndr_k[k])=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void highPassFilter						(Term &n)
		{
			auto ndr_r=(double*)n.r.p, ndr_i=(double*)n.i.p, ndr_j=(double*)n.j.p, ndr_k=(double*)n.k.p;
			unsigned N=xs.Xplaces, T=11;
			boost::math::quaternion<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=boost::math::quaternion<double>(ndr_r[k%N], ndr_i[k%N], ndr_j[k%N], ndr_k[k%N]);
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
			{
				t0[k%T]=boost::math::quaternion<double>(ndr_r[k], ndr_i[k], ndr_j[k], ndr_k[k]);
				QuatRef(ndr_r[k], ndr_i[k], ndr_j[k], ndr_k[k])-=sum/double(T);
				int idx=(k+T/2)%N;
				sum+=boost::math::quaternion<double>(ndr_r[idx], ndr_i[idx], ndr_j[idx], ndr_k[idx])-t0[(k-T/2)%T];
			}
			for(unsigned k=N-T/2;k<N;++k)
				QuatRef(ndr_r[k], ndr_i[k], ndr_j[k], ndr_k[k])-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}

		void messageTimer()
		{
			int dx=conditional_negate(10, _2d_drag_graph_not_window);
			if(kb[VK_LEFT		])	xs.shift(-dx), toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=dx;
			if(kb[VK_RIGHT		])	xs.shift(+dx), toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=dx;
			if(kb[VK_UP			])	ys.shift(+dx);
			if(kb[VK_DOWN		])	ys.shift(-dx);
			if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])
			{
					 if(kb['X'])xs.zoom(1/1.05), AR_Y/=1.05;
				else if(kb['Y'])AR_Y*=1.05;
				else			xs.zoom(1/1.05);
				function1(), toSolve=true, shiftOnly=0;
			}
			if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])
			{
					 if(kb['X'])xs.zoom(1.05), AR_Y*=1.05;
				else if(kb['Y'])AR_Y/=1.05;
				else			xs.zoom(1.05);
				function1(), toSolve=true, shiftOnly=0;
			}
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
		}
		int inputLButtonDown(int lParam)
		{
			if(!drag)
			{
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
				SetCapture(ghWnd);
				drag=1;
				if(contourOn&&!time_variance&&!timer)
				{
					POINT p=centerP;
					ScreenToClient(ghWnd, &p), ((short*)&oldMouse)[0]=(short)p.x, ((short*)&oldMouse)[1]=(short)p.y;
					a_draw();
				}
			}
			return 0;
		}
		int inputMouseMove(int lParam)
		{
			int draw=0;
			if(drag)
			{
				if(!m_bypass)
				{
					int mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
					int dx=mx-w/2, dy=h/2-my;
					if(_2d_drag_graph_not_window)
						dx=-dx, dy=-dy;
					xs.shift(dx), ys.shift(dy);
					toSolve=true;
					if(shiftOnly)
						shiftOnly=1, Xoffset+=dx;
					SetCursorPos(centerP.x, centerP.y);
					if(!time_variance&&!timer)
						draw=1;
				}
				m_bypass=!m_bypass;
			}
			else if(contourOn&&!time_variance&&!timer)
				oldMouse=lParam, draw=1;
			if(draw)
				a_draw();
			return 0;
		}
		void inputLButtonUp(int lParam)
		{
			if(drag)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
				if(contourOn&&!time_variance&&!timer)
				{
					POINT p=mouseP0;
					ScreenToClient(ghWnd, &p), ((short*)&oldMouse)[0]=(short)p.x, ((short*)&oldMouse)[1]=(short)p.y;
					a_draw();
				}
			}
		}
		int inputKeyDown(int wParam, int lParam)
		{
			switch(wParam)
			{
			case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
			case VK_ADD:case VK_SUBTRACT://numpad
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(!kb[wParam])
					++kp;
				if(!time_variance&&!timer)
					SetTimer(ghWnd, 0, 10, 0), timer=true;
				break;
			case VK_OEM_3://~: contour
				if(contourOn)
				{
					if(kb[VK_CONTROL])
						contourOnly=!contourOnly;
					else
						contourOn=false;
				}
				else
				{
					contourOn=true, contourOnly=false;//contour on
					if(!toSolve)
					{
						Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
						doContour(cursorEx);
					}
				}
				break;
			case '0':case VK_NUMPAD0:
				if(operations.size())
					toSolve=true, shiftOnly=0;
				operations.clear();
				break;
			case '1':case VK_NUMPAD1:
			case '2':case VK_NUMPAD2:
			case '3':case VK_NUMPAD3:
			case '4':case VK_NUMPAD4:
			case '5':case VK_NUMPAD5:
			case '6':case VK_NUMPAD6:
				{
					auto op=&Transverse_1D_H::differentiate;
					switch(wParam)
					{
					case '1':case VK_NUMPAD1:operations.push_back(1), op=&Transverse_1D_H::differentiate;					break;
					case '2':case VK_NUMPAD2:operations.push_back(2), op=&Transverse_1D_H::integrate;						break;
					case '3':case VK_NUMPAD3:operations.push_back(3), op=&Transverse_1D_H::discreteFourrierTransform;		break;
					case '4':case VK_NUMPAD4:operations.push_back(4), op=&Transverse_1D_H::inverseDiscreteFourrierTransform;break;
					case '5':case VK_NUMPAD5:operations.push_back(5), op=&Transverse_1D_H::lowPassFilter;					break;
					case '6':case VK_NUMPAD6:operations.push_back(6), op=&Transverse_1D_H::highPassFilter;					break;
					}
					for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)
					{
						auto &ex=expr[ke];
						if(ex.rmode[0]==4)
							(this->*op)(ex.n[ex.resultTerm]);
					}
					if(contourOn)
					{
						Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
						doContour(cursorEx);
					}
				}
				break;
			case 'C':
				clearScreen=!clearScreen;
				break;
			case 'E':
				xs.reset_scale(), ys.reset_scale(), AR_Y=1, function1();
				toSolve=true, shiftOnly=0;
				break;
			case 'R':
				if(!kb[VK_CONTROL])
					xs.reset_scale(), ys.reset_scale(), function1();
				xs.reset_position(), ys.reset_position();
				toSolve=true, shiftOnly=0;
				break;
			default:
				if(lParam&1<<30)
					return 0;
				break;
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		void draw()
		{
			if(usingOpenGL)
				gl_disabledepthtest();
			ys.DX=xs.DX*h/(w*AR_Y);
			if(ys.DX<=0)
				ys.DX=1;
			_2dMode_DrawCheckboard_range(penGrid, xs, ys, 0, w, h, 0);
		//	_2dMode_DrawCheckboard_range(hPenGrid, hBrush, xs, ys, 0, w, h, 0);
			auto &ex=expr[cursorEx];
			{
				bool changed=false;
				if(toSolve)
				{
					if(!operations.size()&&shiftOnly==1&&abs(xs.Xplaces)<Xoffset)
					{
						if(Xoffset)
						{
							if(ex.nITD)
							{
								solver.synchronize();
								solver.full(ex);
							}
							else
							{
								solver.partial_bounds(Xoffset);
								solver.partial(ex);
							}
						}
					}
					else
					{
						auto old_time_variance=time_variance;
						time_variance=false;
						labels.clear();

						xs.Xplaces=setXplaces(w), xs.set_Xplaces(w), ys.set_Xplaces(h);
						solver.full_resize(xs.Xplaces);
						time_variance|=ex.nITD;
						labels.fill(cursorEx);
						if(!paused)
							solver.synchronize();
						solver.full(ex);
						for(auto it=operations.begin();it!=operations.end();++it)
						{
							auto &operation=*it;
							switch(operation)
							{
							case 1:differentiate					(ex.n[ex.resultTerm]);break;
							case 2:integrate						(ex.n[ex.resultTerm]);break;
							case 3:discreteFourrierTransform		(ex.n[ex.resultTerm]);break;
							case 4:inverseDiscreteFourrierTransform	(ex.n[ex.resultTerm]);break;
							case 5:lowPassFilter					(ex.n[ex.resultTerm]);break;
							case 6:highPassFilter					(ex.n[ex.resultTerm]);break;
							}
						}
						if(time_variance)
						{
							if(!paused)
								SetTimer(ghWnd, 0, 10, 0);
						}
						else if(old_time_variance&&!timer)
							KillTimer(ghWnd, 0);
					}
					changed=true;
					toSolve=false, shiftOnly=2, Xoffset=0;
				}
				else if(time_variance)
				{
					if(!paused)
						solver.synchronize();
					solver.full(ex);
					for(auto it=operations.begin();it!=operations.end();++it)
					{
						auto &operation=*it;
						switch(operation)
						{
						case 1:differentiate					(ex.n[ex.resultTerm]);break;
						case 2:integrate						(ex.n[ex.resultTerm]);break;
						case 3:discreteFourrierTransform		(ex.n[ex.resultTerm]);break;
						case 4:inverseDiscreteFourrierTransform	(ex.n[ex.resultTerm]);break;
						case 5:lowPassFilter					(ex.n[ex.resultTerm]);break;
						case 6:highPassFilter					(ex.n[ex.resultTerm]);break;
						}
					}
					changed=true;
				}
				if(changed&&contourOn)
				{
					Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
					doContour(cursorEx);
				}
			}
			if(!clearScreen)
			{
				int bkMode=getBkMode();
			//	int bkMode=GetBkMode(ghMemDC);
				int H=0, V=0, VT=0;
				_2dMode_NumberAxes(H, V, VT, xs, ys);
				line(0, H, w, H), line(V, 0, V, h);
				{
					int textColor=getTextColor(), Xs=VT+24+8*ys.prec>w-24-ys.prec*8?VT-24-8*ys.prec:VT+24+8*ys.prec, Ys=0;
					setTextColor(rColor), print(Xs, Ys, "R()", 3), Ys+=16;
					setTextColor(iColor), print(Xs, Ys, "I()", 3), Ys+=16;
					setTextColor(jColor), print(Xs, Ys, "J()", 3), Ys+=16;
					setTextColor(kColor), print(Xs, Ys, "K()", 3);
					setTextColor(textColor);
					//int textColor=GetTextColor(ghMemDC), Xs=VT+24+8*ys.prec>w-24-ys.prec*8?VT-24-8*ys.prec:VT+24+8*ys.prec, Ys=0;
					//SetTextColor(ghMemDC, rColor), TextOutA(ghMemDC, Xs, Ys, "R()", 3), Ys+=16;
					//SetTextColor(ghMemDC, iColor), TextOutA(ghMemDC, Xs, Ys, "I()", 3), Ys+=16;
					//SetTextColor(ghMemDC, jColor), TextOutA(ghMemDC, Xs, Ys, "J()", 3), Ys+=16;
					//SetTextColor(ghMemDC, kColor), TextOutA(ghMemDC, Xs, Ys, "K()", 3);
					//SetTextColor(ghMemDC, textColor);
				}
				{
					int Ys=H+(H>h-46?-34:18), Ys0=Ys;
					for(int kl=0, klEnd=labels.Xlabels.size();kl<klEnd;++kl)
					{
						auto &label=labels.Xlabels[kl];
						print(w-arrow_label_offset_X, Ys, label.label.c_str(), label.label.size()), Ys+=16;
					//	TextOutA(ghMemDC, w-arrow_label_offset_X, Ys, label.label.c_str(), label.label.size()), Ys+=16;
					}
					Ys=Ys0>h/3?0:h-16*labels.Clabels.size();
					for(int kl=0, klEnd=labels.Clabels.size();kl<klEnd;++kl)
					{
						auto &label=labels.Clabels[kl];
						int linelen=sprintf_s(g_buf, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
						print(w-const_label_offset_X, Ys, g_buf, linelen), Ys+=16;
					//	TextOutA(ghMemDC, w-const_label_offset_X, Ys, g_buf, linelen), Ys+=16;
					}
				}
				setBkMode(bkMode);
			//	SetBkMode(ghMemDC, bkMode);
			}
			if(!contourOnly)//draw the curves
			{
				Pen *p[]={&penR, &penI, &penJ, &penK};
			//	HPEN p[]={hPenR, hPenI, hPenJ, hPenK};
				auto &n=ex.n[ex.resultTerm];
				for(unsigned c=0;c<4;++c)
				{
					auto &ndr=(&n.r)[c];
					p[c]->use();
				//	p[c]=(HPEN)SelectObject(ghMemDC, p[c]);
					if(usingOpenGL)
						GL2_2D::curve_begin();
					_2d.curve_start();
					for(int v=0, vEnd=xs.Xplaces-1;v<vEnd;++v)
					{
						_2d.curve_point(bpx+v, ys.fn_y(ndr[v]));
						if(!operations.size()&&ex.discontinuities[v])
							_2d.curve_start();
					}
					_2d.curve_point(bpx+xs.Xplaces-1, ys.fn_y(ndr[xs.Xplaces-1]));
					_2d.set_point();
					if(usingOpenGL)
						GL2_2D::draw_curve();
					p[c]->drop();
				//	p[c]=(HPEN)SelectObject(ghMemDC, p[c]);
				}
				int k=0, Y=h-operations.size()*16;
				for(auto it=operations.begin();it!=operations.end();++it)
				{
					auto &operation=*it;
					char const *a=0;
					switch(operation)
					{
					case 1:a="%d: Differentiate";	break;
					case 2:a="%d: Integrate";		break;
					case 3:a="%d: DFT";				break;
					case 4:a="%d: IDFT";			break;
					case 5:a="%d: LPF";				break;
					case 6:a="%d: HPF";				break;
					}
					GUIPrint(w-const_label_offset_X, Y, a, k);
					++k, Y+=16;
				}
			}
			if(contourOn)//mark the crossings
			{
				int mrX1=-60, mrX2=60, mrY1=-60, mrY2=60;
				int mx=((short*)&oldMouse)[0], my=((short*)&oldMouse)[1];

				for(int c=0;c<4;++c)
				{
					(&penR)[c].use();
				//	(&hPenR)[c]=(HPEN__*)SelectObject(ghMemDC, (&hPenR)[c]);
					auto &Rcontour=(&Rcontours)[c][cursorEx];				//Rcontours[e]=Rcontour, Rcontour[r level (r/step)]=points, *points.begin()=(x,i,j,k)
					for(auto cit=Rcontour.begin();cit!=Rcontour.end();++cit)//std::map<unsigned, std::unordered_map<int, std::list<contour::Vector4d>>>
					{
						auto &L=*cit;
						double missing=ys.ticks2dist(L.first);
						int y=ys.fn_y_int(missing);
						for(auto xit=L.second.begin();xit!=L.second.end();++xit)//through the list of points on this level
						{
							contour::Vector4d &X=*xit;
						//	auto &X=*xit;
							int x=xs.fn_x_int(X.a);
						//	int x=int((X.x-Xstart)*w/DX);
							line(x-5, y, x+5, y);
							line(x, y-5, x, y+5);
							if(active&&x>=mx+mrX1&&x<mx+mrX2&&y>=my+mrY1&&y<my+mrY2)
								X.print(x, y, missing);
							//	GUIPrint(ghMemDC, x, y, "%g, %g+%gi+%gj+%gk", X.x, R, X.i, X.j, X.k);
							//	GUIPrint(ghMemDC, x, y, "%g, %g+%gi+%gj+%gk", X.x, X.r, I, X.j, X.k);
							//	GUIPrint(ghMemDC, x, y, "%g, %g+%gi+%gj+%gk", X.x, X.r, X.i, J, X.k);
							//	GUIPrint(ghMemDC, x, y, "%g, %g+%gi+%gj+%gk", X.x, X.r, X.i, X.j, K);
						}
					}
					(&penR)[c].drop();
				//	(&hPenR)[c]=(HPEN__*)SelectObject(ghMemDC, (&hPenR)[c]);
				}
				if(active)
				{
				//	auto ClearDIBPixel=[&](int x, int y){if(x>=0&&x<w&&y>=0&&y<h)rgb[y*w+x]=0;};
					if(drag)
					{
						int w_2=w/2, h_2=h/2;
						setPixel(w_2+mrX1, h_2+mrY1, 0), setPixel(w_2+mrX2, h_2+mrY1, 0);
						setPixel(w_2+mrX1, h_2+mrY2, 0), setPixel(w_2+mrX2, h_2+mrY2, 0);
						//ClearDIBPixel(w_2+mrX1, h_2+mrY1), ClearDIBPixel(w_2+mrX2, h_2+mrY1);
						//ClearDIBPixel(w_2+mrX1, h_2+mrY2), ClearDIBPixel(w_2+mrX2, h_2+mrY2);
					}
					else
					{
						setPixel(mx+mrX1, my+mrY1, 0), setPixel(mx+mrX2, my+mrY1, 0);
						setPixel(mx+mrX1, my+mrY2, 0), setPixel(mx+mrX2, my+mrY2, 0);
						//ClearDIBPixel(mx+mrX1, my+mrY1), ClearDIBPixel(mx+mrX2, my+mrY1);
						//ClearDIBPixel(mx+mrX1, my+mrY2), ClearDIBPixel(mx+mrX2, my+mrY2);
					}
				}
			}
		}
		void i_draw();
		void a_draw();
	} t1d_h;
	const int		Transverse_1D_H::modes[]={4}, Transverse_1D_H::nmodes=sizeof(modes)>>2;
	void			Transverse_1D_H::i_draw()
	{
		if(modes::ready)
		{
			draw();
			if(showLastModeOnIdle)
				capture_window(modeRGB);
			//	std::copy(rgb, rgb+w*h, modeRGB);

			selectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			{
				int bkMode=getBkMode();
			//	int bkMode=GetBkMode(ghMemDC);
				setBkMode(OPAQUE);
			//	SetBkMode(ghMemDC, OPAQUE);
				itb.draw();
				setBkMode(bkMode);
			//	SetBkMode(ghMemDC, bkMode);
			}
			deselectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	
			if(showBenchmark)
				Performance(0, h-32);//
#ifndef BUILD_1_7
			BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
#endif
		}
		else
		{
			display_texture_fullwindow(modeRGB);
		//	std::copy(modeRGB, modeRGB+w*h, rgb);
			if(showBenchmark)
				Performance(0, h-32);//
		}
	}
	void			Transverse_1D_H::a_draw()
	{
		newframe();
	//	rectangle(bpx-1, bpy-1, bw+1, bh+1);
	//	Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);

		draw();
		
		if(contextHelp)
		{
			const char *help[]=
			{
				"arrows/drag: move",
				"+/-/enter/backspace/wheel: zoom",
				"X/Y +/-/enter/backspace/wheel: scale x/y",
				"E: reset scale",
				"R: reset scale & view",
				"C: toggle clear screen",
				"1: differentiate",
				"2: integrate",
				"3: DFT",
				"4: Inverse DFT",
				"5: LPF",
				"6: HPF",
				"0: reset operations",
				"`: contour",
				"Tab/Shift Tab: switch renderer",
				"Esc: back to text editor"
			};
			print_contextHelp(help, sizeof(help)>>2, 270);
		}
		if(showBenchmark&&!clearScreen)
			Performance(0, h-32);//
		show();
	//	BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
		report_error();
	}
	class		Implicit_2D:public _2D_Mode
	{
	public:
		int Xoffset, Yoffset, exprRemoved;

		int Xplaces, Yplaces;
		Solve_2D_Implicit solver;
		
		_2D _2d;
		bool showValue;
		bool clearScreen;
		Labels_2D labels;
		static const int modes[], nmodes;
		PenBrush penBrush;
		//HPEN hPen;
		//HBRUSH hBrush;
		typedef std::pair<unsigned, unsigned> ExTx;
		std::vector<ExTx> gl_textures;

		Implicit_2D():
			solver(xs, ys), _2D_Mode(solver),
			Xoffset(0), Yoffset(0), exprRemoved(0),
			clearScreen(false),
			penBrush(_2dCheckColor)
		{
		//	hPen=CreatePen(PS_SOLID, 1, _2dCheckColor), hBrush=CreateSolidBrush(_2dCheckColor);
		}
		//~Implicit_2D(){DeleteObject(hPen), DeleteObject(hBrush);}

		void messageTimer()
		{
			int dx=conditional_negate(10, _2d_drag_graph_not_window);
			if(kb[VK_LEFT		]){	xs.shift(-dx), toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=dx;}
			if(kb[VK_RIGHT		]){	xs.shift(+dx), toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=dx;}
			if(kb[VK_UP			]){	ys.shift(+dx), toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset+=dx;}
			if(kb[VK_DOWN		]){	ys.shift(-dx), toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset-=dx;}
			if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])
			{
					 if(kb['X'])xs.zoom(1/1.1), AR_Y/=1.1;
				else if(kb['Y'])AR_Y*=1.1;
				else			xs.zoom(1/1.1);
				function1(), toSolve=true, shiftOnly=0;
			}
			if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])
			{
					 if(kb['X'])xs.zoom(1.1), AR_Y*=1.1;
				else if(kb['Y'])AR_Y/=1.1;
				else			xs.zoom(1.1);
				function1(), toSolve=true, shiftOnly=0;
			}
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
		}
		int inputLButtonDown(int lParam)
		{
			if(!drag)
			{
				drag=1;
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
				SetCapture(ghWnd);
			}
			return 0;
		}
		int inputMouseMove(int lParam)
		{
			if(drag)
			{
				if(!m_bypass)
				{
					int mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
					int dx=mx-w/2, dy=h/2-my;
					if(_2d_drag_graph_not_window)
						dx=-dx, dy=-dy;
					xs.shift(dx), ys.shift(dy);
					toSolve=true;
					if(shiftOnly)
						shiftOnly=1, Xoffset+=dx, Yoffset+=dy;
					SetCursorPos(centerP.x, centerP.y);
					if(!time_variance&&!timer)
						a_draw();
				}
				m_bypass=!m_bypass;
			}
			else if(showValue&&!time_variance&&!timer)
				oldMouse=lParam, a_draw();
			return 0;
		}
		void inputLButtonUp(int lParam)
		{
			if(drag)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
			}
		}
		int inputKeyDown(int wParam, int lParam)
		{
			switch(wParam)
			{
			case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
			case VK_ADD:case VK_SUBTRACT://numpad
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(!kb[wParam])
					++kp;
				if(!time_variance&&!timer)
					SetTimer(ghWnd, 0, 10, 0), timer=true;
				break;
			case 'C':
				clearScreen=!clearScreen;
				break;
			case 'V'://show value at cursor
				showValue=!showValue;
				break;
			case 'E':
				xs.reset_scale(), ys.reset_scale(), AR_Y=1, function1();
				toSolve=true, shiftOnly=0;
				break;
			case 'R':
				if(!kb[VK_CONTROL])
					xs.reset_scale(), ys.reset_scale(), function1();
				xs.reset_position(), ys.reset_position();
				toSolve=true, shiftOnly=0;
				break;
			default:
				if(lParam&1<<30)
					return 0;
				break;
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		void cl_draw()
		{
			newframe();
			for(int ktx=0, ntx=gl_textures.size();ktx<ntx;++ktx)//draw the solutions
				display_gl_texture(gl_textures[ktx].second);
		}
		void draw()
		{
			if(usingOpenGL)
				gl_disabledepthtest();
			ys.DX=xs.DX*h/(w*AR_Y);
			if(ys.DX<=0)
				ys.DX=1;
			if(toSolve)
			{
				if(usingOpenGL==MODE_CL_GL_INTEROP)
				{
					if(!paused)
						solver.synchronize();
					Xplaces=w, Yplaces=h;
					xs.set_Xplaces(w), ys.set_Xplaces(h);
					ModeParameters mp=
					{
						MODE_I2D, nExpr[11],
						(unsigned)Xplaces, (unsigned)Yplaces, 1,//ndr dimensions
						xs.Xstart, xs.Xsample,//Xstart, Xsample
						ys.Xend, -ys.Xsample,//Yend, -Ysample
						0, 0,
						nullptr, nullptr,
					};
					unsigned prevsize=gl_textures.size(), newsize=nExpr[11];
					if(prevsize<newsize)
					{
						gl_textures.resize(newsize);
						for(unsigned k=prevsize;k<newsize;++k)
							glGenTextures(1, &gl_textures[k].second);
					}
					else if(prevsize>newsize)
					{
						for(unsigned k=newsize;k<prevsize;++k)
							glDeleteTextures(1, &gl_textures[k].second);
						gl_textures.resize(newsize);
					}
					for(int ke=0, ktx=0, ne=expr.size();ke<ne;++ke)
					{
						auto ex=expr[ke];
						if(ex.rmode[0]==11)
						{
							auto &gl_tx=gl_textures[ktx];
							gl_tx.first=ke;
							generate_glcl_texture(gl_tx.second, Xplaces, Yplaces);
							cl_solve(ex, mp, solver.T, gl_tx.second);
							cl_finish();
							++ktx;
						}
					}
					cl_draw();
				}
				else if(shiftOnly==1&&abs(Xoffset)<Xplaces&&abs(Yoffset)<Yplaces)
				{
					if(Xoffset||Yoffset)
					{
						solver.partial_bounds(Xoffset, Yoffset);
						solver.bitmap.use();
					//	solver.hBitmap=(HBITMAP)SelectObject(ghMemDC, solver.hBitmap);
						solver.shiftAndCheckboard(penBrush, clearScreen);
					//	solver.shiftAndCheckboard(hPen, hBrush, clearScreen);
						solver.prgb=&solver.bitmap.rgb;
						for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)
						{
							auto &ex=expr[ke];
							if(ex.rmode[0]==11&&!ex.nITD)
								(solver.*solver.partial)(ex);
						}
						solver.bitmap.drop();
					//	solver.hBitmap=(HBITMAP)SelectObject(ghMemDC, solver.hBitmap);
					//	display_texture_fullwindow(solver.rgb);
						std::copy(solver.bitmap.rgb, solver.bitmap.rgb+w*h, gBitmap.rgb);
						solver.prgb=&gBitmap.rgb;
						solver.synchronize();
						for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)
						{
							auto &ex=expr[ke];
							if(ex.rmode[0]==11&&ex.nITD)
								solver.full(ex), solver.draw(ex);
						}
					}
				}
				else
				{
					auto old_time_variance=time_variance;
					time_variance=false;
					labels.clear();
					xs.set_Xplaces(w), ys.set_Xplaces(h);
					solver.full_resize(Xplaces=setXplaces(w), Yplaces=h);
					solver.bitmap.use();
				//	solver.hBitmap=(HBITMAP)SelectObject(ghMemDC, solver.hBitmap);//draw grid and time-fixed expressions on solver bitmap
					{
						rectangle(bpx-1, bpy-1, bw+1, bh+1);
					//	Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);
					//	if(!clearScreen)
							_2dMode_DrawCheckboard_range(penBrush, xs, ys, 0, w, h, 0);
						//	_2dMode_DrawCheckboard_range(hPen, hBrush, xs, ys, 0, w, h, 0);
					}
					solver.prgb=&solver.bitmap.rgb;
					for(unsigned e=0;e<expr.size();++e)
					{
						auto &ex=expr[e];
						if(ex.rmode[0]==11&&!ex.nITD)
						{
							labels.fill(e);
							solver.full(ex), solver.draw(ex);
						}
					}
					solver.bitmap.drop();
				//	solver.hBitmap=(HBITMAP)SelectObject(ghMemDC, solver.hBitmap);
					std::copy(solver.bitmap.rgb, solver.bitmap.rgb+w*h, gBitmap.rgb);
					solver.prgb=&gBitmap.rgb;
					if(!paused)
						solver.synchronize();
					for(unsigned e=0;e<expr.size();++e)
					{
						auto &ex=expr[e];
						if(ex.rmode[0]==11&&ex.nITD)
					//	if(ex.rmode[0]==11&&(time_variance|=ex.nITD))
						{
							labels.fill(e);
							solver.full(ex), solver.draw(ex);
							time_variance=true;
						}
					}
					if(time_variance)
					{
						if(!paused)
							SetTimer(ghWnd, 0, 10, 0);
					}
					else if(old_time_variance&&!timer)
						KillTimer(ghWnd, 0);
				}
				toSolve=false, shiftOnly=2, Xoffset=0, Yoffset=0;
				exprRemoved=false;
			}
			else if(exprRemoved)//expression(s) was removed
			{
				solver.bitmap.use();
			//	solver.hBitmap=(HBITMAP)SelectObject(ghMemDC, solver.hBitmap);
				{
					rectangle(bpx-1, bpy-1, bw+1, bh+1);
				//	Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);
				//	if(!clearScreen)
						_2dMode_DrawCheckboard_range(penBrush, xs, ys, 0, w, h, 0);
					//	_2dMode_DrawCheckboard_range(hPen, hBrush, xs, ys, 0, w, h, 0);
				}
				solver.prgb=&solver.bitmap.rgb;

				auto old_time_variance=time_variance;
				time_variance=false;
				labels.clear();
				for(unsigned e=0;e<expr.size();++e)
				{
					auto &ex=expr[e];
					if(ex.rmode[0]==11&&!ex.nITD)
					{
						labels.fill(e);
						solver.draw(ex);
					}
				}
				solver.bitmap.drop();
			//	solver.hBitmap=(HBITMAP)SelectObject(ghMemDC, solver.hBitmap);
				std::copy(solver.bitmap.rgb, solver.bitmap.rgb+w*h, gBitmap.rgb);
				solver.prgb=&gBitmap.rgb;
				for(unsigned e=0;e<expr.size();++e)
				{
					auto &ex=expr[e];
					if(ex.rmode[0]==11&&ex.nITD)
					{
						labels.fill(e);
						solver.draw(ex);
						time_variance=true;
					}
				}
				if(old_time_variance&&!time_variance&&!timer)
					KillTimer(ghWnd, 0);
				exprRemoved=false;
			}
			else if(time_variance)
			{
				std::copy(solver.bitmap.rgb, solver.bitmap.rgb+w*h, gBitmap.rgb);
				if(!paused)
					solver.synchronize();
				for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)
				{
					auto &ex=expr[ke];
					if(ex.rmode[0]==11&&ex.nITD)
						solver.full(ex), solver.draw(ex);
				}
			}
			else
			{
				if(usingOpenGL==MODE_CL_GL_INTEROP)
					cl_draw();
				else
					std::copy(solver.bitmap.rgb, solver.bitmap.rgb+w*h, gBitmap.rgb);
			}
			int colorCondition=nExpr[11]>1;
			if(!clearScreen)
			{
				int bkMode=getBkMode();
			//	int bkMode=GetBkMode(ghMemDC);
				int H=0, V=0, VT=0;
				_2dMode_NumberAxes(H, V, VT, xs, ys);
				int textColor;
				if(colorCondition)
					textColor=getTextColor();
				//	textColor=GetTextColor(ghMemDC);
				int Ys=H+(H>h-46?-34:18)-2, Ys0=Ys;
				for(int kl=0, klEnd=labels.Xlabels.size();kl<klEnd;++kl)
				{
					auto &label=labels.Xlabels[kl];
					if(colorCondition)
						setTextColor(expr[label.exNo].winColor);
					//	SetTextColor(ghMemDC, expr[label.exNo].winColor);
					print(w-arrow_label_offset_X, Ys, label.label.c_str(), label.label.size()), Ys+=16;
				//	TextOutA(ghMemDC, w-arrow_label_offset_X, Ys, label.label.c_str(), label.label.size()), Ys+=16;
				}
				int Xs=	VT+24+8*ys.prec>w-24-ys.prec*8
					?	VT-24-8*ys.prec
					:	VT+24+8*ys.prec;
				Ys=0;
				for(int kl=0, klEnd=labels.Ylabels.size();kl<klEnd;++kl)
				{
					auto &label=labels.Ylabels[kl];
					if(colorCondition)
						setTextColor(expr[label.exNo].winColor);
					//	SetTextColor(ghMemDC, expr[label.exNo].winColor);
					print(Xs, Ys, label.label.c_str(), label.label.size()), Ys+=16;
				//	TextOutA(ghMemDC, Xs, Ys, label.label.c_str(), label.label.size()), Ys+=16;
				}
				Ys=Ys0>h/3?0:h-16*labels.Clabels.size();
				for(int kl=0, klEnd=labels.Clabels.size();kl<klEnd;++kl)
				{
					auto &label=labels.Clabels[kl];
					if(colorCondition)
						setTextColor(expr[label.exNo].winColor);
					//	SetTextColor(ghMemDC, expr[label.exNo].winColor);
					int linelen=sprintf_s(g_buf, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
					print(w-const_label_offset_X, Ys, g_buf, linelen);
				//	TextOutA(ghMemDC, w-const_label_offset_X, Ys, g_buf, linelen);
					Ys+=16;
				}
				if(active&&showValue)
				{
					int mx=((short*)&oldMouse)[0], my=((short*)&oldMouse)[1];
					if(mx>=0&&mx<w&&my>=0&&my<h)
					{
						std::vector<std::string> v;
						int max_size=-1;
						for(int k=0, kEnd=expr.size();k<kEnd;++k)
						{
							auto &ex=expr[k];
							if(ex.rmode[0]==11)
							{
								int idx=(Xplaces+((ex.resultLogicType>=2)<<1))*my+mx;
								auto &n=ex.n[ex.resultTerm];
								int offset=0;
								Value(n.r[idx]).printComplex(g_buf, offset);
								v.push_back(std::string(g_buf, offset));
								if(max_size==-1||max_size<offset)
									max_size=offset;
							}
						}
						const int fontH=16, cursorH=31, textW=max_size<<3;
						int textH=fontH*v.size(), px=mx, py=my-textH;//big cursor size: 19x31
						if(my-textH<0)
							py+=textH+cursorH;
						if(mx+textW>w)
							px-=textW;
						int bkMode=getBkMode();
					//	int bkMode=GetBkMode(ghMemDC);
						setBkMode(OPAQUE);
					//	SetBkMode(ghMemDC, OPAQUE);
						for(int k=0, k2=0, kEnd=expr.size();k<kEnd;++k)
						{
							auto &ex=expr[k];
							if(ex.rmode[0]==11)
							{
								if(colorCondition)
									setTextColor(expr[k].winColor);
								//	SetTextColor(ghMemDC, expr[k].winColor);
								print(px, py+k2*fontH, v[k2].c_str(), v[k2].size());
							//	TextOutA(ghMemDC, px, py+k2*fontH, v[k2].c_str(), v[k2].size());
								++k2;
							}
						}
					}
				}
				if(colorCondition)
					setTextColor(textColor);
				//	SetTextColor(ghMemDC, textColor);
				setBkMode(bkMode);
			//	SetBkMode(ghMemDC, bkMode);
			}
		}
		void i_draw();
		void a_draw();
	} ti2d;
	const int		Implicit_2D::modes[]={11}, Implicit_2D::nmodes=sizeof(modes)>>2;
	void			Implicit_2D::i_draw()
	{
		if(modes::ready)
		{
			draw();
			if(showLastModeOnIdle)
				capture_window(modeRGB);
			//	std::copy(rgb, rgb+w*h, modeRGB);

			selectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			{
				int bkMode=getBkMode();
			//	int bkMode=GetBkMode(ghMemDC);
				setBkMode(OPAQUE);
			//	SetBkMode(ghMemDC, OPAQUE);
				if(nExpr[11]>1)
					itb.draw_color(modes, nmodes);
				else
					itb.draw();
				setBkMode(bkMode);
			//	SetBkMode(ghMemDC, bkMode);
			}
			deselectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	
			if(showBenchmark)
				Performance(0, h-32);//
#ifndef BUILD_1_7
			BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
#endif
		}
		else
		{
			display_texture_fullwindow(modeRGB);
		//	std::copy(modeRGB, modeRGB+w*h, rgb);
			if(showBenchmark)
				Performance(0, h-32);//
		}
	}
	void			Implicit_2D::a_draw()
	{
		newframe();
	//	Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);

		draw();
		
		if(contextHelp)
		{
			const char *help[]=
			{
				"arrows/drag: move",
				"+/-/enter/backspace/wheel: zoom",
				"x/y +/-/enter/backspace/wheel: scale x/y",
				"E: reset scale",
				"R: reset scale & view",
				"C: toggle clear screen",
				"V: show value at cursor",
				"`: contour",
				"Esc: back to text editor"
			};
			print_contextHelp(help, sizeof(help)>>2, 265);
		}
		if(showBenchmark&&!clearScreen)
			Performance(0, h-32);//
		show();
	//	BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
		report_error();
	}
	namespace contour
	{
		struct Double_X_Y
		{
			double x, y;
			Double_X_Y(double x, double y):x(x), y(y){}
		};
		struct Double_X_Y_V
		{
			double X, Y, V;
			Double_X_Y_V(double X, double Y, double V):X(X), Y(Y), V(V){}
		};
		void solve_quadratic(double a, double b, double c, std::complex<double> &r1, std::complex<double> &r2)
		{
			const double lim=1e10;
			if(a==0)
				r1=-c/b, r2=_HUGE;
			else if(std::abs(b)/std::abs(a)>=lim&&std::abs(c)/std::abs(a)>=lim)
				r1=-c/b, r2=-b/a;
			else
			{
				b/=a, c/=a;
				double first=-0.5*b, disc=b*b-4*c;
				if(disc<0)
				{
					disc=sqrt(-disc)*0.5;
					r1.real(first), r1.imag(disc);
					r1.real(first), r1.imag(-disc);
				}
				else if(disc==0)
				{
					r1.real(first), r1.imag(0);
					r2=r1;
				}
				else
				{
					disc=sqrt(disc)*0.5;
					r1.real(first+disc), r1.imag(0);
					r2.real(first-disc), r2.imag(0);
				}
				//std::complex<double> disc=std::sqrt(b*b-4*c);
				//r1=.5*(first+disc), r2=.5*(first-disc);
			}
		}
		void contour_2d_grid(int e, int c, std::unordered_map<int, std::list<std::pair<contour::Double_X_Y, contour::Double_X_Y>>> &contour, int Xplaces, int Yplaces, Scale &xs, Scale &ys, Scale &zs, double AR_Y)
		{
			using namespace contour;
			auto &ex=expr[e];
			auto ndr=(double*)(&ex.n[ex.resultTerm].r)[c].p;
			unsigned yDiscOffset=(Xplaces-1)*Yplaces;
			double X0, X1, Y0, Y1, V00, V01, V10, V11;
			auto getPos=[&](double &t, double Vx, Double_X_Y_V &A, Double_X_Y_V &B)->bool
			{
				double
					Xd=B.X-A.X, X1a=X1-A.X, Xa0=A.X-X0,
					Yd=B.Y-A.Y, Y1a=Y1-A.Y, Ya0=A.Y-Y0,
					
					A0=(V01-V00)*Xd, B0=X1a*V00+Xa0*V01,
					A1=(V11-V10)*Xd, B1=X1a*V10+Xa0*V11,
					
					a=(A1-A0)*Yd, b=(B1-B0)*Yd+Y1a*A0+Ya0*A1, c=Y1a*B0+Ya0*B1-(X1-X0)*(Y1-Y0)*Vx;

				if(a==0&&b==0)
				{
					t=(Vx-A.V)/(B.V-A.V);
					return true;
				}
				std::complex<double> r1, r2;
				modes::contour::solve_quadratic(a, b, c, r1, r2);
				if(r1.real()>=0&&r1.real()<=1)
				{
					t=r1.real();
					return true;
				}
				if(r2.real()>=0&&r2.real()<=1)
				{
					t=r2.real();
					return true;
				}
				if(r1.real()>=-1e-5&&r1.real()<=1+1e-5)
				{
					t=r1.real();
					return true;
				}
				if(r2.real()>=-1e-5&&r2.real()<=1+1e-5)
				{
					t=r2.real();
					return true;
				}
				if(r1.real()>=-1e-1&&r1.real()<=1+1e-1)
				{
					t=r1.real();
					return true;
				}
				if(r2.real()>=-1e-1&&r2.real()<=1+1e-1)
				{
					t=r2.real();
					return true;
				}
				return false;
			};
			int zi=zs.dist2ticks(zs_Zstart), zf=zs.dist2ticks(zs.Xend);
			auto cutTrgl=[&](Double_X_Y_V &A, Double_X_Y_V &B, Double_X_Y_V &C)
			{
				modes::contour::Double_X_Y_V *_1, *_2, *_3;//ordered by z in acscending order
				if(A.V<B.V)//ab
				{
						 if(B.V<C.V)	_1=&A, _2=&B, _3=&C;
					else if(A.V<C.V)	_1=&A, _2=&C, _3=&B;
					else				_1=&C, _2=&A, _3=&B;
				}
				else//ba
				{
						 if(A.V<C.V)	_1=&B, _2=&A, _3=&C;
					else if(B.V<C.V)	_1=&B, _2=&C, _3=&A;
					else				_1=&C, _2=&B, _3=&A;
				}
				using modes::contour::Double_X_Y;
				int V1t, V2t, V3t;//ticks
				//for V1 -> V2
				if(_1->V==_1->V&&_2->V==_2->V&&(V1t=zs.dist2ticks(_1->V))!=(V2t=zs.dist2ticks(_2->V)))
				{
					for(int v=maximum(V1t, zi), vEnd=minimum(V2t, zf);v<=vEnd;++v)
					{
						double VL=zs.ticks2dist(v);
						double M12, M13;
						if(getPos(M12, VL, *_1, *_2)&&getPos(M13, VL, *_1, *_3))
						{
							contour[v].push_back(std::pair<Double_X_Y, Double_X_Y>(
								Double_X_Y(_1->X+M12*(_2->X-_1->X), _1->Y+M12*(_2->Y-_1->Y)),
								Double_X_Y(_1->X+M13*(_3->X-_1->X), _1->Y+M13*(_3->Y-_1->Y))
								));
						}
					}
				}
				//for V2 -> V3
				if(_2->V==_2->V&&_3->V==_3->V&&(V2t=zs.dist2ticks(_2->V))!=(V3t=zs.dist2ticks(_3->V)))
				{
					for(int v=maximum(V2t, zi), vEnd=minimum(V3t, zf);v<=vEnd;++v)
					{
						double VL=zs.ticks2dist(v);
						double M32, M31;
						if(getPos(M32, VL, *_2, *_3)&&getPos(M31, VL, *_1, *_3))
						{
							contour[int(v)].push_back(std::pair<Double_X_Y, Double_X_Y>(
								Double_X_Y(_2->X+M32*(_3->X-_2->X), _2->Y+M32*(_3->Y-_2->Y)),
								Double_X_Y(_1->X+M31*(_3->X-_1->X), _1->Y+M31*(_3->Y-_1->Y))
								));
						}
					}
				}
			};
			double Xstart=xs.Xstart, Ystart=AR_Y*ys_Ystart;
			for(unsigned vy=0, vyEnd=Yplaces-1;vy<vyEnd;++vy)
			{
				Y0=ys.ifn_x(vy), Y1=ys.ifn_x(vy+1);
				for(unsigned vx=0, vxEnd=Xplaces-1;vx<vxEnd;++vx)
				{
					X0=xs.ifn_x(vx), X1=xs.ifn_x(vx+1);
					double Xm=xs.ifn_x(vx+0.5), Ym=ys.ifn_x(vy+0.5);

					Double_X_Y_V//yx
						P00(X0, Y0, V00=ndr[Xplaces* vy   +vx  ]), P01(X1, Y0, V01=ndr[Xplaces* vy   +vx+1]),
						P10(X0, Y1, V10=ndr[Xplaces*(vy+1)+vx  ]), P11(X1, Y1, V11=ndr[Xplaces*(vy+1)+vx+1]),
						
						Pmm(Xm, Ym, .25*(V00+V01+V10+V11));

					if(!ex.discontinuities[(Xplaces-1)*vy+vx]&&!ex.discontinuities[yDiscOffset+(Yplaces-1)*(vx+1)+vy]&&!ex.discontinuities[(Xplaces-1)*(vy+1)+vx]&&!ex.discontinuities[yDiscOffset+(Yplaces-1)*vx+vy])
					{
						cutTrgl(P00, Pmm, P01);
						cutTrgl(P01, Pmm, P11);
						cutTrgl(P11, Pmm, P10);
						cutTrgl(P10, Pmm, P00);
					}
				}
			}
		}
	}
	class		Transverse_2D:public _3D_Mode
	{
	public:
		int Xoffset, Yoffset, exprRemoved;
		int X0, Y0;

		int Xplaces, Yplaces;
		double XshiftPoint, YshiftPoint;
		double XsamplePos, YsamplePos;

		Solve_2D solver;
		std::list<int> operations;

		bool contourOn, contourOnly, contourFlat;
		std::map<unsigned, std::unordered_map<int, std::list<std::pair<contour::Double_X_Y, contour::Double_X_Y>>>>
			contours;//contours[e]=contour, contour[z level (z/step)]=sticks, *stick.begin()=((x,y),(x,y))
		
		bool clearScreen, kb_VK_F6_msg;
		Labels_2D labels;
		_3D _3d;
		int gridColor;
		static const int modes[], nmodes;

		Transverse_2D():
			solver(true, xs, ys), _3D_Mode(solver),
			Xplaces(100), Yplaces(100),
			XshiftPoint(0), YshiftPoint(0),
			XsamplePos(0), YsamplePos(0),
			_3d(4, 4, 4, 225*G2::_pi/180, 324.7356103172454*G2::_pi/180, 1),
			gridColor(_3dGridColor),
			Xoffset(0), Yoffset(0),
			contourOn(false), contourOnly(false), contourFlat(false),
			clearScreen(false), kb_VK_F6_msg(false)
		{}

		void doContour(unsigned e){contour::contour_2d_grid(e, 0, contours[e], Xplaces, Yplaces, xs, ys, zs, AR_Y);}
		void differentiate_x					(Term &n)
		{
			auto ndr_r=(double*)n.r.p;
			double _1_step=xs.inv_Xsample;
			for(int ky=0;ky<Yplaces;++ky)
			{
				for(int kx=0;kx<Xplaces-1;++kx)
					ndr_r[Xplaces*ky+kx]=(ndr_r[Xplaces*ky+kx+1]-ndr_r[Xplaces*ky+kx])*_1_step;
				ndr_r[Xplaces*ky+Xplaces-1]*=-_1_step;
			}
			ndr_r[Xplaces-1]*=-_1_step;
		}
		void differentiate_y					(Term &n)
		{
			auto ndr_r=(double*)n.r.p;
			double _1_step=xs.inv_Xsample;
			for(int ky=0;ky<Yplaces-1;++ky)
				for(int kx=0;kx<Xplaces;++kx)
					ndr_r[Xplaces*ky+kx]=(ndr_r[Xplaces*(ky+1)+kx]-ndr_r[Xplaces*ky+kx])*_1_step;
			for(int kx=0;kx<Xplaces;++kx)
				ndr_r[Xplaces*(Yplaces-1)+kx]*=-_1_step;
			ndr_r[Xplaces-1]*=-_1_step;
		}
		void integrate_x						(Term &n)
		{
			auto ndr_r=(double*)n.r.p;
			double step=xs.Xsample;
			double sum=0;
			for(int ky=0;ky<Yplaces;++ky)
			{
				for(int kx=0;kx<Xplaces;++kx)
				{
					auto &v=ndr_r[Xplaces*ky+kx];
					v=(sum+=v)*step;
				}
				sum=0;
			}
		}
		void integrate_y						(Term &n)
		{
			auto ndr_r=(double*)n.r.p;
			double step=xs.Xsample;
			std::vector<double> sum(Xplaces, 0);
			for(int ky=0;ky<Yplaces;++ky)
				for(int kx=0;kx<Xplaces;++kx)
				{
					auto &v=ndr_r[Xplaces*ky+kx];
					v=(sum[kx]+=v)*step;
				}
		}
		fftw_complex *fft_in, *fft_out;
		fftw_plan fft_p, ifft_p;
		unsigned fft_N0, fft_N1;
		double fft_sqrt_N;
		void discreteFourrierTransform			(Term &n)
		{
			if(n.i.size()!=n.r.size())
				n.i.resize(n.r.size());
			fft_2d_forward((double*)n.r.p, (double*)n.i.p, Xplaces, Yplaces, fft_N0, fft_N1, fft_sqrt_N, fft_in, fft_out, fft_p, ifft_p);
		}
		void inverseDiscreteFourrierTransform	(Term &n)
		{
			if(n.i.size()!=n.r.size())
				n.i.resize(n.r.size());
			fft_2d_inverse((double*)n.r.p, (double*)n.i.p, Xplaces, Yplaces, fft_N0, fft_N1, fft_sqrt_N, fft_in, fft_out, fft_p, ifft_p);
		}
		void lowPassFilter						(Term &n){lpf_2d(n, Xplaces, Yplaces);}
		void highPassFilter						(Term &n){hpf_2d(n, Xplaces, Yplaces);}

		void setDimensions(int x, int y, int w, int h)
		{
			bpx=x, bpy=y, bw=w, bh=h, X0=bpx+bw/2, Y0=bpy+bh/2;
			_3d.setDimensions(x, y, w, h);
			bool XstepChanged, YstepChanged, ZstepChanged;
			function1(XstepChanged, YstepChanged, ZstepChanged);
			if(!toSolve&&contourOn&&ZstepChanged)
			{
				contours.clear();
				for(unsigned e=0;e<expr.size();++e)
					if(expr[e].rmode[0]==5)
						doContour(e);
			}
			ready=true;
		}
		void shiftNDR(double &DshiftPoint, double Dsample, double &DsamplePos, double &VD, int &Doffset, double ammount)
		{
			double newDsamplePos=std::floor((DshiftPoint+=ammount)/Dsample);
			if(newDsamplePos!=DsamplePos)
			{
				toSolve=true;
				if(shiftOnly)
					shiftOnly=1, Doffset+=int(newDsamplePos-DsamplePos);
				DsamplePos=newDsamplePos, VD=newDsamplePos*Dsample;
			}
		}
		void shiftNDRupdate(double DshiftPoint, double Dsample, double &DsamplePos, double &VD)
		{
			double newDsamplePos=std::floor(DshiftPoint/Dsample);
			if(newDsamplePos!=DsamplePos)
				DsamplePos=newDsamplePos, VD=newDsamplePos*Dsample;
		}
		void messageTimer()
		{
				 if(kb[VK_SHIFT	]){	 if(kb['W'])	_3d.cam.moveFastForward();
									 if(kb['A'])	_3d.cam.moveFastLeft();
									 if(kb['S'])	_3d.cam.moveFastBack();
									 if(kb['D'])	_3d.cam.moveFastRight();
									 if(kb['T'])	_3d.cam.p.z+=10*_3d.cam.dcam;
									 if(kb['G'])	_3d.cam.p.z-=10*_3d.cam.dcam;}
			else				  {	 if(kb['W'])	_3d.cam.moveForward();
									 if(kb['A'])	_3d.cam.moveLeft();
									 if(kb['S'])	_3d.cam.moveBack();
									 if(kb['D'])	_3d.cam.moveRight();
									 if(kb['T'])	_3d.cam.p.z+=_3d.cam.dcam;
									 if(kb['G'])	_3d.cam.p.z-=_3d.cam.dcam;}
			auto &VX=xs.VX, &DX=xs.DX, &VY=ys.VX, &DY=ys.DX, &VZ=zs.VX, &DZ=zs.DX;
			double dVD=DX/100;
			if(kb['X'])
			{
				if(kb['Y'])
				{
					if(kb['Z'])	//xyz
					{
					}
					else		//xy
					{
						if(kb[VK_UP])	shiftNDR(YshiftPoint, ys.Xsample, YsamplePos, VY, Yoffset,  dVD), _3d.cam.p.y+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])	shiftNDR(YshiftPoint, ys.Xsample, YsamplePos, VY, Yoffset, -dVD), _3d.cam.p.y-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT])shiftNDR(XshiftPoint, xs.Xsample, XsamplePos, VX, Xoffset,  dVD), _3d.cam.p.x+=_3d_shift_move_cam*dVD;
						if(kb[VK_LEFT])	shiftNDR(XshiftPoint, xs.Xsample, XsamplePos, VX, Xoffset, -dVD), _3d.cam.p.x-=_3d_shift_move_cam*dVD;
					}
				}
				else
				{
					if(kb['Z'])	//xz
					{
						if(kb[VK_UP])	VZ+=dVD, _3d.cam.p.z+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])	VZ-=dVD, _3d.cam.p.z-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT])shiftNDR(XshiftPoint, xs.Xsample, XsamplePos, VX, Xoffset,  dVD), _3d.cam.p.x+=_3d_shift_move_cam*dVD;
						if(kb[VK_LEFT])	shiftNDR(XshiftPoint, xs.Xsample, XsamplePos, VX, Xoffset, -dVD), _3d.cam.p.x-=_3d_shift_move_cam*dVD;
					}
					else		//x
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(XshiftPoint, xs.Xsample, XsamplePos, VX, Xoffset, dVD),  _3d.cam.p.x+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(XshiftPoint, xs.Xsample, XsamplePos, VX, Xoffset, -dVD), _3d.cam.p.x-=_3d_shift_move_cam*dVD;
					}
				}
			}
			else
			{
				if(kb['Y'])
				{
					if(kb['Z'])	//yz
					{
						if(kb[VK_UP])	VZ+=dVD, _3d.cam.p.z+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])	VZ-=dVD, _3d.cam.p.z-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT])shiftNDR(YshiftPoint, ys.Xsample, YsamplePos, VY, Yoffset,  dVD), _3d.cam.p.y+=_3d_shift_move_cam*dVD;
						if(kb[VK_LEFT])	shiftNDR(YshiftPoint, ys.Xsample, YsamplePos, VY, Yoffset, -dVD), _3d.cam.p.y-=_3d_shift_move_cam*dVD;
					}
					else		//y
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(YshiftPoint, ys.Xsample, YsamplePos, VY, Yoffset,  dVD), _3d.cam.p.y+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(YshiftPoint, ys.Xsample, YsamplePos, VY, Yoffset, -dVD), _3d.cam.p.y-=_3d_shift_move_cam*dVD;
					}
				}
				else
				{
					if(kb['Z'])	//z
					{
						if(kb[VK_UP]||kb[VK_RIGHT]){	VZ+=dVD, _3d.cam.p.x+=_3d_shift_move_cam*dVD;	if(contourOn)toSolve=true, shiftOnly=0;}//just to update contour
						if(kb[VK_DOWN]||kb[VK_LEFT]){	VZ-=dVD, _3d.cam.p.x-=_3d_shift_move_cam*dVD;	if(contourOn)toSolve=true, shiftOnly=0;}
					}
					else
					{
						if(kb[VK_UP])	_3d.cam.turnUp();
						if(kb[VK_DOWN])	_3d.cam.turnDown();
						if(kb[VK_RIGHT])_3d.cam.turnRight();
						if(kb[VK_LEFT])	_3d.cam.turnLeft();
					}
				}
			}
		/*	if(kb['X'])
			{
				if(kb['Y'])
				{
					if(kb['Z'])	//xyz
					{
					}
					else		//xy
					{
						if(kb[VK_UP])	shiftNDR(YshiftPoint, ys.Xsample*AR_Y,	YsamplePos, VY, Yoffset,  dVD), _3d.cam.p.y+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])	shiftNDR(YshiftPoint, ys.Xsample*AR_Y,	YsamplePos, VY, Yoffset, -dVD), _3d.cam.p.y-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT])shiftNDR(XshiftPoint, xs.Xsample,		XsamplePos, VX, Xoffset,  dVD), _3d.cam.p.x+=_3d_shift_move_cam*dVD;
						if(kb[VK_LEFT])	shiftNDR(XshiftPoint, xs.Xsample,		XsamplePos, VX, Xoffset, -dVD), _3d.cam.p.x-=_3d_shift_move_cam*dVD;
					}
				}
				else
				{
					if(kb['Z'])	//xz
					{
						if(kb[VK_UP])	VZ+=dVD, _3d.cam.p.z+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])	VZ-=dVD, _3d.cam.p.z-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT])shiftNDR(XshiftPoint, xs.Xsample, XsamplePos, VX, Xoffset,  dVD), _3d.cam.p.x+=_3d_shift_move_cam*dVD;
						if(kb[VK_LEFT])	shiftNDR(XshiftPoint, xs.Xsample, XsamplePos, VX, Xoffset, -dVD), _3d.cam.p.x-=_3d_shift_move_cam*dVD;
					}
					else		//x
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(XshiftPoint, xs.Xsample, XsamplePos, VX, Xoffset, dVD),  _3d.cam.p.x+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(XshiftPoint, xs.Xsample, XsamplePos, VX, Xoffset, -dVD), _3d.cam.p.x-=_3d_shift_move_cam*dVD;
					}
				}
			}
			else
			{
				if(kb['Y'])
				{
					if(kb['Z'])	//yz
					{
						if(kb[VK_UP])	VZ+=dVD, _3d.cam.p.z+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])	VZ-=dVD, _3d.cam.p.z-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT])shiftNDR(YshiftPoint, ys.Xsample*AR_Y, YsamplePos, VY, Yoffset,  dVD), _3d.cam.p.y+=_3d_shift_move_cam*dVD;
						if(kb[VK_LEFT])	shiftNDR(YshiftPoint, ys.Xsample*AR_Y, YsamplePos, VY, Yoffset, -dVD), _3d.cam.p.y-=_3d_shift_move_cam*dVD;
					}
					else		//y
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(YshiftPoint, ys.Xsample*AR_Y, YsamplePos, VY, Yoffset,  dVD), _3d.cam.p.y+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(YshiftPoint, ys.Xsample*AR_Y, YsamplePos, VY, Yoffset, -dVD), _3d.cam.p.y-=_3d_shift_move_cam*dVD;
					}
				}
				else
				{
					if(kb['Z'])	//z
					{
						if(kb[VK_UP]||kb[VK_RIGHT]){	VZ+=dVD, _3d.cam.p.x+=_3d_shift_move_cam*dVD;	if(contourOn)toSolve=true, shiftOnly=0;}//just to update contour
						if(kb[VK_DOWN]||kb[VK_LEFT]){	VZ-=dVD, _3d.cam.p.x-=_3d_shift_move_cam*dVD;	if(contourOn)toSolve=true, shiftOnly=0;}
					}
					else
					{
						if(kb[VK_UP])	_3d.cam.turnUp();
						if(kb[VK_DOWN])	_3d.cam.turnDown();
						if(kb[VK_RIGHT])_3d.cam.turnRight();
						if(kb[VK_LEFT])	_3d.cam.turnLeft();
					}
				}
			}//*/
			if(kb[VK_ADD]|kb[VK_RETURN]|kb[VK_OEM_PLUS])
			{
				if(kb[VK_MENU])//alt+
				{
					if(_3d_zoom_move_cam)//zoom in
						DX/=1.1, _3d.cam.p.x=VX+(_3d.cam.p.x-VX)/1.1, _3d.cam.p.y=VY+(_3d.cam.p.y-VY)/1.1, _3d.cam.p.z=VZ+(_3d.cam.p.z-VZ)/1.1, _3d.cam.dcam/=1.1;
					else//zoom out
						DX*=1.1;
					function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					toSolve=true, shiftOnly=0;
				}
				else if(kb['X'])//x+ stretch (zoom out (compress), stretch y, z)
				{
					if(_3d_stretch_move_cam)
					{
						double VX0=VX, VY0=VY;
						DX/=1.1;//zoom out
						function1();
						shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
						shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						_3d.cam.p.x=VX+(_3d.cam.p.x-VX0)/1.1, _3d.cam.p.y=VY+(_3d.cam.p.y-VY0)/1.1, _3d.cam.p.z=VZ+(_3d.cam.p.z-VZ)/1.1, _3d.cam.dcam/=1.1;

						VY0=VY;//stretch y
						YshiftPoint/=1.1;
						AR_Y/=1.1, function1();
						shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						_3d.cam.p.y+=VY-VY0;

						_3d.cam.p.z-=VZ/11., VZ/=1.1;//stretch z
						AR_Z/=1.1, function1();
					}
					else
					{
						DX/=1.1, AR_Y/=1.1, AR_Z/=1.1, function1();
						_3d.cam.p.x/=1.1, _3d.cam.p.y/=1.1, _3d.cam.p.z/=1.1, _3d.cam.dcam/=1.1;
						shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					}
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Y'])//y+ stretch
				{
					double VY0=VY;
					YshiftPoint*=1.1;//move cube
					AR_Y*=1.1, function1();
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					if(_3d_stretch_move_cam)
						_3d.cam.p.y+=VY-VY0;
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Z'])//z+ stretch
				{
					if(_3d_stretch_move_cam)
						_3d.cam.p.z+=VZ*0.1;
					VZ*=1.1;//move cube
					AR_Z*=1.1, function1();
					if(contourOn)
						toSolve=true, shiftOnly=0;
				}
				else if(!kb[VK_CONTROL])//zoom in fov
					_3d.cam.zoomIn();
			}
			if(kb[VK_SUBTRACT]||kb[VK_BACK]||kb[VK_OEM_MINUS])
			{
				if(kb[VK_MENU])//alt-
				{
					if(_3d_zoom_move_cam)//zoom out
						DX*=1.1, _3d.cam.p.x=VX+(_3d.cam.p.x-VX)*1.1, _3d.cam.p.y=VY+(_3d.cam.p.y-VY)*1.1, _3d.cam.p.z=VZ+(_3d.cam.p.z-VZ)*1.1, _3d.cam.dcam*=1.1;
					else//zoom in
						DX/=1.1;
					function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					toSolve=true, shiftOnly=0;
				}
				else if(kb['X'])//x- compress (zoom in (stretch), compress y z)
				{
					if(_3d_stretch_move_cam)
					{
						double VX0=VX, VY0=VY;
						DX*=1.1;//zoom in
						function1();
						shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
						shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						_3d.cam.p.x=VX+(_3d.cam.p.x-VX0)*1.1, _3d.cam.p.y=VY+(_3d.cam.p.y-VY0)*1.1, _3d.cam.p.z=VZ+(_3d.cam.p.z-VZ)*1.1, _3d.cam.dcam*=1.1;
					
						VY0=VY;//compress y
						YshiftPoint*=1.1;
						AR_Y*=1.1, function1();
						shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						_3d.cam.p.y+=VY-VY0;
					
						_3d.cam.p.z+=VZ*0.1, VZ*=1.1;//compress z
						AR_Z*=1.1, function1();
					}
					else
					{
						DX*=1.1, AR_Y*=1.1, AR_Z*=1.1, function1();
						_3d.cam.p.x*=1.1, _3d.cam.p.y*=1.1, _3d.cam.p.z*=1.1, _3d.cam.dcam*=1.1;
						shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					}
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Y'])//y- compress
				{
					double VY0=VY;
					YshiftPoint/=1.1;//move cube
					AR_Y/=1.1, function1();
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					if(_3d_stretch_move_cam)
						_3d.cam.p.y+=VY-VY0;
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Z'])//z- compress
				{
					if(_3d_stretch_move_cam)
						_3d.cam.p.z-=VZ/11.;
					VZ/=1.1;//move cube
					AR_Z/=1.1, function1();
					if(contourOn)
						toSolve=true, shiftOnly=0;
				}
				else if(!kb[VK_CONTROL])//zoom out fov
					_3d.cam.zoomOut();
			}
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
		}
		int inputLButtonDown(int lParam)
		{
			if(!drag)
			{
				if(!shift)
				{
					ShowCursor(0);
					GetCursorPos(&mouseP0);
					SetCursorPos(centerP.x, centerP.y);
					SetCapture(ghWnd);
				}
				drag=1;
			}
			return 0;
		}
		int inputMouseMove(int lParam)
		{
			if(!m_bypass)
			{
				int draw=0;
				int dmx=((short*)&lParam)[0]-w/2, dmy=h/2-((short*)&lParam)[1];
				auto &VX=xs.VX, &DX=xs.DX, &VY=ys.VX, &DY=ys.DX, &VZ=zs.VX, &DZ=zs.DX;
				if(kb['X'])
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//xyz	mx my mw
						{
							double VX0=VX, VY0=VY;
							shiftNDR(XshiftPoint, xs.Xsample, XsamplePos, VX, Xoffset, dmx*DX/w), _3d.cam.p.x+=(VX-VX0)*_3d_shift_move_cam;
							shiftNDR(YshiftPoint, ys.Xsample, YsamplePos, VY, Yoffset, dmy*DX/w), _3d.cam.p.y+=(VY-VY0)*_3d_shift_move_cam;
						//	shiftNDR(YshiftPoint, ys.Xsample*AR_Y,	YsamplePos, VY, Yoffset, dmy*DX/w), _3d.cam.p.y+=(VY-VY0)*_3d_shift_move_cam;
						}
						else		//xy	mx my
						{
							double VX0=VX, VY0=VY;
							shiftNDR(XshiftPoint, xs.Xsample, XsamplePos, VX, Xoffset, dmx*DX/w), _3d.cam.p.x+=(VX-VX0)*_3d_shift_move_cam;
							shiftNDR(YshiftPoint, ys.Xsample, YsamplePos, VY, Yoffset, dmy*DX/w), _3d.cam.p.y+=(VY-VY0)*_3d_shift_move_cam;
						//	shiftNDR(YshiftPoint, ys.Xsample*AR_Y,	YsamplePos, VY, Yoffset, dmy*DX/w), _3d.cam.p.y+=(VY-VY0)*_3d_shift_move_cam;
						}
						draw=1;
					}
					else
					{
						if(kb['Z'])	//xz	mx my
						{
							double VX0=VX;
							shiftNDR(XshiftPoint, xs.Xsample, XsamplePos, VX, Xoffset, dmx*DX/w), _3d.cam.p.x+=(VX-VX0)*_3d_shift_move_cam;
							double dVZ=dmy*DX/w;
							VZ+=dVZ, _3d.cam.p.x+=dVZ*_3d_shift_move_cam;
						}
						else		//x		mx
						{
							double VX0=VX;
							shiftNDR(XshiftPoint, xs.Xsample, XsamplePos, VX, Xoffset, dmx*DX/w), _3d.cam.p.x+=(VX-VX0)*_3d_shift_move_cam;
						}
						draw=1;
					}
				}
				else
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//yz	mx my
						{
							double VY0=VY;
							shiftNDR(YshiftPoint, ys.Xsample, YsamplePos, VY, Yoffset, dmx*DX/w), _3d.cam.p.y+=(VY-VY0)*_3d_shift_move_cam;
						//	shiftNDR(YshiftPoint, ys.Xsample*AR_Y, YsamplePos, VY, Yoffset, dmx*DX/w), _3d.cam.p.y+=(VY-VY0)*_3d_shift_move_cam;
							double dVZ=dmy*DX/w;
							VZ+=dVZ, _3d.cam.p.x+=dVZ*_3d_shift_move_cam;
						}
						else		//y		mx
						{
							double VY0=VY;
							shiftNDR(YshiftPoint, ys.Xsample/AR_Y, YsamplePos, VY, Yoffset, dmx*DX/w), _3d.cam.p.y+=(VY-VY0)*_3d_shift_move_cam;
						//	shiftNDR(YshiftPoint, ys.Xsample, YsamplePos, VY, Yoffset, dmx*DX/w), _3d.cam.p.y+=(VY-VY0)*_3d_shift_move_cam;
						//	shiftNDR(YshiftPoint, ys.Xsample*AR_Y, YsamplePos, VY, Yoffset, dmx*DX/w), _3d.cam.p.y+=(VY-VY0)*_3d_shift_move_cam;
						}
						draw=1;
					}
					else
					{
						if(kb['Z'])	//z		my
						{
							double dVZ=dmy*DX/w;
						//	double dVZ=dmy*DX/Xplaces;
							VZ+=dVZ, _3d.cam.p.z+=dVZ*_3d_shift_move_cam;
							if(contourOn)
								toSolve=true, shiftOnly=0;//just to update contour
							draw=1;
						}
						else if(drag)
						{
							_3d.cam.turnMouse(lParam);
							draw=1;
						}
					}
				}
			/*	if(kb['X'])
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//xyz	mx my mw
						{
							double VX0=VX, VY0=VY;
							shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, VX, Xoffset, dmx*DX/w), _3d.cam.p.x+=(VX-VX0)*_3d_shift_move_cam;
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y,	YsamplePos, VY, Yoffset, dmy*DX/w), _3d.cam.p.y+=(VY-VY0)*_3d_shift_move_cam;
						}
						else		//xy	mx my
						{
							double VX0=VX, VY0=VY;
							shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, VX, Xoffset, dmx*DX/w), _3d.cam.p.x+=(VX-VX0)*_3d_shift_move_cam;
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y,	YsamplePos, VY, Yoffset, dmy*DX/w), _3d.cam.p.y+=(VY-VY0)*_3d_shift_move_cam;
						}
						draw=1;
					}
					else
					{
						if(kb['Z'])	//xz	mx my
						{
							double VX0=VX;
							shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, VX, Xoffset, dmx*DX/w), _3d.cam.p.x+=(VX-VX0)*_3d_shift_move_cam;
							double dVZ=dmy*DX/w;
							VZ+=dVZ, _3d.cam.p.x+=dVZ*_3d_shift_move_cam;
						}
						else		//x		mx
						{
							double VX0=VX;
							shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, VX, Xoffset, dmx*DX/w), _3d.cam.p.x+=(VX-VX0)*_3d_shift_move_cam;
						}
						draw=1;
					}
				}
				else
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//yz	mx my
						{
							double VY0=VY;
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, VY, Yoffset, dmx*DX/w), _3d.cam.p.y+=(VY-VY0)*_3d_shift_move_cam;
							double dVZ=dmy*DX/w;
							VZ+=dVZ, _3d.cam.p.x+=dVZ*_3d_shift_move_cam;
						}
						else		//y		mx
						{
							double VY0=VY;
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, VY, Yoffset, dmx*DX/w), _3d.cam.p.y+=(VY-VY0)*_3d_shift_move_cam;
						}
						draw=1;
					}
					else
					{
						if(kb['Z'])	//z		my
						{
							double dVZ=dmy*DX/w;
						//	double dVZ=dmy*DX/Xplaces;
							VZ+=dVZ, _3d.cam.p.z+=dVZ*_3d_shift_move_cam;
							if(contourOn)
								toSolve=true, shiftOnly=0;//just to update contour
							draw=1;
						}
						else if(drag)
						{
							_3d.cam.turnMouse(lParam);
							draw=1;
						}
					}
				}//*/
				if(draw)
				{
					SetCursorPos(centerP.x, centerP.y);
					if(!time_variance&&!timer)
						a_draw();
				}
			}
			m_bypass=!m_bypass;
			return 0;
		}
		void inputLButtonUp(int lParam)
		{
			if(drag)
			{
				if(!shift)
				{
					ReleaseCapture();
					SetCursorPos(mouseP0.x, mouseP0.y);
					ShowCursor(1);
				}
				drag=0;
			}
		}
		int inputMouseWheel(int wParam)
		{
			bool mw_forward=((short*)&wParam)[1]>0;
			auto &VX=xs.VX, &DX=xs.DX, &VY=ys.VX, &DY=ys.DX, &VZ=zs.VX, &DZ=zs.DX;
			if(kb['X']&&kb['Y']&&kb['Z'])//ordered by case priority
			{
				double dVD=DX/100;
					 if(mw_forward)	VZ+=dVD, _3d.cam.p.z+=dVD*_3d_shift_move_cam;
				else				VZ-=dVD, _3d.cam.p.z-=dVD*_3d_shift_move_cam;
			}
			else if(kb[VK_MENU])//alt wheel
			{
				double VX0=VX, VY0=VY;
					 if(mw_forward)	DX*=1.1;//, DY*=1.1;
				else				DX/=1.1;//, DY/=1.1;
				function1();
				shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);//
				shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);//
				if(_3d_zoom_move_cam)
				{
						 if(mw_forward)	_3d.cam.p.x=VX+(_3d.cam.p.x-VX0)*1.1, _3d.cam.p.y=VY+(_3d.cam.p.y-VY0)*1.1, _3d.cam.p.z=VZ+(_3d.cam.p.z-VZ)*1.1, _3d.cam.dcam*=1.1;
					else				_3d.cam.p.x=VX+(_3d.cam.p.x-VX0)/1.1, _3d.cam.p.y=VY+(_3d.cam.p.y-VY0)/1.1, _3d.cam.p.z=VZ+(_3d.cam.p.z-VZ)/1.1, _3d.cam.dcam/=1.1;
				}
				toSolve=true, shiftOnly=0;
			}
			else if(kb['X'])//x wheel
			{
				if(_3d_stretch_move_cam)
				{
					double VX0=VX, VY0=VY;
						 if(mw_forward)	DX/=1.1;//zoom out
					else				DX*=1.1;
					function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						 if(mw_forward)	_3d.cam.p.x=VX+(_3d.cam.p.x-VX0)/1.1, _3d.cam.p.y=VY+(_3d.cam.p.y-VY0)/1.1, _3d.cam.p.z=VZ+(_3d.cam.p.z-VZ)/1.1, _3d.cam.dcam/=1.1;
					else				_3d.cam.p.x=VX+(_3d.cam.p.x-VX0)*1.1, _3d.cam.p.y=VY+(_3d.cam.p.y-VY0)*1.1, _3d.cam.p.z=VZ+(_3d.cam.p.z-VZ)*1.1, _3d.cam.dcam*=1.1;

					VY0=VY;//stretch y
						 if(mw_forward)	AR_Y/=1.1,	YshiftPoint/=1.1;
					else				AR_Y*=1.1,	YshiftPoint*=1.1;
					function1();
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					_3d.cam.p.y+=VY-VY0;

						 if(mw_forward)	_3d.cam.p.z-=VZ/11., AR_Z/=1.1,	VZ/=1.1;//stretch z
					else				_3d.cam.p.z+=VZ*0.1, AR_Z*=1.1,	VZ*=1.1;
					function1();
				}
				else
				{
						 if(mw_forward)	DX/=1.1, AR_Y/=1.1, AR_Z/=1.1, _3d.cam.p.x/=1.1, _3d.cam.p.y/=1.1, _3d.cam.p.z/=1.1, _3d.cam.dcam/=1.1;
					else				DX*=1.1, AR_Y*=1.1, AR_Z*=1.1, _3d.cam.p.x*=1.1, _3d.cam.p.y*=1.1, _3d.cam.p.z*=1.1, _3d.cam.dcam*=1.1;
					function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
				}
				toSolve=true, shiftOnly=0;
			}
			else if(kb['Y'])//y wheel
			{
				double VY0=VY;
					 if(mw_forward)	AR_Y*=1.1,	YshiftPoint*=1.1;
				else				AR_Y/=1.1,	YshiftPoint/=1.1;
				function1();
				shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
				_3d.cam.p.y+=(VY-VY0)*_3d_stretch_move_cam;
				toSolve=true, shiftOnly=0;
			}
			else if(kb['Z'])//z wheel
			{
					 if(mw_forward)	AR_Z*=1.1, _3d.cam.p.z+=VZ*0.1*_3d_stretch_move_cam,	VZ*=1.1;
				else				AR_Z/=1.1, _3d.cam.p.z-=VZ/11.*_3d_stretch_move_cam,	VZ/=1.1;
				function1();
				if(contourOn)
					toSolve=true, shiftOnly=0;
			}
			else if(kb[VK_CONTROL])//ctrl wheel
			{
					 if(mw_forward)	_3d.cam.faster();
				else				_3d.cam.slower();
			}
			else if(kb[VK_SHIFT])//shift wheel
			{
				if(mw_forward)
					Yplaces=Xplaces+=1<<max_simd_method, toSolve=true, shiftOnly=0;
				else if(Xplaces>1<<max_simd_method)
					Yplaces=Xplaces-=1<<max_simd_method, toSolve=true, shiftOnly=0;
			}
			else//wheel
			{
					 if(mw_forward)	_3d.cam.zoomIn();
				else				_3d.cam.zoomOut();
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyDown(int wParam, int lParam)
		{
			auto &VX=xs.VX, &DX=xs.DX, &VY=ys.VX, &DY=ys.DX, &VZ=zs.VX, &DZ=zs.DX;
			switch(wParam)
			{
			case 'W':case 'A':case 'S':case 'D':case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:case 'T':case 'G':
				if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case VK_ADD:case VK_OEM_PLUS:case VK_RETURN:
				if(kb[VK_CONTROL])
					_3d.cam.faster();
				else if(kb[VK_SHIFT])
				{
					Yplaces=Xplaces+=1<<max_simd_method, toSolve=true, shiftOnly=0;
					break;
				}
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case VK_SUBTRACT:case VK_OEM_MINUS:case VK_BACK:
				if(kb[VK_CONTROL])
					_3d.cam.slower();
				else if(kb[VK_SHIFT])
				{
					if(Xplaces>1<<max_simd_method)
						Yplaces=Xplaces-=1<<max_simd_method, toSolve=true, shiftOnly=0;
					break;
				}
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case 'X':case 'Y':case 'Z':
				if(!(lParam&1<<30)&&!shift)
				{
					if(!drag)
					{
						GetCursorPos(&mouseP0);
						ShowCursor(0);
						SetCursorPos(centerP.x, centerP.y);
						SetCapture(ghWnd);
					}
					shift=1;
				}
				return 0;
			case VK_OEM_3:
				if(contourOn)//was on
				{
					if(kb[VK_CONTROL])
					{
						//contour+surface
						//contour only
						//flat contour
						//flat+surface
						if(contourFlat)
						{
							if(contourOnly)
								contourOnly=false;//3: surface appears
							else
								contourFlat=false;//4: pops up
						}
						else
						{
							if(contourOnly)
								contourFlat=true;//2: gets flat
							else
								contourOnly=true;//1: surface disappears
						}
					}
					else
						contourOn=false, contourOnly=false, contourFlat=false;
				}
				else//was off
				{
					contourOn=true;
					if(!toSolve)
					{
						contours.clear();
						for(unsigned e=0;e<expr.size();++e)
							if(expr[e].rmode[0]==5)
								doContour(e);
					}
				}
				break;
			case '0':case VK_NUMPAD0:
				if(operations.size())
					toSolve=true, shiftOnly=0;
				operations.clear();
				break;
			case '1':case VK_NUMPAD1:
			case '2':case VK_NUMPAD2:
			case '3':case VK_NUMPAD3:
			case '4':case VK_NUMPAD4:
			case '5':case VK_NUMPAD5:
			case '6':case VK_NUMPAD6:
			case '7':case VK_NUMPAD7:
			case '8':case VK_NUMPAD8:
				{
					auto op=&Transverse_2D::differentiate_x;
					switch(wParam)
					{
					case '1':case VK_NUMPAD1:	operations.push_back( 1), op=&Transverse_2D::differentiate_x;					break;
					case '2':case VK_NUMPAD2:	operations.push_back( 2), op=&Transverse_2D::differentiate_y;					break;
					case '3':case VK_NUMPAD3:	operations.push_back( 3), op=&Transverse_2D::integrate_x;						break;
					case '4':case VK_NUMPAD4:	operations.push_back( 4), op=&Transverse_2D::integrate_y;						break;
					case '5':case VK_NUMPAD5:	operations.push_back( 5), op=&Transverse_2D::discreteFourrierTransform;			break;
					case '6':case VK_NUMPAD6:	operations.push_back( 6), op=&Transverse_2D::inverseDiscreteFourrierTransform;	break;
					case '7':case VK_NUMPAD7:	operations.push_back( 7), op=&Transverse_2D::lowPassFilter;						break;
					case '8':case VK_NUMPAD8:	operations.push_back( 8), op=&Transverse_2D::highPassFilter;					break;
					}
					if(!toSolve)
					{
						contours.clear();
						for(unsigned e=0;e<expr.size();++e)
						{
							(this->*op)(expr[e].n[expr[e].resultTerm]);
							if(contourOn)
								doContour(e);
						}
					}
				}
				break;
			case 'C':
				clearScreen=!clearScreen;
				break;
			case 'E'://reset axes scale
				{
					double r=20/DX;

					XshiftPoint*=r, YshiftPoint*=r, VZ*=r;
					_3d.cam.p.x*=r, _3d.cam.p.y*=r, _3d.cam.p.z*=r, _3d.cam.dcam*=r;
					xs.reset_scale(), ys.reset_scale(), zs.reset_scale(), AR_Y=1, AR_Z=1, function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					toSolve=true, shiftOnly=0;
				}
				break;
			case 'R'://reset position and zoom,		ctrl: position only
				_3d.cam.dcam=.04, _3d.cam.tanfov=1;
				if(!kb[VK_CONTROL])
				{
					xs.reset_scale(), ys.reset_scale(), zs.reset_scale(), AR_Y=1, AR_Z=1, function1();
					Xplaces=Yplaces=100;//Xplaces multiple of 4
				//	Xplaces=Yplaces=4;//DEBUG
				}

				XshiftPoint=YshiftPoint=0;
				shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
				shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
				xs.reset_position(), ys.reset_position(), zs.reset_position();

				toSolve=true, shiftOnly=0;
				if(kb['X'])
					_3d.teleport_degrees(20, 0, 0, 180, 0, 1);
				else if(kb['Y'])
					_3d.teleport_degrees(0, 20, 0, 270, 0, 1);
				else if(kb['Z'])
					_3d.teleport_degrees(0, 0, 20, 90, 270, 1);
				else
					_3d.teleport_degrees(4, 4, 4, 225, 324.7356103172454, 1);
				break;
			case VK_F6:
				if(!(lParam&1<<30))
				{
					kb_VK_F6_msg=true;
					if(!_3d_stretch_move_cam&!_3d_shift_move_cam&!_3d_zoom_move_cam)
						_3d_stretch_move_cam=true;
					else if(!_3d_shift_move_cam&!_3d_zoom_move_cam)
						_3d_shift_move_cam=true;
					else if(!_3d_zoom_move_cam)
						_3d_zoom_move_cam=true;
					else
						_3d_stretch_move_cam=_3d_shift_move_cam=_3d_zoom_move_cam=false;
				}
				break;
			default:
				if(lParam&1<<30)
					return 0;
				break;
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		void draw()
		{
			if(usingOpenGL)
				gl_enabledepthtest();
			auto &VX=xs.VX, &DX=xs.DX, &VY=ys.VX, &DY=ys.DX, &VZ=zs.VX, &DZ=zs.DX;
			double DY0=ys.DX, VY0=VY, DZ0=zs.DX, VZ0=VZ;
			DY/=AR_Y, VY/=AR_Y, DZ/=AR_Z, VZ/=AR_Z;
		//	DY=DX/AR_Y, DZ=DX/AR_Z;
			xs.set_Xplaces(Xplaces), ys.set_Xplaces(Yplaces);//sets places, sample, start & end
		//	double DY=DX/AR_Y, DZ=DX/AR_Z;
			int Yoffset0=Yoffset;
			if(toSolve)
			{
				if(!operations.size()&&shiftOnly==1&&abs(Xoffset)<Xplaces&&abs(Yoffset)<Yplaces)
				{
					if(Xoffset||Yoffset)
					{
					//	GUIPrint(w-200, h/2, "Xoffset=%d", Xoffset);//
					//	GUIPrint(w-200, h/2+18, "Yoffset=%d", Yoffset);//
						solver.partial_bounds(VX, DX, VY/AR_Y, DY, Xoffset, Yoffset);//only uses Xoffset & Yoffset
						solver.synchronize();
						for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)
						{
							auto &ex=expr[ke];
							if(ex.rmode[0]==5)
								(solver.*(ex.nITD?&Solve_2D::full:solver.partial))(ex);
						}
					}
				}
				else
				{
					auto old_time_variance=time_variance;
					time_variance=false;
					labels.clear();
					solver.full_resize(VX, DX, VY/AR_Y, DY, Xplaces, Yplaces);
					XsamplePos=std::floor(XshiftPoint/xs.Xsample);
					YsamplePos=std::floor(YshiftPoint/ys.Xsample);
				//	XsamplePos=std::floor(XshiftPoint/solver.Xsample);
				//	YsamplePos=std::floor(YshiftPoint/(solver.Ysample*AR_Y));
					if(!paused)
						solver.synchronize();
					for(unsigned e=0;e<expr.size();++e)
					{
						auto &ex=expr[e];
						if(ex.rmode[0]==5)
						{
							time_variance|=ex.nITD;
							labels.fill(e);
							solver.full(ex);
							for(auto it=operations.begin();it!=operations.end();++it)
							{
								auto &operation=*it;
								switch(operation)
								{
								case  1:differentiate_x					(ex.n[ex.resultTerm]);break;
								case  2:differentiate_y					(ex.n[ex.resultTerm]);break;
								case  3:integrate_x						(ex.n[ex.resultTerm]);break;
								case  4:integrate_y						(ex.n[ex.resultTerm]);break;
								case  5:discreteFourrierTransform		(ex.n[ex.resultTerm]);break;
								case  6:inverseDiscreteFourrierTransform(ex.n[ex.resultTerm]);break;
								case  7:lowPassFilter					(ex.n[ex.resultTerm]);break;
								case  8:highPassFilter					(ex.n[ex.resultTerm]);break;
								}
							}
						}
					}
					if(time_variance)
					{
						if(!paused)
							SetTimer(ghWnd, 0, 10, 0);
					}
					else if(old_time_variance&&!timer)
						KillTimer(ghWnd, 0);
				}
				if(contourOn)
				{
					contours.clear();
					for(unsigned e=0;e<expr.size();++e)
						if(expr[e].rmode[0]==5)
							doContour(e);
				}
				toSolve=false, shiftOnly=2, Xoffset=0, Yoffset=0;
				exprRemoved=false;
			}
			else if(time_variance)
			{
				if(!paused)
					solver.synchronize();
				for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)
				{
					auto &ex=expr[ke];
					if(ex.rmode[0]==5&&ex.nITD)
					{
						solver.full(ex);
						for(auto it=operations.begin();it!=operations.end();++it)
						{
							auto &operation=*it;
							switch(operation)
							{
							case  1:differentiate_x					(ex.n[ex.resultTerm]);break;
							case  2:differentiate_y					(ex.n[ex.resultTerm]);break;
							case  3:integrate_x						(ex.n[ex.resultTerm]);break;
							case  4:integrate_y						(ex.n[ex.resultTerm]);break;
							case  5:discreteFourrierTransform		(ex.n[ex.resultTerm]);break;
							case  6:inverseDiscreteFourrierTransform(ex.n[ex.resultTerm]);break;
							case  7:lowPassFilter					(ex.n[ex.resultTerm]);break;
							case  8:highPassFilter					(ex.n[ex.resultTerm]);break;
							}
						}
					}
				}
				if(contourOn)
				{
					for(unsigned e=0;e<expr.size();++e)
					{
						auto &ex=expr[e];
						if(ex.rmode[0]==5&&ex.nITD)
						{
							contours[e].clear();
							doContour(e);
						}
					}
				}
			}
			else if(exprRemoved)
			{
				auto old_time_variance=time_variance;
				time_variance=false;
				labels.clear();
				for(unsigned e=0;e<expr.size();++e)
				{
					auto &ex=expr[e];
					if(ex.rmode[0]==5)
					{
						time_variance|=ex.nITD;
						labels.fill(e);
					}
				}
				if(old_time_variance&&!time_variance&&!timer)
					KillTimer(ghWnd, 0);
				exprRemoved=false;
			}

		//	_3dMode_FrameStart(_3d, xs, ys, zs, AR_Y, AR_Z);
			clear_depth_buffer();
			if(usingOpenGL)
				GL2_3D::begin();
			GUIPrint(w-400, (h>>1)+18, "VY=%g, DY=%g, AR_Y=%g (ys)", VY, DY, ys.AR);//
			GUIPrint(w-400, (h>>1)+18*2, "VY=%g, DY=%g, AR_Y=%g (draw)", VY0, DY0, AR_Y);//
			GUIPrint(w-400, (h>>1)+18*3, "Yplaces=%d, ys.Yplaces=%d, Ysample=%g", Yplaces, ys.Xplaces, ys.Xsample);//
			GUIPrint(w-400, (h>>1)+18*4, "Ystart=%g, Yend=%g (ys)", ys_Ystart, ys.Xend);//
			GUIPrint(w-400, (h>>1)+18*5, "Ystart=%g, Yend=%g (modes)", modes::Ystart, modes::Yend);//
			GUIPrint(w-400, (h>>1)+18*6, "YshiftPoint=%g, YsamplePos=%g, Yoffset=%d", YshiftPoint, YsamplePos, Yoffset0);//
			GUIPrint(w-400, (h>>1)+18*7, "x1=%d, x2=%d, y1=%d, y2=%d", solver.ra[0], solver.ra[1], solver.ra[2], solver.ra[3]);//
			//GUIPrint(0, 0, "Ystart=%g, Ysample=%g modes", modes::Ystart, modes::Ysample);//
			//GUIPrint(0, 16, "Ystart=%g, Ysample=%g ys", ys_Ystart, ys.Xsample);//
			if(modes::Ystart!=ys_Ystart||modes::Ysample!=ys.Xsample)
				int LOL_1=0;
		//	GUIPrint(0, 0, "DX=%g, DY=%g, DZ=%g", DX, DY, DZ);//
			DY=DY0, VY=VY0, DZ=DZ0, VZ=VZ0;
		//	GUIPrint(0, 16, "DY0=%g, DZ0=%g", DY, DZ);//
			_3dMode_DrawGridNAxes(_3d, xs, ys, zs, AR_Y, AR_Z);
			int colorCondition=nExpr[5]>1;
		//	double Xstart=solver.Xstart, Xr=solver.Xsample, Ystart=AR_Y*solver.Ystart, Yr=AR_Y*solver.Ysample;
			if(!contourOnly)//draw the surfaces
			{
				if(operations.size())
				{
					for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)
					{
						auto &ex=expr[ke];
						if(ex.rmode[0]==5)
						{
							if(colorCondition)
								_3d.lineColor=ex.getColor();
							auto ndr=(double*)ex.n[ex.resultTerm].r.p;

							for(int y=0;y<Yplaces;++y)
							{
								_3d.curve_start();
								for(int x=0;x<Xplaces;++x)
									_3d.curve_point(xs.fn(xs.ifn_x(x)), ys.fn(ys.ifn_x(y)), zs.fn(AR_Z*ndr[Xplaces*y+x]));
								//	_3d.curve_point(Xstart+x*Xr, Ystart+y*Yr, AR_Z*ndr[Xplaces*y+x]);
							}
							for(int x=0;x<Xplaces;++x)
							{
								_3d.curve_start();
								for(int y=0;y<Yplaces;++y)
									_3d.curve_point(xs.fn(xs.ifn_x(x)), ys.fn(ys.ifn_x(y)), zs.fn(AR_Z*ndr[Xplaces*y+x]));
								//	_3d.curve_point(Xstart+x*Xr, Ystart+y*Yr, AR_Z*ndr[Xplaces*y+x]);
							}
							_3d.lineColor=0;
						}
					}
				}
				else
				{
					unsigned yDiscOffset=(Xplaces-1)*Yplaces;
					for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)
					{
						auto &ex=expr[ke];
						if(ex.rmode[0]==5)
						{
							if(colorCondition)
								_3d.lineColor=ex.getColor();
							auto ndr=(double*)ex.n[ex.resultTerm].r.p;

							for(int y=0;y<Yplaces;++y)
							{
								_3d.curve_start();
								for(int x=0;x<Xplaces-1;++x)
								{
									_3d.curve_point(xs.fn(xs.ifn_x(x)), ys.fn(ys.ifn_x(y)), zs.fn(AR_Z*ndr[Xplaces*y+x]));
								//	_3d.curve_point(Xstart+x*Xr, Ystart+y*Yr, AR_Z*ndr[Xplaces*y+x]);
									if(ex.discontinuities[(Xplaces-1)*y+x])
										_3d.curve_start();
								}
								_3d.curve_point(xs.fn(xs.ifn_x(Xplaces-1)), ys.fn(ys.ifn_x(y)), zs.fn(AR_Z*ndr[Xplaces*y+(Xplaces-1)]));
							//	_3d.curve_point(Xstart+(Xplaces-1)*Xr, Ystart+y*Yr, AR_Z*ndr[Xplaces*y+(Xplaces-1)]);
							}
							for(int x=0;x<Xplaces;++x)
							{
								_3d.curve_start();
								for(int y=0;y<Yplaces-1;++y)
								{
									_3d.curve_point(xs.fn(xs.ifn_x(x)), ys.fn(ys.ifn_x(y)), zs.fn(AR_Z*ndr[Xplaces*y+x]));
								//	_3d.curve_point(Xstart+x*Xr, Ystart+y*Yr, AR_Z*ndr[Xplaces*y+x]);
									if(ex.discontinuities[yDiscOffset+(Yplaces-1)*x+y])
										_3d.curve_start();
								}
								_3d.curve_point(xs.fn(xs.ifn_x(x)), ys.fn(ys.ifn_x(Yplaces-1)), zs.fn(AR_Z*ndr[Xplaces*(Yplaces-1)+x]));
							//	_3d.curve_point(Xstart+x*Xr, Ystart+(Yplaces-1)*Yr, AR_Z*ndr[Xplaces*(Yplaces-1)+x]);
							}
							_3d.lineColor=0;
						}
					}
				}
			}
			if(contourOn)//draw the contour
			{
				for(unsigned e=0;e<expr.size();++e)
				{
					auto &ex=expr[e];
					if(ex.rmode[0]==5)
					{
						if(colorCondition)
							_3d.lineColor=ex.getColor();
						auto &contour=contours[e];
						for(auto cit=contour.begin();cit!=contour.end();++cit)
						{
							auto &L=*cit;
							double Z=contourFlat?VZ:zs.ticks2dist(L.first);
							for(auto xit=L.second.begin();xit!=L.second.end();++xit)
							{
								auto &p=*xit;
								_3d.line(dvec3(xs.ifn(p.first.x), ys.fn(p.first.y), zs.fn(AR_Z*Z)), dvec3(xs.ifn(p.second.x), ys.fn(p.second.y), zs.fn(AR_Z*Z)));
							}
						}
					}
				}
			}
			if(usingOpenGL)
			{
				GL2_3D::end();
				GL2_3D::draw(_3d.cam);
			}
			if(!clearScreen)
			{
				{
					int bkMode=setBkMode(TRANSPARENT);
				//	int bkMode=GetBkMode(ghMemDC);
				//	SetBkMode(ghMemDC, TRANSPARENT);
					_3dMode_NumberAxes(_3d, xs, ys, zs, AR_Y, AR_Z);
					{
						auto al=colorCondition?(void (_3D::*)(double, double, double, double, double, double, std::vector<Label>&))&_3D::arrowLabelsColor:&_3D::arrowLabels;
						(_3d.*al)(0, 0, 0, 1, 0, 0, labels.Xlabels);
						(_3d.*al)(0, 0, 0, 0, 1, 0, labels.Ylabels);
					}
					{
						int textColor;
						if(colorCondition)
							textColor=getTextColor();
						//	textColor=GetTextColor(ghMemDC);
						int Ys=0;
						for(int kl=0, klEnd=labels.Clabels.size();kl<klEnd;++kl)
						{
							auto &label=labels.Clabels[kl];
							int linelen=sprintf_s(g_buf, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
							if(colorCondition)
								setTextColor(expr[label.exNo].winColor);
							//	SetTextColor(ghMemDC, expr[label.exNo].winColor);
							print(w-const_label_offset_X, Ys, g_buf, linelen), Ys+=16;
						//	TextOutA(ghMemDC, w-const_label_offset_X, Ys, g_buf, linelen), Ys+=16;
						}
						if(colorCondition)
							setTextColor(textColor);
						//	SetTextColor(ghMemDC, textColor);
					}
					setBkMode(bkMode);
				//	SetBkMode(ghMemDC, bkMode);
				}
				{
					int k=0, Y=h-operations.size()*16;
					for(auto it=operations.begin();it!=operations.end();++it)
					{
						auto &operation=*it;
						char const *a=0;
						switch(operation)
						{
						case 1:a="%d: Differentiate X";	break;
						case 2:a="%d: Differentiate Y";	break;
						case 3:a="%d: Integrate X";		break;
						case 4:a="%d: Integrate Y";		break;
						case 5:a="%d: DFT";				break;
						case 6:a="%d: IDFT";			break;
						case 7:a="%d: LPF";				break;
						case 8:a="%d: HPF";				break;
						case 9:a="%d: HT";				break;
						case 10:a="%d: IHT";			break;
						}
						_3d.textIn2D(w-const_label_offset_X, Y, OPAQUE, a, k);
						++k, Y+=16;
					}
				}
				_3d.text_show();
				if(kb_VK_F6_msg||kb[VK_F6])
				{
					int bkMode=setBkMode(OPAQUE);
				//	int kb_mode=SetBkMode(ghMemDC, OPAQUE);
					kb_VK_F6_msg=false;
					if(!_3d_stretch_move_cam&!_3d_shift_move_cam&!_3d_zoom_move_cam)
						GUIPrint(0, h-18*3, "move cam: [-] scale, [-] shift, [-] zoom");
					else if(!_3d_shift_move_cam&!_3d_zoom_move_cam)
						GUIPrint(0, h-18*3, "move cam: [v] scale, [-] shift, [-] zoom");
					else if(!_3d_zoom_move_cam)
						GUIPrint(0, h-18*3, "move cam: [v] scale, [v] shift, [-] zoom");
					else
						GUIPrint(0, h-18*3, "move cam: [v] scale, [v] shift, [v] zoom");
					setBkMode(bkMode);
				//	SetBkMode(ghMemDC, kb_mode);
				}
			}
		}
		void i_draw();
		void a_draw();
	} t2d;
	const int		Transverse_2D::modes[]={5}, Transverse_2D::nmodes=sizeof(modes)>>2;
	void			Transverse_2D::i_draw()
	{
		if(modes::ready)
		{
			draw();
			if(showLastModeOnIdle)
				capture_window(modeRGB);
			//	std::copy(rgb, rgb+w*h, modeRGB);

			selectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			{
				int bkMode=setBkMode(OPAQUE);
			//	int bkMode=GetBkMode(ghMemDC);
			//	SetBkMode(ghMemDC, OPAQUE);
				if(nExpr[5]>1)
					itb.draw_color(modes, nmodes);
				else
					itb.draw();
				setBkMode(bkMode);
			//	SetBkMode(ghMemDC, bkMode);
			}
			deselectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	
			if(showBenchmark)
				Performance(0, h-32);//
#ifndef BUILD_1_7
			BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
#endif
		}
		else
		{
			display_texture_fullwindow(modeRGB);
		//	std::copy(modeRGB, modeRGB+w*h, rgb);
			if(showBenchmark)
				Performance(0, h-32);//
		}
	}
	void			Transverse_2D::a_draw()
	{
		newframe();
	//	rectangle(bpx-1, bpy-1, bw+1, bh+1);
	//	Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);

		draw();
		
		if(contextHelp)
		{
			const char *help[]=
			{
				"W/A/S/D/T/G: move",
				"arrows: turn",
				"+/-/enter/backspace/wheel: change FOV",
				"X/Y/Z arrows/mouse move: shift x/y/z",
				"X/Y/Z +/-/enter/backspace/wheel: scale x/y/z",
				"alt +/-/enter/backspace/wheel: zoom",
				"shift +/-/enter/backspace/wheel: change resolution",
				"E: reset scale",
				"R: reset scale & view",
				"C: toggle clear screen",
				"F6: change camera settings",
				"1: differentiate x",
				"2: differentiate y",
				"3: integrate x",
				"4: integrate y",
				"5: DFT",
				"6: Inverse DFT",
				"7: LPF",
				"8: HPF",
				"0: reset operations",
				"`: contour",
				"Tab/Shift Tab: switch renderer",
				"Esc: back to text editor"
			};
			print_contextHelp(help, sizeof(help)>>2, 330);
		}
		if(showBenchmark&&!clearScreen)
			Performance(0, h-32);//
		show();
	//	BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
		report_error();
	}
	namespace contour
	{
		struct Int_x_y_z_Double_Z
		{
			int x, y, c;
			double Z;
			Int_x_y_z_Double_Z(int x, int y, int c, double Z):x(x), y(y), c(c), Z(Z){}
		};
	}
	class		Color_2D:public _2D_Mode
	{
	public:
		int Xoffset, Yoffset;

		int Xplaces, Yplaces;
		Solve_C2D solver;
		std::list<int> operations;

		bool contourOn, contourOnly;//, contourFlat;
		bool showValue;
		
		bool clearScreen;
		Labels_2D labels;
		HPEN__ *hPen;
		HBRUSH__ *hBrush;
		static const int modes[], nmodes;

		Color_2D():
			_2D_Mode(solver),
			Xoffset(0), Yoffset(0),
			fft_N0(0), fft_N1(0),
			contourOnly(false),//, contourFlat(true)
			showValue(false),
			clearScreen(true)
		{
			hPen=CreatePen(PS_SOLID, 1, 0x00EFEFEF), hBrush=CreateSolidBrush(0x00EFEFEF);
		}
		~Color_2D()
		{
			DeleteObject(hPen), DeleteObject(hBrush);
			if(fft_N0||fft_N1)
			{
				fftw_destroy_plan(fft_p), fftw_destroy_plan(ifft_p);
				fftw_free(fft_in), fftw_free(fft_out);
			}
		}
		
		void doContour_component_range(double *ndr, unsigned const component, int x1, int x2, int y1, int y2)
		{
			int dx=x2-x1, dy=y2-y1, x11=x1+1, y11=y1+1, x2_1=x2-1, y2_1=y2-1;
			if(dx>=3&&dy>=3)
			{
				const double aa_thickness=1,
				
					_1_aa_thickness=1/aa_thickness;
				const int aa_bound=int(std::round(aa_thickness));

				//crossings
				int Xplaces_1=Xplaces-1, Yplaces_1=Yplaces-1,
					XCsize=Xplaces_1*Yplaces, YCsize=Yplaces_1*Xplaces, ndrSize=Xplaces*Yplaces,
					Xplaces1=Xplaces+aa_bound;
				std::vector<double>
					Xcross(XCsize, -1),//._
					Ycross(YCsize, -1);//!
				std::vector<bool> shade(Xplaces1*(Yplaces+aa_bound));
				{
					// _	top left
					//|_!
					auto&v00=ndr[Xplaces*y1	+x1], &v01=ndr[Xplaces*y1	+x11],
						&v10=ndr[Xplaces*y11+x1], &v11=ndr[Xplaces*y11	+x11];
					BITREF corner=shade[Xplaces1*y11+x11];
					if(std::signbit(v00)!=std::signbit(v01))
						corner=true, Xcross[Xplaces_1*y1+x1]=(0-v00)/(v01-v00);		//zero cross
					if(std::signbit(v10)!=std::signbit(v11))
						corner=true, Xcross[Xplaces_1*y11+x1]=(0-v10)/(v11-v10);
					if(std::signbit(v00)!=std::signbit(v10))
						corner=true, Ycross[Xplaces*y1+x1]=(0-v00)/(v10-v00);
					if(std::signbit(v01)!=std::signbit(v11))
						corner=true, Ycross[Xplaces*y1+x11]=(0-v01)/(v11-v01);
				}
				{
					// _	top right
					//._|
					auto&v00=ndr[Xplaces*y1	+x2_1-1], &v01=ndr[Xplaces*y1	+x2_1],
						&v10=ndr[Xplaces*y11+x2_1-1], &v11=ndr[Xplaces*y11	+x2_1];
					BITREF corner=shade[Xplaces1*y11+x2_1-1];
					if(std::signbit(v00)!=std::signbit(v01))
						corner=true, Xcross[Xplaces_1*y1	+x2_1-1]=(0-v00)/(v01-v00);		//zero cross
					if(std::signbit(v10)!=std::signbit(v11))
						corner=true, Xcross[Xplaces_1*y11	+x2_1-1]=(0-v10)/(v11-v10);
					if(std::signbit(v01)!=std::signbit(v11))
						corner=true, Ycross[Xplaces*y11+	x2_1]=(0-v01)/(v11-v01);
				}
				{
					//  .	bottom left
					//|_|
					auto&v00=ndr[Xplaces*(y2_1-1)	+x1], &v01=ndr[Xplaces*(y2_1-1)	+x11],
						&v10=ndr[Xplaces* y2_1		+x1], &v11=ndr[Xplaces* y2_1	+x11];
					BITREF corner=shade[Xplaces1*(y2_1-1)+x11];
					if(std::signbit(v10)!=std::signbit(v11))
						corner=true, Xcross[Xplaces_1*y2_1		+x1]=(0-v10)/(v11-v10);		//zero cross
					if(std::signbit(v00)!=std::signbit(v10))
						corner=true, Ycross[Xplaces*(y2_1-1)	+x1]=(0-v00)/(v10-v00);
					if(std::signbit(v01)!=std::signbit(v11))
						corner=true, Ycross[Xplaces*(y2_1-1)	+x11]=(0-v01)/(v11-v01);
				}
				for(int x=x11, xEnd=x2_1-1;x<xEnd;++x)
				{
					// _	upper row
					//._!
					auto&v00=ndr[Xplaces*y1	+x], &v01=ndr[Xplaces*y1	+x+1],
						&v10=ndr[Xplaces*y11+x], &v11=ndr[Xplaces*y11	+x+1];
					BITREF p0=shade[Xplaces1*y11+x];
					BITREF p1=shade[Xplaces1*y11+x+1];
					if(std::signbit(v00)!=std::signbit(v01))
						p0=p1=true, Xcross[Xplaces_1*y1	+x]=(0-v00)/(v01-v00);		//zero cross
					if(std::signbit(v10)!=std::signbit(v11))
						p0=p1=true, Xcross[Xplaces_1*y11+x]=(0-v10)/(v11-v10);
					if(std::signbit(v01)!=std::signbit(v11))
						p0=p1=true, Ycross[Xplaces*y1	+x+1]=(0-v01)/(v11-v01);
				}
				for(int y=y11, yEnd=y2_1-1;y<yEnd;++y)
				{
					//  .	left column
					//|_!
					auto&v00=ndr[Xplaces* y   +x1], &v01=ndr[Xplaces* y   +x11],
						&v10=ndr[Xplaces*(y+1)+x1], &v11=ndr[Xplaces*(y+1)+x11];
					BITREF p0=shade[Xplaces1*y+x11];
					BITREF p1=shade[Xplaces1*(y+1)+x11];
					if(std::signbit(v10)!=std::signbit(v11))
						p0=p1=true, Xcross[Xplaces_1*(y+1)	+x1]=(0-v10)/(v11-v10);		//zero cross
					if(std::signbit(v00)!=std::signbit(v10))
						p0=p1=true, Ycross[Xplaces*y		+x1]=(0-v00)/(v10-v00);
					if(std::signbit(v01)!=std::signbit(v11))
						p0=p1=true, Ycross[Xplaces*y		+x11]=(0-v01)/(v11-v01);
				}
				auto aa_straight=[&](double d){return d>aa_thickness?1:d*_1_aa_thickness;};
				auto aa_close=[&](double x, double y)->double
				{
					double d=x*y*inv_sqrt(x*x+y*y);
				//	double d=std::abs(x*y)*inv_sqrt(x*x+y*y);
					return d>aa_thickness?1:d*_1_aa_thickness;
				};
				auto aa_middle=[&](double a, double b)->double//|. |
				{
					double b_a=b-a, d=a*inv_sqrt(1+b_a*b_a);
					return d>aa_thickness?1:d*_1_aa_thickness;
				};
				auto aa_far=[&](double x, double y)->double
				{
					double x_1=x-1, y_1=y-1;
					double d=std::abs(x*y-1)*inv_sqrt(x_1*x_1+y_1*y_1);
					return d>aa_thickness?1:d*_1_aa_thickness;
				};
				int complement=component?0x00FF00:0x0000FF;
			//	int complement=component?0xFFFFFF:0;
				int *&_rgb=solver.rgb;
				auto ApplyDIBPixelUnchecked=[&](int x, int y, double a)
				{
					auto p=(unsigned char*)&_rgb[y*Xplaces+x];
				//	auto p=(unsigned char*)&_rgb[y*w+x];
				//	auto p=(unsigned char*)&solver.rgb[y*w+x];
					*(int*)p^=complement;
					p[0]=(unsigned char)(p[0]*a), p[1]=(unsigned char)(p[1]*a), p[2]=(unsigned char)(p[2]*a);
					*(int*)p^=complement;
				};
				double d=0, d_min=0;
				for(int y=y1+aa_bound, yEnd=y2_1;y<yEnd;++y)
				{
					for(int x=x1+aa_bound, xEnd=x2_1;x<xEnd;++x)
					{
						int ndrP=Xplaces*y+x;
						int sp=Xplaces1*y+x;
						{
							auto						&v01=ndr[ndrP			+1],
								&v10=ndr[ndrP+Xplaces], &v11=ndr[ndrP+Xplaces	+1];
							if(std::signbit(v10)!=std::signbit(v11))
							{
								Xcross[Xplaces_1*(y+1)+x]=(0-v10)/(v11-v10);	//zero cross
								shade[sp				]=true, shade[sp			+1	]=true;
								shade[sp+Xplaces1		]=true, shade[sp+Xplaces1	+1	]=true;
								shade[sp+Xplaces1*2		]=true, shade[sp+Xplaces1*2	+1	]=true;
							}
							if(std::signbit(v01)!=std::signbit(v11))
							{
								Ycross[ndrP+1]=(0-v01)/(v11-v01);
								shade[sp				]=true, shade[sp			+1	]=true, shade[sp			+2	]=true;
								shade[sp+Xplaces1		]=true, shade[sp+Xplaces1	+1	]=true, shade[sp+Xplaces1	+2	]=true;
							}
						}
						if(shade[sp])
						{
							//	 	Dx
							//	Lx	+	Rx
							//		Ux  '
							auto		&Dx=Ycross[Xplaces*(y-1)+x],
								&Lx=Xcross[Xplaces_1*y+x-1],	&Rx=Xcross[Xplaces_1*y+x],
										&Ux=Ycross[Xplaces* y   +x];
							if(Ux!=-1)
							{
								if(Dx!=-1)
								{
									if(Lx!=-1)
									{
										if(Rx!=-1)	//udlr	>=2 lines	\+\	/+/
										{
											d_min=aa_close(Rx, Ux);
											if(d_min>(d=aa_close(Rx, 1-Dx)))
												d_min=d;
											if(d_min>(d=aa_close(1-Lx, 1-Dx)))
												d_min=d;
											if(d_min>(d=aa_close(1-Lx, Ux)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
										else		//udl	>=2 lines	<+
										{
											d_min=aa_close(1-Lx, 1-Dx);
											if(d_min>(d=aa_close(1-Lx, Ux)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
									}
									else
									{
										if(Rx!=-1)	//ud r	>=2 lines	+>
										{
											d_min=aa_close(Rx, Ux);
											if(d_min>(d=aa_close(Rx, 1-Dx)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
										else		//ud				_F_
										{
											d_min=Ux;
											if(d_min>(d=1-Dx))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
									}
								}
								else
								{
									if(Lx!=-1)
									{
										if(Rx!=-1)	//u lr	>=2 lines	\+/
										{
											d_min=aa_close(Rx, 1-Dx);
											if(d_min>(d=aa_close(1-Lx, 1-Dx)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
										else		//u l	>=1 line	\+
											ApplyDIBPixelUnchecked(x, y, aa_close(1-Lx, Ux));
									}
									else
									{
										if(Rx!=-1)	//u  r	>=1 line	+/
											ApplyDIBPixelUnchecked(x, y, aa_close(Rx, Ux));
										else		//u		>=1 line	_+_
										{
											auto &LUx=Ycross[Xplaces* y   +x-1], &RUx=Ycross[Xplaces* y   +x+1];
											d_min=Ux;
											if(LUx!=-1&&LUx<Ux&&d_min>(d=aa_middle(Ux, LUx)))
												d_min=d;
											if(RUx!=-1&&RUx<Ux&&d_min>(d=aa_middle(Ux, RUx)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
									}
								}
							}
							else
							{
								if(Dx!=-1)
								{
									if(Lx!=-1)
									{
										if(Rx!=-1)	// dlr	>=2 lines	/+\ 		backslash can extend line comment
										{
											d_min=aa_close(Rx, Ux);
											if(d_min>(d=aa_close(1-Lx, Ux)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
										else		// dl	>=1 line	/+
											ApplyDIBPixelUnchecked(x, y, aa_close(1-Lx, 1-Dx));
									}
									else
									{
										if(Rx!=-1)	// d r	>=1 line	+\ 		backslash can extend line comment
											ApplyDIBPixelUnchecked(x, y, aa_close(Rx, 1-Dx));
										else		// d	>=1 line	F
										{
											auto &LDx=Ycross[Xplaces*(y-1)+x-1], &RDx=Ycross[Xplaces*(y-1)+x+1];
											d_min=1-Dx;
											if(LDx!=-1&&LDx>Dx&&d_min>(d=aa_middle(1-Dx, 1-LDx)))
												d_min=d;
											if(RDx!=-1&&RDx>Dx&&d_min>(d=aa_middle(1-Dx, 1-RDx)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
									}
								}
								else
								{
									if(Lx!=-1)
									{
										if(Rx!=-1)	//  lr	>=1 line	|+|
										{
											d_min=Rx;
											if(d_min>(d=1-Lx))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
										else		//  l	>=1 line	|+
										{
											auto &DLx=Xcross[Xplaces_1*(y-1)+x-1], &ULx=Xcross[Xplaces_1*(y+1)+x-1];
											d_min=1-Lx;
											if(DLx!=-1&&DLx>Lx&&d_min>(d=aa_middle(1-Lx, 1-DLx)))
												d_min=d;
											if(ULx!=-1&&ULx>Lx&&d_min>(d=aa_middle(1-Lx, 1-ULx)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
									}
									else
									{
										if(Rx!=-1)	//   r	>=1 line	+|
										{
											auto &DRx=Xcross[Xplaces_1*(y-1)+x  ], &URx=Xcross[Xplaces_1*(y+1)+x  ];
											d_min=Rx;
											if(DRx!=-1&&DRx<Rx&&d_min>(d=aa_middle(Rx, DRx)))
												d_min=d;
											if(URx!=-1&&URx<Rx&&d_min>(d=aa_middle(Rx, URx)))
												d_min=d;
											ApplyDIBPixelUnchecked(x, y, d_min);
										}
										else		//		>=0 lines
										{
											auto
												&DLx=Xcross[Xplaces_1*(y-1)+x-1],	&LDx=Ycross[Xplaces*(y-1)+x-1],//	 _    _
												&DRx=Xcross[Xplaces_1*(y-1)+x  ],	&RDx=Ycross[Xplaces*(y-1)+x+1],//	| 1  2 | D
												&ULx=Xcross[Xplaces_1*(y+1)+x-1],	&LUx=Ycross[Xplaces* y   +x-1],//	    .
												&URx=Xcross[Xplaces_1*(y+1)+x  ],	&RUx=Ycross[Xplaces* y   +x+1];//	|_3  4_| U
											d_min=_HUGE;
											if(DLx!=-1&&LDx!=-1&&d_min>(d=aa_far(1-DLx, 1-LDx)))//1
												d_min=d;
											if(DRx!=-1&&RDx!=-1&&d_min>(d=aa_far(  DRx, 1-RDx)))//2
												d_min=d;
											if(ULx!=-1&&LUx!=-1&&d_min>(d=aa_far(1-ULx,   LUx)))//3
												d_min=d;
											if(URx!=-1&&RUx!=-1&&d_min>(d=aa_far(  URx,   RUx)))//4
												d_min=d;
											if(d_min!=_HUGE)
												ApplyDIBPixelUnchecked(x, y, d_min>aa_thickness?1:d_min*_1_aa_thickness);
										}
									}
								}
							}
						}
					}
				}
			}
		}
		void doContour_component_partial(double *ndr, unsigned const component, int Xoffset, int Yoffset)
		{
			int Xoffset2=std::abs(Xoffset)+2, Yoffset2=std::abs(Yoffset)+2;
				 if(Xoffset>0){							 if(Yoffset>0)					doContour_component_range(ndr, component,	0,					Xplaces,	0,					Yoffset2),			doContour_component_range(ndr, component,	Xplaces-Xoffset2,	Xplaces,	Yoffset,			Yplaces);
													else if(Yoffset<0)Yoffset=-Yoffset,	doContour_component_range(ndr, component,	Xplaces-Xoffset2,	Xplaces,	0,					Yplaces-Yoffset),	doContour_component_range(ndr, component,	0,					Xplaces,	Yplaces-Yoffset2,	Yplaces);
													else								doContour_component_range(ndr, component,	Xplaces-Xoffset2,	Xplaces,	0,					Yplaces);}
			else if(Xoffset<0){Xoffset=-Xoffset;		 if(Yoffset>0)					doContour_component_range(ndr, component,	0,					Xplaces,	0,					Yoffset2),			doContour_component_range(ndr, component,	0,					Xoffset2,	Yoffset,			Yplaces);
													else if(Yoffset<0)Yoffset=-Yoffset,	doContour_component_range(ndr, component,	0,					Xoffset2,	0,					Yplaces-Yoffset),	doContour_component_range(ndr, component,	0,					Xplaces,	Yplaces-Yoffset2,	Yplaces);
													else								doContour_component_range(ndr, component,	0,					Xoffset2,	0,					Yplaces);}
			else{										 if(Yoffset>0)					doContour_component_range(ndr, component,	0,					Xplaces,	0,					Yoffset2);
													else if(Yoffset<0)Yoffset=-Yoffset,	doContour_component_range(ndr, component,	0,					Xplaces,	Yplaces-Yoffset2,	Yplaces);
													else;}
		}
		void doContour_partial(unsigned e, int Xoffset, int Yoffset)
		{
			auto &ndr=expr[e].n[expr[e].resultTerm].r;
			doContour_component_partial((double*)(&ndr)[0].p, 0, Xoffset, Yoffset);
			doContour_component_partial((double*)(&ndr)[1].p, 1, Xoffset, Yoffset);
		}
		void doContour(unsigned e)
		{
			auto &ndr=expr[e].n[expr[e].resultTerm].r;
			doContour_component_range((double*)(&ndr)[0].p, 0, 0, Xplaces, 0, Yplaces);
			doContour_component_range((double*)(&ndr)[1].p, 1, 0, Xplaces, 0, Yplaces);
		}
		void differentiate_x					(Term &n)
		{
			auto ndr_r=(double*)n.r.p, ndr_i=(double*)n.i.p;
			double _1_step=xs.inv_Xsample;
			for(int ky=0;ky<Yplaces;++ky)
			{
				for(int kx=0;kx<Xplaces-1;++kx)
				{
					int idx=Xplaces*ky+kx;
					CompRef(ndr_r[idx], ndr_i[idx])=(std::complex<double>(ndr_r[idx+1], ndr_i[idx+1])-std::complex<double>(ndr_r[idx], ndr_i[idx]))*_1_step;
				}
				int idx=Xplaces*ky+Xplaces-1;
				CompRef(ndr_r[idx], ndr_i[idx])*=-_1_step;
			}
			int idx=Xplaces*Yplaces-1;
			CompRef(ndr_r[idx], ndr_i[idx])*=-_1_step;
		}
		void differentiate_y					(Term &n)
		{
			auto ndr_r=(double*)n.r.p, ndr_i=(double*)n.i.p;
			double _1_step=xs.inv_Xsample;
			for(int ky=0;ky<Yplaces-1;++ky)
				for(int kx=0;kx<Xplaces;++kx)
				{
					int idx=Xplaces*ky+kx;
					CompRef(ndr_r[idx], ndr_i[idx])=(std::complex<double>(ndr_r[idx+Xplaces], ndr_i[idx+Xplaces])-std::complex<double>(ndr_r[idx], ndr_i[idx]))*_1_step;
				}
			for(int kx=0;kx<Xplaces;++kx)
			{
				int idx=Xplaces*(Yplaces-1)+kx;
				CompRef(ndr_r[idx], ndr_i[idx])*=-_1_step;
			}
			int idx=Xplaces*Yplaces-1;
			CompRef(ndr_r[idx], ndr_i[idx])*=-_1_step;
		}
		void integrate_x						(Term &n)
		{
			auto ndr_r=(double*)n.r.p, ndr_i=(double*)n.i.p;
			double step=xs.Xsample;
			std::complex<double> sum;
			for(int ky=0;ky<Yplaces;++ky)
			{
				for(int kx=0;kx<Xplaces;++kx)
				{
					int idx=Xplaces*ky+kx;
					CompRef(ndr_r[idx], ndr_i[idx])=(sum+=std::complex<double>(ndr_r[idx], ndr_i[idx]))*step;
				}
				sum=0;
			}
		}
		void integrate_y						(Term &n)
		{
			auto ndr_r=(double*)n.r.p, ndr_i=(double*)n.i.p;
			double step=xs.Xsample;
			std::vector<std::complex<double>> sum(Xplaces);
			for(int ky=Yplaces-1;ky>=0;--ky)
				for(int kx=0;kx<Xplaces;++kx)
				{
					int idx=Xplaces*ky+kx;
					CompRef(ndr_r[idx], ndr_i[idx])=(sum[kx]+=std::complex<double>(ndr_r[idx], ndr_i[idx]))*step;
				}
		}
		fftw_complex *fft_in, *fft_out;
		fftw_plan fft_p, ifft_p;
		unsigned fft_N0, fft_N1;
		double fft_sqrt_N;
		void discreteFourrierTransform			(Term &n){fft_2d_forward((double*)n.r.p, (double*)n.i.p, Xplaces, Yplaces, fft_N0, fft_N1, fft_sqrt_N, fft_in, fft_out, fft_p, ifft_p);}
		void inverseDiscreteFourrierTransform	(Term &n){fft_2d_inverse((double*)n.r.p, (double*)n.i.p, Xplaces, Yplaces, fft_N0, fft_N1, fft_sqrt_N, fft_in, fft_out, fft_p, ifft_p);}
		void lowPassFilter						(Term &n){lpf_2d(n, Xplaces, Yplaces);}
		void highPassFilter						(Term &n){hpf_2d(n, Xplaces, Yplaces);}
		void HemalyTransform					(Term &n)
		{
			auto ndr_r=(double*)n.r.p, ndr_i=(double*)n.i.p;
			std::vector<std::complex<double>> t0(ndrSize), t1(ndrSize);
			for(int k=0;k<ndrSize;++k)
				t0[k]=std::complex<double>(ndr_r[k], ndr_i[k]);
			auto sqrtsize=::sqrt(double(Xplaces*Yplaces));
			int Xplaces3=Xplaces*Xplaces*Xplaces, Yplaces3=Yplaces*Yplaces*Yplaces;
		//	auto Xplaces3_2=sqrt(Xplaces3), Yplaces3_2=sqrt(Yplaces3);
			for(int kv=0;kv<Yplaces;++kv)
			{
				for(int ku=0;ku<Xplaces;++ku)
				{
					auto &Fuv=t1[Xplaces*kv+ku];

					std::complex<double>//reversible with noise
						pu=-2*G2::_pi*std::complex<double>(0, 1)*(double(ku-Xplaces/2)/Xplaces3),
						pv=-2*G2::_pi*std::complex<double>(0, 1)*(double(kv-Yplaces/2)/Yplaces3);
					for(int ky=0;ky<Yplaces;++ky)
					{
						double py=ky-Yplaces/2; std::complex<double> ty=pv*(py*py*py);
						for(int kx=0;kx<Xplaces;++kx)
						{
							double px=kx-Xplaces/2;
							Fuv+=t0[Xplaces*ky+kx]*std::exp(pu*(px*px*px)+ty);
						}
					}
					Fuv/=sqrtsize;
				}
			}
			for(int k=0;k<ndrSize;++k)
				CompRef(ndr_r[k], ndr_i[k])=t1[k];
		}
		void inverseHemalyTransform				(Term &n)
		{
			auto ndr_r=(double*)n.r.p, ndr_i=(double*)n.i.p;
			std::vector<std::complex<double>> t0(ndrSize), t1(ndrSize);
			for(int k=0;k<ndrSize;++k)
				t0[k]=std::complex<double>(ndr_r[k], ndr_i[k]);
			auto sqrtsize=::sqrt(double(Xplaces*Yplaces));
			int Xplaces3=Xplaces*Xplaces*Xplaces, Yplaces3=Yplaces*Yplaces*Yplaces;
		//	auto Xplaces3_2=sqrt(Xplaces3), Yplaces3_2=sqrt(Yplaces3);
			for(int ky=0;ky<Yplaces;++ky)
			{
				for(int kx=0;kx<Xplaces;++kx)
				{
					auto &Fxy=t1[Xplaces*ky+kx];

					std::complex<double>//reversible with noise
						px=2*G2::_pi*std::complex<double>(0, 1)*(double(kx-Xplaces/2)*double(kx-Xplaces/2)*double(kx-Xplaces/2)/Xplaces3),
						py=2*G2::_pi*std::complex<double>(0, 1)*(double(ky-Yplaces/2)*double(ky-Yplaces/2)*double(ky-Yplaces/2)/Yplaces3);
					for(int kv=0;kv<Yplaces;++kv)
					{
						std::complex<double> tv=py*double(kv-Yplaces/2);
						for(int ku=0;ku<Xplaces;++ku)
							Fxy+=t0[Xplaces*kv+ku]*std::exp(px*double(ku-Xplaces/2)+tv);
					}
					Fxy/=sqrtsize;
				}
			}
			for(int k=0;k<ndrSize;++k)
				CompRef(ndr_r[k], ndr_i[k])=t1[k];
		}

		void messageTimer()
		{
			int dx=conditional_negate(10, _2d_drag_graph_not_window);
			if(kb[VK_LEFT		]){	xs.shift(-dx), toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=dx;}
			if(kb[VK_RIGHT		]){	xs.shift(+dx), toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=dx;}
			if(kb[VK_UP			]){	ys.shift(+dx), toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset+=dx;}
			if(kb[VK_DOWN		]){	ys.shift(-dx), toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset-=dx;}
			if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])
			{
					 if(kb['X'])xs.zoom(1/1.1), AR_Y/=1.1;
				else if(kb['Y'])AR_Y*=1.1;
				else			xs.zoom(1/1.1);
				function1(), toSolve=true, shiftOnly=0;
			}
			if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])
			{
					 if(kb['X'])xs.zoom(1.1), AR_Y*=1.1;
				else if(kb['Y'])AR_Y/=1.1;
				else			xs.zoom(1.1);
				function1(), toSolve=true, shiftOnly=0;
			}
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
		}
		int inputLButtonDown(int lParam)
		{
			if(!drag)
			{
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
				SetCapture(ghWnd);
				drag=1;
			}
			return 0;
		}
		int inputMouseMove(int lParam)
		{
			if(drag)
			{
				if(!m_bypass)
				{
					int mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
					int dx=mx-w/2, dy=h/2-my;
					if(_2d_drag_graph_not_window)
						dx=-dx, dy=-dy;
					xs.shift(dx), ys.shift(dy);
					toSolve=true;
					if(shiftOnly)
						shiftOnly=1, Xoffset+=dx, Yoffset+=dy;
					SetCursorPos(centerP.x, centerP.y);
					if(!time_variance&&!timer)
						a_draw();
				}
				m_bypass=!m_bypass;
			}
			else if(showValue&&!time_variance&&!timer)
				oldMouse=lParam, a_draw();
			return 0;
		}
		void inputLButtonUp(int lParam)
		{
			if(drag)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
			}
		}
		int inputKeyDown(int wParam, int lParam)
		{
			auto &VX=xs.VX, &DX=xs.DX, &VY=ys.VX, &DY=ys.DX;
			switch(wParam)
			{
			case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
			case VK_ADD:case VK_SUBTRACT://numpad
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(!kb[wParam])
					++kp;
				if(!time_variance&&!timer)
					SetTimer(ghWnd, 0, 10, 0), timer=true;
				break;
			case VK_OEM_3://~	contour
				if(contourOn)//was on
				{
					if(kb[VK_CONTROL])
						contourOnly=!contourOnly, toSolve=true, shiftOnly=0;
				/*	{
						//1: flat contour+surface
						//2: flat contour
						//3: contour
						//4: contour+surface
						if(kb[VK_SHIFT])//reverse
						{
							if(contourFlat)
							{
								if(contourOnly)
									contourOnly=false, toSolve=true, shiftOnly=0;//4: surface reappears
								else
									contourFlat=false, toSolve=true, shiftOnly=0;//1: pops up
							}
							else
							{
								if(contourOnly)
									contourFlat=true, toSolve=true, shiftOnly=0;//3: flat
								else
									contourOnly=true;//2: surface disappears
							}
						}
						else
						{
							if(contourFlat)
							{
								if(contourOnly)
									contourFlat=false, toSolve=true, shiftOnly=0;//2: pops up
								else
									contourOnly=true;//1: surface disappears
							}
							else
							{
								if(contourOnly)
									contourOnly=false, toSolve=true, shiftOnly=0;//3: surface reappears
								else
									contourFlat=true, toSolve=true, shiftOnly=0;//4: flat
							}
						}
					}//*/
					else
						contourOn=false, contourOnly=false, toSolve=true, shiftOnly=0;//contour off
					//	contourOn=false, contourOnly=false, contourFlat=true, toSolve=true, shiftOnly=0;//contour off
				}
				else//was off
				{
					contourOn=true;
					if(kb[VK_CONTROL])//
						contourOnly=!contourOnly;//
					if(!toSolve)
					{
					//	Rcontours.clear(), Icontours.clear();
						if(contourOn)
						{
							if(contourOnly)
								memset(solver.rgb, 0xFF, solver.Xplaces*solver.Yplaces*sizeof(int));//
							doContour(cursorEx);
						}
					}
				}
				break;
			case '0':case VK_NUMPAD0:
				if(operations.size())
					toSolve=true, shiftOnly=0;
				operations.clear();
				break;
			case '1':case VK_NUMPAD1:
			case '2':case VK_NUMPAD2:
			case '3':case VK_NUMPAD3:
			case '4':case VK_NUMPAD4:
			case '5':case VK_NUMPAD5:
			case '6':case VK_NUMPAD6:
			case '7':case VK_NUMPAD7:
			case '8':case VK_NUMPAD8:
			case 'H':
			case 'J':
				{
					auto op=&Color_2D::differentiate_x;
					switch(wParam)
					{
					case '1':case VK_NUMPAD1:	operations.push_back( 1), op=&Color_2D::differentiate_x;					break;
					case '2':case VK_NUMPAD2:	operations.push_back( 2), op=&Color_2D::differentiate_y;					break;
					case '3':case VK_NUMPAD3:	operations.push_back( 3), op=&Color_2D::integrate_x;						break;
					case '4':case VK_NUMPAD4:	operations.push_back( 4), op=&Color_2D::integrate_y;						break;
					case '5':case VK_NUMPAD5:	operations.push_back( 5), op=&Color_2D::discreteFourrierTransform;			break;
					case '6':case VK_NUMPAD6:	operations.push_back( 6), op=&Color_2D::inverseDiscreteFourrierTransform;	break;
					case '7':case VK_NUMPAD7:	operations.push_back( 7), op=&Color_2D::lowPassFilter;						break;
					case '8':case VK_NUMPAD8:	operations.push_back( 8), op=&Color_2D::highPassFilter;						break;
					case 'H':					operations.push_back( 9), op=&Color_2D::HemalyTransform;					break;
					case 'J':					operations.push_back(10), op=&Color_2D::inverseHemalyTransform;				break;
					}
					if(!toSolve)
					{
						auto &n=expr[cursorEx].n[expr[cursorEx].resultTerm];
						(this->*op)(n);
						if(contourOnly)
							memset(solver.rgb, 0xFF, Xplaces*Yplaces*sizeof(int));
						else
							solver.updateRGB(n);
						if(contourOn)
						{
						//	Rcontours.clear(), Icontours.clear();
							doContour(cursorEx);
						}
					}
				}
				break;
			case 'C':
				clearScreen=!clearScreen;
				break;
			case 'F'://toggle color scheme
				solver.toggleColorScheme();
				toSolve=true, shiftOnly=0;
				break;
			case 'V'://show value at cursor
				showValue=!showValue;
				break;
			case 'E':
				xs.reset_scale(), ys.reset_scale(), AR_Y=1, function1();
				toSolve=true, shiftOnly=0;
				break;
			case 'R':
				if(!kb[VK_CONTROL])
					xs.reset_scale(), ys.reset_scale(), AR_Y=1, function1();
				xs.reset_position(), ys.reset_position();
				toSolve=true, shiftOnly=0;
				break;
			default:
				if(lParam&1<<30)
					return 0;
				break;
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		void draw()
		{
			prof_add("entry");
			static unsigned gl_texture=0;
			if(usingOpenGL)
				gl_disabledepthtest();
			auto &VX=xs.VX, &DX=xs.DX, &VY=ys.VX, &DY=ys.DX;
			DY=DX*h/(w*AR_Y);
			if(DY<=0)
				DY=1;
			auto &ex=expr[cursorEx];
			{
				bool changed=false;
				if(toSolve)
				{
					if(usingOpenGL==MODE_CL_GL_INTEROP)
					{
						if(!paused)
							solver.synchronize();
						Xplaces=w, Yplaces=h;
						xs.set_Xplaces(w), ys.set_Xplaces(h);
						generate_glcl_texture(gl_texture, Xplaces, Yplaces);
						ModeParameters mp=
						{
							MODE_C2D, 1,
							(unsigned)Xplaces, (unsigned)Yplaces, 1,//ndr dimensions
							xs.Xstart, xs.Xsample,//Xstart, Xsample
							ys.Xend, -ys.Xsample,//Yend, -Ysample
							0, 0,
							nullptr, nullptr,
						};
						cl_solve(ex, mp, solver.T, gl_texture);
					}
					else if(!operations.size()&&shiftOnly==1&&abs(Xoffset)<Xplaces&&abs(Yoffset)<Yplaces)
					{
						if(Xoffset||Yoffset)
						{
						//	Xoffset=Yoffset=0;//DEBUG
							solver.partial_bounds(VX, DX, VY, DY, Xoffset, Yoffset);
							solver.synchronize();
							if(ex.nITD)
							{
								solver.full(ex);
								if(contourOnly)
									memset(solver.rgb, 0xFF, Xplaces*Yplaces*sizeof(int));
								else
									solver.updateRGB(ex.n[ex.resultTerm]);
							}
							else
								(solver.*(solver.partial))(ex, contourOnly);
							prof_add("partial solve");
							if(contourOn&&abs(Xoffset)+2<Xplaces&&abs(Yoffset)+2<Yplaces)
							{
							//	Rcontours.clear(), Icontours.clear();
								doContour_partial(cursorEx, Xoffset, Yoffset);
							}
							else changed=true;
						}
					}
					else
					{
						auto old_time_variance=time_variance;
						time_variance=false;
						labels.clear();
						xs.set_Xplaces(w), ys.set_Xplaces(h);
						solver.full_resize(VX, DX, VY, DY, Xplaces=setXplaces(w), Yplaces=h);
						if(!paused)
							solver.synchronize();
						time_variance|=ex.nITD;
						labels.fill(cursorEx);
						solver.full(ex);
					//	prof_add("solve");
						for(auto it=operations.begin();it!=operations.end();++it)
						{
							auto &operation=*it;
							switch(operation)
							{
							case  1:differentiate_x					(ex.n[ex.resultTerm]);break;
							case  2:differentiate_y					(ex.n[ex.resultTerm]);break;
							case  3:integrate_x						(ex.n[ex.resultTerm]);break;
							case  4:integrate_y						(ex.n[ex.resultTerm]);break;
							case  5:discreteFourrierTransform		(ex.n[ex.resultTerm]);break;
							case  6:inverseDiscreteFourrierTransform(ex.n[ex.resultTerm]);break;
							case  7:lowPassFilter					(ex.n[ex.resultTerm]);break;
							case  8:highPassFilter					(ex.n[ex.resultTerm]);break;
							case  9:HemalyTransform					(ex.n[ex.resultTerm]);break;
							case 10:inverseHemalyTransform			(ex.n[ex.resultTerm]);break;
							}
						}
						prof_add("operations");
						if(contourOnly)
							memset(solver.rgb, 0xFF, Xplaces*Yplaces*sizeof(int));
						else
							solver.updateRGB(ex.n[ex.resultTerm]);
						if(time_variance)
						{
							if(!paused)
								SetTimer(ghWnd, 0, 10, 0);
						}
						else if(old_time_variance&&!timer)
							KillTimer(ghWnd, 0);
						changed=true;
					}
				//	changed=true;
					toSolve=false, shiftOnly=2, Xoffset=0, Yoffset=0;
				}
				else if(time_variance)
				{
					if(!paused)
						solver.synchronize();
					solver.full(ex);
				//	prof_add("solve");
					for(auto it=operations.begin();it!=operations.end();++it)
					{
						auto &operation=*it;
						switch(operation)
						{
						case  1:differentiate_x					(ex.n[ex.resultTerm]);break;
						case  2:differentiate_y					(ex.n[ex.resultTerm]);break;
						case  3:integrate_x						(ex.n[ex.resultTerm]);break;
						case  4:integrate_y						(ex.n[ex.resultTerm]);break;
						case  5:discreteFourrierTransform		(ex.n[ex.resultTerm]);break;
						case  6:inverseDiscreteFourrierTransform(ex.n[ex.resultTerm]);break;
						case  7:lowPassFilter					(ex.n[ex.resultTerm]);break;
						case  8:highPassFilter					(ex.n[ex.resultTerm]);break;
						case  9:HemalyTransform					(ex.n[ex.resultTerm]);break;
						case 10:inverseHemalyTransform			(ex.n[ex.resultTerm]);break;
						}
					}
					prof_add("operations");
					if(contourOnly)
						memset(solver.rgb, 0xFF, Xplaces*Yplaces*sizeof(int));
					else
						solver.updateRGB(ex.n[ex.resultTerm]);
					changed=true;
				}
				if(changed&&contourOn)
				{
				//	Rcontours.clear(), Icontours.clear();
					doContour(cursorEx);
					prof_add("gen contour");
				}
			}
		//	if(!contourOnly)
			if(usingOpenGL==MODE_CL_GL_INTEROP)//draw the mona lisa
			{
				cl_finish();
				if(cl_gl_interop)
					display_gl_texture(gl_texture);//draw the solution
				else
				{
				//	debug_printrgb(rgb, w, h, 512);
					display_texture(0, w, 0, h, rgb, w, h);
				}
			}
			else
			{
				for(int ky=0;ky<h;++ky)//Xplaces=setXplaces(w)
					std::copy(solver.rgb+Xplaces*ky, solver.rgb+Xplaces*ky+w, gBitmap.rgb+w*ky);
			}
			prof_add("draw");

			if(!clearScreen)
			{
			//	GUIPrint(ghMemDC, w/2, h/2, "LOL_1");
				{
					int H=0, V=0, VT=0;
					int bkMode=getBkMode();
				//	int bkMode=GetBkMode(ghMemDC);
					_2dMode_NumberAxes(H, V, VT, xs, ys);
					{
						int Ys=H+(H>h-46?-34:18);
						for(int kl=0, klEnd=labels.Xlabels.size();kl<klEnd;++kl)
						{
							auto &label=labels.Xlabels[kl];
							print(w-arrow_label_offset_X, Ys, label.label.c_str(), label.label.size()), Ys+=16;
						//	TextOutA(ghMemDC, w-arrow_label_offset_X, Ys, label.label.c_str(), label.label.size()), Ys+=16;
						}
						int Xs=	VT+24+8*ys.prec>w-24-ys.prec*8
							?	VT-24-8*ys.prec
							:	VT+24+8*ys.prec;
						//int Xs=	V+VT+24+8*ys.prec>w-24-ys.prec*8
						//	?	V+VT-24-8*ys.prec
						//	:	V+VT+24+8*ys.prec;
						Ys=0;
						for(int kl=0, klEnd=labels.Ylabels.size();kl<klEnd;++kl)
						{
							auto &label=labels.Ylabels[kl];
							print(Xs, Ys, label.label.c_str(), label.label.size()), Ys+=16;
						//	TextOutA(ghMemDC, Xs, Ys, label.label.c_str(), label.label.size()), Ys+=16;
						}
						Ys=0;
						for(int kl=0, klEnd=labels.Clabels.size();kl<klEnd;++kl)
						{
							auto &label=labels.Clabels[kl];
							int linelen=sprintf_s(g_buf, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
							print(w-const_label_offset_X, Ys, g_buf, linelen);
						//	TextOutA(ghMemDC, w-const_label_offset_X, Ys, g_buf, linelen);
							Ys+=16;
						}
					}
					setBkMode(bkMode);
				//	SetBkMode(ghMemDC, bkMode);
				}
				{
					int k=0, Y=h-operations.size()*16;
					for(auto it=operations.begin();it!=operations.end();++it)
					{
						auto &operation=*it;
						char const *a=0;
						switch(operation)
						{
						case 1:a="%d: Differentiate X";break;
						case 2:a="%d: Differentiate Y";break;
						case 3:a="%d: Integrate X";break;
						case 4:a="%d: Integrate Y";break;
						case 5:a="%d: DFT";break;
						case 6:a="%d: IDFT";break;
						case 7:a="%d: LPF";break;
						case 8:a="%d: HPF";break;
						case 9:a="%d: HT";break;
						case 10:a="%d: IHT";break;
						}
						GUIPrint(w-const_label_offset_X, Y, a, k);
						++k, Y+=16;
					}
				}
			/*	{//TEST
					auto ndr=ex.n[ex.resultTerm].r.p;
					int ndrSize=Xplaces*Yplaces;
					double vmin=0, vmax=0, vmin2=0, vmax2=0;

					minmax_sse2(ndr, ndrSize, vmin, vmax);//warm up
					minmax_naive(ndr, ndrSize, vmin2, vmax2);

					long long t1=__rdtsc();
					minmax_naive(ndr, ndrSize, vmin2, vmax2);
					int diff=int(__rdtsc()-t1);

					t1=__rdtsc();
					minmax_sse2(ndr, ndrSize, vmin, vmax);
					int diff2=int(__rdtsc()-t1);
					GUIPrint(ghMemDC, w>>2, h>>2, "%d %s %d", diff, diff<diff2?"<-":"->", diff2);
				}//END TEST//*/
				if(showValue)
				{
					int mx=((short*)&oldMouse)[0], my=((short*)&oldMouse)[1], idx=Xplaces*my+mx;
					auto &n=ex.n[ex.resultTerm];
					int offset=0;
					Value(n.r[idx], n.i[idx]).printComplex(g_buf, offset);
					const int fontH=16, cursorH=31, textW=258;
					int px=mx, py=my-fontH;//big cursor size: 19x31
					if(my-fontH<0)
						py+=fontH+cursorH;
					if(mx+textW>w)
						px-=textW;
					int bkMode=setBkMode(OPAQUE);
				//	int bkMode=GetBkMode(ghMemDC);
				//	SetBkMode(ghMemDC, OPAQUE);
					print(px, py, g_buf, offset);
				//	TextOutA(ghMemDC, px, py, g_buf, offset);
					setBkMode(bkMode);
				//	SetBkMode(ghMemDC, bkMode);
				}
			}
		}
		void i_draw();
		void a_draw();
	} c2d;
	const int		Color_2D::modes[]={6}, Color_2D::nmodes=sizeof(modes)>>2;
	void			Color_2D::i_draw()
	{
		if(modes::ready)
		{
			draw();
			if(showLastModeOnIdle)
				capture_window(modeRGB);
			//	std::copy(rgb, rgb+w*h, modeRGB);

			selectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			{
				int bkMode=setBkMode(OPAQUE);
			//	int bkMode=GetBkMode(ghMemDC);
			//	SetBkMode(ghMemDC, OPAQUE);
				itb.draw();
				setBkMode(bkMode);
			//	SetBkMode(ghMemDC, bkMode);
			}
			deselectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	
			if(showBenchmark)
				Performance(0, h-32);//
#ifndef BUILD_1_7
			BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
#endif
		}
		else
		{
			display_texture_fullwindow(modeRGB);
		//	std::copy(modeRGB, modeRGB+w*h, rgb);
			if(showBenchmark)
				Performance(0, h-32);//
		}
	}
	void			Color_2D::a_draw()
	{
		newframe();
	//	rectangle(bpx-1, bpy-1, bw+1, bh+1);
	//	Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);
		
		draw();
		
		if(contextHelp)
		{
			const char *help[]=
			{
				"arrows/drag: move",
				"+/-/enter/backspace/wheel: zoom",
				"X/Y +/-/enter/backspace/wheel: scale x/y",
				"E: reset scale",
				"R: reset scale & view",
				"C: toggle clear screen",
				"F: toggle color scheme",
				"V: show value at cursor",
				"1: differentiate x",
				"2: differentiate y",
				"3: integrate x",
				"4: integrate y",
				"5: DFT",
				"6: Inverse DFT",
				"7: LPF",
				"8: HPF",
				"H: HT",
				"J: Inverse HT",
				"0: reset operations",
				"`: contour",
				"Tab/Shift Tab: switch renderer",
				"Esc: back to text editor"
			};
			print_contextHelp(help, sizeof(help)>>2, 270);
		}
		if(showBenchmark&&!clearScreen)
			Performance(0, h-32);//
		show();
	//	BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
		report_error();
	}
	class		Longitudinal_2D:public _2D_Mode
	{
	public:
		int Xoffset, Yoffset, exprRemoved;

	//	int Xplaces, Yplaces, old_nX, old_nY;
		double T;
		Solve_L2D solver;
		
		bool clearScreen;
		Labels_2D labels;
		_2D_L2D _2d;
		static const int modes[], nmodes;
		Pen pen;
		//HPEN__ *hPen;
		//HBRUSH__ *hBrush;

		Longitudinal_2D():
			solver(true, xs, ys), _2D_Mode(solver),
			Xoffset(0), Yoffset(0), exprRemoved(0),
			clearScreen(false),
			pen(_3dGridColor)
		{
		//	hPen=CreatePen(PS_SOLID, 1, _3dGridColor);
		}
		//~Longitudinal_2D(){DeleteObject(hPen);}

		void messageTimer()
		{
			int dx=conditional_negate(10, _2d_drag_graph_not_window);
			if(kb[VK_LEFT		]){	xs.shift(-dx), toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset-=dx;}
			if(kb[VK_RIGHT		]){	xs.shift(+dx), toSolve=true; if(shiftOnly)shiftOnly=1, Xoffset+=dx;}
			if(kb[VK_UP			]){	ys.shift(+dx), toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset+=dx;}
			if(kb[VK_DOWN		]){	ys.shift(-dx), toSolve=true; if(shiftOnly)shiftOnly=1, Yoffset-=dx;}
			if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])
			{
					 if(kb['X'])xs.zoom(1/1.05), AR_Y/=1.05;
				else if(kb['Y'])AR_Y*=1.05;
				else			xs.zoom(1/1.05);
				function1(), toSolve=true, shiftOnly=0;
			}
			if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])
			{
					 if(kb['X'])xs.zoom(1.05), AR_Y*=1.05;
				else if(kb['Y'])AR_Y/=1.05;
				else			xs.zoom(1.05);
				function1(), toSolve=true, shiftOnly=0;
			}
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
		}
		int inputLButtonDown(int lParam)
		{
			if(!drag)
			{
				drag=1;
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
				SetCapture(ghWnd);
			}
			return 0;
		}
		int inputMouseMove(int lParam)
		{
			if(drag)
			{
				if(!m_bypass)
				{
					int mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
					int dx=mx-w/2, dy=h/2-my;
					if(_2d_drag_graph_not_window)
						dx=-dx, dy=-dy;
					xs.shift(dx), ys.shift(dy);
					toSolve=true;
					if(shiftOnly)
						shiftOnly=1, Xoffset+=dx, Yoffset+=dy;
					SetCursorPos(centerP.x, centerP.y);
					if(!time_variance&&!timer)
						a_draw();
				}
				m_bypass=!m_bypass;
			}
			return 0;
		}
		void inputLButtonUp(int lParam)
		{
			if(drag)
			{
				drag=0;
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
			}
		}
		int inputKeyDown(int wParam, int lParam)
		{
			auto &VX=xs.VX, &DX=xs.DX, &VY=ys.VX, &DY=ys.DX;
			switch(wParam)
			{
			case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
			case VK_ADD:case VK_SUBTRACT://numpad
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(!kb[wParam])
					++kp;
				if(!time_variance&&!timer)
					SetTimer(ghWnd, 0, 10, 0), timer=true;
				return 0;
			case 'C':
				clearScreen=!clearScreen;
				break;
			case 'E':
				xs.reset_scale(), ys.reset_scale(), AR_Y=1, function1();
				toSolve=true, shiftOnly=0;
				break;
			case 'R':
				if(!kb[VK_CONTROL])
					xs.reset_scale(), ys.reset_scale(), function1();
				xs.reset_position(), ys.reset_position();
				toSolve=true, shiftOnly=0;
				break;
			default:
				if(lParam&1<<30)
					return 0;
				break;
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		void draw()
		{
			if(usingOpenGL)
				gl_disabledepthtest();
			auto &VX=xs.VX, &DX=xs.DX, &VY=ys.VX, &DY=ys.DX;
			DY=DX*h/(w*AR_Y);
			if(DY<=0)
				DY=1;

			pen.use();
		//	hPen=(HPEN__*)SelectObject(ghMemDC, hPen);
			{
				xs.Xplaces=w, ys.Xplaces=h;
				for(double x=xs.start_grid(), xEnd=xs.Xend;x<xEnd;)//draw the grid
				{
					int X=xs.fn_x_int(x);
					line(X, 0, X, h);
					if(xs.next(x))
						break;
				}
				for(double y=ys.start_grid(), yEnd=ys.Xend;y<yEnd;)
			//	for(double y=ys.start_grid_y(), yEnd=ys.Xend;y>yEnd;)
				{
					int Y=ys.fn_y_int(y);
					line(0, Y, w, Y);
					if(ys.next(y))
						break;
				}
			}
			//{
			//	double Ystart=VY-DY/2, Yend=VY+DY/2, Xstart=VX-DX/2, Xend=VX+DX/2;
			//	for(double x=floor(Xstart/Xstep)*Xstep, xEnd=ceil(Xend/Xstep)*Xstep;x<xEnd;x+=Xstep)
			//	{
			//		double _X=(x-Xstart)/DX*w;
			//		int X=int(_X)-(_X<0);
			//		MoveToEx(ghMemDC, X, 0, 0), LineTo(ghMemDC, X, h);
			//	}
			//	for(double y=ceil(Yend/Ystep)*Ystep, yEnd=floor(Ystart/Ystep)*Ystep-Ystep;y>yEnd;y-=Ystep)
			//	{
			//		double _Y=(Yend-y)/DY*h;
			//		int Y=int(_Y)-(_Y<0);
			//		MoveToEx(ghMemDC, 0, Y, 0), LineTo(ghMemDC, w, Y);
			//	}
			//}
			pen.drop();
		//	hPen=(HPEN__*)SelectObject(ghMemDC, hPen);
			if(toSolve)
			{
				if(_dangerous_code&&//
					shiftOnly==1&&abs(Xoffset)<xs.Xplaces&&abs(Yoffset)<ys.Xplaces)
				{
					if(Xoffset||Yoffset)
					{
						solver.partial_bounds(VX, DX, VY, DY, Xoffset, Yoffset);
						solver.synchronize();
						for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)
						{
							auto &ex=expr[ke];
							if(ex.rmode[0]==7)
								(solver.*(ex.nITD?&Solve_L2D::full:solver.partial))(ex);
						}
					}
				}
				else
				{
					auto old_time_variance=time_variance;
					time_variance=false;
					labels.clear();
					xs.Xplaces=setXplaces(w), ys.Xplaces=setXplaces(h), xs.set_Xplaces(w), ys.set_Xplaces(h);
					function1();
					solver.full_resize(xs.Xplaces, ys.Xplaces);
					if(!paused)
						solver.synchronize();
					for(unsigned e=0;e<expr.size();++e)
					{
						auto &ex=expr[e];
						if(ex.rmode[0]==7)
						{
							time_variance|=ex.nITD;
							labels.fill(e);
							solver.full(ex);
						}
					}
					if(time_variance)
					{
						if(!paused)
							SetTimer(ghWnd, 0, 10, 0);
					}
					else if(old_time_variance&&!timer)
						KillTimer(ghWnd, 0);
				}
				toSolve=false, shiftOnly=2, Xoffset=Yoffset=0;
				exprRemoved=false;
			}
			else if(exprRemoved)
			{
				auto old_time_variance=time_variance;
				time_variance=false;
				labels.clear();
				for(unsigned e=0;e<expr.size();++e)
				{
					auto &ex=expr[e];
					if(ex.rmode[0]==7)
					{
						time_variance|=ex.nITD;
						labels.fill(e);
					}
				}
				if(old_time_variance&&!time_variance&&!timer)
					KillTimer(ghWnd, 0);
				exprRemoved=false;
			}
			else if(time_variance)
			{
				if(!paused)
					solver.synchronize();
				for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)
				{
					auto &ex=expr[ke];
					if(ex.rmode[0]==7&&ex.nITD)
						solver.full(ex);
				}
			}
			int colorCondition=nExpr[7]>1;
			if(!clearScreen)//number and label axes
			{
			//	double LOL_1=h*(VY+DY/2)/DY;//242.99999999999997
			//	double LOL_2=h*(VY/DY+.5);//243.00000000000000
				int bkMode=getBkMode();
			//	int bkMode=GetBkMode(ghMemDC);
				int H=0, V=0, VT=0;
				_2dMode_NumberAxes(H, V, VT, xs, ys);
				line(0, H, w, H), line(V, 0, V, h);
			//	MoveToEx(ghMemDC, 0, H, 0), LineTo(ghMemDC, w, H), MoveToEx(ghMemDC, V, 0, 0), LineTo(ghMemDC, V, h);
				{
					int textColor;
					if(colorCondition)
						textColor=getTextColor();
					//	textColor=GetTextColor(ghMemDC);
					int Ys=H+(H>h-46?-34:18);
					for(int kl=0, klEnd=labels.Xlabels.size();kl<klEnd;++kl)
					{
						auto &label=labels.Xlabels[kl];
						if(colorCondition)
							setTextColor(expr[label.exNo].winColor);
						//	SetTextColor(ghMemDC, expr[label.exNo].winColor);
						print(w-arrow_label_offset_X, Ys, label.label.c_str(), label.label.size()), Ys+=16;
					//	TextOutA(ghMemDC, w-arrow_label_offset_X, Ys, label.label.c_str(), label.label.size()), Ys+=16;
					}
					int Xs=	VT+24+8*ys.prec>w-24-ys.prec*8
						?	VT-24-8*ys.prec
						:	VT+24+8*ys.prec;
					//int Xs=	V+VT+24+8*ys.prec>w-24-ys.prec*8
					//	?	V+VT-24-8*ys.prec
					//	:	V+VT+24+8*ys.prec;
					Ys=0;
					for(int kl=0, klEnd=labels.Ylabels.size();kl<klEnd;++kl)
					{
						auto &label=labels.Ylabels[kl];
						if(colorCondition)
							setTextColor(expr[label.exNo].winColor);
						//	SetTextColor(ghMemDC, expr[label.exNo].winColor);
						print(Xs, Ys, label.label.c_str(), label.label.size()), Ys+=16;
					//	TextOutA(ghMemDC, Xs, Ys, label.label.c_str(), label.label.size()), Ys+=16;
					}
					Ys=0;
					for(int kl=0, klEnd=labels.Clabels.size();kl<klEnd;++kl)
					{
						auto &label=labels.Clabels[kl];
						int linelen=sprintf_s(g_buf, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
						if(colorCondition)
							setTextColor(expr[label.exNo].winColor);
						//	SetTextColor(ghMemDC, expr[label.exNo].winColor);
						print(w-const_label_offset_X, Ys, g_buf, linelen), Ys+=16;
					//	TextOutA(ghMemDC, w-const_label_offset_X, Ys, g_buf, linelen), Ys+=16;
					}
					if(colorCondition)
						setTextColor(textColor);
					//	SetTextColor(ghMemDC, textColor);
				}
				setBkMode(bkMode);
			//	SetBkMode(ghMemDC, bkMode);
			}
			//double XXstart=solver.XXstart, YYend=VY+DY/2;
			//double Xr=w/DX, Yr=h/DY;
			Pen gPen;
		//	HPEN hGPen=0;
			int colored=0;
			unsigned yDiscOffset=(xs.Xplaces-1)*solver.nX;
			for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)//draw the curves/lines
			{
				auto &ex=expr[ke];
				if(ex.rmode[0]==7)
				{
					if(colorCondition)
						gPen.set(ex.winColor), gPen.use(), colored=1;
					//	hGPen=(HPEN)SelectObject(ghMemDC, CreatePen(PS_SOLID, 1, ex.winColor)), colored=1;
					auto &n=ex.n[ex.resultTerm];
					auto ndr_r=(double*)n.r.p, ndr_i=(double*)n.i.p;
					if(usingOpenGL)
						GL2_2D::curve_begin();
					for(int y=0;y<solver.nX;++y)//horizontal projected lines
					{
						_2d.curve_start();
						for(int x=0;x<xs.Xplaces-1;++x)
						{
							int idx=xs.Xplaces*y+x;
							CompRef V(ndr_r[idx], ndr_i[idx]);
							_2d.curve_point(xs.fn_x(V.r), ys.fn_y(V.i));
							if(ex.discontinuities[(xs.Xplaces-1)*y+x])
								_2d.curve_start();
						}
						int idx=xs.Xplaces*y+xs.Xplaces-1;
						CompRef V(ndr_r[idx], ndr_i[idx]);
						_2d.curve_point(xs.fn_x(V.r), ys.fn_y(V.i));
					}
					int yPos=xs.Xplaces*solver.nX;
					for(int x=0;x<solver.nY;++x)//vertical projected lines
					{
						_2d.curve_start();
						for(int y=0;y<ys.Xplaces-1;++y)
						{
							//if(x==19&y==979)//CRASH
							//	int LOL_2=0;
							int idx=yPos+ys.Xplaces*x+y;
							CompRef V(ndr_r[idx], ndr_i[idx]);
							_2d.curve_point(xs.fn_x(V.r), ys.fn_y(V.i));
							if(ex.discontinuities[yDiscOffset+(ys.Xplaces-1)*x+y])
								_2d.curve_start();
						}
						int idx=yPos+ys.Xplaces*x+ys.Xplaces-1;
						CompRef V(ndr_r[idx], ndr_i[idx]);
						_2d.curve_point(xs.fn_x(V.r), ys.fn_y(V.i));
						_2d.set_point();
					}
					//for(int y=0;y<solver.nX;++y)//horizontal projected lines
					//{
					//	_2d.curve_start();
					//	for(int x=0;x<Xplaces-1;++x)
					//	{
					//		int idx=Xplaces*y+x;
					//		CompRef V(ndr_r[idx], ndr_i[idx]);
					//		auto LOL=Yr*(YYend-V.i);//
					//		_2d.curve_point(Xr*(V.r-XXstart), Yr*(YYend-V.i));
					//		if(ex.discontinuities[(Xplaces-1)*y+x])
					//			_2d.curve_start();
					//	}
					//	int idx=Xplaces*y+Xplaces-1;
					//	CompRef V(ndr_r[idx], ndr_i[idx]);
					//	_2d.curve_point(Xr*(V.r-XXstart), Yr*(YYend-V.i));
					//}
					//int yPos=Xplaces*solver.nX;
					//for(int x=0;x<solver.nY;++x)//vertical projected lines
					//{
					//	_2d.curve_start();
					//	for(int y=0;y<Yplaces-1;++y)
					//	{
					//		int idx=yPos+Yplaces*x+y;
					//		CompRef V(ndr_r[idx], ndr_i[idx]);
					//		_2d.curve_point(Xr*(V.r-XXstart), Yr*(YYend-V.i));
					//		if(ex.discontinuities[yDiscOffset+(Yplaces-1)*x+y])
					//			_2d.curve_start();
					//	}
					//	int idx=yPos+Yplaces*x+Yplaces-1;
					//	CompRef V(ndr_r[idx], ndr_i[idx]);
					//	_2d.curve_point(Xr*(V.r-XXstart), Yr*(YYend-V.i));
					//	_2d.set_point();
					//}
					if(usingOpenGL)
						GL2_2D::draw_curve();

					if(colored)
						gPen.drop(), gPen.destroy(), colored=0;
					//	DeleteObject(SelectObject(ghMemDC, hGPen)), colored=0;
				}
			}
			if(!clearScreen)
				GUIPrint(0, h-48, _dangerous_code?"partial shift, F9 for full shift":"full shift, F9 for partial shift");
		//	GUIPrint(ghMemDC, 0, h-48, _dangerous_code?"F9 for full shift":"F9 for partial shift");
		//	GUIPrint(ghMemDC, 0, h-48, _dangerous_code?"F9: toggle full solve on shifting":"F9: toggle partial solve on shifting");
		//	GUIPrint(ghMemDC, 0, h-48, _dangerous_code?"F9: to solve whole buffer":"F9: to shift buffer");
		}
		void i_draw();
		void a_draw();
	} l2d;
	const int		Longitudinal_2D::modes[]={7}, Longitudinal_2D::nmodes=sizeof(modes)>>2;
	void			Longitudinal_2D::i_draw()
	{
		if(modes::ready)
		{
			draw();
			if(showLastModeOnIdle)
				capture_window(modeRGB);
			//	std::copy(rgb, rgb+w*h, modeRGB);

			selectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			{
				int bkMode=setBkMode(OPAQUE);
			//	int bkMode=GetBkMode(ghMemDC);
			//	SetBkMode(ghMemDC, OPAQUE);
				if(nExpr[7]>1)
					itb.draw_color(modes, nmodes);
				else
					itb.draw();
				setBkMode(bkMode);
			//	SetBkMode(ghMemDC, bkMode);
			}
			deselectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	
			if(showBenchmark)
				Performance(0, h-32);//
#ifndef BUILD_1_7
			BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
#endif
		}
		else
		{
			display_texture_fullwindow(modeRGB);
		//	std::copy(modeRGB, modeRGB+w*h, rgb);
			if(showBenchmark)
				Performance(0, h-32);//
		}
	}
	void			Longitudinal_2D::a_draw()
	{
		newframe();
	//	rectangle(bpx-1, bpy-1, bw+1, bh+1);
	//	Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);
		
		draw();
		
		if(contextHelp)
		{
			const char *help[]=
			{
				"arrows/drag: move",
				"+/-/enter/backspace/wheel: zoom",
				"X/Y +/-/enter/backspace/wheel: scale x/y",
				"E: reset scale",
				"R: reset scale & view",
				"C: toggle clear screen",
				"Tab/Shift Tab: switch renderer",
				"Esc: back to text editor"
			};
			print_contextHelp(help, sizeof(help)>>2, 270);
		}
		if(showBenchmark&&!clearScreen)
			Performance(0, h-32);//
		show();
	//	BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
	}
	class		Transverse_2D_H:public _3D_Mode
	{
	public:
		int Xoffset, Yoffset;
		int X0, Y0;

		int Xplaces, Yplaces;
		double XshiftPoint, YshiftPoint;
		double XsamplePos, YsamplePos;

		double Xstart, Xr, Ystart, Yr;
		Solve_2D solver;
		std::list<int> operations;
		
		bool contourOn, contourOnly, contourFlat;
		std::map<unsigned, std::unordered_map<int, std::list<std::pair<contour::Double_X_Y, contour::Double_X_Y>>>>
			Rcontours,//contours[e]=contour, contour[r level (r/step)]=sticks, *stick.begin()=((x,y),(x,y))
			Icontours,//contours[e]=contour, contour[i level (i/step)]=sticks, *stick.begin()=((x,y),(x,y))
			Jcontours,//contours[e]=contour, contour[j level (j/step)]=sticks, *stick.begin()=((x,y),(x,y))
			Kcontours;//contours[e]=contour, contour[k level (k/step)]=sticks, *stick.begin()=((x,y),(x,y))
		
		bool clearScreen, kb_VK_F6_msg;
		Labels_2D labels;
		_3D _3d;
		static const int modes[], nmodes;
		int gridColor, rColor, iColor, jColor, kColor;

		Transverse_2D_H():
			solver(true, xs, ys), _3D_Mode(solver),
			Xplaces(100), Yplaces(100),
			XshiftPoint(0), YshiftPoint(0),
			XsamplePos(0), YsamplePos(0),
			_3d(4, 4, 4, 225*G2::_pi/180, 324.7356103172454*G2::_pi/180, 1),
			gridColor(_3dGridColor), rColor(0), iColor(0x000000EF), jColor(0x0000EF00), kColor(0x00EF0000),//rgb
			Xoffset(0), Yoffset(0),
			contourOnly(false),
			clearScreen(false), kb_VK_F6_msg(false)
		{}

		void doContour(unsigned e)
		{
			contour::contour_2d_grid(e, 0, Rcontours[e], Xplaces, Yplaces, xs, ys, zs, AR_Y);
			contour::contour_2d_grid(e, 1, Icontours[e], Xplaces, Yplaces, xs, ys, zs, AR_Y);
			contour::contour_2d_grid(e, 2, Jcontours[e], Xplaces, Yplaces, xs, ys, zs, AR_Y);
			contour::contour_2d_grid(e, 3, Kcontours[e], Xplaces, Yplaces, xs, ys, zs, AR_Y);
		}

		void setDimensions(int x, int y, int w, int h)
		{
			bpx=x, bpy=y, bw=w, bh=h, X0=bpx+bw/2, Y0=bpy+bh/2;
			_3d.setDimensions(x, y, w, h);
			bool XstepChanged, YstepChanged, ZstepChanged;
			function1(XstepChanged, YstepChanged, ZstepChanged);
			if(!toSolve&&contourOn&&ZstepChanged)
			{
				Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
				doContour(cursorEx);
			}
			ready=true;
		}
		void shiftNDR(double &DshiftPoint, double Dsample, double &DsamplePos, double &VD, int &Doffset, double ammount)
		{
			double newDsamplePos=std::floor((DshiftPoint+=ammount)/Dsample);
			if(newDsamplePos!=DsamplePos)
			{
				toSolve=true;
				if(shiftOnly)
					shiftOnly=1, Doffset+=int(newDsamplePos-DsamplePos);
				DsamplePos=newDsamplePos, VD=newDsamplePos*Dsample;
			}
			DsamplePos=newDsamplePos;
		}
		void shiftNDRupdate(double DshiftPoint, double Dsample, double &DsamplePos, double &VD)
		{
			double newDsamplePos=std::floor(DshiftPoint/Dsample);
			if(newDsamplePos!=DsamplePos)
				DsamplePos=newDsamplePos, VD=newDsamplePos*Dsample;
		}
		void messageTimer()
		{
				 if(kb[VK_SHIFT	]){	 if(kb['W'])	_3d.cam.moveFastForward();
									 if(kb['A'])	_3d.cam.moveFastLeft();
									 if(kb['S'])	_3d.cam.moveFastBack();
									 if(kb['D'])	_3d.cam.moveFastRight();
									 if(kb['T'])	_3d.cam.p.z+=10*_3d.cam.dcam;
									 if(kb['G'])	_3d.cam.p.z-=10*_3d.cam.dcam;}
			else				  {	 if(kb['W'])	_3d.cam.moveForward();
									 if(kb['A'])	_3d.cam.moveLeft();
									 if(kb['S'])	_3d.cam.moveBack();
									 if(kb['D'])	_3d.cam.moveRight();
									 if(kb['T'])	_3d.cam.p.z+=_3d.cam.dcam;
									 if(kb['G'])	_3d.cam.p.z-=_3d.cam.dcam;}
			auto &VX=xs.VX, &DX=xs.DX, &VY=ys.VX, &DY=ys.DX, &VZ=zs.VX, &DZ=zs.DX;
			double dVD=DX*0.01;
			if(kb['X'])
			{
				if(kb['Y'])
				{
					if(kb['Z'])
					{
					}
					else		//xy
					{
						if(kb[VK_UP])	shiftNDR(YshiftPoint, ys.Xsample*AR_Y,	YsamplePos, VY, Yoffset,  dVD), _3d.cam.p.y+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])	shiftNDR(YshiftPoint, ys.Xsample*AR_Y,	YsamplePos, VY, Yoffset, -dVD), _3d.cam.p.y-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT])shiftNDR(XshiftPoint, xs.Xsample,		XsamplePos, VX, Xoffset,  dVD), _3d.cam.p.x+=_3d_shift_move_cam*dVD;
						if(kb[VK_LEFT])	shiftNDR(XshiftPoint, xs.Xsample,		XsamplePos, VX, Xoffset, -dVD), _3d.cam.p.x-=_3d_shift_move_cam*dVD;
					}
				}
				else
				{
					if(kb['Z'])	//xz
					{
						if(kb[VK_UP])	VZ+=DX/100, _3d.cam.p.z+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])	VZ-=DX/100, _3d.cam.p.z-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT])shiftNDR(XshiftPoint, xs.Xsample, XsamplePos, VX, Xoffset,  dVD), _3d.cam.p.x+=_3d_shift_move_cam*dVD;
						if(kb[VK_LEFT])	shiftNDR(XshiftPoint, xs.Xsample, XsamplePos, VX, Xoffset, -dVD), _3d.cam.p.x-=_3d_shift_move_cam*dVD;
					}
					else		//x
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(XshiftPoint, xs.Xsample, XsamplePos, VX, Xoffset,  dVD), _3d.cam.p.x+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(XshiftPoint, xs.Xsample, XsamplePos, VX, Xoffset, -dVD), _3d.cam.p.x-=_3d_shift_move_cam*dVD;
					}
				}
			}
			else
			{
				if(kb['Y'])
				{
					if(kb['Z'])	//yz
					{
						if(kb[VK_UP])	VZ+=DX/100, _3d.cam.p.z+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])	VZ-=DX/100, _3d.cam.p.z-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT])shiftNDR(YshiftPoint, ys.Xsample*AR_Y, YsamplePos, VY, Yoffset,  dVD), _3d.cam.p.y+=_3d_shift_move_cam*dVD;
						if(kb[VK_LEFT])	shiftNDR(YshiftPoint, ys.Xsample*AR_Y, YsamplePos, VY, Yoffset, -dVD), _3d.cam.p.y-=_3d_shift_move_cam*dVD;
					}
					else		//y
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(YshiftPoint, ys.Xsample*AR_Y, YsamplePos, VY, Yoffset,  dVD), _3d.cam.p.y+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(YshiftPoint, ys.Xsample*AR_Y, YsamplePos, VY, Yoffset, -dVD), _3d.cam.p.y-=_3d_shift_move_cam*dVD;
					}
				}
				else
				{
					if(kb['Z'])	//z
					{
						if(kb[VK_UP]||kb[VK_RIGHT]){	VZ+=DX/100, _3d.cam.p.x+=_3d_shift_move_cam*dVD;	if(contourOn)toSolve=true, shiftOnly=0;}//just to update contour
						if(kb[VK_DOWN]||kb[VK_LEFT]){	VZ-=DX/100, _3d.cam.p.x-=_3d_shift_move_cam*dVD;	if(contourOn)toSolve=true, shiftOnly=0;}
					}
					else
					{
						if(kb[VK_UP])	_3d.cam.turnUp();
						if(kb[VK_DOWN])	_3d.cam.turnDown();
						if(kb[VK_RIGHT])_3d.cam.turnRight();
						if(kb[VK_LEFT])	_3d.cam.turnLeft();
					}
				}
			}
			if(kb[VK_ADD]||kb[VK_RETURN]||kb[VK_OEM_PLUS])
			{
				if(kb[VK_MENU])//alt+
				{
					if(_3d_zoom_move_cam)//zoom in
						DX/=1.1, _3d.cam.p.x=VX+(_3d.cam.p.x-VX)/1.1, _3d.cam.p.y=VY+(_3d.cam.p.y-VY)/1.1, _3d.cam.p.z=VZ+(_3d.cam.p.z-VZ)/1.1, _3d.cam.dcam/=1.1;
					else//zoom out
						DX*=1.1;
					function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					toSolve=true, shiftOnly=0;
				}
				else if(kb['X'])//x+ stretch (zoom out (compress), stretch y, z)
				{
					if(_3d_stretch_move_cam)
					{
						double VX0=VX, VY0=VY;
						DX/=1.1;//zoom out
						function1();
						shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
						shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						_3d.cam.p.x=VX+(_3d.cam.p.x-VX0)/1.1, _3d.cam.p.y=VY+(_3d.cam.p.y-VY0)/1.1, _3d.cam.p.z=VZ+(_3d.cam.p.z-VZ)/1.1, _3d.cam.dcam/=1.1;

						VY0=VY;//stretch y
						YshiftPoint/=1.1;
						AR_Y/=1.1, function1();
						shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						_3d.cam.p.y+=VY-VY0;

						_3d.cam.p.z-=VZ/11., VZ/=1.1;//stretch z
						AR_Z/=1.1, function1();
					}
					else
					{
						DX/=1.1, AR_Y/=1.1, AR_Z/=1.1, function1();
						_3d.cam.p.x/=1.1, _3d.cam.p.y/=1.1, _3d.cam.p.z/=1.1, _3d.cam.dcam/=1.1;
						shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					}
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Y'])//y+ stretch
				{
					double VY0=VY;
					YshiftPoint*=1.1;//move cube
					AR_Y*=1.1, function1();
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					if(_3d_stretch_move_cam)
						_3d.cam.p.y+=VY-VY0;
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Z'])
				{
					if(_3d_stretch_move_cam)
						_3d.cam.p.z+=VZ*0.1;
					VZ*=1.1;//move cube
					AR_Z*=1.1, function1();
					if(contourOn)
						toSolve=true, shiftOnly=0;
				}
				else if(!kb[VK_CONTROL])
					_3d.cam.zoomIn();
			}
			if(kb[VK_SUBTRACT]||kb[VK_BACK]||kb[VK_OEM_MINUS])
			{
				if(kb[VK_MENU])//alt-
				{
					if(_3d_zoom_move_cam)//zoom out
						DX*=1.1, _3d.cam.p.x=VX+(_3d.cam.p.x-VX)*1.1, _3d.cam.p.y=VY+(_3d.cam.p.y-VY)*1.1, _3d.cam.p.z=VZ+(_3d.cam.p.z-VZ)*1.1, _3d.cam.dcam*=1.1;
					else//zoom in
						DX/=1.1;
					function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					toSolve=true, shiftOnly=0;
				}
				else if(kb['X'])
				{
					if(_3d_stretch_move_cam)
					{
						double VX0=VX, VY0=VY;
						DX*=1.1;//zoom in
						function1();
						shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
						shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						_3d.cam.p.x=VX+(_3d.cam.p.x-VX0)*1.1, _3d.cam.p.y=VY+(_3d.cam.p.y-VY0)*1.1, _3d.cam.p.z=VZ+(_3d.cam.p.z-VZ)*1.1, _3d.cam.dcam*=1.1;
					
						VY0=VY;//compress y
						YshiftPoint*=1.1;
						AR_Y*=1.1, function1();
						shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						_3d.cam.p.y+=VY-VY0;
					
						_3d.cam.p.z+=VZ*0.1, VZ*=1.1;//compress z
						AR_Z*=1.1, function1();
					}
					else
					{
						DX*=1.1, AR_Y*=1.1, AR_Z*=1.1, function1();
						_3d.cam.p.x*=1.1, _3d.cam.p.y*=1.1, _3d.cam.p.z*=1.1, _3d.cam.dcam*=1.1;
						shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					}
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Y'])
				{
					double VY0=VY;
					YshiftPoint/=1.1;//move cube
					AR_Y/=1.1, function1();
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					if(_3d_stretch_move_cam)
						_3d.cam.p.y+=VY-VY0;
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Z'])
				{
					if(_3d_stretch_move_cam)
						_3d.cam.p.z-=VZ/11.;
					VZ/=1.1;//move cube
					AR_Z/=1.1, function1();
					if(contourOn)
						toSolve=true, shiftOnly=0;
				}
				else if(!kb[VK_CONTROL])
					_3d.cam.zoomOut();
			}
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
		}
		int inputLButtonDown(int lParam)
		{
			if(!drag)
			{
				if(!shift)
				{
					ShowCursor(0);
					GetCursorPos(&mouseP0);
					SetCursorPos(centerP.x, centerP.y);
					SetCapture(ghWnd);
				}
				drag=1;
			}
			return 0;
		}
		int inputMouseMove(int lParam)
		{
			if(!m_bypass)
			{
				auto &VX=xs.VX, &DX=xs.DX, &VY=ys.VX, &DY=ys.DX, &VZ=zs.VX, &DZ=zs.DX;
				int dmx=((short*)&lParam)[0]-w/2, dmy=h/2-((short*)&lParam)[1];
				int draw=0;
				if(kb['X'])
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//xyz	mx my mw
						{
							double VX0=VX, VY0=VY;
							shiftNDR(XshiftPoint, xs.Xsample,		XsamplePos, VX, Xoffset, dmx*DX/w), _3d.cam.p.x+=(VX-VX0)*_3d_shift_move_cam;
							shiftNDR(YshiftPoint, ys.Xsample*AR_Y,	YsamplePos, VY, Yoffset, dmy*DX/w), _3d.cam.p.y+=(VY-VY0)*_3d_shift_move_cam;
						}
						else		//xy	mx my
						{
							double VX0=VX, VY0=VY;
							shiftNDR(XshiftPoint, xs.Xsample,		XsamplePos, VX, Xoffset, dmx*DX/w), _3d.cam.p.x+=(VX-VX0)*_3d_shift_move_cam;
							shiftNDR(YshiftPoint, ys.Xsample*AR_Y,	YsamplePos, VY, Yoffset, dmy*DX/w), _3d.cam.p.y+=(VY-VY0)*_3d_shift_move_cam;
						}
						draw=1;
					}
					else
					{
						if(kb['Z'])	//xz	mx my
						{
							double VX0=VX;
							shiftNDR(XshiftPoint, xs.Xsample, XsamplePos, VX, Xoffset, dmx*DX/w), _3d.cam.p.x+=(VX-VX0)*_3d_shift_move_cam;
							double dVZ=dmy*DX/w;
							VZ+=dVZ, _3d.cam.p.x+=dVZ*_3d_shift_move_cam;
						}
						else		//x		mx
						{
							double VX0=VX;
							shiftNDR(XshiftPoint, xs.Xsample, XsamplePos, VX, Xoffset, dmx*DX/w), _3d.cam.p.x+=(VX-VX0)*_3d_shift_move_cam;
						}
						draw=1;
					}
				}
				else
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//yz	mx my
						{
							double VY0=VY;
							shiftNDR(YshiftPoint, ys.Xsample*AR_Y, YsamplePos, VY, Yoffset, dmx*DX/w), _3d.cam.p.y+=(VY-VY0)*_3d_shift_move_cam;
							double dVZ=dmy*DX/w;
							VZ+=dVZ, _3d.cam.p.x+=dVZ*_3d_shift_move_cam;
						}
						else		//y		mx
						{
							double VY0=VY;
							shiftNDR(YshiftPoint, ys.Xsample*AR_Y, YsamplePos, VY, Yoffset, dmx*DX/w), _3d.cam.p.y+=(VY-VY0)*_3d_shift_move_cam;
						}
						draw=1;
					}
					else
					{
						if(kb['Z'])	//z		my
						{
							double dVZ=dmy*DX/w;
							VZ+=dVZ, _3d.cam.p.z+=dVZ*_3d_shift_move_cam;
							if(contourOn)
								toSolve=true, shiftOnly=0;//just to update contour
							draw=1;
						}
						else if(drag)
						{
							_3d.cam.turnMouse(lParam);
							draw=1;
						}
					}
				}
				if(draw)
				{
					SetCursorPos(centerP.x, centerP.y);
					if(!time_variance&&!timer)
						a_draw();
				}
			}
			m_bypass=!m_bypass;
			return 0;
		}
		void inputLButtonUp(int lParam)
		{
			if(drag)
			{
				if(!shift)
				{
					ReleaseCapture();
					SetCursorPos(mouseP0.x, mouseP0.y);
					ShowCursor(1);
				}
				drag=0;
			}
		}
		int inputMouseWheel(int wParam)
		{
			auto &VX=xs.VX, &DX=xs.DX, &VY=ys.VX, &DY=ys.DX, &VZ=zs.VX, &DZ=zs.DX;
			bool mw_forward=((short*)&wParam)[1]>0;
			if(kb['X']&&kb['Y']&&kb['Z'])
			{
				double dVD=DX/100;
					 if(mw_forward)	VZ+=dVD, _3d.cam.p.z+=dVD*_3d_shift_move_cam;
				else				VZ-=dVD, _3d.cam.p.z-=dVD*_3d_shift_move_cam;
			}
			else if(kb[VK_MENU])
			{
				double VX0=VX, VY0=VY;
					 if(mw_forward)	DX*=1.1;
				else				DX/=1.1;
				function1();
				shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);//
				shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);//
				if(_3d_zoom_move_cam)
				{
						 if(mw_forward)	_3d.cam.p.x=VX+(_3d.cam.p.x-VX0)*1.1, _3d.cam.p.y=VY+(_3d.cam.p.y-VY0)*1.1, _3d.cam.p.z=VZ+(_3d.cam.p.z-VZ)*1.1, _3d.cam.dcam*=1.1;
					else				_3d.cam.p.x=VX+(_3d.cam.p.x-VX0)/1.1, _3d.cam.p.y=VY+(_3d.cam.p.y-VY0)/1.1, _3d.cam.p.z=VZ+(_3d.cam.p.z-VZ)/1.1, _3d.cam.dcam/=1.1;
				}
				toSolve=true, shiftOnly=0;
			}
			else if(kb['X'])//x wheel
			{
				if(_3d_stretch_move_cam)
				{
					double VX0=VX, VY0=VY;
						 if(mw_forward)	DX/=1.1;//zoom out
					else				DX*=1.1;
					function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						 if(mw_forward)	_3d.cam.p.x=VX+(_3d.cam.p.x-VX0)/1.1, _3d.cam.p.y=VY+(_3d.cam.p.y-VY0)/1.1, _3d.cam.p.z=VZ+(_3d.cam.p.z-VZ)/1.1, _3d.cam.dcam/=1.1;
					else				_3d.cam.p.x=VX+(_3d.cam.p.x-VX0)*1.1, _3d.cam.p.y=VY+(_3d.cam.p.y-VY0)*1.1, _3d.cam.p.z=VZ+(_3d.cam.p.z-VZ)*1.1, _3d.cam.dcam*=1.1;

					VY0=VY;//stretch y
						 if(mw_forward)	AR_Y/=1.1,	YshiftPoint/=1.1;
					else				AR_Y*=1.1,	YshiftPoint*=1.1;
					function1();
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					_3d.cam.p.y+=VY-VY0;

						 if(mw_forward)	_3d.cam.p.z-=VZ/11., AR_Z/=1.1,	VZ/=1.1;//stretch z
					else				_3d.cam.p.z+=VZ*0.1, AR_Z*=1.1,	VZ*=1.1;
					function1();
				}
				else
				{
						 if(mw_forward)	DX/=1.1, AR_Y/=1.1, AR_Z/=1.1, _3d.cam.p.x/=1.1, _3d.cam.p.y/=1.1, _3d.cam.p.z/=1.1, _3d.cam.dcam/=1.1;
					else				DX*=1.1, AR_Y*=1.1, AR_Z*=1.1, _3d.cam.p.x*=1.1, _3d.cam.p.y*=1.1, _3d.cam.p.z*=1.1, _3d.cam.dcam*=1.1;
					function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
				}
				toSolve=true, shiftOnly=0;
			}
			else if(kb['Y'])//y wheel
			{
				double VY0=VY;
					 if(mw_forward)	AR_Y*=1.1,	YshiftPoint*=1.1;
				else				AR_Y/=1.1,	YshiftPoint/=1.1;
				function1();
				shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
				_3d.cam.p.y+=(VY-VY0)*_3d_stretch_move_cam;
				toSolve=true, shiftOnly=0;
			}
			else if(kb['Z'])//z wheel
			{
					 if(mw_forward)	AR_Z*=1.1, _3d.cam.p.z+=VZ*0.1*_3d_stretch_move_cam,	VZ*=1.1;
				else				AR_Z/=1.1, _3d.cam.p.z-=VZ/11.*_3d_stretch_move_cam,	VZ/=1.1;
				function1();
				if(contourOn)//
					toSolve=true, shiftOnly=0;
			}
			else if(kb[VK_CONTROL])//ctrl wheel
			{
					 if(mw_forward)	_3d.cam.faster();
				else				_3d.cam.slower();
			}
			else if(kb[VK_SHIFT])//shift wheel
			{
				if(mw_forward)
					Yplaces=Xplaces+=1<<max_simd_method, toSolve=true, shiftOnly=0;
				else if(Xplaces>1)
					Yplaces=Xplaces-=1<<max_simd_method, toSolve=true, shiftOnly=0;
			}
			else//wheel
			{
					 if(mw_forward)	_3d.cam.zoomIn();
				else				_3d.cam.zoomOut();
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyDown(int wParam, int lParam)
		{
			auto &VX=xs.VX, &DX=xs.DX, &VY=ys.VX, &DY=ys.DX, &VZ=zs.VX, &DZ=zs.DX;
			switch(wParam)
			{
			case 'W':case 'A':case 'S':case 'D':case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:case 'T':case 'G':
				if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case VK_ADD:case VK_OEM_PLUS:case VK_RETURN:
				if(kb[VK_CONTROL])
					_3d.cam.faster();
				else if(kb[VK_SHIFT])
				{
					Yplaces=Xplaces+=1<<max_simd_method, toSolve=true, shiftOnly=0;
					break;
				}
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case VK_SUBTRACT:case VK_OEM_MINUS:case VK_BACK:
				if(kb[VK_CONTROL])
					_3d.cam.slower();
				else if(kb[VK_SHIFT])
				{
					if(Xplaces>1<<max_simd_method)
						Yplaces=Xplaces-=1<<max_simd_method, toSolve=true, shiftOnly=0;
					break;
				}
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case 'X':case 'Y':case 'Z':
				if(!(lParam&1<<30)&&!shift)
				{
					if(!drag)
					{
						GetCursorPos(&mouseP0);
						ShowCursor(0);
						SetCursorPos(centerP.x, centerP.y);
						SetCapture(ghWnd);
					}
					shift=1;
				}
				return 0;
			case VK_OEM_3:
				if(contourOn)//was on
				{
					if(kb[VK_CONTROL])
					{
						//contour+surface
						//contour only
						//flat contour
						//flat+surface
						if(contourFlat)
						{
							if(contourOnly)
								contourOnly=false;//3: surface appears
							else
								contourFlat=false;//4: pops up
						}
						else
						{
							if(contourOnly)
								contourFlat=true;//2: gets flat
							else
								contourOnly=true;//1: surface disappears
						}
					}
					else
						contourOn=false, contourOnly=false, contourFlat=false;
				}
				else//was off
				{
					contourOn=true;
					if(!toSolve)
					{
						Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
					//	double Xs=DX/Xplaces, DZ=DX/AR_Z;
						doContour(cursorEx);
					}
				}
				break;
			case 'C':
				clearScreen=!clearScreen;
				break;
			case 'E'://reset axes scale
				{
					double r=20/DX;

					XshiftPoint*=r, YshiftPoint*=r, VZ*=r;
					_3d.cam.p.x*=r, _3d.cam.p.y*=r, _3d.cam.p.z*=r, _3d.cam.dcam*=r;
					xs.reset_scale(), ys.reset_scale(), zs.reset_scale(), AR_Y=1, AR_Z=1, function1();
				//	DX=20, AR_Y=1, AR_Z=1, function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					toSolve=true, shiftOnly=0;
				}
				break;
			case 'R'://reset position and zoom,		ctrl: position only
				_3d.cam.dcam=.04, _3d.cam.tanfov=1;
				if(!kb[VK_CONTROL])
					xs.reset_scale(), ys.reset_scale(), zs.reset_scale(), AR_Y=1, AR_Z=1, function1(), Xplaces=Yplaces=100;//Xplaces multiple of 4
				//	DX=20, AR_Y=1, AR_Z=1, function1(), Xplaces=Yplaces=100;

				XshiftPoint=YshiftPoint=0;
				shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
				shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
				xs.reset_position(), ys.reset_position(), zs.reset_position();
				toSolve=true, shiftOnly=0;
				if(kb['X'])
					_3d.teleport_degrees(20, 0, 0, 180, 0, 1);
				else if(kb['Y'])
					_3d.teleport_degrees(0, 20, 0, 270, 0, 1);
				else if(kb['Z'])
					_3d.teleport_degrees(0, 0, 20, 90, 270, 1);
				else
					_3d.teleport_degrees(4, 4, 4, 225, 324.7356103172454, 1);
				break;
			case VK_F6:
				if(!(lParam&1<<30))
				{
					kb_VK_F6_msg=true;
					if(!_3d_stretch_move_cam&!_3d_shift_move_cam&!_3d_zoom_move_cam)
						_3d_stretch_move_cam=true;
					else if(!_3d_shift_move_cam&!_3d_zoom_move_cam)
						_3d_shift_move_cam=true;
					else if(!_3d_zoom_move_cam)
						_3d_zoom_move_cam=true;
					else
						_3d_stretch_move_cam=_3d_shift_move_cam=_3d_zoom_move_cam=false;
				}
				break;
			default:
				if(lParam&1<<30)
					return 0;
				break;
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		void draw()
		{
			if(usingOpenGL)
				gl_enabledepthtest();
			auto &VX=xs.VX, &DX=xs.DX, &VY=ys.VX, &DY=ys.DX, &VZ=zs.VX, &DZ=zs.DX;
			DY=DX/AR_Y, DZ=DX/AR_Z;
			xs.set_Xplaces(Xplaces), ys.set_Xplaces(Yplaces);
			auto &ex=expr[cursorEx];
			{
				bool changed=false;
				if(toSolve)
				{
					if(shiftOnly==1&&abs(Xoffset)<Xplaces&&abs(Yoffset)<Yplaces)
					{
						if(Xoffset||Yoffset)
						{
							solver.partial_bounds(VX, DX, VY/AR_Y, DY, Xoffset, Yoffset);
							solver.synchronize();
							(solver.*(ex.nITD?&Solve_2D::full:solver.partial))(ex);
						}
					}
					else
					{
						auto old_time_variance=time_variance;
						time_variance=false;
						labels.clear();
					//	xs.set_Xplaces(Xplaces), ys.set_Xplaces(Yplaces);
						solver.full_resize(VX, DX, VY/AR_Y, DY, Xplaces, Yplaces);
						XsamplePos=std::floor(XshiftPoint/xs.Xsample);
						YsamplePos=std::floor(YshiftPoint/ys.Xsample);
						time_variance|=ex.nITD;
						labels.fill(cursorEx);
						if(!paused)
							solver.synchronize();
						solver.full(ex);
						if(time_variance)
						{
							if(!paused)
								SetTimer(ghWnd, 0, 10, 0);
						}
						else if(old_time_variance&&!timer)
							KillTimer(ghWnd, 0);
					}
					changed=true;
					toSolve=false, shiftOnly=2, Xoffset=Yoffset=0;
				}
				else if(time_variance)
				{
					if(!paused)
						solver.synchronize();
					solver.full(ex);
					changed=true;
				}
				if(changed&&contourOn)
				{
					Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
					doContour(cursorEx);
				}
			}

		//	_3dMode_FrameStart(_3d, xs, ys, zs, AR_Y, AR_Z);
			clear_depth_buffer();
			if(usingOpenGL)
				GL2_3D::begin();
			_3dMode_DrawGridNAxes(_3d, xs, ys, zs, AR_Y, AR_Z);
		//	double Xstart=solver.Xstart, Xsample=solver.Xsample, Ystart=AR_Y*solver.Ystart, Ysample=AR_Y*solver.Ysample;
			if(!contourOnly)//draw the surfaces
			{
				double Yend=VY+DY/2;
				auto &n=ex.n[ex.resultTerm];
				int lColor[4];
				if(usingOpenGL)
					lColor[0]=swap_rb(rColor), lColor[1]=swap_rb(iColor), lColor[2]=swap_rb(jColor), lColor[3]=swap_rb(kColor);
				else
					lColor[0]=rColor, lColor[1]=iColor, lColor[2]=jColor, lColor[3]=kColor;
			//	int lColor[]={rColor, iColor, jColor, kColor};
				if(operations.size())
				{
					for(unsigned c=0;c<4;++c)
					{
						auto ndr=(double*)(&n.r)[c].p;
						_3d.lineColor=lColor[c];
						for(int y=0;y<Yplaces;++y)
						{
							_3d.curve_start();
							for(int x=0;x<Xplaces;++x)
								_3d.curve_point(xs.fn(xs.ifn_x(x)), ys.fn(ys.ifn_x(y)), zs.fn(AR_Z*ndr[Xplaces*y+x]));
							//	_3d.curve_point(Xstart+x*Xsample, Ystart+y*Ysample, AR_Z*ndr[Xplaces*y+x]);
						}
						for(int x=0;x<Xplaces;++x)
						{
							_3d.curve_start();
							for(int y=0;y<Yplaces;++y)
								_3d.curve_point(xs.fn(xs.ifn_x(x)), ys.fn(ys.ifn_x(y)), zs.fn(AR_Z*ndr[Xplaces*y+x]));
							//	_3d.curve_point(Xstart+x*Xsample, Ystart+y*Ysample, AR_Z*ndr[Xplaces*y+x]);
						}
					}
				}
				else
				{
					unsigned yDiscOffset=(Xplaces-1)*Yplaces;
					for(unsigned c=0;c<4;++c)
					{
						auto ndr=(double*)(&n.r)[c].p;
						_3d.lineColor=lColor[c];
						for(int y=0;y<Yplaces;++y)
						{
							_3d.curve_start();
							for(int x=0;x<Xplaces-1;++x)
							{
								_3d.curve_point(xs.fn(xs.ifn_x(x)), ys.fn(ys.ifn_x(y)), zs.fn(AR_Z*ndr[Xplaces*y+x]));
							//	_3d.curve_point(Xstart+x*Xsample, Ystart+y*Ysample, AR_Z*ndr[Xplaces*y+x]);
								if(ex.discontinuities[(Xplaces-1)*y+x])
									_3d.curve_start();
							}
							_3d.curve_point(xs.fn(xs.ifn_x(Xplaces-1)), ys.fn(ys.ifn_x(y)), zs.fn(AR_Z*ndr[Xplaces*y+(Xplaces-1)]));
						//	_3d.curve_point(Xstart+(Xplaces-1)*Xsample, Ystart+y*Ysample, AR_Z*ndr[Xplaces*y+(Xplaces-1)]);
						}
						for(int x=0;x<Xplaces;++x)
						{
							_3d.curve_start();
							for(int y=0;y<Yplaces-1;++y)
							{
								_3d.curve_point(xs.fn(xs.ifn_x(x)), ys.fn(ys.ifn_x(y)), zs.fn(AR_Z*ndr[Xplaces*y+x]));
							//	_3d.curve_point(Xstart+x*Xsample, Ystart+y*Ysample, AR_Z*ndr[Xplaces*y+x]);
								if(ex.discontinuities[yDiscOffset+(Yplaces-1)*x+y])
									_3d.curve_start();
							}
							_3d.curve_point(xs.fn(xs.ifn_x(x)), ys.fn(ys.ifn_x(Yplaces-1)), zs.fn(AR_Z*ndr[Xplaces*(Yplaces-1)+x]));
						//	_3d.curve_point(Xstart+x*Xsample, Ystart+(Yplaces-1)*Ysample, AR_Z*ndr[Xplaces*(Yplaces-1)+x]);
						}
					}
				}
				_3d.lineColor=0;
			}
			if(contourOn)//draw the contour
			{
				double Xstart=VX-DX/2;
				double Ystart=VY-DY/2;
				double Zstart=VZ-DX/2, Zend=VZ+DX/2;

				for(int c=0;c<4;++c)
				{
					_3d.lineColor=(&rColor)[c];
					auto &contour=(&Rcontours)[c][cursorEx];
					for(auto cit=contour.begin();cit!=contour.end();++cit)
					{
						auto &L=*cit;
						double Z=contourFlat?VZ:zs.ticks2dist(L.first);
						for(auto pit=L.second.begin();pit!=L.second.end();++pit)
						{
							auto &p=*pit;
							_3d.line(dvec3(xs.ifn(p.first.x), ys.fn(p.first.y), zs.fn(AR_Z*Z)), dvec3(xs.ifn(p.second.x), ys.fn(p.second.y), zs.fn(AR_Z*Z)));
						}
					}
				}
			}
			if(usingOpenGL)
			{
				GL2_3D::end();
				GL2_3D::draw(_3d.cam);
			}
			if(!clearScreen)
			{
				int bkMode=getBkMode();
			//	int bkMode=GetBkMode(ghMemDC);
				_3dMode_NumberAxes(_3d, xs, ys, zs, AR_Y, AR_Z);
				_3d.arrowLabels(0, 0, 0, 1, 0, 0, labels.Xlabels);
				_3d.arrowLabels(0, 0, 0, 0, 1, 0, labels.Ylabels);
				char const *const OpLabels[]={"R()", "I()", "J()", "K()"};
				int const OpLabelColors[]={rColor, kColor, jColor, iColor};//bgr in windows API
				_3d.arrowLabelsColor(0, 0, 0, 0, 0, 1, OpLabels, OpLabelColors, sizeof(OpLabels)/sizeof(OpLabels[0]));
				{
					int Ys=0;
					for(int kl=0, klEnd=labels.Clabels.size();kl<klEnd;++kl)
					{
						auto &label=labels.Clabels[kl];
						int linelen=sprintf_s(g_buf, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
						print(w-const_label_offset_X, Ys, g_buf, linelen), Ys+=16;
					//	TextOutA(ghMemDC, w-const_label_offset_X, Ys, g_buf, linelen), Ys+=16;
					}
				}
				setBkMode(bkMode);
			//	SetBkMode(ghMemDC, bkMode);
				_3d.text_show();
			}
			if(kb_VK_F6_msg||kb[VK_F6])
			{
				int bkMode=setBkMode(OPAQUE);
			//	int kb_mode=SetBkMode(ghMemDC, OPAQUE);
				kb_VK_F6_msg=false;
				if(!_3d_stretch_move_cam&!_3d_shift_move_cam&!_3d_zoom_move_cam)
					GUIPrint(0, h-18*3, "move cam: [-] scale, [-] shift, [-] zoom");
				else if(!_3d_shift_move_cam&!_3d_zoom_move_cam)
					GUIPrint(0, h-18*3, "move cam: [v] scale, [-] shift, [-] zoom");
				else if(!_3d_zoom_move_cam)
					GUIPrint(0, h-18*3, "move cam: [v] scale, [v] shift, [-] zoom");
				else
					GUIPrint(0, h-18*3, "move cam: [v] scale, [v] shift, [v] zoom");
				setBkMode(bkMode);
			//	SetBkMode(ghMemDC, kb_mode);
			}
		}
		void i_draw();
		void a_draw();
	} t2d_h;
	const int		Transverse_2D_H::modes[]={8}, Transverse_2D_H::nmodes=sizeof(modes)>>2;
	void			Transverse_2D_H::i_draw()
	{
		if(modes::ready)
		{
			draw();
			if(showLastModeOnIdle)
				capture_window(modeRGB);
			//	std::copy(rgb, rgb+w*h, modeRGB);

			selectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			{
				int bkMode=setBkMode(OPAQUE);
			//	int bkMode=GetBkMode(ghMemDC);
			//	SetBkMode(ghMemDC, OPAQUE);
				itb.draw();
				setBkMode(bkMode);
			//	SetBkMode(ghMemDC, bkMode);
			}
			deselectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	
			Performance(0, h-32);//
#ifndef BUILD_1_7
			BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
#endif
		}
		else
		{
			display_texture_fullwindow(modeRGB);
		//	std::copy(modeRGB, modeRGB+w*h, rgb);
			if(showBenchmark)
				Performance(0, h-32);//
		}
	}
	void			Transverse_2D_H::a_draw()
	{
		newframe();
	//	rectangle(bpx-1, bpy-1, bw+1, bh+1);
	//	Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);

		draw();
		
		if(contextHelp)
		{
			const char *help[]=
			{
				"W/A/S/D/T/G: move",
				"arrows: turn",
				"+/-/enter/backspace/wheel: change FOV",
				"X/Y/Z arrows/mouse move: shift x/y/z",
				"X/Y/Z +/-/enter/backspace/wheel: scale x/y/z",
				"alt +/-/enter/backspace/wheel: zoom",
				"shift +/-/enter/backspace/wheel: change resolution",
				"E: reset scale",
				"R: reset scale & view",
				"C: toggle clear screen",
				"F6: change camera settings",
				"`: contour",
				"Tab/Shift Tab: switch renderer",
				"Esc: back to text editor"
			};
			print_contextHelp(help, sizeof(help)>>2, 330);
		}
		if(!clearScreen)
			Performance(0, h-32);//
		show();
	//	BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
		report_error();
	}
	struct Surface
	{
		std::vector<vec3> vertices;
		std::vector<int> indices;//3 for each triangle
		//std::vector<std::vector<int>> rev_db;//for each vertex which polygons it is in
		//void add(_3D::Triangle const &t)
		//{
		//	int a_idx=-1, b_idx=-1, c_idx=-1;
		//	for(int k=0, kEnd=vertices.size();k<kEnd;++k)
		//	{
		//		auto &v=vertices[k];
		//		if(t.a==v)
		//			a_idx=k;
		//		if(t.b==v)
		//			b_idx=k;
		//		if(t.c==v)
		//			c_idx=k;
		//	}
		//	if(a_idx==-1)
		//		vertices.push_back(t.a), rev_db.push_back(std::vector<int>()), a_idx=vertices.size()-1;
		//	if(b_idx==-1)
		//		vertices.push_back(t.b), rev_db.push_back(std::vector<int>()), b_idx=vertices.size()-1;
		//	if(c_idx==-1)
		//		vertices.push_back(t.c), rev_db.push_back(std::vector<int>()), c_idx=vertices.size()-1;
		//	int trNo=indices.size();//triangle index
		//	indices.push_back(a_idx), rev_db[a_idx].push_back(trNo);
		//	indices.push_back(b_idx), rev_db[b_idx].push_back(trNo);
		//	indices.push_back(c_idx), rev_db[c_idx].push_back(trNo);
		//}
	};
	struct VertexHelper
	{
		vec3 v;
		std::vector<int> trgls;
		VertexHelper(vec3 const &v):v(v){}
	};
	struct EdgeHelper
	{
		int a, b,//vertex idx
			t1, t2;//triangle idx
	//	std::vector<int> trgls;
		EdgeHelper(int a, int b):a(a), b(b), t1(-1), t2(-1){}
		void add(int trgl_idx)
		{
			if(t1==-1)
				t1=trgl_idx;
			else if(t2==-1)
				t2=trgl_idx;
		}
		int get_other(int trgl_idx)
		{
			if(t1==trgl_idx)
				return t2;
			if(t2==trgl_idx)
				return t1;
			return -1;
		}
	};
	inline bool operator==(EdgeHelper const &e1, EdgeHelper const &e2)
	{
		return e1.a==e2.a&&e1.b==e2.b||e1.a==e2.b&&e1.b==e2.a;
	}
	struct TriangleHelper
	{
		int a, b, c,//vertex idx, unique
			ab, bc, ca,//edge idx
			tab, tbc, tca;//neighbor triangle idx, -1: no neighbor
		vec3 n;//normal: ab x ac
		TriangleHelper(int a, int b, int c):a(a), b(b), c(c), tab(-1), tbc(-1), tca(-1){}
		TriangleHelper(int a, int b, int c, int ab, int bc, int ca, vec3 const &n):a(a), b(b), c(c), ab(ab), bc(bc), ca(ca), tab(-1), tbc(-1), tca(-1), n(n){}
		bool found(int idx){return a==idx||b==idx||c==idx;}
	};
	inline bool operator==(TriangleHelper const &t1, TriangleHelper const &t2)
	{
		return (t1.a==t2.a||t1.a==t2.b||t1.a==t2.c)
			&& (t1.b==t2.a||t1.b==t2.b||t1.b==t2.c)
			&& (t1.c==t2.a||t1.c==t2.b||t1.c==t2.c);
		//return t1.a==t2.a&&t1.b==t2.b&&t1.c==t2.c
		//	|| t1.a==t2.c&&t1.b==t2.a&&t1.c==t2.b
		//	|| t1.a==t2.b&&t1.b==t2.c&&t1.c==t2.a
		//	|| t1.a==t2.c&&t1.b==t2.b&&t1.c==t2.a
		//	|| t1.a==t2.a&&t1.b==t2.c&&t1.c==t2.b
		//	|| t1.a==t2.b&&t1.b==t2.a&&t1.c==t2.c;
	}
	struct SurfaceHelper
	{
		int level;
		float Rlevel;
		std::vector<VertexHelper> v;//unique vertices
		std::vector<EdgeHelper> e;//unique edges
		std::vector<TriangleHelper> t;//triangles
		void add(_3D::Triangle const &t)
		{
			int a_idx=-1, b_idx=-1, c_idx=-1;
			if(t.a==t.b||t.b==t.c||t.c==t.a)//reject illegal geometry
				return;
			for(int k=0, kEnd=v.size();k<kEnd;++k)//for each vertex: search for these vertices
			{
				auto &vk=v[k];
				if(t.a==vk.v)
					a_idx=k;
				if(t.b==vk.v)
					b_idx=k;
				if(t.c==vk.v)
					c_idx=k;
				if(a_idx!=-1&&b_idx!=-1&&c_idx!=-1)
					break;
			}
			if(a_idx==-1)
				a_idx=v.size(), v.push_back(VertexHelper(t.a));
			if(b_idx==-1)
				b_idx=v.size(), v.push_back(VertexHelper(t.b));
			if(c_idx==-1)
				c_idx=v.size(), v.push_back(VertexHelper(t.c));

			TriangleHelper th(a_idx, b_idx, c_idx);
			for(int k=0, kEnd=this->t.size();k<kEnd;++k)//for each triangle: search for this triangle
				if(th==this->t[k])//already here
					return;

			//if(th.found(44)||th.found(45))
			//	int LOL_1=0;
			int ab_idx=-1, bc_idx=-1, ca_idx=-1;
			EdgeHelper eab(a_idx, b_idx), ebc(b_idx, c_idx), eca(c_idx, a_idx);
			for(int k=0, kEnd=e.size();k<kEnd;++k)//for each edge: search for these edges
			{
				auto &ek=e[k];
				if(eab==ek)
					ab_idx=k;
				if(ebc==ek)
					bc_idx=k;
				if(eca==ek)
					ca_idx=k;
			}
			if(ab_idx==-1)
				ab_idx=e.size(), e.push_back(eab);
			if(bc_idx==-1)
				bc_idx=e.size(), e.push_back(ebc);
			if(ca_idx==-1)
				ca_idx=e.size(), e.push_back(eca);
			vec3 ab=v[b_idx].v-v[a_idx].v, ac=v[c_idx].v-v[a_idx].v, n=ab.cross(ac);
			th.ab=ab_idx, th.bc=bc_idx, th.ca=ca_idx, th.n=n/n.magnitude();

			int t_idx=this->t.size();//triangle index
			this->t.push_back(th);
			e[ab_idx].add(t_idx);
			e[bc_idx].add(t_idx);
			e[ca_idx].add(t_idx);
			v[a_idx].trgls.push_back(t_idx);
			v[b_idx].trgls.push_back(t_idx);
			v[c_idx].trgls.push_back(t_idx);
		}
		void correctNormal(vec3 const &tp, bool greater)
		{
			auto &tk=*t.rbegin();
			auto &n=tk.n;
			bool sameside=(tp-v[tk.a].v).dot(n)>0;
			if(sameside&&!greater)
				n=-n;
		}
		void build_neighbors()
		{
			for(int k=0, kEnd=t.size();k<kEnd;++k)
			{
				auto &tk=t[k];
				tk.tab=e[tk.ab].get_other(k);
				tk.tbc=e[tk.bc].get_other(k);
				tk.tca=e[tk.ca].get_other(k);
			}
		}
		operator Surface()
		{
			Surface s;
			s.vertices.resize(v.size()<<1);
			s.indices.resize(t.size()*3);
		//	std::vector<vec3> normals;
			for(int k=0, kEnd=v.size();k<kEnd;++k)//for each vertex
			{
				auto &vk=v[k];
				int k2=k<<1;
				s.vertices[k2]=vk.v;//vertex
				auto &n=s.vertices[k2+1];//normal
				n.set(0, 0, 0);

				int va0=-1, va=-1, vb=-1, vb2=-1;
				auto &tk=t[*vk.trgls.begin()];
				if(tk.a==k)
					va=tk.b, vb=tk.c;
				else if(tk.b==k)
					va=tk.a, vb=tk.c;
				else
					va=tk.a, vb=tk.b;
				va0=va;
				int it=0, nit=vk.trgls.size();
				do
				{
					vec3 n2=(v[va].v-vk.v).cross(v[vb].v-vk.v);
					n+=n2*(1.f/n2.magnitude());
					vb2=-1;
					for(int k3=0, k3End=vk.trgls.size();k3<k3End;++k3)
					{
						auto &tk2=t[vk.trgls[k3]];
						if((tk2.a==k||tk2.b==k||tk2.c==k)&&(tk2.a==vb||tk2.b==vb||tk2.c==vb)&&tk2.a!=va&&tk2.b!=va&&tk2.c!=va)
						{
							if(tk2.a==k)
							{
								if(tk2.b==vb)
									vb2=tk2.c;
								else//c==vb
									vb2=tk2.b;
							}
							else if(tk2.b==k)
							{
								if(tk2.a==vb)
									vb2=tk2.c;
								else//c==vb
									vb2=tk2.a;
							}
							else//c==k
							{
								if(tk2.a==vb)
									vb2=tk2.b;
								else//b==vb
									vb2=tk2.a;
							}
							break;
						}
					}
					va=vb, vb=vb2;
				//	++it;
				}
				while(vb2!=va0&&vb2!=-1&&it<nit);
				//for(int k3=0, k3End=vk.trgls.size();k3<k3End;++k3)
				//	n+=t[vk.trgls[k3]].n;
				n*=1.f/n.magnitude();
			}
			build_neighbors();
			std::vector<char> fresh(t.size(), true);
			for(int k=0, kEnd=t.size();k<kEnd;++k)//for each triangle
			{
				int i_idx=k*3;
				s.indices[i_idx  ]=t[k].a<<1;
				s.indices[i_idx+1]=t[k].b<<1;
				s.indices[i_idx+2]=t[k].c<<1;
				//s.indices[i_idx  ]=t[k].a<<(int)!usingOpenGL;
				//s.indices[i_idx+1]=t[k].b<<(int)!usingOpenGL;
				//s.indices[i_idx+2]=t[k].c<<(int)!usingOpenGL;
			}
			//if(Rlevel==-600)//
			//{
			////	vbo_to_clipboard(&s.vertices[0], s.vertices.size(), &s.indices[0], s.indices.size());//
			//	int LOL_1=0;//
			//}
			for(int k=0, kEnd=t.size();k<kEnd;++k)//for each triangle
			{
				if(fresh[k])
				{
					fresh[k]=false;
					typedef std::pair<int, int> TR;//triangle idx, reference vertex idx
					std::queue<TR> q;
					q.push(TR(k, 0));
					while(q.size())
					{
						int kt=q.front().first;
						auto &tk=t[kt];
						int ref=q.front().second;
						q.pop();
						auto &nr=s.vertices[(ref<<1)+1], &na=s.vertices[(tk.a<<1)+1], &nb=s.vertices[(tk.b<<1)+1], &nc=s.vertices[(tk.c<<1)+1];
					//	int kr=(&tk.a)[ref], kb=(&tk.a)[(ref+1)%3], kc=(&tk.a)[(ref+2)%3];
					//	auto &nr=s.vertices[(kr<<1)+1], &nb=s.vertices[(kb<<1)+1], &nc=s.vertices[(kc<<1)+1];
						if(nr.dot(na)<0)//make all normals of this triangle on same side as reference vertex normal
							na=-na;
						if(nr.dot(nb)<0)
							nb=-nb;
						if(nr.dot(nc)<0)
							nc=-nc;
						if(tk.tab!=-1&&fresh[tk.tab])
							fresh[tk.tab]=false, q.push(TR(tk.tab, tk.a));
						if(tk.tbc!=-1&&fresh[tk.tbc])
							fresh[tk.tbc]=false, q.push(TR(tk.tbc, tk.b));
						if(tk.tca!=-1&&fresh[tk.tca])
							fresh[tk.tca]=false, q.push(TR(tk.tca, tk.c));
					}
				}
			}
			//if(Rlevel==-600)//
			//{
			//	vbo_to_clipboard(&s.vertices[0], s.vertices.size(), &s.indices[0], s.indices.size());//
			//	int LOL_1=0;//
			//}

			//s.vertices.resize(v.size());
			//s.indices.resize(t.size()*3);
			//for(int k=0, kEnd=v.size();k<kEnd;++k)
			//	s.vertices[k]=v[k].v;
			//for(int k=0, kEnd=t.size();k<kEnd;++k)
			//{
			//	int i_idx=k*3;
			//	s.indices[i_idx  ]=t[k].a;
			//	s.indices[i_idx+1]=t[k].b;
			//	s.indices[i_idx+2]=t[k].c;
			//}
			return s;
		}
	};
	std::unordered_map<int, SurfaceHelper> g_contour;
	bool normals_equal(vec3 const &n1, vec3 const &n2)
	{
		static const float tolerance=1-1e-6f;
		float d=n1.dot(n2);
		return abs(d)>=tolerance;
		//vec3 diff=n2-n1;
		//return diff.mag_sq()<tolerance;
	}
	//bool collinear(vec3 const &a, vec3 const &b, vec3 const &c)
	//{
	//	const float tolerance=1e-10f;
	//	vec3 ab=b-a, ac=c-a;
	//	float d=ab.dot(ac), ab2=ab.mag_sq(), ac2=ac.mag_sq();
	//	return abs(d*d-ab2*ac2)<tolerance;
	//}
#if 0
	class		Implicit_3D:public Mode
	{
	public:
		int shiftOnly;//0 full, 1 partial, 2 no change yet
		int Xoffset, Yoffset, Zoffset;
		int bpx, bpy, bh, bw, X0, Y0;

		int Xplaces, Yplaces, Zplaces;
		double XshiftPoint, YshiftPoint, ZshiftPoint;
		double XsamplePos, YsamplePos, ZsamplePos;
	//	int KXplaces, KYplaces, KZplaces;

		double VX, VY, VZ, DX, AR_Y, AR_Z, Xstep, Ystep, Zstep;
		int prec;
		Solve_3D solver;
		std::list<int> operations;

		bool contourOn, contourOnly, contourFlat;
		std::map<unsigned, std::unordered_map<int, std::list<_3D::Triangle>>>
			Rcontours,//contours[e]=contour, contour[r level (r/step)]=triangles, *triangles.begin()=triangle
			Icontours,//contours[e]=contour, contour[i level (i/step)]=triangles, *triangles.begin()=triangle
			Jcontours,//contours[e]=contour, contour[j level (j/step)]=triangles, *triangles.begin()=triangle
			Kcontours;//contours[e]=contour, contour[k level (k/step)]=triangles, *triangles.begin()=triangle
		std::map<unsigned, std::unordered_map<int, std::list<_3D::Stick>>>
			Rlines,//contours[e]=contour, contour[r level (r/step)]=sticks, *sticks.begin()=stick
			Ilines,//contours[e]=contour, contour[i level (i/step)]=sticks, *sticks.begin()=stick
			Jlines,//contours[e]=contour, contour[j level (j/step)]=sticks, *sticks.begin()=stick
			Klines;//contours[e]=contour, contour[k level (k/step)]=sticks, *sticks.begin()=stick
		
		bool clearScreen;
		Labels_3D labels;
		static const int rColor=0, iColor=0x00EF0000, jColor=0x0000EF00, kColor=0x000000EF;
		_3D _3d;
		int gridColor;
		
		bool timer, drag, m_bypass, shift;
		int kp;

		Implicit_3D():
			VX(0), VY(0), VZ(0), DX(20), AR_Y(1), AR_Z(1),
			Xplaces(10), Yplaces(10), Zplaces(10),
			XshiftPoint(0), YshiftPoint(0), ZshiftPoint(0),
			XsamplePos(0), YsamplePos(0), ZsamplePos(0),
			_3d(20, 20, 20, 225*G2::_pi/180, 324.7356103172454*G2::_pi/180, 1),
			gridColor(_3dGridColor),
			timer(false), drag(false), m_bypass(false), shift(false), kp(0),
			shiftOnly(2), Xoffset(0), Yoffset(0),
			contourOn(false), contourOnly(false), contourFlat(false),
			clearScreen(false)
		{}

		void enter()
		{
			if(kb[VK_LBUTTON])
			{
				ShowCursor(0);
				GetCursorPos(&mouseP0);
				SetCursorPos(centerP.x, centerP.y);
			//	SetCapture(ghWnd);
				drag=1;
			}
			kp=kb['W']+kb['A']+kb['S']+kb['D']+kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}
		void exit()
		{
			if(drag||shift)
			{
				drag=0, shift=0;
			//	ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
			}
			if(!time_variance&&timer)
				KillTimer(ghWnd, 0), timer=false;
		}
		void pause()
		{
			if(time_variance&&!paused)
			{
				solver.pause();
				KillTimer(ghWnd, 0);
				paused=true;
			}
		}
		void resume()
		{
			if(time_variance)
			{
				SetTimer(ghWnd, 0, 10, 0);
				solver.resume();
				paused=false;
			}
		}
		void appDeactivate()
		{
			if(drag||shift)
			{
				ReleaseCapture();
				SetCursorPos(mouseP0.x, mouseP0.y);
				ShowCursor(1);
				drag=0;
			}
			kp=0, timer=false;
			if(!time_variance)
				KillTimer(ghWnd, 0);
		}
		void appActivate()
		{
			kp=kb['W']+kb['A']+kb['S']+kb['D']+kb[VK_UP]+kb[VK_DOWN]+kb[VK_LEFT]+kb[VK_RIGHT]
				+kb[VK_ADD]+kb[VK_SUBTRACT]//numpad
				+kb[VK_OEM_PLUS]+kb[VK_OEM_MINUS]
				+kb[VK_RETURN]+kb[VK_BACK];
			if(!time_variance&&kp&&!timer)
				SetTimer(ghWnd, 0, 10, 0), timer=true;
		}
		
		void draw_contour(std::map<unsigned, std::unordered_map<int, std::list<_3D::Triangle>>> &contours, std::map<unsigned, std::unordered_map<int, std::list<_3D::Stick>>> &lines, unsigned lineColor)
		{
			for(auto &L:contours[cursorEx])
			{
				double RL=10*L.first*Xstep;
				int color=colorFunction_r(RL);
				if(!color)
					color=0x00D0D0D0;
				for(auto &p:L.second)
					_3d.triangle_halfTransparent(p, color);
			}
			_3d.lineColor=lineColor;
		/*	for(auto &L:contours[cursorEx])//contour mesh
			{
				for(auto &p:L.second)
				{
					_3d.line(p.X1, p.Y1, p.Z1, p.X2, p.Y2, p.Z2);
					_3d.line(p.X2, p.Y2, p.Z2, p.X3, p.Y3, p.Z3);
					_3d.line(p.X3, p.Y3, p.Z3, p.X1, p.Y1, p.Z1);
				}
			}//*/
			for(auto &Vlevel:lines[cursorEx])
				for(auto &s:Vlevel.second)
					_3d.line(s.X1, s.Y1, s.Z1, s.X2, s.Y2, s.Z2);
		}
		void draw_contourGrid(double Xs)
		{
			unsigned e=cursorEx, c=0;
			using namespace contour;
			auto &ndr=expr[e].n[0].ndr;
			_3d.lineColor=0x00D0D0D0;

			double X0, X1, Y0, Y1, Z0, Z1, V000, V001, V010, V011, V100, V101, V110, V111;
			auto interpolate=[&](double Xa, double Ya, double Za)
			{
				double dX0=Xa-X0, dX1=X1-Xa, dY0=(Ya-Y0), dY1=(Y1-Ya);
				return
					(	(Z1-Za)*	(	dY1*	(	dX1*V000+
													dX0*V001	)+
										dY0*	(	dX1*V010+
													dX0*V011	))+
						(Za-Z0)*	(	dY1*	(	dX1*V100+
													dX0*V101	)+
										dY0*	(	dX1*V110+
													dX0*V111	))
					)/(Z1-Z0)/(Y1-Y0)/(X1-X0);
			};

			auto cutTrap=[&](Double_X_Y_Z_V &A, Double_X_Y_Z_V &B, Double_X_Y_Z_V &C, Double_X_Y_Z_V &D)
			{
				_3d.line(A.X, A.Y, A.Z, B.X, B.Y, B.Z);
				_3d.line(B.X, B.Y, B.Z, C.X, C.Y, C.Z);
				_3d.line(C.X, C.Y, C.Z, D.X, D.Y, D.Z);
				_3d.line(D.X, D.Y, D.Z, A.X, A.Y, A.Z);
			};
			auto print=[&](Double_X_Y_Z_V &P){_3d.textIn3D(P.X, P.Y, P.Z, OPAQUE, "%g", P.V);};
			for(unsigned vz=0, vzEnd=Zplaces-1;vz<vzEnd;++vz)
			{
				for(unsigned vy=0, vyEnd=Yplaces-1;vy<vyEnd;++vy)
				{
					for(unsigned vx=0, vxEnd=Xplaces-1;vx<vxEnd;++vx)
					{
						X0=solver.Xstart+Xs*vx, X1=solver.Xstart+Xs*(vx+1);
						Y0=solver.Ystart+Xs*vy, Y1=solver.Ystart+Xs*(vy+1);
						Z0=solver.Zstart+Xs*vz, Z1=solver.Zstart+Xs*(vz+1);
						double Xm=solver.Xstart+Xs*(vx+.5), Ym=solver.Ystart+Xs*(vy+.5), Zm=solver.Zstart+Xs*(vz+.5);
							
						Double_X_Y_Z_V
							P000(X0, Y0, Z0, V000=(&ndr[Xplaces*(Yplaces* vz   +vy  )+vx  ].r)[c]),
							P001(X1, Y0, Z0, V001=(&ndr[Xplaces*(Yplaces* vz   +vy  )+vx+1].r)[c]),
							P010(X0, Y1, Z0, V010=(&ndr[Xplaces*(Yplaces* vz   +vy+1)+vx  ].r)[c]),
							P011(X1, Y1, Z0, V011=(&ndr[Xplaces*(Yplaces* vz   +vy+1)+vx+1].r)[c]),
							P100(X0, Y0, Z1, V100=(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx  ].r)[c]),
							P101(X1, Y0, Z1, V101=(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx+1].r)[c]),
							P110(X0, Y1, Z1, V110=(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+vx  ].r)[c]),
							P111(X1, Y1, Z1, V111=(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+vx+1].r)[c]),

							P00m(Xm, Y0, Z0, interpolate(Xm, Y0, Z0)),
							P01m(Xm, Y1, Z0, interpolate(Xm, Y1, Z0)),
							P10m(Xm, Y0, Z1, interpolate(Xm, Y0, Z1)),
							P11m(Xm, Y1, Z1, interpolate(Xm, Y1, Z1)),

							P0m0(X0, Ym, Z0, interpolate(X0, Ym, Z0)),
							P0m1(X1, Ym, Z0, interpolate(X1, Ym, Z0)),
							P1m0(X0, Ym, Z1, interpolate(X0, Ym, Z1)),
							P1m1(X1, Ym, Z1, interpolate(X1, Ym, Z1)),

							Pm00(X0, Y0, Zm, interpolate(X0, Y0, Zm)),
							Pm01(X1, Y0, Zm, interpolate(X1, Y0, Zm)),
							Pm10(X0, Y1, Zm, interpolate(X0, Y1, Zm)),
							Pm11(X1, Y1, Zm, interpolate(X1, Y1, Zm)),

							P0mm(Xm, Ym, Z0, interpolate(Xm, Ym, Z0)),
							P1mm(Xm, Ym, Z1, interpolate(Xm, Ym, Z1)),

							Pm0m(Xm, Y0, Zm, interpolate(Xm, Y0, Zm)),
							Pm1m(Xm, Y1, Zm, interpolate(Xm, Y1, Zm)),

							Pmm0(X0, Ym, Zm, interpolate(X0, Ym, Zm)),
							Pmm1(X1, Ym, Zm, interpolate(X1, Ym, Zm)),

							Pmmm(Xm, Ym, Zm, interpolate(Xm, Ym, Zm));
						
						print(P00m), print(P01m), print(P10m), print(P11m);
						print(P0m0), print(P0m1), print(P1m0), print(P1m1);
						print(Pm00), print(Pm01), print(Pm10), print(Pm11);
						print(P0mm), print(P1mm);
						print(Pm0m), print(Pm1m);
						print(Pmm0), print(Pmm1);
						print(Pmmm);
						
						cutTrap(Pm00, Pm0m, P000, Pmmm);
						cutTrap(Pm0m, P00m, P000, Pmmm);
						cutTrap(P00m, P0mm, P000, Pmmm);
						cutTrap(P0mm, P0m0, P000, Pmmm);
						cutTrap(P0m0, Pmm0, P000, Pmmm);
						cutTrap(Pmm0, Pm00, P000, Pmmm);
						
						cutTrap(Pm01, Pm0m, P001, Pmmm);
						cutTrap(Pm0m, P00m, P001, Pmmm);
						cutTrap(P00m, P0mm, P001, Pmmm);
						cutTrap(P0mm, P0m1, P001, Pmmm);
						cutTrap(P0m1, Pmm1, P001, Pmmm);
						cutTrap(Pmm1, Pm01, P001, Pmmm);
						
						cutTrap(Pm10, Pm1m, P010, Pmmm);
						cutTrap(Pm1m, P01m, P010, Pmmm);
						cutTrap(P01m, P0mm, P010, Pmmm);
						cutTrap(P0mm, P0m0, P010, Pmmm);
						cutTrap(P0m0, Pmm0, P010, Pmmm);
						cutTrap(Pmm0, Pm10, P010, Pmmm);
						
						cutTrap(Pm11, Pm1m, P011, Pmmm);
						cutTrap(Pm1m, P01m, P011, Pmmm);
						cutTrap(P01m, P0mm, P011, Pmmm);
						cutTrap(P0mm, P0m1, P011, Pmmm);
						cutTrap(P0m1, Pmm1, P011, Pmmm);
						cutTrap(Pmm1, Pm11, P011, Pmmm);
						
						cutTrap(Pm00, Pm0m, P100, Pmmm);
						cutTrap(Pm0m, P10m, P100, Pmmm);
						cutTrap(P10m, P1mm, P100, Pmmm);
						cutTrap(P1mm, P1m0, P100, Pmmm);
						cutTrap(P1m0, Pmm0, P100, Pmmm);
						cutTrap(Pmm0, Pm00, P100, Pmmm);
						
						cutTrap(Pm01, Pm0m, P101, Pmmm);
						cutTrap(Pm0m, P10m, P101, Pmmm);
						cutTrap(P10m, P1mm, P101, Pmmm);
						cutTrap(P1mm, P1m1, P101, Pmmm);
						cutTrap(P1m1, Pmm1, P101, Pmmm);
						cutTrap(Pmm1, Pm01, P101, Pmmm);
						
						cutTrap(Pm10, Pm1m, P110, Pmmm);
						cutTrap(Pm1m, P11m, P110, Pmmm);
						cutTrap(P11m, P1mm, P110, Pmmm);
						cutTrap(P1mm, P1m0, P110, Pmmm);
						cutTrap(P1m0, Pmm0, P110, Pmmm);
						cutTrap(Pmm0, Pm10, P110, Pmmm);
						
						cutTrap(Pm11, Pm1m, P111, Pmmm);
						cutTrap(Pm1m, P11m, P111, Pmmm);
						cutTrap(P11m, P1mm, P111, Pmmm);
						cutTrap(P1mm, P1m1, P111, Pmmm);
						cutTrap(P1m1, Pmm1, P111, Pmmm);
						cutTrap(Pmm1, Pm11, P111, Pmmm);
					}
				}
			}
		}
		void doContour_component(unsigned e, unsigned c, double Xs, double Vstart, double Vend, double Vstep, unsigned nvSteps)//cursorEx, comp, DX/Xplaces, -DX/2, +DX/2, Xstep, 2
		{
			using namespace contour;
			auto &ndr=expr[e].n[0].ndr;
			decltype(&Rcontours[e]) contour=0;
			switch(c)
			{
			case 0:contour=&Rcontours[e];break;
			case 1:contour=&Icontours[e];break;
			case 2:contour=&Jcontours[e];break;
			case 3:contour=&Kcontours[e];break;
			}
			double X0, X1, Y0, Y1, Z0, Z1, V000, V001, V010, V011, V100, V101, V110, V111;
			auto getPos=[&](double &t, double Vx, Double_X_Y_Z_V &A, Double_X_Y_Z_V &B)
			{
				double
					Xd=B.X-A.X, X1a=X1-A.X, Xa0=A.X-X0,
					Yd=B.Y-A.Y, Y1a=Y1-A.Y, Ya0=A.Y-Y0,
					Zd=B.Z-A.Z, Z1a=Z1-A.Z, Za0=A.Z-Z0,
					
					A00=(V001-V000)*Xd, B00=X1a*V000+Xa0*V001,
					A01=(V011-V010)*Xd, B01=X1a*V010+Xa0*V011,
					A10=(V101-V100)*Xd, B10=X1a*V100+Xa0*V101,
					A11=(V111-V110)*Xd, B11=X1a*V110+Xa0*V111,
					
					C0=(A01-A00)*Yd, D0=(B01-B00)*Yd+Y1a*A00+Ya0*A01, E0=Y1a*B00+Ya0*B01,
					C1=(A11-A10)*Yd, D1=(B11-B10)*Yd+Y1a*A10+Ya0*A11, E1=Y1a*B10+Ya0*B11,
					
					a=(C1-C0)*Zd, b=(D1-D0)*Zd+Z1a*C0+Za0*C1, c=(E1-E0)*Zd+Z1a*D0+Za0*D1, d=Z1a*E0+Za0*E1-(X1-X0)*(Y1-Y0)*(Z1-Z0)*Vx;

			//	if(A.Z==Z0&&B.Z==Z0)
			//		int LOL_1=0;
				if(a==0&&b==0&&c==0)
				{
					t=(Vx-A.V)/(B.V-A.V);
					return true;
				}
				double r1;
				std::complex<double> r2, r3;
				solve_cubic(a, b, c, d, r1, r2, r3);
				if(r1>=0&&r1<=1)
				{
					t=r1;
					return true;
				}
				if(r2.real()>=0&&r2.real()<=1)//what
				{
					t=r2.real();
					return true;
				}
				if(r3.real()>=0&&r3.real()<=1)
				{
					t=r3.real();
					return true;
				}
				if(r1>=-1e-5&&r1<=1+1e-5)
				{
					t=r1;
					return true;
				}
				if(r2.real()>=-1e-5&&r2.real()<=1+1e-5)//what
				{
					t=r2.real();
					return true;
				}
				if(r3.real()>=-1e-5&&r3.real()<=1+1e-5)
				{
					t=r3.real();
					return true;
				}
				if(r1>=-1e-1&&r1<=1+1e-1)
				{
					t=r1;
					return true;
				}
				if(r2.real()>=-1e-1&&r2.real()<=1+1e-1)//what
				{
					t=r2.real();
					return true;
				}
				if(r3.real()>=-1e-1&&r3.real()<=1+1e-1)
				{
					t=r3.real();
					return true;
				}
				return false;
			};
			auto cutTrap=[&](Double_X_Y_Z_V &A, Double_X_Y_Z_V &B, Double_X_Y_Z_V &C, Double_X_Y_Z_V &D)
			{
				Double_X_Y_Z_V *_1, *_2, *_3, *_4;//sorted by V in ascending order
				if(A.V<B.V)//ab
				{
					if(B.V<C.V)//abc
					{
							 if(C.V<D.V)	_1=&A, _2=&B, _3=&C, _4=&D;
						else if(B.V<D.V)	_1=&A, _2=&B, _3=&D, _4=&C;
						else if(A.V<D.V)	_1=&A, _2=&D, _3=&B, _4=&C;
						else				_1=&D, _2=&A, _3=&B, _4=&C;
					}
					else if(A.V<C.V)//acb
					{
							 if(B.V<D.V)	_1=&A, _2=&C, _3=&B, _4=&D;
						else if(C.V<D.V)	_1=&A, _2=&C, _3=&D, _4=&B;
						else if(A.V<D.V)	_1=&A, _2=&D, _3=&C, _4=&B;
						else				_1=&D, _2=&A, _3=&C, _4=&B;
					}
					else//cab
					{
							 if(B.V<D.V)	_1=&C, _2=&A, _3=&B, _4=&D;
						else if(A.V<D.V)	_1=&C, _2=&A, _3=&D, _4=&B;
						else if(C.V<D.V)	_1=&C, _2=&D, _3=&A, _4=&B;
						else				_1=&D, _2=&C, _3=&A, _4=&B;
					}
				}
				else//ba
				{
					if(A.V<C.V)//bac
					{
							 if(C.V<D.V)	_1=&B, _2=&A, _3=&C, _4=&D;
						else if(A.V<D.V)	_1=&B, _2=&A, _3=&D, _4=&C;
						else if(B.V<D.V)	_1=&B, _2=&D, _3=&A, _4=&C;
						else				_1=&D, _2=&B, _3=&A, _4=&C;
					}
					else if(B.V<C.V)//bca
					{
							 if(A.V<D.V)	_1=&B, _2=&C, _3=&A, _4=&D;
						else if(C.V<D.V)	_1=&B, _2=&C, _3=&D, _4=&A;
						else if(B.V<D.V)	_1=&B, _2=&D, _3=&C, _4=&A;
						else				_1=&D, _2=&B, _3=&C, _4=&A;
					}
					else//cba
					{
							 if(A.V<D.V)	_1=&C, _2=&B, _3=&A, _4=&D;
						else if(B.V<D.V)	_1=&C, _2=&B, _3=&D, _4=&A;
						else if(C.V<D.V)	_1=&C, _2=&D, _3=&B, _4=&A;
						else				_1=&D, _2=&C, _3=&B, _4=&A;
					}
				}
				for(double v=std::floor((_1->V<Vstart?Vstart:_1->V)/Vstep), vEnd=std::floor((_2->V>Vend?Vend:_2->V)/Vstep);v<=vEnd;++v)
				{
					double VL=Vstep*v;
					if(_1->V<=VL&&VL<_2->V)
					{
						double M12, M13, M14;
						if(getPos(M12, VL, *_1, *_2)&&getPos(M13, VL, *_1, *_3)&&getPos(M14, VL, *_1, *_4))
						{
							contour->operator[](int(v)).push_back(_3D::Triangle(
								_1->X+M12*(_2->X-_1->X), _1->Y+M12*(_2->Y-_1->Y), _1->Z+M12*(_2->Z-_1->Z),
								_1->X+M13*(_3->X-_1->X), _1->Y+M13*(_3->Y-_1->Y), _1->Z+M13*(_3->Z-_1->Z),
								_1->X+M14*(_4->X-_1->X), _1->Y+M14*(_4->Y-_1->Y), _1->Z+M14*(_4->Z-_1->Z)
								));
						}
					}
				}
				for(double v=std::floor((_2->V<Vstart?Vstart:_2->V)/Vstep), vEnd=std::floor((_3->V>Vend?Vend:_3->V)/Vstep);v<=vEnd;++v)
				{
					double VL=Vstep*v;
					if(_2->V<=VL&&VL<_3->V)
					{
						double M13, M23, M24, M14;
						if(getPos(M13, VL, *_1, *_3)&&getPos(M23, VL, *_2, *_3)&&getPos(M24, VL, *_2, *_4)&&getPos(M14, VL, *_1, *_4))
						{
							double
								X13=_1->X+M13*(_3->X-_1->X), Y13=_1->Y+M13*(_3->Y-_1->Y), Z13=_1->Z+M13*(_3->Z-_1->Z),
								X23=_2->X+M23*(_3->X-_2->X), Y23=_2->Y+M23*(_3->Y-_2->Y), Z23=_2->Z+M23*(_3->Z-_2->Z),
								X24=_2->X+M24*(_4->X-_2->X), Y24=_2->Y+M24*(_4->Y-_2->Y), Z24=_2->Z+M24*(_4->Z-_2->Z),
								X14=_1->X+M14*(_4->X-_1->X), Y14=_1->Y+M14*(_4->Y-_1->Y), Z14=_1->Z+M14*(_4->Z-_1->Z);
							contour->operator[](int(v)).push_back(_3D::Triangle(X13, Y13, Z13, X23, Y23, Z23, X24, Y24, Z24));
							contour->operator[](int(v)).push_back(_3D::Triangle(X13, Y13, Z13, X14, Y14, Z14, X24, Y24, Z24));
						}
					}
				}
				for(double v=std::floor((_3->V<Vstart?Vstart:_3->V)/Vstep), vEnd=std::floor((_4->V>Vend?Vend:_4->V)/Vstep);v<=vEnd;++v)
				{
					double VL=Vstep*v;
					if(_3->V<=VL&&VL<_4->V)
					{
						double M14, M24, M34;
						if(getPos(M14, VL, *_1, *_4)&&getPos(M24, VL, *_2, *_4)&&getPos(M34, VL, *_3, *_4))
						{
							contour->operator[](int(v)).push_back(_3D::Triangle(
								_1->X+M14*(_4->X-_1->X), _1->Y+M14*(_4->Y-_1->Y), _1->Z+M14*(_4->Z-_1->Z),
								_2->X+M24*(_4->X-_2->X), _2->Y+M24*(_4->Y-_2->Y), _2->Z+M24*(_4->Z-_2->Z),
								_3->X+M34*(_4->X-_3->X), _3->Y+M34*(_4->Y-_3->Y), _3->Z+M34*(_4->Z-_3->Z)
								));
						}
					}
				}
			};
			double dispYstart=AR_Y*solver.Ystart, dispZstart=AR_Z*solver.Zstart;
			for(unsigned vz=0, vzEnd=Zplaces-1;vz<vzEnd;++vz)
			{
				for(unsigned vy=0, vyEnd=Yplaces-1;vy<vyEnd;++vy)
				{
					for(unsigned vx=0, vxEnd=Xplaces-1;vx<vxEnd;++vx)
					{
						X0=solver.Xstart+Xs*vx, X1=solver.Xstart+Xs*(vx+1);
						Y0=   dispYstart+Xs*vy, Y1=   dispYstart+Xs*(vy+1);
						Z0=   dispZstart+Xs*vz, Z1=   dispZstart+Xs*(vz+1);
						double Xm=solver.Xstart+Xs*(vx+.5), Ym=dispYstart+Xs*(vy+.5), Zm=dispZstart+Xs*(vz+.5);		//display env units		faster

					//	X0=solver.Xstart+Xs*vx, X1=solver.Xstart+Xs*(vx+1);
					//	Y0=AR_Y*solver.Ystart+Xs*vy, Y1=AR_Y*solver.Ystart+Xs*(vy+1);
					//	Z0=AR_Z*solver.Zstart+Xs*vz, Z1=AR_Z*solver.Zstart+Xs*(vz+1);
					//	double Xm=solver.Xstart+Xs*(vx+.5), Ym=AR_Y*solver.Ystart+Xs*(vy+.5), Zm=AR_Z*solver.Zstart+Xs*(vz+.5);		//display env units		faster

					//	X0=solver.Xstart+Xs*vx, X1=solver.Xstart+Xs*(vx+1);
					//	Y0=solver.Ystart+Xs/AR_Y*vy, Y1=solver.Ystart+Xs/AR_Y*(vy+1);
					//	Z0=solver.Zstart+Xs/AR_Z*vz, Z1=solver.Zstart+Xs/AR_Z*(vz+1);
					//	double Xm=solver.Xstart+Xs*(vx+.5), Ym=solver.Ystart+Xs/AR_Y*(vy+.5), Zm=solver.Zstart+Xs/AR_Z*(vz+.5);		//math env units		multiply by gain at draw
							
						Double_X_Y_Z_V//zyx matrix notation
							P000(X0, Y0, Z0, V000=(&ndr[Xplaces*(Yplaces* vz   +vy  )+vx  ].r)[c]),
							P001(X1, Y0, Z0, V001=(&ndr[Xplaces*(Yplaces* vz   +vy  )+vx+1].r)[c]),
							P010(X0, Y1, Z0, V010=(&ndr[Xplaces*(Yplaces* vz   +vy+1)+vx  ].r)[c]),
							P011(X1, Y1, Z0, V011=(&ndr[Xplaces*(Yplaces* vz   +vy+1)+vx+1].r)[c]),
							P100(X0, Y0, Z1, V100=(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx  ].r)[c]),
							P101(X1, Y0, Z1, V101=(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx+1].r)[c]),
							P110(X0, Y1, Z1, V110=(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+vx  ].r)[c]),
							P111(X1, Y1, Z1, V111=(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+vx+1].r)[c]),
							
							P00m(Xm, Y0, Z0, .5*(V000+V001)),
							P01m(Xm, Y1, Z0, .5*(V010+V011)),
							P10m(Xm, Y0, Z1, .5*(V100+V101)),
							P11m(Xm, Y1, Z1, .5*(V110+V111)),

							P0m0(X0, Ym, Z0, .5*(V000+V010)),
							P0m1(X1, Ym, Z0, .5*(V001+V011)),
							P1m0(X0, Ym, Z1, .5*(V100+V110)),
							P1m1(X1, Ym, Z1, .5*(V101+V111)),

							Pm00(X0, Y0, Zm, .5*(V000+V100)),
							Pm01(X1, Y0, Zm, .5*(V001+V101)),
							Pm10(X0, Y1, Zm, .5*(V010+V110)),
							Pm11(X1, Y1, Zm, .5*(V011+V111)),

							P0mm(Xm, Ym, Z0, .25*(V000+V001+V010+V011)),
							P1mm(Xm, Ym, Z1, .25*(V100+V101+V110+V111)),

							Pm0m(Xm, Y0, Zm, .25*(V000+V001+V100+V101)),
							Pm1m(Xm, Y1, Zm, .25*(V010+V011+V110+V111)),

							Pmm0(X0, Ym, Zm, .25*(V000+V010+V100+V110)),
							Pmm1(X1, Ym, Zm, .25*(V001+V011+V101+V111)),

							Pmmm(Xm, Ym, Zm, .125*(V000+V001+V010+V011+V100+V101+V110+V111));

						cutTrap(Pm00, Pm0m, P000, Pmmm);
						cutTrap(Pm0m, P00m, P000, Pmmm);
						cutTrap(P00m, P0mm, P000, Pmmm);
						cutTrap(P0mm, P0m0, P000, Pmmm);
						cutTrap(P0m0, Pmm0, P000, Pmmm);
						cutTrap(Pmm0, Pm00, P000, Pmmm);
						
						cutTrap(Pm01, Pm0m, P001, Pmmm);
						cutTrap(Pm0m, P00m, P001, Pmmm);
						cutTrap(P00m, P0mm, P001, Pmmm);
						cutTrap(P0mm, P0m1, P001, Pmmm);
						cutTrap(P0m1, Pmm1, P001, Pmmm);
						cutTrap(Pmm1, Pm01, P001, Pmmm);
						
						cutTrap(Pm10, Pm1m, P010, Pmmm);
						cutTrap(Pm1m, P01m, P010, Pmmm);
						cutTrap(P01m, P0mm, P010, Pmmm);
						cutTrap(P0mm, P0m0, P010, Pmmm);
						cutTrap(P0m0, Pmm0, P010, Pmmm);
						cutTrap(Pmm0, Pm10, P010, Pmmm);
						
						cutTrap(Pm11, Pm1m, P011, Pmmm);
						cutTrap(Pm1m, P01m, P011, Pmmm);
						cutTrap(P01m, P0mm, P011, Pmmm);
						cutTrap(P0mm, P0m1, P011, Pmmm);
						cutTrap(P0m1, Pmm1, P011, Pmmm);
						cutTrap(Pmm1, Pm11, P011, Pmmm);
						
						cutTrap(Pm00, Pm0m, P100, Pmmm);
						cutTrap(Pm0m, P10m, P100, Pmmm);
						cutTrap(P10m, P1mm, P100, Pmmm);
						cutTrap(P1mm, P1m0, P100, Pmmm);
						cutTrap(P1m0, Pmm0, P100, Pmmm);
						cutTrap(Pmm0, Pm00, P100, Pmmm);
						
						cutTrap(Pm01, Pm0m, P101, Pmmm);
						cutTrap(Pm0m, P10m, P101, Pmmm);
						cutTrap(P10m, P1mm, P101, Pmmm);
						cutTrap(P1mm, P1m1, P101, Pmmm);
						cutTrap(P1m1, Pmm1, P101, Pmmm);
						cutTrap(Pmm1, Pm01, P101, Pmmm);
						
						cutTrap(Pm10, Pm1m, P110, Pmmm);
						cutTrap(Pm1m, P11m, P110, Pmmm);
						cutTrap(P11m, P1mm, P110, Pmmm);
						cutTrap(P1mm, P1m0, P110, Pmmm);
						cutTrap(P1m0, Pmm0, P110, Pmmm);
						cutTrap(Pmm0, Pm10, P110, Pmmm);
						
						cutTrap(Pm11, Pm1m, P111, Pmmm);
						cutTrap(Pm1m, P11m, P111, Pmmm);
						cutTrap(P11m, P1mm, P111, Pmmm);
						cutTrap(P1mm, P1m1, P111, Pmmm);
						cutTrap(P1m1, Pmm1, P111, Pmmm);
						cutTrap(Pmm1, Pm11, P111, Pmmm);
					}
				}
			}
			decltype(&Rlines[e]) lines=0;
			switch(e)
			{
			case 0:lines=&Rlines[e];break;
			case 1:lines=&Ilines[e];break;
			case 2:lines=&Jlines[e];break;
			case 3:lines=&Klines[e];break;
			}
			for(auto &level:*contour)
			{
				for(auto &T:level.second)
				{
					double *X1, *Y1, *V1, *X2, *Y2, *V2, *X3, *Y3, *V3;
					if(T.Z1<T.Z2)//12
					{
							 if(T.Z2<T.Z3)	X1=&T.X1, Y1=&T.Y1, V1=&T.Z1, X2=&T.X2, Y2=&T.Y2, V2=&T.Z2, X3=&T.X3, Y3=&T.Y3, V3=&T.Z3;
						else if(T.Z1<T.Z3)	X1=&T.X1, Y1=&T.Y1, V1=&T.Z1, X2=&T.X3, Y2=&T.Y3, V2=&T.Z3, X3=&T.X2, Y3=&T.Y2, V3=&T.Z2;
						else				X1=&T.X3, Y1=&T.Y3, V1=&T.Z3, X2=&T.X1, Y2=&T.Y1, V2=&T.Z1, X3=&T.X2, Y3=&T.Y2, V3=&T.Z2;
					}
					else//21
					{
							 if(T.Z1<T.Z3)	X1=&T.X2, Y1=&T.Y2, V1=&T.Z2, X2=&T.X1, Y2=&T.Y1, V2=&T.Z1, X3=&T.X3, Y3=&T.Y3, V3=&T.Z3;
						else if(T.Z2<T.Z3)	X1=&T.X2, Y1=&T.Y2, V1=&T.Z2, X2=&T.X3, Y2=&T.Y3, V2=&T.Z3, X3=&T.X1, Y3=&T.Y1, V3=&T.Z1;
						else				X1=&T.X3, Y1=&T.Y3, V1=&T.Z3, X2=&T.X2, Y2=&T.Y2, V2=&T.Z2, X3=&T.X1, Y3=&T.Y1, V3=&T.Z1;
					}
					double X13, Y13;
					{
						double Zr=(*V2-*V1)/(*V3-*V1);
						X13=*X1+Zr*(*X3-*X1), Y13=*Y1+Zr*(*Y3-*Y1);//V13=V2;
					}
					//for V1 -> V2
					for(double v=std::floor((*V1<Vstart?Vstart:*V1)/Vstep), zEnd=std::floor((*V2>Vend?Vend:*V2)/Vstep);v<=zEnd;++v)
					{
						double ZL=Vstep*v;
						if(*V1<=ZL&&ZL<*V2)
						{
							double M=(ZL-*V1)/(*V2-*V1);
							lines->operator[](level.first).push_back(_3D::Stick(*X1+M*(*X2-*X1), *Y1+M*(*Y2-*Y1), ZL, *X1+M*(X13-*X1), *Y1+M*(Y13-*Y1), ZL));
						}
					}
					//for V2 -> V3
					for(double v=std::floor((*V2<Vstart?Vstart:*V2)/Vstep), zEnd=std::floor((*V3>Vend?Vend:*V3)/Vstep);v<=zEnd;++v)
					{
						double ZL=Vstep*v;
						if(*V2<=ZL&&ZL<*V3)
						{
							double M=(ZL-*V2)/(*V3-*V2);
							lines->operator[](level.first).push_back(_3D::Stick(*X2+M*(*X3-*X2), *Y2+M*(*Y3-*Y2), ZL, X13+M*(*X3-X13), Y13+M*(*Y3-Y13), ZL));
						}
					}
				}
			}
		}
		void doContour(unsigned e, double Xs, double Vstart, double Vend, double Vstep, unsigned nvSteps)
		{
			Vstep*=10;//
			switch(expr[e].resultMathSet)
		//	switch(expr[e].n[0].mathSet)
			{
			case 'R':
				doContour_component(e, 0, Xs, Vstart, Vend, Vstep, nvSteps);
				break;
			case 'c':
				doContour_component(e, 0, Xs, Vstart, Vend, Vstep, nvSteps);
				doContour_component(e, 1, Xs, Vstart, Vend, Vstep, nvSteps);
				break;
			case 'h':
				doContour_component(e, 0, Xs, Vstart, Vend, Vstep, nvSteps);
				doContour_component(e, 1, Xs, Vstart, Vend, Vstep, nvSteps);
				doContour_component(e, 2, Xs, Vstart, Vend, Vstep, nvSteps);
				doContour_component(e, 3, Xs, Vstart, Vend, Vstep, nvSteps);
				break;
			}
		}
		fftw_complex *fft_in, *fft_out;
		fftw_plan fft_p, ifft_p;
		unsigned fft_N0, fft_N1, fft_N2;
		double fft_sqrt_N;
		void discreteFourrierTransform			(std::vector<Value> &ndr)
		{
			int ndrSize=Xplaces*Yplaces*Zplaces;
			if(fft_N0!=Zplaces||fft_N1!=Yplaces||fft_N2!=Xplaces)
			{
				if(fft_N0||fft_N1||fft_N2)
				{
					fftw_destroy_plan(fft_p), fftw_destroy_plan(ifft_p);
					fftw_free(fft_in), fftw_free(fft_out);
				}
				fft_N0=Zplaces, fft_N1=Yplaces, fft_N2=Xplaces;
				fft_in=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex)), fft_out=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex));
				fft_sqrt_N=std::sqrt(ndrSize);
				fft_p=fftw_plan_dft_3d(fft_N0, fft_N1, fft_N2, fft_in, fft_out, FFTW_FORWARD, FFTW_ESTIMATE);
				ifft_p=fftw_plan_dft_3d(fft_N0, fft_N1, fft_N2, fft_in, fft_out, FFTW_BACKWARD, FFTW_ESTIMATE);
			}
			for(int k=0;k<ndrSize;++k)
			{
				unsigned x=k%Xplaces, y=k%Zplaces/Xplaces, z=k/Xplaces/Zplaces;
				int sign=1-((x%2^y%2^z%2)<<1);
				fft_in[k][0]=ndr[k].r*sign, fft_in[k][1]=ndr[k].i*sign;
			}
			fftw_execute(fft_p);
			for(int k=0;k<ndrSize;++k)
				ndr[k].r=fft_out[k][0]/fft_sqrt_N, ndr[k].i=fft_out[k][1]/fft_sqrt_N;
		}
		void inverseDiscreteFourrierTransform	(std::vector<Value> &ndr)
		{
			int ndrSize=Xplaces*Yplaces;
			if(fft_N0!=Zplaces||fft_N1!=Yplaces||fft_N2!=Xplaces)
			{
				if(fft_N0||fft_N1||fft_N2)
				{
					fftw_destroy_plan(fft_p), fftw_destroy_plan(ifft_p);
					fftw_free(fft_in), fftw_free(fft_out);
				}
				fft_N0=Zplaces, fft_N1=Yplaces, fft_N2=Xplaces;
				fft_in=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex)), fft_out=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex));
				fft_sqrt_N=std::sqrt(ndrSize);
				fft_p=fftw_plan_dft_3d(fft_N0, fft_N1, fft_N2, fft_in, fft_out, FFTW_FORWARD, FFTW_ESTIMATE);
				ifft_p=fftw_plan_dft_3d(fft_N0, fft_N1, fft_N2, fft_in, fft_out, FFTW_BACKWARD, FFTW_ESTIMATE);
			}
			for(int k=0;k<ndrSize;++k)
				fft_in[k][0]=ndr[k].r, fft_in[k][1]=ndr[k].i;
			fftw_execute(ifft_p);
			for(int k=0;k<ndrSize;++k)
			{
				unsigned x=k%Xplaces, y=k%Zplaces/Xplaces, z=k/Xplaces/Zplaces;
				double gain=(1-((x%2^y%2^z%2)<<1))/fft_sqrt_N;
				ndr[k].r=fft_out[k][0]*gain, ndr[k].i=fft_out[k][1]*gain;
			}
		}
		void lowPassFilter_xyz					(std::vector<Value> &ndr)
		{
			int nComponents=n_components_in_current_expr();
			std::vector<Value> t_ndr(ndr.size());
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* 0   +0  )+0  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces* 0   +0  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +0  )+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +0+1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +0+1)+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+0  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+0  )+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+0+1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+0+1)+0+1].r)[c]
				)/27;
			for(int vx=1;vx<Xplaces-1;++vx)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* 0   +0  )+vx  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces* 0   +0  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +0  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +0  )+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +0+1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +0+1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +0+1)+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+0  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+0  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+0  )+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+0+1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+0+1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+0+1)+vx+1].r)[c]
					)/27;
			}
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* 0   +0  )+Xplaces-1  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces* 0   +0  )+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +0  )+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +0+1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +0+1)+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+0  )+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+0  )+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+0+1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+0+1)+Xplaces-1  ].r)[c]
				)/27;
			for(int vy=1;vy<Yplaces-1;++vy)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* 0   +vy  )+0  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces* 0   +vy-1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy-1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy+1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy+1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy-1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy-1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy+1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy+1)+0+1].r)[c]
					)/27;
				for(int vx=1;vx<Xplaces-1;++vx)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* 0   +vy  )+vx  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces* 0   +vy-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy+1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy+1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy+1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy+1)+vx+1].r)[c]
						)/27;
				}
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* 0   +vy  )+Xplaces-1  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces* 0   +vy-1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy-1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +vy+1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy-1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy-1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+vy+1)+Xplaces-1  ].r)[c]
					)/27;
			}
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+0  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1-1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1-1)+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1-1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1-1)+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1  )+0+1].r)[c]
				)/27;
			for(int vx=1;vx<Xplaces-1;++vx)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+vx  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1-1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1-1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1-1)+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1-1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1-1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1-1)+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1  )+vx+1].r)[c]
					)/27;
			}
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+Xplaces-1  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1-1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1-1)+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1+1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1+1)+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1-1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1-1)+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1  )+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1  )+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1+1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1+1)+Xplaces-1  ].r)[c]
				)/27;
			for(int vz=1;vz<Zplaces-1;++vz)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* vz   +0  )+0  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(vz-1)+0  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+0  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+0+1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+0+1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +0  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +0  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +0+1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +0+1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+0  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+0  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+0+1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+0+1)+0+1].r)[c]
					)/27;
				for(int vx=1;vx<Xplaces-1;++vx)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* vz   +0  )+vx  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces*(vz-1)+0  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+0  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+0  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+0+1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+0+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+0+1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +0  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +0  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +0  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +0+1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +0+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +0+1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+0  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+0  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+0  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+0+1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+0+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+0+1)+vx+1].r)[c]
						)/27;
				}
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* vz   +0  )+Xplaces-1  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(vz-1)+0  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+0  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+0+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+0+1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +0  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +0  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +0+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +0+1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+0  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+0  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+0+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+0+1)+Xplaces-1  ].r)[c]
					)/27;
				for(int vy=1;vy<Yplaces-1;++vy)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* vz   +vy  )+0  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy-1)+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy-1)+0+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy  )+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy  )+0+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy+1)+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy+1)+0+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy-1)+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy-1)+0+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy  )+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy  )+0+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy+1)+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy+1)+0+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy-1)+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy-1)+0+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+0+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+0  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+0+1].r)[c]
						)/27;
					for(int vx=1;vx<Xplaces-1;++vx)
					{
						for(int c=0;c<nComponents;++c)
							(&t_ndr[Xplaces*(Yplaces* vz   +vy  )+vx  ].r)[c]=
							(
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy-1)+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy-1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy-1)+vx+1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy  )+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy  )+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy  )+vx+1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy+1)+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy+1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy+1)+vx+1].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy-1)+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy-1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy-1)+vx+1].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy  )+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy  )+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy  )+vx+1].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy+1)+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy+1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy+1)+vx+1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy-1)+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy-1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy-1)+vx+1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx+1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+vx-1].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+vx+1].r)[c]
							)/27;
					}
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* vz   +vy  )+Xplaces-1  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy-1)+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy-1)+Xplaces-1  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy  )+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy  )+Xplaces-1  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy+1)+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+vy+1)+Xplaces-1  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy-1)+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy-1)+Xplaces-1  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy  )+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy  )+Xplaces-1  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy+1)+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +vy+1)+Xplaces-1  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy-1)+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy-1)+Xplaces-1  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+Xplaces-1  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+Xplaces-1-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+Xplaces-1  ].r)[c]
						)/27;
				}
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+0  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+0+1].r)[c]
					)/27;
				for(int vx=1;vx<Xplaces-1;++vx)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+vx  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+vx+1].r)[c]
						)/27;
				}
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+Xplaces-1  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1+1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1+1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1+1)+Xplaces-1  ].r)[c]
					)/27;
			}
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+0  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+0+1].r)[c]
				)/27;
			for(int vx=1;vx<Xplaces-1;++vx)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+vx  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+vx+1].r)[c]
					)/27;
			}
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+Xplaces-1  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+Xplaces-1  ].r)[c]
				)/27;
			for(int vy=1;vy<Yplaces-1;++vy)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+0  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy-1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy-1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy+1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy+1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy-1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy-1)+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+0+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy+1)+0  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy+1)+0+1].r)[c]
					)/27;
				for(int vx=1;vx<Xplaces-1;++vx)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+vx  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy+1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy+1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy+1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy+1)+vx+1].r)[c]
						)/27;
				}
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+Xplaces-1  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy-1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy-1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy+1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy-1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy-1)+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+Xplaces-1  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy+1)+Xplaces-1-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy+1)+Xplaces-1  ].r)[c]
					)/27;
			}
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+0  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+0+1].r)[c]
				)/27;
			for(int vx=1;vx<Xplaces-1;++vx)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+vx  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+vx+1].r)[c]
					)/27;
			}
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+Xplaces-1  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1+1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1+1)+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+Xplaces-1  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1+1)+Xplaces-1-1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1+1)+Xplaces-1  ].r)[c]
				)/27;
		}
		void lowPassFilter_x					(std::vector<Value> &ndr)
		{
			int nComponents=n_components_in_current_expr();
			std::vector<Value> t_ndr(ndr.size());
			for(int vx=0;vx<Xplaces;++vx)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* 0   +0  )+vx  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces* 0   +0  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +0+1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+0  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+0+1)+vx  ].r)[c]
					)/27;
			}
			for(int vy=1;vy<Yplaces-1;++vy)
			{
				for(int vx=0;vx<Xplaces;++vx)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* 0   +vy  )+vx  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces* 0   +vy-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* 0   +vy+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(0+1)+vy+1)+vx  ].r)[c]
						)/27;
				}
			}
			for(int vx=0;vx<Xplaces;++vx)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+vx  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1-1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* 0   +Yplaces-1  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1-1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(0+1)+Yplaces-1  )+vx  ].r)[c]
					)/27;
			}
			for(int vz=1;vz<Zplaces-1;++vz)
			{
				for(int vx=0;vx<Xplaces;++vx)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* vz   +0  )+vx  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces*(vz-1)+0  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+0+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +0  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +0+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+0  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+0+1)+vx  ].r)[c]
						)/27;
				}
				for(int vy=1;vy<Yplaces-1;++vy)
				{
					for(int vx=0;vx<Xplaces;++vx)
					{
						for(int c=0;c<nComponents;++c)
							(&t_ndr[Xplaces*(Yplaces* vz   +vy  )+vx  ].r)[c]=
							(
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy-1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy  )+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz-1)+vy+1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy-1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy  )+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces* vz   +vy+1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy-1)+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy  )+vx  ].r)[c]+
								(&ndr[Xplaces*(Yplaces*(vz+1)+vy+1)+vx  ].r)[c]
							)/27;
					}
				}
				for(int vx=0;vx<Xplaces;++vx)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+vx  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz-1)+Yplaces-1  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* vz   +Yplaces-1  )+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1-1)+vx+1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+vx-1].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(vz+1)+Yplaces-1  )+vx+1].r)[c]
						)/27;
				}
			}
			for(int vx=0;vx<Xplaces;++vx)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+vx  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0  )+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+0+1)+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0  )+vx+1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+vx-1].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +0+1)+vx+1].r)[c]
					)/27;
			}
			for(int vy=1;vy<Yplaces-1;++vy)
			{
				for(int vx=0;vx<Xplaces;++vx)
				{
					for(int c=0;c<nComponents;++c)
						(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+vx  ].r)[c]=
						(
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+vy+1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy-1)+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy  )+vx  ].r)[c]+
							(&ndr[Xplaces*(Yplaces* Zplaces-1   +vy+1)+vx  ].r)[c]
						)/27;
				}
			}
			for(int c=0;c<nComponents;++c)
				(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+0  ].r)[c]=
				(
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+0+1].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+0  ].r)[c]+
					(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+0+1].r)[c]
				)/27;
			for(int vx=0;vx<Xplaces;++vx)
			{
				for(int c=0;c<nComponents;++c)
					(&t_ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+vx  ].r)[c]=
					(
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1-1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces*(Zplaces-1-1)+Yplaces-1  )+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1-1)+vx  ].r)[c]+
						(&ndr[Xplaces*(Yplaces* Zplaces-1   +Yplaces-1  )+vx  ].r)[c]
					)/27;
			}
		}
		void lowPassFilter_y					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void lowPassFilter_z					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void lowPassFilter_xy					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void lowPassFilter_yz					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void lowPassFilter_xz					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void highPassFilter_xyz					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void highPassFilter_x					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void highPassFilter_y					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void highPassFilter_z					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void highPassFilter_xy					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void highPassFilter_yz					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}
		void highPassFilter_xz					(std::vector<Value> &ndr)
		{
			unsigned N=ndr.size(), T=11;
			std::complex<double> sum;
			std::vector<decltype(sum)> t0(T);
			for(unsigned k=-int(T)/2;k<T/2;++k)
				sum+=t0[k%T]=(decltype(sum))ndr[k%N];
			std::vector<decltype(sum)> t1(t0);
			for(unsigned k=0;k<N-T/2;++k)
				t0[k%T]=(decltype(sum))ndr[k], ndr[k]-=sum/double(T), sum+=(decltype(sum))ndr[(k+T/2)%N]-t0[(k-T/2)%T];
			for(unsigned k=N-T/2;k<N;++k)
				ndr[k]-=sum/double(T), sum+=t1[(k-(N-T/2))%T]-t0[(k-T/2)%T];
		}

		void setDimensions(int x, int y, int w, int h)
		{
			bpx=x, bpy=y, bw=w, bh=h, X0=bpx+bw/2, Y0=bpy+bh/2;
			_3d.setDimensions(x, y, w, h);
			double old_Xstep=Xstep;
			function1();
			if(!toSolve&&contourOn&&old_Xstep!=Xstep)
			{
				Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
				Rlines.clear(), Ilines.clear(), Jlines.clear(), Klines.clear();
				doContour(cursorEx, DX/Xplaces, -DX/2, +DX/2, Xstep, 2);
			}
			ready=true;
		}
		void messagePaint(int x, int y, int w, int h)
		{
			setDimensions(x, y, w, h);
			if(!time_variance&&!timer)
				a_draw();
		}
		void shiftNDR(double &DshiftPoint, double &Dsample, double &DsamplePos, int &Doffset, double &VD, double ammount)
		{
			double newDsamplePos=std::floor((DshiftPoint+=ammount)/Dsample);
			if(newDsamplePos!=DsamplePos)
			{
				toSolve=true;
				if(shiftOnly)
					shiftOnly=1, Doffset+=int(newDsamplePos-DsamplePos);
				DsamplePos=newDsamplePos, VD=newDsamplePos*Dsample;
			}
			DsamplePos=newDsamplePos;
		}
		void messageTimer()
		{
				 if(kb[VK_SHIFT	]){	 if(kb['W'])	_3d.cam.moveFastForward();
									 if(kb['A'])	_3d.cam.moveFastLeft();
									 if(kb['S'])	_3d.cam.moveFastBack();
									 if(kb['D'])	_3d.cam.moveFastRight();}
			else				  {	 if(kb['W'])	_3d.cam.moveForward();
									 if(kb['A'])	_3d.cam.moveLeft();
									 if(kb['S'])	_3d.cam.moveBack();
									 if(kb['D'])	_3d.cam.moveRight();}
			if(kb['X'])
			{
				if(kb['Y'])
				{
					if(kb['Z'])	//xyz
					{
					}
					else		//xy
					{
						if(kb[VK_UP])	shiftNDR(YshiftPoint, solver.Ysample*AR_Y,	YsamplePos, Yoffset, VY, DX/100);
						if(kb[VK_DOWN])	shiftNDR(YshiftPoint, solver.Ysample*AR_Y,	YsamplePos, Yoffset, VY, -DX/100);
						if(kb[VK_RIGHT])shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, Xoffset, VX, DX/100);
						if(kb[VK_LEFT])	shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, Xoffset, VX, -DX/100);
					}
				}
				else
				{
					if(kb['Z'])	//xz
					{
						if(kb[VK_UP])	shiftNDR(ZshiftPoint, solver.Zsample*AR_Z,	ZsamplePos, Zoffset, VZ, DX/100);
						if(kb[VK_DOWN])	shiftNDR(ZshiftPoint, solver.Zsample*AR_Z,	ZsamplePos, Zoffset, VZ, -DX/100);
						if(kb[VK_RIGHT])shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, Xoffset, VX, DX/100);
						if(kb[VK_LEFT])	shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, Xoffset, VX, -DX/100);
					}
					else		//x
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, DX/100);
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, -DX/100);
					}
				}
			}
			else
			{
				if(kb['Y'])
				{
					if(kb['Z'])	//yz
					{
						if(kb[VK_UP])	shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, Zoffset, VZ, DX/100);
						if(kb[VK_DOWN])	shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, Zoffset, VZ, -DX/100);
						if(kb[VK_RIGHT])shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, Yoffset, VY, DX/100);
						if(kb[VK_LEFT])	shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, Yoffset, VY, -DX/100);
					}
					else		//y
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, Yoffset, VY, DX/100);
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, Yoffset, VY, -DX/100);
					}
				}
				else
				{
					if(kb['Z'])	//z
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, Zoffset, VZ, DX/100);
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, Zoffset, VZ, -DX/100);
					}
					else
					{
						if(kb[VK_UP])	_3d.cam.turnUp();
						if(kb[VK_DOWN])	_3d.cam.turnDown();
						if(kb[VK_RIGHT])_3d.cam.turnRight();
						if(kb[VK_LEFT])	_3d.cam.turnLeft();
					}
				}
			}
			if(kb[VK_ADD]||kb[VK_RETURN]||kb[VK_OEM_PLUS])
			{
				if(kb[VK_MENU])
					DX*=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(kb['X'])
				{
					DX/=1.1, AR_Y/=1.1, AR_Z/=1.1, function1();
					VX/=1.1, VY/=1.1, VZ/=1.1;
					_3d.cam.p.x/=1.1, _3d.cam.p.y/=1.1, _3d.cam.p.z/=1.1, _3d.cam.dcam/=1.1;
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Y'])
					AR_Y*=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(kb['Z'])
					AR_Z*=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(!(kb[VK_CONTROL]||kb[VK_SHIFT]))
					_3d.cam.zoomIn();
			}
			if(kb[VK_SUBTRACT]||kb[VK_BACK]||kb[VK_OEM_MINUS])
			{
				if(kb[VK_MENU])
					DX/=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(kb['X'])
				{
					DX*=1.1, AR_Y*=1.1, AR_Z*=1.1, function1();
					VX*=1.1, VY*=1.1, VZ*=1.1;
					_3d.cam.p.x*=1.1, _3d.cam.p.y*=1.1, _3d.cam.p.z*=1.1, _3d.cam.dcam*=1.1;
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Y'])
					AR_Y/=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(kb['Z'])
					AR_Z/=1.1, function1(), toSolve=true, shiftOnly=0;
				else if(!(kb[VK_CONTROL]||kb[VK_SHIFT]))
					_3d.cam.zoomOut();
			}
		//		 if(kb[VK_MENU	]){		if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])	DX*=1.1, DY*=1.1, DZ*=1.1, function1(), toSolve=true, shiftOnly=0;
		//								if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])	DX/=1.1, DY/=1.1, DZ/=1.1, function1(), toSolve=true, shiftOnly=0;}
		//	else if(!kb[VK_CONTROL]){	if(kb[VK_ADD		]||kb[VK_RETURN	]||kb[VK_OEM_PLUS	])	_3d.cam.zoomIn();
		//								if(kb[VK_SUBTRACT	]||kb[VK_BACK	]||kb[VK_OEM_MINUS	])	_3d.cam.zoomOut();}
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
		}
		int inputLButtonDown(int lParam)
		{
			if(!drag)
			{
				if(!shift)
				{
					ShowCursor(0);
					GetCursorPos(&mouseP0);
					SetCursorPos(centerP.x, centerP.y);
					SetCapture(ghWnd);
				}
				drag=1;
			}
			return 0;
		}
		int inputMouseMove(int lParam)
		{
			if(!m_bypass)
			{
				int draw=0;
				if(kb['X'])
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//xyz	mx my mw
						{
							shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, Xoffset, VX, (((short*)&lParam)[0]-w/2)*DX/w);
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y,	YsamplePos, Yoffset, VY, (h/2-((short*)&lParam)[1])*DX/w);
						}
						else		//xy	mx my
						{
							shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, Xoffset, VX, (((short*)&lParam)[0]-w/2)*DX/w);
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y,	YsamplePos, Yoffset, VY, (h/2-((short*)&lParam)[1])*DX/w);
						}
						draw=1;
					}
					else
					{
						if(kb['Z'])	//xz	mx my
						{
							shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, Xoffset, VX, (((short*)&lParam)[0]-w/2)*DX/w);
							shiftNDR(ZshiftPoint, solver.Zsample*AR_Z,	ZsamplePos, Zoffset, VZ, (h/2-((short*)&lParam)[1])*DX/w);
						}
						else		//x		mx
						{
							shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, Xoffset, VX, (((short*)&lParam)[0]-w/2)*DX/w);
						}
						draw=1;
					}
				}
				else
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//yz	mx my
						{
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, Yoffset, VY, (((short*)&lParam)[0]-w/2)*DX/w);
							shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, Zoffset, VZ, (h/2-((short*)&lParam)[1])*DX/w);
						}
						else		//y		mx
						{
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, Yoffset, VY, (((short*)&lParam)[0]-w/2)*DX/w);
						}
						draw=1;
					}
					else
					{
						if(kb['Z'])	//z		my
						{
							shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, Zoffset, VZ, (h/2-((short*)&lParam)[1])*DX/w);
							draw=1;
						}
						else if(drag)
						{
							_3d.cam.turnMouse(lParam);
							draw=1;
						}
					}
				}
				if(draw)
				{
					SetCursorPos(centerP.x, centerP.y);
					if(!time_variance&&!timer)
						a_draw();
				}
			}
			m_bypass=!m_bypass;
			return 0;
		}
		void inputLButtonUp(int lParam)
		{
			if(drag)
			{
				if(!shift)
				{
					ReleaseCapture();
					SetCursorPos(mouseP0.x, mouseP0.y);
					ShowCursor(1);
				}
				drag=0;
			}
		}
		int inputMouseWheel(int wParam)
		{
			if(kb['X']&&kb['Y']&&kb['Z'])
			{
				shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, Zoffset, VZ,
					((short*)&wParam)[1]>0	?	DX/100
											:	-DX/100);
			}
			else if(kb[VK_MENU])
			{
					 if(((short*)&wParam)[1]>0)	DX*=1.1;
				else							DX/=1.1;
				function1();
				toSolve=true, shiftOnly=0;
			}
			else if(kb['X'])
			{
				if(((short*)&wParam)[1]>0)
				{
					DX/=1.1, AR_Y/=1.1, AR_Z/=1.1;
					VX/=1.1, VY/=1.1, VZ/=1.1;
					_3d.cam.p.x/=1.1, _3d.cam.p.y/=1.1, _3d.cam.p.z/=1.1, _3d.cam.dcam/=1.1;
				}
				else
				{
					DX*=1.1, AR_Y*=1.1, AR_Z*=1.1;
					VX*=1.1, VY*=1.1, VZ*=1.1;
					_3d.cam.p.x*=1.1, _3d.cam.p.y*=1.1, _3d.cam.p.z*=1.1, _3d.cam.dcam*=1.1;
				}
				function1();
				toSolve=true, shiftOnly=0;
			}
			else if(kb['Y'])
			{
					 if(((short*)&wParam)[1]>0)	AR_Y*=1.1;
				else							AR_Y/=1.1;
				function1();
				toSolve=true, shiftOnly=0;
			}
			else if(kb['Z'])
			{
					 if(((short*)&wParam)[1]>0)	AR_Z*=1.1;
				else							AR_Z/=1.1;
				function1();
				toSolve=true, shiftOnly=0;
			}
			else if(kb[VK_CONTROL])
			{
					 if(((short*)&wParam)[1]>0)	_3d.cam.faster();
				else							_3d.cam.slower();
			}
			else if(kb[VK_SHIFT])
			{
					 if(((short*)&wParam)[1]>0)
				{
					Zplaces=Yplaces=Xplaces+=1<<max_simd_method, toSolve=true, shiftOnly=0;
				}
				else
				{
					if(Xplaces>1<<max_simd_method)
						Zplaces=Yplaces=Xplaces-=1<<max_simd_method, toSolve=true, shiftOnly=0;
				}
			}
			else
			{
					 if(((short*)&wParam)[1]>0)	_3d.cam.zoomIn();
				else							_3d.cam.zoomOut();
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyDown(int wParam, int lParam)
		{
			switch(wParam)
			{
			case 'W':case 'A':case 'S':case 'D':case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
				if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case VK_ADD:case VK_OEM_PLUS:case VK_RETURN:
				if(kb[VK_CONTROL])
					_3d.cam.faster();
				else if(kb[VK_SHIFT])//increase resolution
				{
					Zplaces=Yplaces=Xplaces+=1<<max_simd_method, toSolve=true, shiftOnly=0;
					break;
				}
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case VK_SUBTRACT:case VK_OEM_MINUS:case VK_BACK:
				if(kb[VK_CONTROL])
					_3d.cam.slower();
				else if(kb[VK_SHIFT])//decrease resolution
				{
					if(Xplaces>1<<max_simd_method)
						Zplaces=Yplaces=Xplaces-=1<<max_simd_method, toSolve=true, shiftOnly=0;
					break;
				}
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case 'X':case 'Y':case 'Z':
				if(!(lParam&1<<30)&&!shift)
				{
					if(!drag)
					{
						GetCursorPos(&mouseP0);
						ShowCursor(0);
						SetCursorPos(centerP.x, centerP.y);
						SetCapture(ghWnd);
					}
					shift=1;
				}
				return 0;
			case VK_OEM_3:
				if(contourOn)//was on
				{
					if(kb[VK_CONTROL])
					{
						//contour+surface
						//contour only
						//flat contour
						//flat+surface
						if(contourFlat)
						{
							if(contourOnly)
								contourOnly=false;//3: surface appears
							else
								contourFlat=false;//4: pops up
						}
						else
						{
							if(contourOnly)
								contourFlat=true;//2: gets flat
							else
								contourOnly=true;//1: surface disappears
						}
					}
					else
						contourOn=false, contourOnly=false, contourFlat=false;
				}
				else//was off
				{
					contourOn=true;
					if(!toSolve)
					{
						Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
						Rlines.clear(), Ilines.clear(), Jlines.clear(), Klines.clear();
						doContour(cursorEx, DX/Xplaces, -DX/2, +DX/2, Xstep, 2);
					}
				}
				break;
			case '0':case VK_NUMPAD0:
				if(operations.size())
					toSolve=true, shiftOnly=0;
				operations.clear();
				break;
			case '1':case VK_NUMPAD1:
			case '2':case VK_NUMPAD2:
			case '3':case VK_NUMPAD3:
			case '4':case VK_NUMPAD4:
			case '5':case VK_NUMPAD5:
			case '6':case VK_NUMPAD6:
			case '7':case VK_NUMPAD7:
			case '8':case VK_NUMPAD8:
				{
					auto op=&Implicit_3D::differentiate_xyz;
					switch(wParam)
					{
					case '1':case VK_NUMPAD1:
							 if(kb['X']){		 if(kb['Y']){		 if(kb['Z'])operations.push_back( 1), op=&Implicit_3D::differentiate_xyz;
																else			operations.push_back( 5), op=&Implicit_3D::differentiate_xy;}
											else			{		 if(kb['Z'])operations.push_back( 7), op=&Implicit_3D::differentiate_xz;
																else			operations.push_back( 2), op=&Implicit_3D::differentiate_x;}}
						else			{		 if(kb['Y']){		 if(kb['Z'])operations.push_back( 6), op=&Implicit_3D::differentiate_yz;
																else			operations.push_back( 3), op=&Implicit_3D::differentiate_y;}
											else			{		 if(kb['Z'])operations.push_back( 4), op=&Implicit_3D::differentiate_z;
																else			operations.push_back( 1), op=&Implicit_3D::differentiate_xyz;}}
						break;
					case '2':case VK_NUMPAD2:
							 if(kb['X']){		 if(kb['Y']){		 if(kb['Z'])operations.push_back( 8), op=&Implicit_3D::integrate_xyz;
																else			operations.push_back(12), op=&Implicit_3D::integrate_xy;}
											else			{		 if(kb['Z'])operations.push_back(14), op=&Implicit_3D::integrate_xz;
																else			operations.push_back( 9), op=&Implicit_3D::integrate_x;}}
						else			{		 if(kb['Y']){		 if(kb['Z'])operations.push_back(13), op=&Implicit_3D::integrate_yz;
																else			operations.push_back(10), op=&Implicit_3D::integrate_y;}
											else			{		 if(kb['Z'])operations.push_back(11), op=&Implicit_3D::integrate_z;
																else			operations.push_back( 8), op=&Implicit_3D::integrate_xyz;}}
						break;
					case '3':case VK_NUMPAD3:	operations.push_back(15), op=&Implicit_3D::discreteFourrierTransform;			break;
					case '4':case VK_NUMPAD4:	operations.push_back(16), op=&Implicit_3D::inverseDiscreteFourrierTransform;	break;
					case '5':case VK_NUMPAD5:
							 if(kb['X']){		 if(kb['Y']){		 if(kb['Z'])operations.push_back(17), op=&Implicit_3D::lowPassFilter_xyz;
																else			operations.push_back(21), op=&Implicit_3D::lowPassFilter_xy;}
											else			{		 if(kb['Z'])operations.push_back(23), op=&Implicit_3D::lowPassFilter_xz;
																else			operations.push_back(18), op=&Implicit_3D::lowPassFilter_x;}}
						else			{		 if(kb['Y']){		 if(kb['Z'])operations.push_back(22), op=&Implicit_3D::lowPassFilter_yz;
																else			operations.push_back(19), op=&Implicit_3D::lowPassFilter_y;}
											else			{		 if(kb['Z'])operations.push_back(20), op=&Implicit_3D::lowPassFilter_z;
																else			operations.push_back(17), op=&Implicit_3D::lowPassFilter_xyz;}}
						break;
					case '6':case VK_NUMPAD6:
							 if(kb['X']){		 if(kb['Y']){		 if(kb['Z'])operations.push_back(24), op=&Implicit_3D::highPassFilter_xyz;
																else			operations.push_back(28), op=&Implicit_3D::highPassFilter_xy;}
											else			{		 if(kb['Z'])operations.push_back(30), op=&Implicit_3D::highPassFilter_xz;
																else			operations.push_back(25), op=&Implicit_3D::highPassFilter_x;}}
						else			{		 if(kb['Y']){		 if(kb['Z'])operations.push_back(29), op=&Implicit_3D::highPassFilter_yz;
																else			operations.push_back(26), op=&Implicit_3D::highPassFilter_y;}
											else			{		 if(kb['Z'])operations.push_back(27), op=&Implicit_3D::highPassFilter_z;
																else			operations.push_back(24), op=&Implicit_3D::highPassFilter_xyz;}}
						break;
					}
					if(!toSolve)
					{
						Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
						Rlines.clear(), Ilines.clear(), Jlines.clear(), Klines.clear();
						(this->*op)(expr[cursorEx].n[0].ndr);
						if(contourOn)
							doContour(cursorEx, DX/Xplaces, -DX/2, +DX/2, Xstep, 2);
					}
				}
				break;
			case 'C':
				clearScreen=!clearScreen;
				break;
			case 'E':
				{
					double r=20/DX;
					VX*=r, VY*=r, VZ*=r;
					_3d.cam.p.x*=r, _3d.cam.p.y*=r, _3d.cam.p.z*=r, _3d.cam.dcam*=r;
					DX=20, AR_Y=1, AR_Z=1, function1();
					toSolve=true, shiftOnly=0;
				}
				break;
			case 'R':
				_3d.cam.dcam=.04;
				if(!kb[VK_CONTROL])
					DX=20, AR_Y=1, AR_Z=1, function1(), Xplaces=Yplaces=Zplaces=10;
				if(VX!=0||VY!=0||VZ!=0)
					VX=VY=VZ=0;
				toSolve=true, shiftOnly=0;
				if(kb['X'])
					_3d.teleport_degrees(20, 0, 0, 180, 0, 1);
				else if(kb['Y'])
					_3d.teleport_degrees(0, 20, 0, 270, 0, 1);
				else if(kb['Z'])
					_3d.teleport_degrees(0, 0, 20, 90, 270, 1);
				else
					_3d.teleport_degrees(20, 20, 20, 225, 324.7356103172454, 1);
				//	_3d.teleport_degrees(4, 4, 4, 225, 324.7356103172454, 1);
				break;
			default:
				if(lParam&1<<30)
					return 0;
				break;
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyUp(int wParam)
		{
			switch(wParam)
			{
			case 'W':case 'A':case 'S':case 'D':case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:
				if(kp>0)
					--kp;
				break;
			case VK_ADD:case VK_SUBTRACT://numpad
			case VK_OEM_PLUS:case VK_OEM_MINUS:
			case VK_RETURN:case VK_BACK:
				if(!kb[VK_CONTROL]&&kp>0)
					--kp;
				return 0;
			case 'X':
				if(!kb['Y']&&!kb['Z']&&shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;
			case 'Y':
				if(!kb['X']&&!kb['Z']&&shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;
			case 'Z':
				if(!kb['X']&&!kb['Y']&&shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;
		/*	case 'X':case 'Y':case 'Z':
				if(shift)
				{
					if(!drag)
					{
						ReleaseCapture();
						SetCursorPos(mouseP0.x, mouseP0.y);
						ShowCursor(1);
					}
					shift=0;
				}
				return 0;*/
			}
			return 0;
		}
		void function1()
		{
			double t=100*DX/w;
			Xstep=exp(floor(log10(t))*log(10));
			switch(int(t/Xstep))
			{
			case 1:Xstep*=1;break;
			case 2:Xstep*=2;break;
			case 3:Xstep*=2;break;
			case 4:Xstep*=2;break;
			case 5:Xstep*=5;break;
			case 6:Xstep*=5;break;
			case 7:Xstep*=5;break;
			case 8:Xstep*=5;break;
			case 9:Xstep*=5;break;
			default:Xstep*=6;break;
			}
			if(AR_Y==1)
				Ystep=Xstep;
			else
			{
				double t=100*DX/(w*AR_Y);
				Ystep=exp(floor(log10(t))*log(10));
				switch(int(t/Ystep))
				{
				case 1:Ystep*=1;break;
				case 2:Ystep*=2;break;
				case 3:Ystep*=2;break;
				case 4:Ystep*=2;break;
				case 5:Ystep*=5;break;
				case 6:Ystep*=5;break;
				case 7:Ystep*=5;break;
				case 8:Ystep*=5;break;
				case 9:Ystep*=5;break;
				default:Ystep*=6;break;
				}
			}
			if(AR_Z==1)
				Zstep=Xstep;
			else
			{
				double t=100*DX/(w*AR_Z);
				Zstep=exp(floor(log10(t))*log(10));
				switch(int(t/Zstep))
				{
				case 1:Zstep*=1;break;
				case 2:Zstep*=2;break;
				case 3:Zstep*=2;break;
				case 4:Zstep*=2;break;
				case 5:Zstep*=5;break;
				case 6:Zstep*=5;break;
				case 7:Zstep*=5;break;
				case 8:Zstep*=5;break;
				case 9:Zstep*=5;break;
				default:Zstep*=6;break;
				}
			}
		}
		void draw()
		{
			double DY=DX/AR_Y, DZ=DX/AR_Z;
			auto &ex=expr[cursorEx];
			{
				bool changed=false;
				if(toSolve)
				{
					if(!operations.size()&&shiftOnly==1&&abs(Xoffset)<Xplaces&&abs(Yoffset)<Yplaces&&abs(Zoffset)<Zplaces)
					{
						solver.partial_bounds(VX, DX, VY/AR_Y, DY, VZ/AR_Z, DZ, Xoffset, Yoffset, Zoffset);
						solver.synchronize();
						(solver.*(ex.nITD?&Solve_3D::full:solver.partial))(ex);
					}
					else
					{
						auto old_time_variance=time_variance;
						time_variance=false;
						labels.clear();
					//	Xplaces=Yplaces=Zplaces=
					//		50//2//4//8//10//50
					//		;
						solver.full_resize(VX, DX, VY/AR_Y, DY, VZ/AR_Z, DZ, Xplaces, Yplaces, Zplaces);
						XsamplePos=std::floor(XshiftPoint/solver.Xsample);
						YsamplePos=std::floor(YshiftPoint/solver.Ysample);
						ZsamplePos=std::floor(ZshiftPoint/solver.Zsample);

					//	KXplaces=Xplaces/100?Xplaces/100:1, KYplaces=Yplaces/100?Yplaces/100:1, KZplaces=Zplaces/100?Zplaces/100:1;
						time_variance|=ex.nITD;
						labels.fill(cursorEx);
						if(!paused)
							solver.synchronize();
						solver.full(ex);
						doOperations(ex.n[0].ndr);
						if(time_variance)
						{
							if(!paused)
								SetTimer(ghWnd, 0, 10, 0);
						}
						else if(old_time_variance&&!timer)
							KillTimer(ghWnd, 0);
					}
					toSolve=false, shiftOnly=2, Xoffset=Yoffset=Zoffset=0;
					changed=true;
				}
				else if(time_variance)
				{
					if(!paused)
						solver.synchronize();
					solver.full(ex);
					doOperations(ex.n[0].ndr);
					changed=true;
				}
				if(changed)
				{
					solver.updateRGB(ex);
				//	solver.updateRGB(ex.n[0]);
					if(contourOn)
					{
						Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
						Rlines.clear(), Ilines.clear(), Jlines.clear(), Klines.clear();
						doContour(cursorEx, DX/Xplaces, -DX/2, +DX/2, Xstep, 2);
					}
				}
			}
			
			_3d.newFrame();
			if(!clearScreen)
				_3dMode_DrawGridNAxes(_3d, VX, VY, VZ, DX, Xstep, AR_Y*Ystep, AR_Z*Zstep, AR_Y, AR_Z);
			if(!contourOnly)//draw the points
			{
				double Xstart=VX-DX/2, Xr=DX/Xplaces, Ystart=VY-DX/2, Ysample=DX/Yplaces, Zstart=VZ-DX/2, Zr=DX/Zplaces;
				auto ndrIT=ex.n[0].ndr.begin();
				unsigned v=0;
				switch(ex.resultMathSet)
				{
				case 'R':case 'c':
					for(int k=0;k<Zplaces;++k)
						for(int k2=0;k2<Yplaces;++k2)
							for(int k3=0;k3<Xplaces;++k3, ++ndrIT, ++v)
								_3d.point(Xstart+Xr*k3, Ystart+Ysample*k2, Zstart+Zr*k, solver.ndr_rgb[v]);
							//	_3d.textIn3D(Xstart+Xr*k3, Ystart+Ysample*k2, Zstart+Zr*k, OPAQUE, "%g", ndrIT->r);
					break;
				case 'h':
					for(int k=0;k<Zplaces;++k)
						for(int k2=0;k2<Yplaces;++k2)
							for(int k3=0;k3<Xplaces;++k3, ++ndrIT, ++v)
								_3d.point(Xstart+Xr*k3, Ystart+Ysample*k2, Zstart+Zr*k, solver.ndr_rgb[v], solver.ndr_rgb_i[v], solver.ndr_rgb_j[v], solver.ndr_rgb_k[v]);
					break;
				}
			}
			if(contourOn)//draw the contour
			{
			//	draw_contourGrid(DX/Xplaces);
				switch(ex.resultMathSet)
			//	switch(ex.n[0].mathSet)
			//	switch(ex.n[0].ndrMathType)
				{
				case 'R':
					draw_contour(Rcontours, Rlines, rColor);
					break;
				case 'c':
					draw_contour(Rcontours, Rlines, rColor);
					draw_contour(Icontours, Ilines, iColor);
					break;
				case 'h':
					draw_contour(Rcontours, Rlines, rColor);
					draw_contour(Icontours, Ilines, iColor);
					draw_contour(Icontours, Ilines, jColor);
					draw_contour(Icontours, Ilines, kColor);
					break;
				}
			}
			if(!clearScreen)
			{
				int bkMode=GetBkMode(ghMemDC);
				SetBkMode(ghMemDC, TRANSPARENT);
					for(double X=floor((VX-DX/2)/Xstep)*Xstep+Xstep, Xend=ceil((VX+DX/2)/Xstep)*Xstep;X<Xend;X+=Xstep)
						if(abs(X)>Xstep/2)
							_3d.label(X, VY, VZ, "%g", X);
					if(AR_Y==1)
					{
						for(double Y=floor((VY-DX/2)/Ystep)*Ystep+Ystep, Yend=ceil((VY+DX/2)/Ystep)*Ystep;Y<Yend;Y+=Ystep)
							if(Y<-Ystep/2||Y>Ystep/2)
								_3d.label(VX, Y, VZ, "%g", Y);
					}
					else
					{
						double aYstep=AR_Y*Ystep, Ycore=floor((VY-DX/2)/aYstep);
						for(double Y=Ycore*aYstep+aYstep, Yend=ceil((VY+DX/2)/aYstep)*aYstep, aY=Ycore*Ystep+Ystep;Y<Yend;Y+=aYstep, aY+=Ystep)
							if(Y<-aYstep/2||Y>aYstep/2)
								_3d.label(VX, Y, VZ, "%g", aY);
					}
					if(AR_Z==1)
					{
						for(double Z=floor((VZ-DX/2)/Zstep)*Zstep+Zstep, Zend=ceil((VZ+DX/2)/Zstep)*Zstep;Z<Zend;Z+=Zstep)
							if(Z<-Zstep/2||Z>Zstep/2)
								_3d.label(VX, VY, Z, "%g", Z);
					}
					else
					{
						double aZstep=AR_Z*Zstep, Zcore=floor((VZ-DX/2)/aZstep);
						for(double Z=Zcore*aZstep+aZstep, Zend=ceil((VZ+DX/2)/aZstep)*aZstep, aZ=Zcore*Zstep+Zstep;Z<Zend;Z+=aZstep, aZ+=Zstep)
							if(Z<-aZstep/2||Z>aZstep/2)
								_3d.label(VX, VY, Z, "%g", aZ);
					}
				_3d.arrowLabels(0, 0, 0, 1, 0, 0, labels.Xlabels);
				_3d.arrowLabels(0, 0, 0, 0, 1, 0, labels.Ylabels);
				_3d.arrowLabels(0, 0, 0, 0, 0, 1, labels.Zlabels);
				{
					int Ys=0;
					for(auto &label:labels.Clabels)
					{
						int linelen=sprintf_s(g_buf, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
						TextOutA(ghMemDC, w-const_label_offset_X, Ys, g_buf, linelen), Ys+=16;
					}
				}
				{
					int k=0, Y=h-operations.size()*16;
					for(auto operation:operations)
					{
						char const *a=0;
						switch(operation)
						{
						case  1:a="%d: Differentiate XYZ";	break;
						case  2:a="%d: Differentiate X";	break;
						case  3:a="%d: Differentiate Y";	break;
						case  4:a="%d: Differentiate Z";	break;
						case  5:a="%d: Differentiate XY";	break;
						case  6:a="%d: Differentiate YZ";	break;
						case  7:a="%d: Differentiate XZ";	break;
						case  8:a="%d: Integrate XYZ";		break;
						case  9:a="%d: Integrate X";		break;
						case 10:a="%d: Integrate Y";		break;
						case 11:a="%d: Integrate Z";		break;
						case 12:a="%d: Integrate XY";		break;
						case 13:a="%d: Integrate YZ";		break;
						case 14:a="%d: Integrate XZ";		break;
						case 15:a="%d: DFT";				break;
						case 16:a="%d: IDFT";				break;
						case 17:a="%d: LPF";				break;
						case 18:a="%d: LPF X";				break;
						case 19:a="%d: LPF Y";				break;
						case 20:a="%d: LPF Z";				break;
						case 21:a="%d: LPF XY";				break;
						case 22:a="%d: LPF YZ";				break;
						case 23:a="%d: LPF XZ";				break;
						case 24:a="%d: HPF";				break;
						case 25:a="%d: HPF X";				break;
						case 26:a="%d: HPF Y";				break;
						case 27:a="%d: HPF Z";				break;
						case 28:a="%d: HPF XY";				break;
						case 29:a="%d: HPF YZ";				break;
						case 30:a="%d: HPF XZ";				break;
						}
						_3d.textIn2D(w-const_label_offset_X, Y, OPAQUE, a, k);
						++k, Y+=16;
					}
				}
				SetBkMode(ghMemDC, bkMode);
				_3d.text_show();
			}
			else
				_3d.text_show();
			//	_3d.text_dump();
		}
		void i_draw();
		void a_draw();
	} ti3d;
	void			Implicit_3D::i_draw()
	{
		draw();
		
		font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
		{
			int bkMode=GetBkMode(ghMemDC);
			SetBkMode(ghMemDC, OPAQUE);
			itb.draw();
			SetBkMode(ghMemDC, bkMode);
		}
		font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	
		Performance(0, h-32);//
		BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
	}
	void			Implicit_3D::a_draw()
	{
		Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);

		draw();
		
		if(!clearScreen)
			Performance(0, h-32);//
		BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
	}
#endif
	namespace contour
	{
		struct Double_X_Y_Z_V
		{
			double X, Y, Z, V;
			Double_X_Y_Z_V(){}
			Double_X_Y_Z_V(double X, double Y, double Z, double V):X(X), Y(Y), Z(Z), V(V){}
			void operator()(double X, double Y, double Z, double V){this->X=X, this->Y=Y, this->Z=Z, this->V=V;}
		};
		struct Double_X_Y_Z
		{
			double X, Y, Z;
			Double_X_Y_Z(double X, double Y, double Z):X(X), Y(Y), Z(Z){}
		};
		void solve_cubic(double a, double b, double c, double d, double &r1, std::complex<double> &r2, std::complex<double> &r3)
		{
			//http://easycalculation.com/algebra/learn-cubic-equation.php
			//http://stackoverflow.com/questions/13328676/c-solving-cubic-equations
			if(a==0)
			{
				r1=_HUGE;
				solve_quadratic(b, c, d, r2, r3);
			}
			else if(d==0)
			{
				r1=0;
				solve_quadratic(a, b, c, r2, r3);
			}
			else
			{
				b/=a, c/=a, d/=a;
				double disc, q, r, dum1, s, t, term1, r13;
				q=(3.0*c-(b*b))/9.0;
				r=-(27.0*d)+b*(9.0*c-2.0*(b*b));
				r/=54.0;
				disc=q*q*q+r*r;
				term1=b/3;
				if(disc>0)
				{
					s=r+std::sqrt(disc);
					s=s<0?-std::pow(-s, 1./3):std::pow(s, 1./3);
					t=r-std::sqrt(disc);
					t=t<0?-std::pow(-t, 1./3):std::pow(t, 1./3);
					r1=-term1+s+t;//The first root is always real
					term1+=(s+t)/2;
					double term2=G2::_sqrt3*(-t+s)/2;
					r2=std::complex<double>(-term1, term2);
					r3=std::complex<double>(-term1, -term2);
				}
				else if(disc==0)//The remaining options are all real
				{
					r13=r<0?-std::pow(-r, 1./3):std::pow(r, 1./3);
					r1=-term1+2*r13;
					r3=r2=-(r13+term1);//at least two are equal
				}
				else//Only option left is that all roots are real and unequal (to get here, q < 0)
				{
					q = -q;
					dum1 = q*q*q;
					dum1 = std::acos(r/std::sqrt(dum1));
					r13 = 2.0*std::sqrt(q);
					r1=-term1+r13*std::cos(dum1/3);
					r2=-term1+r13*std::cos((dum1+2*G2::_pi)/3);
					r3=-term1+r13*std::cos((dum1+4*G2::_pi)/3);
				}
			}
		}
	}
	int n_components_in_current_expr()
	{
		int nComponents=0;
		switch(expr[cursorEx].resultMathSet)//function
		{
		case 'R':nComponents=1;break;
		case 'c':nComponents=2;break;
		case 'h':nComponents=4;break;
		}
		return nComponents;
	}
	void apply_kernel_comp(Term &n, int component, const double *kernel, int Xplaces, int Yplaces, int Zplaces, int ndrSize)
	{
		auto ndr=(double*)(&n.r)[component].p;
		AVector_v4d temp(ndrSize);
		auto t=(double*)temp.p;
		int XYplaces=Xplaces*Yplaces;
		for(int kz=0;kz<Zplaces;++kz)
		{
			for(int ky=0;ky<Yplaces;++ky)
			{
				for(int kx=0;kx<Xplaces;++kx)	//27n^3 muls
				{
					int idx=Yplaces*(Xplaces*kz+ky)+kx;
					int kz_1=kz-1+Zplaces, kz1=kz+1,
						ky_1=ky-1+Yplaces, ky1=ky+1,
						kx_1=kz-1+Xplaces, kx1=kx+1;
					kz_1-=Zplaces&-(kz_1>=Zplaces), kz1-=Zplaces&-(kz1>=Zplaces);
					ky_1-=Yplaces&-(ky_1>=Yplaces), ky1-=Yplaces&-(ky1>=Yplaces);
					kx_1-=Xplaces&-(kx_1>=Xplaces), kx1-=Xplaces&-(kx1>=Xplaces);
						kz_1*=XYplaces, ky_1*=Xplaces;
					int kz_0=kz*XYplaces, ky_0=ky*Xplaces;
						kz1*=XYplaces, ky1*=Xplaces;
					t[idx]=
						kernel[ 0]*ndr[kz_1+ky_1+kx_1]+kernel[ 1]*ndr[kz_1+ky_1+kx]+kernel[ 2]*ndr[kz_1+ky_1+kx1]+
						kernel[ 3]*ndr[kz_1+ky_0+kx_1]+kernel[ 4]*ndr[kz_1+ky_0+kx]+kernel[ 5]*ndr[kz_1+ky_0+kx1]+
						kernel[ 6]*ndr[kz_1+ky1 +kx_1]+kernel[ 7]*ndr[kz_1+ky1 +kx]+kernel[ 8]*ndr[kz_1+ky1 +kx1]+

						kernel[ 9]*ndr[kz_0+ky_1+kx_1]+kernel[10]*ndr[kz_0+ky_1+kx]+kernel[11]*ndr[kz_0+ky_1+kx1]+
						kernel[12]*ndr[kz_0+ky_0+kx_1]+kernel[13]*ndr[kz_0+ky_0+kx]+kernel[14]*ndr[kz_0+ky_0+kx1]+
						kernel[15]*ndr[kz_0+ky1 +kx_1]+kernel[16]*ndr[kz_0+ky1 +kx]+kernel[17]*ndr[kz_0+ky1 +kx1]+

						kernel[18]*ndr[kz1 +ky_1+kx_1]+kernel[19]*ndr[kz1 +ky_1+kx]+kernel[20]*ndr[kz1 +ky_1+kx1]+
						kernel[21]*ndr[kz1 +ky_0+kx_1]+kernel[22]*ndr[kz1 +ky_0+kx]+kernel[23]*ndr[kz1 +ky_0+kx1]+
						kernel[24]*ndr[kz1 +ky1 +kx_1]+kernel[25]*ndr[kz1 +ky1 +kx]+kernel[26]*ndr[kz1 +ky1 +kx1];
				}
			}
		}
		(&n.r)[component]=std::move(temp);
	}
	void apply_kernel(const double *kernel, int Xplaces, int Yplaces, int Zplaces, int ndrSize)
	{
		int nComponents=n_components_in_current_expr();
		for(int c=0;c<nComponents;++c)
			apply_kernel_comp(expr[cursorEx].n[expr[cursorEx].resultTerm], c, kernel, Xplaces, Yplaces, Zplaces, ndrSize);
	}
	void _3d_contour_to_clipboard(std::unordered_map<int, std::list<_3D::Triangle>> &contour)
	{
		std::stringstream LOL_1;
		LOL_1<<"(X1, Y1, Z1)\t\t(X2, Y2, Z2)\t\t(X3, Y3, Z3)\r\n";
		for(auto level=contour.begin();level!=contour.end();++level)
		{
			LOL_1<<level->first<<":\r\n";
			for(auto trgl=level->second.begin();trgl!=level->second.end();++trgl)
			{
				LOL_1
					<<"("<<trgl->a.x<<", "<<trgl->a.y<<", "<<trgl->a.z<<")\t"
					<<"("<<trgl->b.x<<", "<<trgl->b.y<<", "<<trgl->b.z<<")\t"
					<<"("<<trgl->c.x<<", "<<trgl->c.y<<", "<<trgl->c.z<<")\r\n";
				//LOL_1
				//	<<"("<<trgl->X1<<", "<<trgl->Y1<<", "<<trgl->Z1<<")\t"
				//	<<"("<<trgl->X2<<", "<<trgl->Y2<<", "<<trgl->Z2<<")\t"
				//	<<"("<<trgl->X3<<", "<<trgl->Y3<<", "<<trgl->Z3<<")\r\n";
			}
			LOL_1<<"\r\n";
		}
		copy_to_clipboard(LOL_1.str());
	}
	void test_drawcube(_3D &_3d, double x1, double x2, double y1, double y2, double z1, double z2)
	{
		_3d.line(dvec3(x1, y1, z1), dvec3(x2, y1, z1));//bottom
		_3d.line(dvec3(x1, y2, z1), dvec3(x2, y2, z1));
		_3d.line(dvec3(x1, y1, z1), dvec3(x1, y2, z1));
		_3d.line(dvec3(x2, y1, z1), dvec3(x2, y2, z1));

		_3d.line(dvec3(x1, y1, z1), dvec3(x1, y1, z2));//vertical edges
		_3d.line(dvec3(x1, y2, z1), dvec3(x1, y2, z2));
		_3d.line(dvec3(x2, y1, z1), dvec3(x2, y1, z2));
		_3d.line(dvec3(x2, y2, z1), dvec3(x2, y2, z2));

		_3d.line(dvec3(x1, y1, z2), dvec3(x2, y1, z2));//top
		_3d.line(dvec3(x1, y2, z2), dvec3(x2, y2, z2));
		_3d.line(dvec3(x1, y1, z2), dvec3(x1, y2, z2));
		_3d.line(dvec3(x2, y1, z2), dvec3(x2, y2, z2));
	}
	void test_drawtetrahedra(_3D &_3d, double x1, double x2, double y1, double y2, double z1, double z2)
	{
		_3d.line(dvec3(x1, y1, z1), dvec3(x2, y2, z1));//bottom
		_3d.line(dvec3(x1, y1, z2), dvec3(x2, y2, z2));//top

		_3d.line(dvec3(x1, y1, z1), dvec3(x2, y1, z2));//south
		_3d.line(dvec3(x1, y2, z1), dvec3(x2, y2, z2));//north

		_3d.line(dvec3(x1, y1, z1), dvec3(x1, y2, z2));//west
		_3d.line(dvec3(x2, y1, z1), dvec3(x2, y2, z2));//east

		_3d.line(dvec3(x1, y1, z1), dvec3(x2, y2, z2));//diagonal
	}
	int test_nvertices=0, test_ntriangles=0;
	class		Color_3D:public _3D_Mode
	{
	public:
		Scale vs;//4th dimension for contour
		int Xoffset, Yoffset, Zoffset;
		int X0, Y0;

		int Xplaces, Yplaces, Zplaces;
		double XshiftPoint, YshiftPoint, ZshiftPoint;
		double XsamplePos, YsamplePos, ZsamplePos;

		Solve_3D solver;
		std::list<int> operations;

		bool contourOn, contourOnly, contourFlat, contourWireframe;
		std::map<unsigned, std::unordered_map<int, Surface>>
	//	std::map<unsigned, std::unordered_map<int, std::list<_3D::Triangle>>>
			Rcontours,//contours[e]=contour, contour[r level (r/step)]=triangles, *triangles.begin()=triangle
			Icontours,//contours[e]=contour, contour[i level (i/step)]=triangles, *triangles.begin()=triangle
			Jcontours,//contours[e]=contour, contour[j level (j/step)]=triangles, *triangles.begin()=triangle
			Kcontours;//contours[e]=contour, contour[k level (k/step)]=triangles, *triangles.begin()=triangle
		std::map<unsigned, std::unordered_map<int, std::list<_3D::Stick>>>
			Rlines,//contours[e]=contour, contour[r level (r/step)]=sticks, *sticks.begin()=stick
			Ilines,//contours[e]=contour, contour[i level (i/step)]=sticks, *sticks.begin()=stick
			Jlines,//contours[e]=contour, contour[j level (j/step)]=sticks, *sticks.begin()=stick
			Klines;//contours[e]=contour, contour[k level (k/step)]=sticks, *sticks.begin()=stick
		
		bool clearScreen, kb_VK_F6_msg;
		Labels_3D labels;
		static const int rColor=0, iColor=0x00EF0000, jColor=0x0000EF00, kColor=0x000000EF;
		_3D _3d;
		int gridColor;
		static const int modes[], nmodes;

		Color_3D():
			vs(0, 20),
			solver(xs, ys, zs), _3D_Mode(solver),
		//	Xplaces(20), Yplaces(20), Zplaces(5),
			Xplaces(8), Yplaces(8), Zplaces(8),
		//	Xplaces(4), Yplaces(4), Zplaces(4),
			XshiftPoint(0), YshiftPoint(0), ZshiftPoint(0),
			XsamplePos(0), YsamplePos(0), ZsamplePos(0),
			_3d(20, 20, 20, 225*G2::_pi/180, 324.7356103172454*G2::_pi/180, 1),
			gridColor(_3dGridColor),
			Xoffset(0), Yoffset(0),
			contourOn(false), contourOnly(false), contourFlat(false), contourWireframe(false),
			clearScreen(false), kb_VK_F6_msg(false)
		{}
		
		void draw_contour_debuggrid(int color)
		{
			_3d.lineColor=color;//draw 3D grid
			double
				Xstart=xs.VX-xs.DX*0.5, Xend=xs.VX+xs.DX*0.5, Xsample=xs.DX/xs.Xplaces,
				Ystart=ys.VX-ys.DX*0.5, Yend=ys.VX+ys.DX*0.5, Ysample=ys.DX/ys.Xplaces,
				Zstart=zs.VX-zs.DX*0.5, Zend=zs.VX+zs.DX*0.5, Zsample=zs.DX/zs.Xplaces;
			for(int ky=0;ky<=Yplaces;++ky)
			{
				for(int kx=0;kx<=Xplaces;++kx)//draw vertical lines
				{
					double x=Xstart+kx*Xsample, y=Ystart+ky*Ysample;
					_3d.line(dvec3(x, y, Zstart), dvec3(x, y, Zend));
				}
			}
			for(int kz=0;kz<=Zplaces;++kz)
			{
				for(int kx=0;kx<=Xplaces;++kx)//draw N-S lines
				{
					double x=Xstart+kx*Xsample, z=Zstart+kz*Zsample;
					_3d.line(dvec3(x, Ystart, z), dvec3(x, Yend, z));
				}
			}
			for(int kz=0;kz<=Zplaces;++kz)
			{
				for(int ky=0;ky<=Yplaces;++ky)//draw E-W lines
				{
					double y=Ystart+ky*Ysample, z=Zstart+kz*Zsample;
					_3d.line(dvec3(Xstart, y, z), dvec3(Xend, y, z));
				}
			}
		}
		void draw_contour(std::map<unsigned, std::unordered_map<int, Surface>> &contours, std::map<unsigned, std::unordered_map<int, std::list<_3D::Stick>>> &lines, unsigned lineColor)
	//	void draw_contour(std::map<unsigned, std::unordered_map<int, std::list<_3D::Triangle>>> &contours, std::map<unsigned, std::unordered_map<int, std::list<_3D::Stick>>> &lines, unsigned lineColor)
		{
		//	static unsigned char cc=0;
			auto &contour=contours[cursorEx];
			if(usingOpenGL)
				GL2_L3D::begin();
			_3d.lineColor=0xFF00FF00;
			int k2=0;
			test_nvertices=test_ntriangles=0;
			for(auto cit=contour.begin();cit!=contour.end();++cit)//for each level
			{
				auto &L=cit->first;//level in ticks
			//	auto &L=*cit;
				double RL=vs.ticks2dist(L);//level value in real units
			//	double RL=vs.ticks2dist(L.first);
			//	double RL=vs.ticks2dist(10*L.first);
				int color=colorFunction_r(RL);
				if(!color)
					color=0x00D0D0D0;
			//	int idx=0;
				auto &S=cit->second;
				test_nvertices+=S.vertices.size(), test_ntriangles+=S.indices.size()/3;//
			//	_3d.render_solid_transparent(vec3(10, 0, 0), vec3(0, 10, 0), vec3(0, 0, 10), color);
				if(usingOpenGL)
				{
				//	++k2;
				//	if(k2<4)
				//		continue;
					GL2_L3D::push_surface(S.vertices.data(), S.vertices.size(), S.indices.data(), S.indices.size(), color);
				//	GL2_L3D::push_surface(S.vertices.data(), S.vertices.size(), S.indices.data(), S.indices.size(), swap_rb(color));
				//	break;
				}
				else// if(RL==-600)//
				{
					for(int k=0, kEnd=S.indices.size();k<kEnd;k+=3)
				//	for(auto pit=L.second.begin();pit!=L.second.end();++pit)
				//	for(auto pit=L.second.begin();pit!=L.second.end();++pit, ++idx, cc+=9)
					{
						render_solid_transparent(_3d.cam, S.vertices[S.indices[k]], S.vertices[S.indices[k+1]], S.vertices[S.indices[k+2]], usingOpenGL?swap_rb(color):color);
						_3d.line((dvec3)S.vertices[S.indices[k  ]], (dvec3)(S.vertices[S.indices[k  ]]+0.1f*S.vertices[S.indices[k  ]+1]));//draw normals
						_3d.line((dvec3)S.vertices[S.indices[k+1]], (dvec3)(S.vertices[S.indices[k+1]]+0.1f*S.vertices[S.indices[k+1]+1]));
						_3d.line((dvec3)S.vertices[S.indices[k+2]], (dvec3)(S.vertices[S.indices[k+2]]+0.1f*S.vertices[S.indices[k+2]+1]));
					//	render_solid_transparent(_3d.cam, S.vertices[S.indices[k]], S.vertices[S.indices[k+1]], S.vertices[S.indices[k+2]], color);
					//	render_solid_transparent(_3d.cam, (vec3)S.vertices[S.indices[k]], (vec3)S.vertices[S.indices[k+1]], (vec3)S.vertices[S.indices[k+2]], color);
					//	_3d.render_solid_transparent(S.vertices[S.indices[k]], S.vertices[S.indices[k+1]], S.vertices[S.indices[k+2]], color);
					//	auto &p=*pit;
					//	_3d.render_solid_transparent(p.a, p.b, p.c, color);

					//	double a=0.1*idx;
					//	_3d.triangle_halfTransparent(p.X1+a, p.Y1+a, p.Z1+a, p.X2+a, p.Y2+a, p.Z2+a, p.X3+a, p.Y3+a, p.Z3+a, (cc>>1)<<16|cc<<8|unsigned char(~cc));//DEBUG: detect overlap
					//	_3d.triangle_halfTransparent(p.X1+a, p.Y1+a, p.Z1+a, p.X2+a, p.Y2+a, p.Z2+a, p.X3+a, p.Y3+a, p.Z3+a, rand()<<16|rand());

					//	_3d.render_solid_transparent(vec3((float)p.X1, (float)p.Y1, (float)p.Z1), vec3((float)p.X2, (float)p.Y2, (float)p.Z2), vec3((float)p.X3, (float)p.Y3, (float)p.Z3), color);
					//	_3d.triangle_halfTransparent(p, color);
					}
				}
				if(S.vertices.size())//print level value
				{
					auto &vk=S.vertices[0];
					_3d.label(vk.x, vk.y, vk.z, "%g", RL);
				}
				//for(int k=0, kEnd=S.vertices.size();k<kEnd;k+=2)//print vertex idx
				//{
				//	auto &vk=S.vertices[k];
				////	_3d.label(vk.x, vk.y, vk.z, "%g: %d", RL, k>>1);
				//	_3d.label(vk.x, vk.y, vk.z+rand()*(0.1/RAND_MAX), "%g: %d", RL, k>>1);
				//}
			}
			if(usingOpenGL)
			{
				GL2_L3D::end();
				vec3 lightPos=_3d.cam.p;
				GL2_L3D::draw(_3d.cam, lightPos);
			}
			//_3d.lineColor=0xFFFF00FF;
			//for(auto cit=g_contour.begin();cit!=g_contour.end();++cit)//face normals
			//{
			//	auto &S=cit->second;
			//	for(int k=0, kEnd=S.t.size();k<kEnd;++k)
			//	{
			//		auto &tk=S.t[k];
			//		vec3 center=(S.v[tk.a].v+S.v[tk.b].v+S.v[tk.c].v)*(1.f/3);
			//		_3d.line(dvec3(center), (dvec3)(center+tk.n));
			//	}
			//}
			_3d.lineColor=lineColor;
			if(contourWireframe)
			{
				for(auto level=contour.begin();level!=contour.end();++level)//contour mesh
				{
					auto &S=level->second;
					for(int k=0, kEnd=S.indices.size();k<kEnd;k+=3)
					{
						_3d.line((dvec3)S.vertices[S.indices[k  ]], (dvec3)S.vertices[S.indices[k+1]]);
						_3d.line((dvec3)S.vertices[S.indices[k+1]], (dvec3)S.vertices[S.indices[k+2]]);
						_3d.line((dvec3)S.vertices[S.indices[k+2]], (dvec3)S.vertices[S.indices[k  ]]);
					}
					//for(auto &p=level->second.begin();p!=level->second.end();++p)
					//{
					//	_3d.line(p->a.x, p->a.y, p->a.z,	p->b.x, p->b.y, p->b.z);
					//	_3d.line(p->b.x, p->b.y, p->b.z,	p->c.x, p->c.y, p->c.z);
					//	_3d.line(p->c.x, p->c.y, p->c.z,	p->a.x, p->a.y, p->a.z);
					//	//_3d.line(p->X1, p->Y1, p->Z1, p->X2, p->Y2, p->Z2);
					//	//_3d.line(p->X2, p->Y2, p->Z2, p->X3, p->Y3, p->Z3);
					//	//_3d.line(p->X3, p->Y3, p->Z3, p->X1, p->Y1, p->Z1);
					//}
				}
				draw_contour_debuggrid(0xFFFF00FF);
				//test
#if 0
				double x=xs.VX, y=ys.VX, z=zs.VX+zs.DX;
				//draw cube
				_3d.lineColor=0xFF0000FF;//red
				test_drawcube(_3d, x-1, x+1, y-1, y+1, z-1, z+1);
				//_3d.line(dvec3(x-1, y-1, z-1), dvec3(x+1, y-1, z-1));//bottom
				//_3d.line(dvec3(x-1, y+1, z-1), dvec3(x+1, y+1, z-1));
				//_3d.line(dvec3(x-1, y-1, z-1), dvec3(x-1, y+1, z-1));
				//_3d.line(dvec3(x+1, y-1, z-1), dvec3(x+1, y+1, z-1));
				//
				//_3d.line(dvec3(x-1, y-1, z-1), dvec3(x-1, y-1, z+1));//vertical edges
				//_3d.line(dvec3(x-1, y+1, z-1), dvec3(x-1, y+1, z+1));
				//_3d.line(dvec3(x+1, y-1, z-1), dvec3(x+1, y-1, z+1));
				//_3d.line(dvec3(x+1, y+1, z-1), dvec3(x+1, y+1, z+1));
				//
				//_3d.line(dvec3(x-1, y-1, z+1), dvec3(x+1, y-1, z+1));//top
				//_3d.line(dvec3(x-1, y+1, z+1), dvec3(x+1, y+1, z+1));
				//_3d.line(dvec3(x-1, y-1, z+1), dvec3(x-1, y+1, z+1));
				//_3d.line(dvec3(x+1, y-1, z+1), dvec3(x+1, y+1, z+1));

				//draw x's on cube faces
				_3d.lineColor=0xFF00FF00;//green
				_3d.line(dvec3(x-1, y-1, z-1), dvec3(x+1, y+1, z-1));//bottom
				_3d.line(dvec3(x-1, y+1, z-1), dvec3(x+1, y-1, z-1));
				_3d.line(dvec3(x-1, y-1, z+1), dvec3(x+1, y+1, z+1));//top
				_3d.line(dvec3(x-1, y+1, z+1), dvec3(x+1, y-1, z+1));

				_3d.line(dvec3(x-1, y-1, z-1), dvec3(x+1, y-1, z+1));//south
				_3d.line(dvec3(x-1, y-1, z+1), dvec3(x+1, y-1, z-1));
				_3d.line(dvec3(x-1, y+1, z-1), dvec3(x+1, y+1, z+1));//north
				_3d.line(dvec3(x-1, y+1, z+1), dvec3(x+1, y+1, z-1));

				_3d.line(dvec3(x-1, y-1, z-1), dvec3(x-1, y+1, z+1));//west
				_3d.line(dvec3(x-1, y+1, z-1), dvec3(x-1, y-1, z+1));
				_3d.line(dvec3(x+1, y-1, z-1), dvec3(x+1, y+1, z+1));//east
				_3d.line(dvec3(x+1, y+1, z-1), dvec3(x+1, y-1, z+1));

				//draw tetrahedra
				_3d.lineColor=0xFFFF0000;//blue
				_3d.line(dvec3(x-1, y, z), dvec3(x, y-1, z));//xy
				_3d.line(dvec3(x, y-1, z), dvec3(x+1, y, z));
				_3d.line(dvec3(x+1, y, z), dvec3(x, y+1, z));
				_3d.line(dvec3(x, y+1, z), dvec3(x-1, y, z));

				_3d.line(dvec3(x, y-1, z), dvec3(x, y, z-1));//yz
				_3d.line(dvec3(x, y, z-1), dvec3(x, y+1, z));
				_3d.line(dvec3(x, y+1, z), dvec3(x, y, z+1));
				_3d.line(dvec3(x, y, z+1), dvec3(x, y-1, z));

				_3d.line(dvec3(x, y, z-1), dvec3(x-1, y, z));//xz
				_3d.line(dvec3(x-1, y, z), dvec3(x, y, z+1));
				_3d.line(dvec3(x, y, z+1), dvec3(x+1, y, z));
				_3d.line(dvec3(x+1, y, z), dvec3(x, y, z-1));

				_3d.lineColor=0xFFFF00FF;//pink
				_3d.line(dvec3(x-1, y, z), dvec3(x+1, y, z));
				_3d.line(dvec3(x, y-1, z), dvec3(x, y+1, z));
				_3d.line(dvec3(x, y, z-1), dvec3(x, y, z+1));

				z=zs.VX+zs.DX*1.5;
				//draw cube
				_3d.lineColor=0xFF0000FF;//red
				test_drawcube		(_3d, x-1, x, y-1, y, z-1, z);
				test_drawcube		(_3d, x+1, x, y-1, y, z-1, z);
				test_drawcube		(_3d, x-1, x, y+1, y, z-1, z);
				test_drawcube		(_3d, x+1, x, y+1, y, z-1, z);
				test_drawcube		(_3d, x-1, x, y-1, y, z+1, z);
				test_drawcube		(_3d, x+1, x, y-1, y, z+1, z);
				test_drawcube		(_3d, x-1, x, y+1, y, z+1, z);
				test_drawcube		(_3d, x+1, x, y+1, y, z+1, z);
				
				_3d.lineColor=0xFF00FF00;//green
				test_drawtetrahedra	(_3d, x-1, x, y-1, y, z-1, z);
				test_drawtetrahedra	(_3d, x+1, x, y-1, y, z-1, z);
				test_drawtetrahedra	(_3d, x-1, x, y+1, y, z-1, z);
				test_drawtetrahedra	(_3d, x+1, x, y+1, y, z-1, z);
				test_drawtetrahedra	(_3d, x-1, x, y-1, y, z+1, z);
				test_drawtetrahedra	(_3d, x+1, x, y-1, y, z+1, z);
				test_drawtetrahedra	(_3d, x-1, x, y+1, y, z+1, z);
				test_drawtetrahedra	(_3d, x+1, x, y+1, y, z+1, z);
#endif
				//end test
			}
			else
			{
				auto &line=lines[cursorEx];
				for(auto vit=line.begin();vit!=line.end();++vit)
				{
					auto &Vlevel=*vit;
					for(auto sit=Vlevel.second.begin();sit!=Vlevel.second.end();++sit)
					{
						auto &s=*sit;
						_3d.line(dvec3(s.X1, s.Y1, s.Z1), dvec3(s.X2, s.Y2, s.Z2));
					}
				}
			}
		}
		void doContour_component(unsigned e, unsigned c)//cursorEx, comp, DX/Xplaces, -DX/2, +DX/2, Xstep, 2
		{
			using namespace contour;
			auto ndr=(&expr[e].n[expr[e].resultTerm].r)[c].p;
			std::unordered_map<int, SurfaceHelper> contour;
		//	auto &contour=(&Rcontours)[c][e];
			double X_E, X_W, Y_N, Y_S, Z_U, Z_D;
		//	double X0, X1, Y0, Y1, Z0, Z1;
			ALIGN(16) double V[8]={0};
			double
				&V_UNW=V[0], &V_UNE=V[1],//z: +Up/-Down	y: +North/-South	x: +East/-West
				&V_USW=V[2], &V_USE=V[3],
				
				&V_DNW=V[4], &V_DNE=V[5],
				&V_DSW=V[6], &V_DSE=V[7];
			auto getPos=[&](double &t, double Vx, Double_X_Y_Z_V &A, Double_X_Y_Z_V &B)->bool
			{
				//t=(A.V-Vx)/(A.V-B.V);
				//return t>=0&&t<=1;
				double
					Xd=B.X-A.X, X_aE=X_E-A.X, X_Wa=A.X-X_W,//see trilinear interpolation
					Yd=B.Y-A.Y, Y_aN=Y_N-A.Y, Y_Sa=A.Y-Y_S,
					Zd=B.Z-A.Z, Z_aU=Z_U-A.Z, Z_Da=A.Z-Z_D,
					
					A_DS=(V_DSE-V_DSW)*Xd, B_DS=X_aE*V_DSW+X_Wa*V_DSE,
					A_DN=(V_DNE-V_DNW)*Xd, B_DN=X_aE*V_DNW+X_Wa*V_DNE,
					A_US=(V_USE-V_USW)*Xd, B_US=X_aE*V_USW+X_Wa*V_USE,
					A_UN=(V_UNE-V_UNW)*Xd, B_UN=X_aE*V_UNW+X_Wa*V_UNE,
					
					C_D=(A_DN-A_DS)*Yd, D_D=(B_DN-B_DS)*Yd+Y_aN*A_DS+Y_Sa*A_DN, E_D=Y_aN*B_DS+Y_Sa*B_DN,
					C_U=(A_UN-A_US)*Yd, D_U=(B_UN-B_US)*Yd+Y_aN*A_US+Y_Sa*A_UN, E_U=Y_aN*B_US+Y_Sa*B_UN,
					
					a=(C_U-C_D)*Zd, b=(D_U-D_D)*Zd+Z_aU*C_D+Z_Da*C_U, c=(E_U-E_D)*Zd+Z_aU*D_D+Z_Da*D_U, d=Z_aU*E_D+Z_Da*E_U-(X_E-X_W)*(Y_N-Y_S)*(Z_U-Z_D)*Vx;

			//	if(A.Z==Z0&&B.Z==Z0)
			//		int LOL_1=0;
				if(a==0&&b==0&&c==0)
				{
					t=(Vx-A.V)/(B.V-A.V);
					return true;
				}
				double r1;
				std::complex<double> r2, r3;
				modes::contour::solve_cubic(a, b, c, d, r1, r2, r3);
				if(r1>=0&&r1<=1)
				{
					t=r1;
					return true;
				}
				if(r2.real()>=0&&r2.real()<=1)//what
				{
					t=r2.real();
					return true;
				}
				if(r3.real()>=0&&r3.real()<=1)
				{
					t=r3.real();
					return true;
				}
				if(r1>=-1e-5&&r1<=1+1e-5)
				{
					t=r1;
					return true;
				}
				if(r2.real()>=-1e-5&&r2.real()<=1+1e-5)//what
				{
					t=r2.real();
					return true;
				}
				if(r3.real()>=-1e-5&&r3.real()<=1+1e-5)
				{
					t=r3.real();
					return true;
				}
				if(r1>=-1e-1&&r1<=1+1e-1)
				{
					t=r1;
					return true;
				}
				if(r2.real()>=-1e-1&&r2.real()<=1+1e-1)//what
				{
					t=r2.real();
					return true;
				}
				if(r3.real()>=-1e-1&&r3.real()<=1+1e-1)
				{
					t=r3.real();
					return true;
				}
				return false;//*/
			};
			int ndrSize=Xplaces*Yplaces*Zplaces;
			ALIGN(32) double extremes[2];
			minmax(ndr, ndrSize, extremes);
		//	ndr_to_clipboard_3d(ndr, Xplaces, Yplaces, Zplaces);//
			vs.VX=(extremes[0]+extremes[1])*0.5, vs.DX=extremes[1]-extremes[0];//2 20 200
		//	Scale vs((extremes[0]+extremes[1])*0.5, extremes[1]-extremes[0]);
			vs.update_scale(vs.DX, 1, 400);//set Vstep		v = 100 200| 500 1000
			vs.start_grid();
			int vi=vs.dist2ticks(vs.Xstart), vf=vs.dist2ticks(vs.Xend);
			//auto insertTriangle=[&](std::list<_3D::Triangle> &level, _3D::Triangle &t)
			//{
			//	bool no_collision=true;
			//	for(auto ti=level.begin();ti!=level.end();++ti)
			//	{
			//		if(t==*ti)
			//		{
			//			no_collision=false;
			//			break;
			//		}
			//	}
			//	if(no_collision)
			//		level.push_back(t);
			//};
			auto cutTrap=[&](Double_X_Y_Z_V &A, Double_X_Y_Z_V &B, Double_X_Y_Z_V &C, Double_X_Y_Z_V &D)
			{
				modes::contour::Double_X_Y_Z_V *_1, *_2, *_3, *_4;//sorted by V in ascending order
				if(A.V<B.V)//ab
				{
					if(B.V<C.V)//abc
					{
							 if(C.V<D.V)	_1=&A, _2=&B, _3=&C, _4=&D;
						else if(B.V<D.V)	_1=&A, _2=&B, _3=&D, _4=&C;
						else if(A.V<D.V)	_1=&A, _2=&D, _3=&B, _4=&C;
						else				_1=&D, _2=&A, _3=&B, _4=&C;
					}
					else if(A.V<C.V)//acb
					{
							 if(B.V<D.V)	_1=&A, _2=&C, _3=&B, _4=&D;
						else if(C.V<D.V)	_1=&A, _2=&C, _3=&D, _4=&B;
						else if(A.V<D.V)	_1=&A, _2=&D, _3=&C, _4=&B;
						else				_1=&D, _2=&A, _3=&C, _4=&B;
					}
					else//cab
					{
							 if(B.V<D.V)	_1=&C, _2=&A, _3=&B, _4=&D;
						else if(A.V<D.V)	_1=&C, _2=&A, _3=&D, _4=&B;
						else if(C.V<D.V)	_1=&C, _2=&D, _3=&A, _4=&B;
						else				_1=&D, _2=&C, _3=&A, _4=&B;
					}
				}
				else//ba
				{
					if(A.V<C.V)//bac
					{
							 if(C.V<D.V)	_1=&B, _2=&A, _3=&C, _4=&D;
						else if(A.V<D.V)	_1=&B, _2=&A, _3=&D, _4=&C;
						else if(B.V<D.V)	_1=&B, _2=&D, _3=&A, _4=&C;
						else				_1=&D, _2=&B, _3=&A, _4=&C;
					}
					else if(B.V<C.V)//bca
					{
							 if(A.V<D.V)	_1=&B, _2=&C, _3=&A, _4=&D;
						else if(C.V<D.V)	_1=&B, _2=&C, _3=&D, _4=&A;
						else if(B.V<D.V)	_1=&B, _2=&D, _3=&C, _4=&A;
						else				_1=&D, _2=&B, _3=&C, _4=&A;
					}
					else//cba
					{
							 if(A.V<D.V)	_1=&C, _2=&B, _3=&A, _4=&D;
						else if(B.V<D.V)	_1=&C, _2=&B, _3=&D, _4=&A;
						else if(C.V<D.V)	_1=&C, _2=&D, _3=&B, _4=&A;
						else				_1=&D, _2=&C, _3=&B, _4=&A;
					}
				}
				int V1t, V2t, V3t, V4t;
				if(_1->V==_1->V&&_2->V==_2->V&&(V1t=vs.dist2ticks(_1->V))!=(V2t=vs.dist2ticks(_2->V)))
				{
					for(int v=maximum(V1t, vi), vEnd=minimum(V2t, vf);v<=vEnd;++v)
					{
						double VL=vs.ticks2dist(v);
						if(_1->V<=VL&&VL<=_2->V)
						{
							double M12, M13, M14;
							if(getPos(M12, VL, *_1, *_2)&&getPos(M13, VL, *_1, *_3)&&getPos(M14, VL, *_1, *_4))
							{
								_3D::Triangle tr(
									_1->X+M12*(_2->X-_1->X), _1->Y+M12*(_2->Y-_1->Y), _1->Z+M12*(_2->Z-_1->Z),
									_1->X+M13*(_3->X-_1->X), _1->Y+M13*(_3->Y-_1->Y), _1->Z+M13*(_3->Z-_1->Z),
									_1->X+M14*(_4->X-_1->X), _1->Y+M14*(_4->Y-_1->Y), _1->Z+M14*(_4->Z-_1->Z));
								if(tr.valid())
							//	if(tr._4_area_sq()>0)
								{
									auto &S=contour[v];
									S.add(tr);
									S.correctNormal(vec3((float)_1->X, (float)_1->Y, (float)_1->Z), _1->V>VL);
								}
								//	contour[v].add(tr);
								//	insertTriangle(contour[v], tr);
								//	contour[v].push_back(tr);
							}
						}
					}
				}
				if(_2->V==_2->V&&_3->V==_3->V&&(V2t=vs.dist2ticks(_2->V))!=(V3t=vs.dist2ticks(_3->V)))
				{
					for(int v=maximum(V2t, vi), vEnd=minimum(V3t, vf);v<=vEnd;++v)
					{
						double VL=vs.ticks2dist(v);
						if(_2->V<=VL&&VL<=_3->V)
						{
							double M13, M23, M24, M14;
							if(getPos(M13, VL, *_1, *_3)&&getPos(M23, VL, *_2, *_3)&&getPos(M24, VL, *_2, *_4)&&getPos(M14, VL, *_1, *_4)&&!(!M13&&!M23&&!M24&&!M14))//there is a triangle with nonzero area
							{
								double
									X13=_1->X+M13*(_3->X-_1->X), Y13=_1->Y+M13*(_3->Y-_1->Y), Z13=_1->Z+M13*(_3->Z-_1->Z),
									X23=_2->X+M23*(_3->X-_2->X), Y23=_2->Y+M23*(_3->Y-_2->Y), Z23=_2->Z+M23*(_3->Z-_2->Z),
									X24=_2->X+M24*(_4->X-_2->X), Y24=_2->Y+M24*(_4->Y-_2->Y), Z24=_2->Z+M24*(_4->Z-_2->Z),
									X14=_1->X+M14*(_4->X-_1->X), Y14=_1->Y+M14*(_4->Y-_1->Y), Z14=_1->Z+M14*(_4->Z-_1->Z);
								_3D::Triangle tr1(X13, Y13, Z13, X23, Y23, Z23, X24, Y24, Z24), tr2(X13, Y13, Z13, X14, Y14, Z14, X24, Y24, Z24);
								if(tr1.valid())
								{
									auto &S=contour[v];
									S.add(tr1);
									S.correctNormal(vec3((float)_2->X, (float)_2->Y, (float)_2->Z), _2->V>VL);
								}
								//	contour[v].add(tr1);
								//	insertTriangle(contour[v], tr1);
								//	contour[v].push_back(tr1);
								if(tr2.valid())
								{
									auto &S=contour[v];
									S.add(tr2);
									S.correctNormal(vec3((float)_1->X, (float)_1->Y, (float)_1->Z), _1->V>VL);
								}
								//	contour[v].add(tr2);
								//	insertTriangle(contour[v], tr2);
								//	contour[v].push_back(tr2);
							}
						}
					}
				}
				if(_3->V==_3->V&&_4->V==_4->V&&(V3t=vs.dist2ticks(_3->V))!=(V4t=vs.dist2ticks(_4->V)))
				{
					for(int v=maximum(V3t, vi), vEnd=minimum(V4t, vf);v<=vEnd;++v)
					{
						double VL=vs.ticks2dist(v);
						if(_3->V<=VL&&VL<=_4->V)
						{
							double M14, M24, M34;
							if(getPos(M14, VL, *_1, *_4)&&getPos(M24, VL, *_2, *_4)&&getPos(M34, VL, *_3, *_4)&&!(M14==1&&M24==1&&M34==1))//there is a triangle with nonzero area
							{
								_3D::Triangle tr(
									_1->X+M14*(_4->X-_1->X), _1->Y+M14*(_4->Y-_1->Y), _1->Z+M14*(_4->Z-_1->Z),
									_2->X+M24*(_4->X-_2->X), _2->Y+M24*(_4->Y-_2->Y), _2->Z+M24*(_4->Z-_2->Z),
									_3->X+M34*(_4->X-_3->X), _3->Y+M34*(_4->Y-_3->Y), _3->Z+M34*(_4->Z-_3->Z));
								if(tr.valid())
								{
									auto &S=contour[v];
									S.add(tr);
									S.correctNormal(vec3((float)_4->X, (float)_4->Y, (float)_4->Z), _4->V>VL);
								}
								//	contour[v].add(tr);
								//	insertTriangle(contour[v], tr);
								//	contour[v].push_back(tr);
							}
						}
					}
				}
			};
			double dispYstart=AR_Y*solver.Ystart, dispZstart=AR_Z*solver.Zstart;
			int XYplaces=Xplaces*Yplaces;
			for(unsigned vz=0, vzEnd=Zplaces-1;vz<vzEnd;++vz)
			{
				for(unsigned vy=0, vyEnd=Yplaces-1;vy<vyEnd;++vy)
				{
					for(unsigned vx=0, vxEnd=Xplaces-1;vx<vxEnd;++vx)
					{
						X_W=xs.ifn_x(vx), X_E=xs.ifn_x(vx+1);
						Y_S=ys.ifn_x(vy), Y_N=ys.ifn_x(vy+1);
						Z_D=zs.ifn_x(vz), Z_U=zs.ifn_x(vz+1);
						double X_m=xs.ifn_x(vx+.5), Y_m=ys.ifn_x(vy+.5), Z_m=zs.ifn_x(vz+.5);

						int idx=Xplaces*(Yplaces*vz+vy)+vx;
						V_UNW=ndr[idx+XYplaces+Xplaces],	V_UNE=ndr[idx+XYplaces+Xplaces+1];
						V_USW=ndr[idx+XYplaces],			V_USE=ndr[idx+XYplaces+1];

						V_DNW=ndr[idx+Xplaces],				V_DNE=ndr[idx+Xplaces+1];
						V_DSW=ndr[idx],						V_DSE=ndr[idx+1];
						if(test_contourMethod==2)//5 tetrahedra
						{
							Double_X_Y_Z_V//z: +Up/-Down	y: +North/-South	x: +East/-West
								P_UNW(X_W, Y_N, Z_U, V_UNW),	P_UNE(X_E, Y_N, Z_U, V_UNE),
								P_USW(X_W, Y_S, Z_U, V_USW),	P_USE(X_E, Y_S, Z_U, V_USE),

								P_DNW(X_W, Y_N, Z_D, V_DNW),	P_DNE(X_E, Y_N, Z_D, V_DNE),
								P_DSW(X_W, Y_S, Z_D, V_DSW),	P_DSE(X_E, Y_S, Z_D, V_DSE);
							if(vx&1^vy&1^vz&1)//put upside-down each time
							{
								cutTrap(P_DSW, P_DNE, P_UNW, P_USE);
								cutTrap(P_DSW, P_DNE, P_UNW, P_DNW);
								cutTrap(P_DSW, P_USW, P_UNW, P_USE);
								cutTrap(P_DSW, P_DNE, P_DSE, P_USE);
								cutTrap(P_UNE, P_DNE, P_UNW, P_USE);
							}
							else
							{
								cutTrap(P_USW, P_UNE, P_DNW, P_DSE);
								cutTrap(P_USW, P_UNE, P_DNW, P_UNW);
								cutTrap(P_USW, P_DSW, P_DNW, P_DSE);
								cutTrap(P_USW, P_UNE, P_USE, P_DSE);
								cutTrap(P_DNE, P_UNE, P_DNW, P_DSE);
							}
						}
						else if(test_contourMethod)//28 tetrahedra
						{
							Double_X_Y_Z_V//z: +Up/-Down	y: +North/-South	x: +East/-West
								P_UNW(X_W, Y_N, Z_U, V_UNW),						/*	P_UNm(X_m, Y_N, Z_U, (V_UNW+V_UNE)*0.5),	*/									P_UNE(X_E, Y_N, Z_U, V_UNE),
							/*	P_UmW(X_W, Y_m, Z_U, (V_UNW+V_USW)*0.5),	*/			P_Umm(X_m, Y_m, Z_U, (V_UNW+V_UNE+V_USW+V_USE)*0.25),						/*	P_UmE(X_E, Y_m, Z_U, (V_UNE+V_USE)*0.5),*/
								P_USW(X_W, Y_S, Z_U, V_USW),						/*	P_USm(X_m, Y_S, Z_U, (V_USW+V_USE)*0.5),	*/									P_USE(X_E, Y_S, Z_U, V_USE),

							/*	P_mNW(X_W, Y_N, Z_m, (V_UNW+V_DNW)*0.5),	*/			P_mNm(X_m, Y_N, Z_m, (V_UNW+V_DNW+V_UNE+V_DNE)*0.25),						/*	P_mNE(X_E, Y_N, Z_m, (V_UNE+V_DNE)*0.5),*/
								P_mmW(X_W, Y_m, Z_m, (V_UNW+V_DNW+V_DSW+V_USW)*0.25),	P_mmm(X_m, Y_m, Z_m, (V_UNW+V_DNW+V_DSW+V_USW+V_UNE+V_DNE+V_USE+V_DSE)*0.125),	P_mmE(X_E, Y_m, Z_m, (V_UNE+V_DNE+V_USE+V_DSE)*0.25),
							/*	P_mSW(X_W, Y_S, Z_m, (V_DSW+V_USW)*0.5),	*/			P_mSm(X_m, Y_S, Z_m, (V_DSW+V_USW+V_USE+V_DSE)*0.25),						/*	P_mSE(X_E, Y_S, Z_m, (V_USE+V_DSE)*0.5),*/

								P_DNW(X_W, Y_N, Z_D, V_DNW),						/*	P_DNm(X_m, Y_N, Z_D, (V_DNW+V_DNE)*0.5),	*/									P_DNE(X_E, Y_N, Z_D, V_DNE),
							/*	P_DmW(X_W, Y_m, Z_D, (V_DNW+V_DSW)*0.5),	*/			P_Dmm(X_m, Y_m, Z_D, (V_DNW+V_DSW+V_DNE+V_DSE)*0.25),						/*	P_DmE(X_E, Y_m, Z_D, (V_DNE+V_DSE)*0.5),*/
								P_DSW(X_W, Y_S, Z_D, V_DSW),						/*	P_DSm(X_m, Y_S, Z_D, (V_DSW+V_DSE)*0.5),	*/									P_DSE(X_E, Y_S, Z_D, V_DSE);
							cutTrap(P_USW, P_DSW, P_mmW, P_mSm);
							cutTrap(P_UNW, P_USW, P_mmW, P_Umm);
							cutTrap(P_DNW, P_UNW, P_mmW, P_mNm);
							cutTrap(P_DSW, P_DNW, P_mmW, P_Dmm);

							cutTrap(P_USE, P_DSE, P_mmE, P_mSm);
							cutTrap(P_UNE, P_USE, P_mmE, P_Umm);
							cutTrap(P_DNE, P_UNE, P_mmE, P_mNm);
							cutTrap(P_DSE, P_DNE, P_mmE, P_Dmm);

							cutTrap(P_DNE, P_DNW, P_mNm, P_Dmm);
							cutTrap(P_DSE, P_DSW, P_Dmm, P_mSm);
							cutTrap(P_USE, P_USW, P_mSm, P_Umm);
							cutTrap(P_UNE, P_UNW, P_Umm, P_mNm);

							cutTrap(P_UNW, P_mmW, P_Umm, P_mNm);
							cutTrap(P_USW, P_Umm, P_mmW, P_mSm);
							cutTrap(P_USE, P_mSm, P_mmE, P_Umm);
							cutTrap(P_UNE, P_mmE, P_Umm, P_mNm);

							cutTrap(P_DNW, P_mmW, P_Dmm, P_mNm);
							cutTrap(P_DSW, P_Dmm, P_mmW, P_mSm);
							cutTrap(P_DSE, P_mSm, P_mmE, P_Dmm);
							cutTrap(P_DNE, P_mmE, P_Dmm, P_mNm);

							cutTrap(P_mmm, P_mmW, P_Umm, P_mNm);
							cutTrap(P_mmm, P_Umm, P_mmW, P_mSm);
							cutTrap(P_mmm, P_mSm, P_mmE, P_Umm);
							cutTrap(P_mmm, P_mmE, P_Umm, P_mNm);

							cutTrap(P_mmm, P_mmW, P_Dmm, P_mNm);
							cutTrap(P_mmm, P_Dmm, P_mmW, P_mSm);
							cutTrap(P_mmm, P_mSm, P_mmE, P_Dmm);
							cutTrap(P_mmm, P_mmE, P_Dmm, P_mNm);
						}
#if 1
						else//48 tetrahedra
						{
							Double_X_Y_Z_V//z: +Up/-Down	y: +North/-South	x: +East/-West
								P_UNW(X_W, Y_N, Z_U, V_UNW),							P_UNm(X_m, Y_N, Z_U, (V_UNW+V_UNE)*0.5),										P_UNE(X_E, Y_N, Z_U, V_UNE),
								P_UmW(X_W, Y_m, Z_U, (V_UNW+V_USW)*0.5),				P_Umm(X_m, Y_m, Z_U, (V_UNW+V_UNE+V_USW+V_USE)*0.25),							P_UmE(X_E, Y_m, Z_U, (V_UNE+V_USE)*0.5),
								P_USW(X_W, Y_S, Z_U, V_USW),							P_USm(X_m, Y_S, Z_U, (V_USW+V_USE)*0.5),										P_USE(X_E, Y_S, Z_U, V_USE),

								P_mNW(X_W, Y_N, Z_m, (V_UNW+V_DNW)*0.5),				P_mNm(X_m, Y_N, Z_m, (V_UNW+V_DNW+V_UNE+V_DNE)*0.25),							P_mNE(X_E, Y_N, Z_m, (V_UNE+V_DNE)*0.5),
								P_mmW(X_W, Y_m, Z_m, (V_UNW+V_DNW+V_DSW+V_USW)*0.25),	P_mmm(X_m, Y_m, Z_m, (V_UNW+V_DNW+V_DSW+V_USW+V_UNE+V_DNE+V_USE+V_DSE)*0.125),	P_mmE(X_E, Y_m, Z_m, (V_UNE+V_DNE+V_USE+V_DSE)*0.25),
								P_mSW(X_W, Y_S, Z_m, (V_DSW+V_USW)*0.5),				P_mSm(X_m, Y_S, Z_m, (V_DSW+V_USW+V_USE+V_DSE)*0.25),							P_mSE(X_E, Y_S, Z_m, (V_USE+V_DSE)*0.5),

								P_DNW(X_W, Y_N, Z_D, V_DNW),							P_DNm(X_m, Y_N, Z_D, (V_DNW+V_DNE)*0.5),										P_DNE(X_E, Y_N, Z_D, V_DNE),
								P_DmW(X_W, Y_m, Z_D, (V_DNW+V_DSW)*0.5),				P_Dmm(X_m, Y_m, Z_D, (V_DNW+V_DSW+V_DNE+V_DSE)*0.25),							P_DmE(X_E, Y_m, Z_D, (V_DNE+V_DSE)*0.5),
								P_DSW(X_W, Y_S, Z_D, V_DSW),							P_DSm(X_m, Y_S, Z_D, (V_DSW+V_DSE)*0.5),										P_DSE(X_E, Y_S, Z_D, V_DSE);

							cutTrap(P_mSW, P_mSm, P_DSW, P_mmm);
							cutTrap(P_mSm, P_DSm, P_DSW, P_mmm);
							cutTrap(P_DSm, P_Dmm, P_DSW, P_mmm);
							cutTrap(P_Dmm, P_DmW, P_DSW, P_mmm);
							cutTrap(P_DmW, P_mmW, P_DSW, P_mmm);
							cutTrap(P_mmW, P_mSW, P_DSW, P_mmm);
						
							cutTrap(P_mSE, P_mSm, P_DSE, P_mmm);
							cutTrap(P_mSm, P_DSm, P_DSE, P_mmm);
							cutTrap(P_DSm, P_Dmm, P_DSE, P_mmm);
							cutTrap(P_Dmm, P_DmE, P_DSE, P_mmm);
							cutTrap(P_DmE, P_mmE, P_DSE, P_mmm);
							cutTrap(P_mmE, P_mSE, P_DSE, P_mmm);
						
							cutTrap(P_mNW, P_mNm, P_DNW, P_mmm);
							cutTrap(P_mNm, P_DNm, P_DNW, P_mmm);
							cutTrap(P_DNm, P_Dmm, P_DNW, P_mmm);
							cutTrap(P_Dmm, P_DmW, P_DNW, P_mmm);
							cutTrap(P_DmW, P_mmW, P_DNW, P_mmm);
							cutTrap(P_mmW, P_mNW, P_DNW, P_mmm);
						
							cutTrap(P_mNE, P_mNm, P_DNE, P_mmm);
							cutTrap(P_mNm, P_DNm, P_DNE, P_mmm);
							cutTrap(P_DNm, P_Dmm, P_DNE, P_mmm);
							cutTrap(P_Dmm, P_DmE, P_DNE, P_mmm);
							cutTrap(P_DmE, P_mmE, P_DNE, P_mmm);
							cutTrap(P_mmE, P_mNE, P_DNE, P_mmm);
						
							cutTrap(P_mSW, P_mSm, P_USW, P_mmm);
							cutTrap(P_mSm, P_USm, P_USW, P_mmm);
							cutTrap(P_USm, P_Umm, P_USW, P_mmm);
							cutTrap(P_Umm, P_UmW, P_USW, P_mmm);
							cutTrap(P_UmW, P_mmW, P_USW, P_mmm);
							cutTrap(P_mmW, P_mSW, P_USW, P_mmm);
						
							cutTrap(P_mSE, P_mSm, P_USE, P_mmm);
							cutTrap(P_mSm, P_USm, P_USE, P_mmm);
							cutTrap(P_USm, P_Umm, P_USE, P_mmm);
							cutTrap(P_Umm, P_UmE, P_USE, P_mmm);
							cutTrap(P_UmE, P_mmE, P_USE, P_mmm);
							cutTrap(P_mmE, P_mSE, P_USE, P_mmm);
						
							cutTrap(P_mNW, P_mNm, P_UNW, P_mmm);
							cutTrap(P_mNm, P_UNm, P_UNW, P_mmm);
							cutTrap(P_UNm, P_Umm, P_UNW, P_mmm);
							cutTrap(P_Umm, P_UmW, P_UNW, P_mmm);
							cutTrap(P_UmW, P_mmW, P_UNW, P_mmm);
							cutTrap(P_mmW, P_mNW, P_UNW, P_mmm);
						
							cutTrap(P_mNE, P_mNm, P_UNE, P_mmm);
							cutTrap(P_mNm, P_UNm, P_UNE, P_mmm);
							cutTrap(P_UNm, P_Umm, P_UNE, P_mmm);
							cutTrap(P_Umm, P_UmE, P_UNE, P_mmm);
							cutTrap(P_UmE, P_mmE, P_UNE, P_mmm);
							cutTrap(P_mmE, P_mNE, P_UNE, P_mmm);
						}
#endif
					}
				}
			}
			prof_add("do cont.: main");
			auto &result_contour=(&Rcontours)[c][e];
			auto &lines=(&Rlines)[c][e];
			g_contour=contour;
			vi=zs.dist2ticks(zs_Zstart), vf=zs.dist2ticks(zs.Xend);
			for(auto cit=contour.begin();cit!=contour.end();++cit)//for each contour level (surface)
			{
				auto &level=cit->first;
				auto &S=cit->second;
			//	auto &level=*cit;
				S.level=level, S.Rlevel=(float)vs.ticks2dist(level);
			/*	S.build_neighbors();
				std::vector<char> visited(S.t.size(), false);			//incomplete mesh simplification code
				std::queue<int> q;
				for(int k=0, kEnd=S.t.size();k<kEnd;++k)
				{
					std::vector<int> t_indices(1, k);
					visited[k]=true;
					q.push(k);
					while(q.size())//breadth-first traversal - find parallel neighboring triangles
					{
						auto &current=S.t[q.front()];
						q.pop();
						if(current.tab!=-1&&!visited[current.tab]&&normals_equal(current.n, S.t[current.tab].n))
							q.push(current.tab), visited[current.tab]=true, t_indices.push_back(current.tab);
						if(current.tbc!=-1&&!visited[current.tbc]&&normals_equal(current.n, S.t[current.tbc].n))
							q.push(current.tbc), visited[current.tbc]=true, t_indices.push_back(current.tbc);
						if(current.tca!=-1&&!visited[current.tca]&&normals_equal(current.n, S.t[current.tca].n))
							q.push(current.tca), visited[current.tca]=true, t_indices.push_back(current.tca);
					}
					for(int k2=0, k2End=t_indices.size();k2<k2End;++k2)//find edge vertices of the polygon
					{
					}
				}//*/
			/*	std::vector<vec3> normals(S.indices.size()/3);
				for(int k=0, kEnd=S.indices.size();k<kEnd;k+=3)//for each triangle
				{
					auto &a=S.vertices[S.indices[k]], &b=S.vertices[S.indices[k+1]], &c=S.vertices[S.indices[k+2]];
					auto n=(b-a).cross(c-a);
					normals[k/3]=n/n.magnitude();
				}
				for(int k=0, kEnd=S.rev_db.size();k<kEnd;++k)//for each vertex
				{
					auto &triangles=S.rev_db[k];
					if(triangles.size()>1)
					{
						bool remove=true;
						const float parallel_threshold=1-1e-7f;
						auto &first=normals[triangles[0]/3];
					//	auto &a=S.vertices[S.indices[first]], &b=S.vertices[S.indices[first+1]], &c=S.vertices[S.indices[first+2]];
						for(int k2=0, k2End=triangles.size();k2<k2End;++k2)
						{
							float abs_d=abs(first.dot(normals[triangles[k2]/3]));
							if(abs_d<parallel_threshold)//if triangles are not parallel
							{
								remove=false;
								break;
							}
						}
						if(remove)//this vertex is inside a flat convex polygon
						{
							if(triangles.size()==3)//remove the vertex, replace 3 triangles with one
							{
								int ka=-1, kb=-1, kc=-1;
								int v_ids[]=
								{
									S.indices[triangles[0]], S.indices[triangles[0]+1], S.indices[triangles[0]+2],
									S.indices[triangles[1]], S.indices[triangles[1]+1], S.indices[triangles[1]+2],
									S.indices[triangles[2]], S.indices[triangles[2]+1], S.indices[triangles[2]+2],
								};
								//auto &a=S.vertices[S.indices[triangles[0]]], &b=S.vertices[S.indices[triangles[0]+1]], &c=S.vertices[S.indices[triangles[0]+2]];
								//auto &d=S.vertices[S.indices[triangles[1]]], &e=S.vertices[S.indices[triangles[1]+1]], &f=S.vertices[S.indices[triangles[1]+2]];
								//auto &g=S.vertices[S.indices[triangles[2]]], &h=S.vertices[S.indices[triangles[2]+1]], &i=S.vertices[S.indices[triangles[2]+2]];
								for(int k3=0;k3<9;++k3)
								{
									if(v_ids[k3]!=k&&v_ids[k3]!=ka&&v_ids[k3]!=kb&&v_ids[k3]!=kc)
									{
										if(ka==-1)
											ka=v_ids[k3];
										else if(kb==-1)
											kb=v_ids[k3];
										else if(kc==-1)
											kc=v_ids[k3];
									}
								}
								S.indices[triangles[0]]=ka, S.indices[triangles[0]+1]=kb, S.indices[triangles[0]+2]=kc;
								int first, second;
								if(triangles[0]<triangles[1])
									first=triangles[0], second=triangles[1];
								else
									first=triangles[1], second=triangles[0];
								S.indices.erase(S.indices.begin()+second, S.indices.begin()+second+3);
								S.indices.erase(S.indices.begin()+first, S.indices.begin()+first+3);
								S.vertices.erase(S.vertices.begin()+k);
								S.rev_db.erase(S.rev_db.begin()+k);
								--k;
							}
						}
					}
				}//*/
				auto &surface=result_contour[cit->first]=cit->second;
				for(int k=0, kEnd=surface.indices.size();k<kEnd;k+=3)//for each triangle
			//	for(auto tit=level.second.begin();tit!=level.second.end();++tit)
				{
					auto &a=surface.vertices[surface.indices[k]], &b=surface.vertices[surface.indices[k+1]], &c=surface.vertices[surface.indices[k+2]];
				//	auto &T=*tit;
					//vec3 *a, *b, *c;
					//if(T.a.z<T.b.z)
					//{
					//		 if(T.b.z<T.c.z)a=&T.a, b=&T.b, c=&T.c;
					//	else if(T.a.z<T.c.z)a=&T.a, b=&T.c, c=&T.b;
					//	else				a=&T.c, b=&T.a, c=&T.b;
					//}
					//else
					//{
					//		 if(T.a.z<T.c.z)a=&T.b, b=&T.a, c=&T.c;
					//	else if(T.b.z<T.c.z)a=&T.b, b=&T.c, c=&T.a;
					//	else				a=&T.c, b=&T.b, c=&T.a;
					//}
					float *X1, *Y1, *V1, *X2, *Y2, *V2, *X3, *Y3, *V3;
					if(a.z<b.z)//12
					{
							 if(b.z<c.z)X1=&a.x, Y1=&a.y, V1=&a.z, X2=&b.x, Y2=&b.y, V2=&b.z, X3=&c.x, Y3=&c.y, V3=&c.z;
						else if(a.z<c.z)X1=&a.x, Y1=&a.y, V1=&a.z, X2=&c.x, Y2=&c.y, V2=&c.z, X3=&b.x, Y3=&b.y, V3=&b.z;
						else			X1=&c.x, Y1=&c.y, V1=&c.z, X2=&a.x, Y2=&a.y, V2=&a.z, X3=&b.x, Y3=&b.y, V3=&b.z;
					}
					else//21
					{
							 if(a.z<c.z)X1=&b.x, Y1=&b.y, V1=&b.z, X2=&a.x, Y2=&a.y, V2=&a.z, X3=&c.x, Y3=&c.y, V3=&c.z;
						else if(b.z<c.z)X1=&b.x, Y1=&b.y, V1=&b.z, X2=&c.x, Y2=&c.y, V2=&c.z, X3=&a.x, Y3=&a.y, V3=&a.z;
						else			X1=&c.x, Y1=&c.y, V1=&c.z, X2=&b.x, Y2=&b.y, V2=&b.z, X3=&a.x, Y3=&a.y, V3=&a.z;
					}
					//double *X1, *Y1, *V1, *X2, *Y2, *V2, *X3, *Y3, *V3;
					//if(T.Z1<T.Z2)//12
					//{
					//		 if(T.Z2<T.Z3)	X1=&T.X1, Y1=&T.Y1, V1=&T.Z1, X2=&T.X2, Y2=&T.Y2, V2=&T.Z2, X3=&T.X3, Y3=&T.Y3, V3=&T.Z3;
					//	else if(T.Z1<T.Z3)	X1=&T.X1, Y1=&T.Y1, V1=&T.Z1, X2=&T.X3, Y2=&T.Y3, V2=&T.Z3, X3=&T.X2, Y3=&T.Y2, V3=&T.Z2;
					//	else				X1=&T.X3, Y1=&T.Y3, V1=&T.Z3, X2=&T.X1, Y2=&T.Y1, V2=&T.Z1, X3=&T.X2, Y3=&T.Y2, V3=&T.Z2;
					//}
					//else//21
					//{
					//		 if(T.Z1<T.Z3)	X1=&T.X2, Y1=&T.Y2, V1=&T.Z2, X2=&T.X1, Y2=&T.Y1, V2=&T.Z1, X3=&T.X3, Y3=&T.Y3, V3=&T.Z3;
					//	else if(T.Z2<T.Z3)	X1=&T.X2, Y1=&T.Y2, V1=&T.Z2, X2=&T.X3, Y2=&T.Y3, V2=&T.Z3, X3=&T.X1, Y3=&T.Y1, V3=&T.Z1;
					//	else				X1=&T.X3, Y1=&T.Y3, V1=&T.Z3, X2=&T.X2, Y2=&T.Y2, V2=&T.Z2, X3=&T.X1, Y3=&T.Y1, V3=&T.Z1;
					//}
					//double X13, Y13;
					//{
					//	double Zr=(b->z-a->z)/(c->z-a->z);
					//	X13=a->x+Zr*(c->x-a->x), Y13=a->y+Zr*(c->y-a->y);//V13=V2;
					//}
					//int V1t, V2t, V3t;
					////for V1 -> V2
					//if(*V1==*V1&&*V2==*V2&&(V1t=zs.dist2ticks(*V1))!=(V2t=zs.dist2ticks(*V2)))
					//{
					//	for(int v=maximum(V1t, vi), zEnd=minimum(V2t, vf);v<=zEnd;++v)
					//	{
					//		double ZL=zs.ticks2dist(v);
					//		if(*V1<=ZL&&ZL<=*V2)
					//		{
					//			double M=(ZL-*V1)/(*V2-*V1);
					//			lines[level.first].push_back(_3D::Stick(*X1+M*(*X2-*X1), *Y1+M*(*Y2-*Y1), ZL, *X1+M*(X13-*X1), *Y1+M*(Y13-*Y1), ZL));
					//		}
					//	}
					//}
					////for V2 -> V3
					//if(*V2==*V2&&*V3==*V3&&(V2t=zs.dist2ticks(*V2))!=(V3t=zs.dist2ticks(*V3)))
					//{
					//	for(int v=maximum(V2t, vi), zEnd=minimum(V3t, vf);v<=zEnd;++v)
					//	{
					//		double ZL=zs.ticks2dist(v);
					//		if(*V2<=ZL&&ZL<=*V3)
					//		{
					//			double M=(ZL-*V2)/(*V3-*V2);
					//			lines[level.first].push_back(_3D::Stick(*X2+M*(*X3-*X2), *Y2+M*(*Y3-*Y2), ZL, X13+M*(*X3-X13), Y13+M*(*Y3-Y13), ZL));
					//		}
					//	}
					//}
					double X13, Y13;
					{
						double Zr=(*V2-*V1)/(*V3-*V1);
						X13=*X1+Zr*(*X3-*X1), Y13=*Y1+Zr*(*Y3-*Y1);//V13=V2;
					}
					int V1t, V2t, V3t;
					//for V1 -> V2
					if(*V1==*V1&&*V2==*V2&&(V1t=zs.dist2ticks(*V1))!=(V2t=zs.dist2ticks(*V2)))
					{
						for(int v=maximum(V1t, vi), zEnd=minimum(V2t, vf);v<=zEnd;++v)
						{
							double ZL=zs.ticks2dist(v);
							if(*V1<=ZL&&ZL<=*V2)
							{
								double M=(ZL-*V1)/(*V2-*V1);
								lines[level].push_back(_3D::Stick(*X1+M*(*X2-*X1), *Y1+M*(*Y2-*Y1), ZL, *X1+M*(X13-*X1), *Y1+M*(Y13-*Y1), ZL));
							}
						}
					}
					//for V2 -> V3
					if(*V2==*V2&&*V3==*V3&&(V2t=zs.dist2ticks(*V2))!=(V3t=zs.dist2ticks(*V3)))
					{
						for(int v=maximum(V2t, vi), zEnd=minimum(V3t, vf);v<=zEnd;++v)
						{
							double ZL=zs.ticks2dist(v);
							if(*V2<=ZL&&ZL<=*V3)
							{
								double M=(ZL-*V2)/(*V3-*V2);
								lines[level].push_back(_3D::Stick(*X2+M*(*X3-*X2), *Y2+M*(*Y3-*Y2), ZL, X13+M*(*X3-X13), Y13+M*(*Y3-Y13), ZL));
							}
						}
					}
				}
			}
			prof_add("do cont.: lines");
		}
		void doContour(unsigned e)
		{
			doContour_component(e, 0);
			auto ms=expr[e].resultMathSet;
			if(ms>='c')
			{
				doContour_component(e, 1);
				if(ms=='h')
				{
					doContour_component(e, 2);
					doContour_component(e, 3);
				}
			}
			//switch(expr[e].resultMathSet)
			//{
			//case 'R':
			//	doContour_component(e, 0);
			//	break;
			//case 'c':
			//	doContour_component(e, 0);
			//	doContour_component(e, 1);
			//	break;
			//case 'h':
			//	doContour_component(e, 0);
			//	doContour_component(e, 1);
			//	doContour_component(e, 2);
			//	doContour_component(e, 3);
			//	break;
			//}
		}
		void doOperations						(Term &n)
		{
			for(auto it=operations.begin();it!=operations.end();++it)
			{
				auto &op=*it;
				switch(op)
				{
				case  1:differentiate_xyz					(n);break;
				case  2:differentiate_x						(n);break;
				case  3:differentiate_y						(n);break;
				case  4:differentiate_z						(n);break;
				case  5:differentiate_xy					(n);break;
				case  6:differentiate_yz					(n);break;
				case  7:differentiate_xz					(n);break;
				case  8:integrate_xyz						(n);break;
				case  9:integrate_x							(n);break;
				case 10:integrate_y							(n);break;
				case 11:integrate_z							(n);break;
				case 12:integrate_xy						(n);break;
				case 13:integrate_yz						(n);break;
				case 14:integrate_xz						(n);break;
				case 15:discreteFourrierTransform			(n);break;
				case 16:inverseDiscreteFourrierTransform	(n);break;
				case 17:lowPassFilter_xyz					(n);break;
				case 18:lowPassFilter_x						(n);break;
				case 19:lowPassFilter_y						(n);break;
				case 20:lowPassFilter_z						(n);break;
				case 21:lowPassFilter_xy					(n);break;
				case 22:lowPassFilter_yz					(n);break;
				case 23:lowPassFilter_xz					(n);break;
				case 24:highPassFilter_xyz					(n);break;
				case 25:highPassFilter_x					(n);break;
				case 26:highPassFilter_y					(n);break;
				case 27:highPassFilter_z					(n);break;
				case 28:highPassFilter_xy					(n);break;
				case 29:highPassFilter_yz					(n);break;
				case 30:highPassFilter_xz					(n);break;
				}
			}
		}
		void differentiate_xyz					(Term &n)
		{
			double step=xs.Xsample;
			double kernel[]=
			{	//y=-1		y=0					y=1
				0, 0, 0,	0, 0,       0,		0, 0,      0,//z=-1
				0, 0, 0,	0, -3/step, 1,		0, 1/step, 0,//z=0
				0, 0, 0,	0, 1/step,  0,		0, 0,      0 //z=1
			};
			apply_kernel(kernel, Xplaces, Yplaces, Zplaces, ndrSize);
		}
		void differentiate_x					(Term &n)
		{
			double step=xs.Xsample;
			double kernel[]=
			{	//y=-1		y=0						y=1
				0, 0, 0,	0, 0,       0,			0, 0, 0,//z=-1
				0, 0, 0,	0, -1/step, 1/step,		0, 0, 0,//z=0
				0, 0, 0,	0, 0,       0,			0, 0, 0 //z=1
			};
			apply_kernel(kernel, Xplaces, Yplaces, Zplaces, ndrSize);
		}
		void differentiate_y					(Term &n)
		{
			double step=xs.Xsample;
			double kernel[]=
			{	//y=-1		y=0						y=1
				0, 0, 0,	0, 0,       0,		0, 0,      0,//z=-1
				0, 0, 0,	0, -1/step, 0,		0, 1/step, 0,//z=0
				0, 0, 0,	0, 0,       0,		0, 0,      0 //z=1
			};
			apply_kernel(kernel, Xplaces, Yplaces, Zplaces, ndrSize);
		}
		void differentiate_z					(Term &n)
		{
			double step=xs.Xsample;
			double kernel[]=
			{	//y=-1		y=0						y=1
				0, 0, 0,	0, 0,       0,		0, 0, 0,//z=-1
				0, 0, 0,	0, -1/step, 0,		0, 0, 0,//z=0
				0, 0, 0,	0, 1/step,  0,		0, 0, 0 //z=1
			};
			apply_kernel(kernel, Xplaces, Yplaces, Zplaces, ndrSize);
		}
		void differentiate_xy					(Term &n)
		{
			double step=xs.Xsample;
			double kernel[]=
			{	//y=-1		y=0						y=1
				0, 0, 0,	0, 0,       0,			0, 0,      0,//z=-1
				0, 0, 0,	0, -2/step, 1/step,		0, 1/step, 0,//z=0
				0, 0, 0,	0, 0,       0,			0, 0,      0 //z=1
			};
			apply_kernel(kernel, Xplaces, Yplaces, Zplaces, ndrSize);
		}
		void differentiate_yz					(Term &n)
		{
			double step=xs.Xsample;
			double kernel[]=
			{	//y=-1		y=0						y=1
				0, 0, 0,	0, 0,       0,		0, 0,      0,//z=-1
				0, 0, 0,	0, -2/step, 0,		0, 1/step, 0,//z=0
				0, 0, 0,	0, 1/step,  0,		0, 0,      0 //z=1
			};
			apply_kernel(kernel, Xplaces, Yplaces, Zplaces, ndrSize);
		}
		void differentiate_xz					(Term &n)
		{
			double step=xs.Xsample;
			double kernel[]=
			{	//y=-1		y=0						y=1
				0, 0, 0,	0, 0,       0,			0, 0, 0,//z=-1
				0, 0, 0,	0, -2/step, 1/step,		0, 0, 0,//z=0
				0, 0, 0,	0, 1/step,  0,			0, 0, 0 //z=1
			};
			apply_kernel(kernel, Xplaces, Yplaces, Zplaces, ndrSize);
		}
		void integrate_xyz						(Term &n)
		{
			double step=xs.Xsample;
			int nComponents=n_components_in_current_expr();
			std::vector<double> Zsum[4], ZYsum[4];
			double ZYXsum[4]={0};
			int ZsumSize=Xplaces*Yplaces;
			for(int c=0;c<nComponents;++c)
			{
				auto ndr=(double*)(&n.r)[c].p;
				Zsum[c].resize(ZsumSize), ZYsum[c].resize(Xplaces);
				for(int vz=0;vz<Zplaces;++vz)
				{
					for(int vy=0;vy<Yplaces;++vy)
					{
						for(int vx=0;vx<Xplaces;++vx)
						{
							auto &V000=ndr[Xplaces*(Yplaces*vz+vy)+vx];
							V000=(ZYXsum[c]+=ZYsum[c][vx]+=Zsum[c][Xplaces*vy+vx]+=V000)*step;
						}
						ZYXsum[c]=0;
					}
					std::fill(ZYsum[c].begin(), ZYsum[c].end(), 0);
				}
			}
		}
		void integrate_x						(Term &n)
		{
			double step=xs.Xsample;
			int nComponents=n_components_in_current_expr();
			double Xsum[4]={0};
			for(int c=0;c<nComponents;++c)
			{
				auto ndr=(double*)(&n.r)[c].p;
				for(int vz=0;vz<Zplaces;++vz)
				{
					for(int vy=0;vy<Yplaces;++vy)
					{
						for(int vx=0;vx<Xplaces;++vx)
						{
							auto &V000=ndr[Xplaces*(Yplaces*vz+vy)+vx];
							V000=(Xsum[c]+=V000)*step;
						}
						Xsum[c]=0;
					}
				}
			}
		}
		void integrate_y						(Term &n)
		{
			int nComponents=n_components_in_current_expr();
			std::vector<double> Ysum[4];
			for(int c=0;c<nComponents;++c)
				Ysum[c].resize(Xplaces);
			double step=xs.Xsample;
			for(int c=0;c<nComponents;++c)
			{
				auto ndr=(double*)(&n.r)[c].p;
				for(int vz=0;vz<Zplaces;++vz)
				{
					for(int vy=0;vy<Yplaces;++vy)
					{
						for(int vx=0;vx<Xplaces;++vx)
						{
							auto &V000=ndr[Xplaces*(Yplaces*vz+vy)+vx];
							V000=(Ysum[c][vx]+=V000)*step;
						}
					}
					std::fill(Ysum[c].begin(), Ysum[c].end(), 0);
				}
			}
		}
		void integrate_z						(Term &n)
		{
			int nComponents=n_components_in_current_expr();
			std::vector<double> Zsum[4];
			int ZsumSize=Xplaces*Yplaces;
			for(int c=0;c<nComponents;++c)
				Zsum[c].resize(ZsumSize);
			double step=xs.Xsample;
			for(int c=0;c<nComponents;++c)
			{
				auto ndr=(double*)(&n.r)[c].p;
				for(int vz=0;vz<Zplaces;++vz)
				{
					for(int vy=0;vy<Yplaces;++vy)
					{
						for(int vx=0;vx<Xplaces;++vx)
						{
							auto &V000=ndr[Xplaces*(Yplaces*vz+vy)+vx];
							V000=(Zsum[c][Xplaces*vy+vx]+=V000)*step;
						}
					}
				}
			}
		}
		void integrate_xy						(Term &n)
		{
			int nComponents=n_components_in_current_expr();
			std::vector<double> Ysum[4];
			double YXsum[4]={0};
			int ZsumSize=Xplaces*Yplaces;
			for(int c=0;c<nComponents;++c)
				Ysum[c].resize(Xplaces);
			double step=xs.Xsample;
			for(int c=0;c<nComponents;++c)
			{
				auto ndr=(double*)(&n.r)[c].p;
				for(int vz=0;vz<Zplaces;++vz)
				{
					for(int vy=0;vy<Yplaces;++vy)
					{
						for(int vx=0;vx<Xplaces;++vx)
						{
							auto &V000=ndr[Xplaces*(Yplaces*vz+vy)+vx];
							V000=(YXsum[c]+=Ysum[c][vx]+=V000)*step;
						}
						for(int c=0;c<nComponents;++c)
							YXsum[c]=0;
					}
					std::fill(Ysum[c].begin(), Ysum[c].end(), 0);
				}
			}
		}
		void integrate_yz						(Term &n)
		{
			int nComponents=n_components_in_current_expr();
			std::vector<double> Zsum[4], ZYsum[4];
			int ZsumSize=Xplaces*Yplaces;
			for(int c=0;c<nComponents;++c)
			{
				auto ndr=(double*)(&n.r)[c].p;
				Zsum[c].resize(ZsumSize), ZYsum[c].resize(Xplaces);
				double step=xs.Xsample;
				for(int vz=0;vz<Zplaces;++vz)
				{
					for(int vy=0;vy<Yplaces;++vy)
					{
						for(int vx=0;vx<Xplaces;++vx)
						{
							auto &V000=ndr[Xplaces*(Yplaces*vz+vy)+vx];
							V000=(ZYsum[c][vx]+=Zsum[c][Xplaces*vy+vx]+=V000)*step;
						}
					}
					std::fill(ZYsum[c].begin(), ZYsum[c].end(), 0);
				}
			}
		}
		void integrate_xz						(Term &n)
		{
			int nComponents=n_components_in_current_expr();
			std::vector<double> Zsum[4];
			double ZXsum[4]={0};
			int ZsumSize=Xplaces*Yplaces;
			for(int c=0;c<nComponents;++c)
			{
				auto ndr=(double*)(&n.r)[c].p;
				Zsum[c].resize(ZsumSize);
				double step=xs.Xsample;
				for(int vz=0;vz<Zplaces;++vz)
				{
					for(int vy=0;vy<Yplaces;++vy)
					{
						for(int vx=0;vx<Xplaces;++vx)
						{
							auto &V000=ndr[Xplaces*(Yplaces*vz+vy)+vx];
							V000=(ZXsum[c]+=Zsum[c][Xplaces*vy+vx]+=V000)*step;
						}
						for(int c=0;c<nComponents;++c)
							ZXsum[c]=0;
					}
				}
			}
		}
		fftw_complex *fft_in, *fft_out;
		fftw_plan fft_p, ifft_p;
		unsigned fft_N0, fft_N1, fft_N2;
		double fft_sqrt_N;
		void discreteFourrierTransform			(Term &n)
		{
			int ndrSize=Xplaces*Yplaces*Zplaces;
			if(n.i.size()!=ndrSize)
				n.i.resize(ndrSize);
			if(fft_N0!=Zplaces||fft_N1!=Yplaces||fft_N2!=Xplaces)
			{
				if(fft_N0||fft_N1||fft_N2)
				{
					fftw_destroy_plan(fft_p), fftw_destroy_plan(ifft_p);
					fftw_free(fft_in), fftw_free(fft_out);
				}
				fft_N0=Zplaces, fft_N1=Yplaces, fft_N2=Xplaces;
				fft_in=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex)), fft_out=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex));
				fft_sqrt_N=std::sqrt((double)ndrSize);
				fft_p=fftw_plan_dft_3d(fft_N0, fft_N1, fft_N2, fft_in, fft_out, FFTW_FORWARD, FFTW_ESTIMATE);
				ifft_p=fftw_plan_dft_3d(fft_N0, fft_N1, fft_N2, fft_in, fft_out, FFTW_BACKWARD, FFTW_ESTIMATE);
			}
			auto ndr_r=(double*)n.r.p, ndr_i=(double*)n.i.p;
			for(int k=0;k<ndrSize;++k)
			{
				unsigned x=k%Xplaces, y=k%Zplaces/Xplaces, z=k/Xplaces/Zplaces;
				int sign=1-((x%2^y%2^z%2)<<1);
				fft_in[k][0]=ndr_r[k]*sign, fft_in[k][1]=ndr_i[k]*sign;
			}
			fftw_execute(fft_p);
			for(int k=0;k<ndrSize;++k)
				ndr_r[k]=fft_out[k][0]/fft_sqrt_N, ndr_i[k]=fft_out[k][1]/fft_sqrt_N;
		}
		void inverseDiscreteFourrierTransform	(Term &n)
		{
			int ndrSize=Xplaces*Yplaces;
			if(n.i.size()!=ndrSize)
				n.i.resize(ndrSize);
			if(fft_N0!=Zplaces||fft_N1!=Yplaces||fft_N2!=Xplaces)
			{
				if(fft_N0||fft_N1||fft_N2)
				{
					fftw_destroy_plan(fft_p), fftw_destroy_plan(ifft_p);
					fftw_free(fft_in), fftw_free(fft_out);
				}
				fft_N0=Zplaces, fft_N1=Yplaces, fft_N2=Xplaces;
				fft_in=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex)), fft_out=(fftw_complex*)fftw_malloc(ndrSize*sizeof(fftw_complex));
				fft_sqrt_N=std::sqrt((double)ndrSize);
				fft_p=fftw_plan_dft_3d(fft_N0, fft_N1, fft_N2, fft_in, fft_out, FFTW_FORWARD, FFTW_ESTIMATE);
				ifft_p=fftw_plan_dft_3d(fft_N0, fft_N1, fft_N2, fft_in, fft_out, FFTW_BACKWARD, FFTW_ESTIMATE);
			}
			auto ndr_r=(double*)n.r.p, ndr_i=(double*)n.i.p;
			for(int k=0;k<ndrSize;++k)
				fft_in[k][0]=ndr_r[k], fft_in[k][1]=ndr_i[k];
			fftw_execute(ifft_p);
			for(int k=0;k<ndrSize;++k)
			{
				unsigned x=k%Xplaces, y=k%Zplaces/Xplaces, z=k/Xplaces/Zplaces;
				double gain=(1-((x%2^y%2^z%2)<<1))/fft_sqrt_N;
				ndr_r[k]=fft_out[k][0]*gain, ndr_i[k]=fft_out[k][1]*gain;
			}
		}
		void lowPassFilter_xyz					(Term &n)
		{
			const double t=1./27;
			const double kernel[]=
			{	//y=-1		y=0			y=1
				t, t, t,	t, t, t,	t, t, t,//z=-1
				t, t, t,	t, t, t,	t, t, t,//z=0
				t, t, t,	t, t, t,	t, t, t //z=1
			};
			apply_kernel(kernel, Xplaces, Yplaces, Zplaces, ndrSize);
		}
		void lowPassFilter_x					(Term &n)
		{
			const double t=1./3;
			const double kernel[]=
			{	//y=-1				y=0					y=1
				0, 0, 0,	0, 0, 0,	0, 0, 0,//z=-1
				0, 0, 0,	t, t, t,	0, 0, 0,//z=0
				0, 0, 0,	0, 0, 0,	0, 0, 0 //z=1
			};
			apply_kernel(kernel, Xplaces, Yplaces, Zplaces, ndrSize);
		}
		void lowPassFilter_y					(Term &n)
		{
			const double t=1./3;
			const double kernel[]=
			{	//y=-1		y=0			y=1
				0, 0, 0,	0, 0, 0,	0, 0, 0,//z=-1
				0, t, 0,	0, t, 0,	0, t, 0,//z=0
				0, 0, 0,	0, 0, 0,	0, 0, 0 //z=1
			};
			apply_kernel(kernel, Xplaces, Yplaces, Zplaces, ndrSize);
		}
		void lowPassFilter_z					(Term &n)
		{
			const double t=1./3;
			const double kernel[]=
			{	//y=-1		y=0			y=1
				0, 0, 0,	0, t, 0,	0, 0, 0,//z=-1
				0, 0, 0,	0, t, 0,	0, 0, 0,//z=0
				0, 0, 0,	0, t, 0,	0, 0, 0 //z=1
			};
			apply_kernel(kernel, Xplaces, Yplaces, Zplaces, ndrSize);
		}
		void lowPassFilter_xy					(Term &n)
		{
			const double t=1./5;
			const double kernel[]=
			{	//y=-1		y=0			y=1
				0, 0, 0,	0, 0, 0,	0, 0, 0,//z=-1
				0, t, 0,	t, t, t,	0, t, 0,//z=0
				0, 0, 0,	0, 0, 0,	0, 0, 0 //z=1
			};
			apply_kernel(kernel, Xplaces, Yplaces, Zplaces, ndrSize);
		}
		void lowPassFilter_yz					(Term &n)
		{
			const double t=1./5;
			const double kernel[]=
			{	//y=-1		y=0			y=1
				0, 0, 0,	0, t, 0,	0, 0, 0,//z=-1
				0, t, 0,	0, t, 0,	0, t, 0,//z=0
				0, 0, 0,	0, t, 0,	0, 0, 0 //z=1
			};
			apply_kernel(kernel, Xplaces, Yplaces, Zplaces, ndrSize);
		}
		void lowPassFilter_xz					(Term &n)
		{
			const double t=1./5;
			const double kernel[]=
			{	//y=-1		y=0			y=1
				0, 0, 0,	0, t, 0,	0, 0, 0,//z=-1
				0, 0, 0,	t, t, t,	0, 0, 0,//z=0
				0, 0, 0,	0, t, 0,	0, 0, 0 //z=1
			};
			apply_kernel(kernel, Xplaces, Yplaces, Zplaces, ndrSize);
		}
		void highPassFilter_xyz					(Term &n)
		{
			const double t=-1./6;
			const double kernel[]=
			{	//y=-1		y=0				y=1
				0, 0, 0,	0, t,    0,		0, 0, 0,//z=-1
				0, t, 0,	t, -6*t, t,		0, t, 0,//z=0
				0, 0, 0,	0, t,    0,		0, 0, 0 //z=1
			};
			apply_kernel(kernel, Xplaces, Yplaces, Zplaces, ndrSize);
		}
		void highPassFilter_x					(Term &n)
		{
			const double t=-1./2;
			const double kernel[]=
			{	//y=-1		y=0				y=1
				0, 0, 0,	0, 0,    0,		0, 0, 0,//z=-1
				0, 0, 0,	t, -2*t, t,		0, 0, 0,//z=0
				0, 0, 0,	0, 0,    0,		0, 0, 0 //z=1
			};
			apply_kernel(kernel, Xplaces, Yplaces, Zplaces, ndrSize);
		}
		void highPassFilter_y					(Term &n)
		{
			const double t=-1./2;
			const double kernel[]=
			{	//y=-1		y=0				y=1
				0, 0, 0,	0, 0,    0,		0, 0, 0,//z=-1
				0, t, 0,	0, -2*t, 0,		0, t, 0,//z=0
				0, 0, 0,	0, 0,    0,		0, 0, 0 //z=1
			};
			apply_kernel(kernel, Xplaces, Yplaces, Zplaces, ndrSize);
		}
		void highPassFilter_z					(Term &n)
		{
			const double t=-1./2;
			const double kernel[]=
			{	//y=-1		y=0				y=1
				0, 0, 0,	0, t,    0,		0, 0, 0,//z=-1
				0, 0, 0,	0, -2*t, 0,		0, 0, 0,//z=0
				0, 0, 0,	0, t,    0,		0, 0, 0 //z=1
			};
			apply_kernel(kernel, Xplaces, Yplaces, Zplaces, ndrSize);
		}
		void highPassFilter_xy					(Term &n)
		{
			const double t=-1./4;
			const double kernel[]=
			{	//y=-1		y=0				y=1
				0, 0, 0,	0, 0,    0,		0, 0, 0,//z=-1
				0, t, 0,	t, -4*t, t,		0, t, 0,//z=0
				0, 0, 0,	0, 0,    0,		0, 0, 0 //z=1
			};
			apply_kernel(kernel, Xplaces, Yplaces, Zplaces, ndrSize);
		}
		void highPassFilter_yz					(Term &n)
		{
			const double t=-1./4;
			const double kernel[]=
			{	//y=-1		y=0				y=1
				0, 0, 0,	0, t,    0,		0, 0, 0,//z=-1
				0, t, 0,	0, -4*t, 0,		0, t, 0,//z=0
				0, 0, 0,	0, t,    0,		0, 0, 0 //z=1
			};
			apply_kernel(kernel, Xplaces, Yplaces, Zplaces, ndrSize);
		}
		void highPassFilter_xz					(Term &n)
		{
			const double t=-1./4;
			const double kernel[]=
			{	//y=-1		y=0				y=1
				0, 0, 0,	0, t,    0,		0, 0, 0,//z=-1
				0, 0, 0,	t, -4*t, t,		0, 0, 0,//z=0
				0, 0, 0,	0, t,    0,		0, 0, 0 //z=1
			};
			apply_kernel(kernel, Xplaces, Yplaces, Zplaces, ndrSize);
		}

		void setDimensions(int x, int y, int w, int h)
		{
			bpx=x, bpy=y, bw=w, bh=h, X0=bpx+bw/2, Y0=bpy+bh/2;
			_3d.setDimensions(x, y, w, h);
			bool XstepChanged, YstepChanged, ZstepChanged;
			function1(XstepChanged, YstepChanged, ZstepChanged);
			if(!toSolve&&contourOn&&XstepChanged)
			{
				Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
				Rlines.clear(), Ilines.clear(), Jlines.clear(), Klines.clear();
				doContour(cursorEx);
			}
			ready=true;
		}
		void shiftNDR(double &DshiftPoint, double Dsample, double &DsamplePos, double &VD, int &Doffset, double ammount)
		{
			double newDsamplePos=std::floor((DshiftPoint+=ammount)/Dsample);
			if(newDsamplePos!=DsamplePos)
			{
				toSolve=true;
				if(shiftOnly)
					shiftOnly=1, Doffset+=int(newDsamplePos-DsamplePos);
				DsamplePos=newDsamplePos, VD=newDsamplePos*Dsample;
			}
			DsamplePos=newDsamplePos;
		}
		void shiftNDRupdate(double DshiftPoint, double Dsample, double &DsamplePos, double &VD)
		{
			double newDsamplePos=std::floor(DshiftPoint/Dsample);
			if(newDsamplePos!=DsamplePos)
				DsamplePos=newDsamplePos, VD=newDsamplePos*Dsample;
		}
		void messageTimer()
		{
				 if(kb[VK_SHIFT	]){	 if(kb['W'])	_3d.cam.moveFastForward();
									 if(kb['A'])	_3d.cam.moveFastLeft();
									 if(kb['S'])	_3d.cam.moveFastBack();
									 if(kb['D'])	_3d.cam.moveFastRight();
									 if(kb['T'])	_3d.cam.p.z+=10*_3d.cam.dcam;
									 if(kb['G'])	_3d.cam.p.z-=10*_3d.cam.dcam;}
			else				  {	 if(kb['W'])	_3d.cam.moveForward();
									 if(kb['A'])	_3d.cam.moveLeft();
									 if(kb['S'])	_3d.cam.moveBack();
									 if(kb['D'])	_3d.cam.moveRight();
									 if(kb['T'])	_3d.cam.p.z+=_3d.cam.dcam;
									 if(kb['G'])	_3d.cam.p.z-=_3d.cam.dcam;}
			auto &VX=xs.VX, &DX=xs.DX, &VY=ys.VX, &DY=ys.DX, &VZ=zs.VX, &DZ=zs.DX;
			double dVD=DX/100;
			if(kb['X'])
			{
				if(kb['Y'])
				{
					if(kb['Z'])	//xyz
					{
					}
					else		//xy
					{
						if(kb[VK_UP])	shiftNDR(YshiftPoint, solver.Ysample*AR_Y,	YsamplePos, VY, Yoffset, dVD), _3d.cam.p.y+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])	shiftNDR(YshiftPoint, solver.Ysample*AR_Y,	YsamplePos, VY, Yoffset, -dVD), _3d.cam.p.y-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT])shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, VX, Xoffset, dVD), _3d.cam.p.x+=_3d_shift_move_cam*dVD;
						if(kb[VK_LEFT])	shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, VX, Xoffset, -dVD), _3d.cam.p.x-=_3d_shift_move_cam*dVD;
					}
				}
				else
				{
					if(kb['Z'])	//xz
					{
						if(kb[VK_UP])	shiftNDR(ZshiftPoint, solver.Zsample*AR_Z,	ZsamplePos, VZ, Zoffset, dVD), _3d.cam.p.z+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])	shiftNDR(ZshiftPoint, solver.Zsample*AR_Z,	ZsamplePos, VZ, Zoffset, -dVD), _3d.cam.p.z-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT])shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, VX, Xoffset, dVD), _3d.cam.p.x+=_3d_shift_move_cam*dVD;
						if(kb[VK_LEFT])	shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, VX, Xoffset, -dVD), _3d.cam.p.x-=_3d_shift_move_cam*dVD;
					}
					else		//x
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, VX, Xoffset, dVD), _3d.cam.p.x+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, VX, Xoffset, -dVD), _3d.cam.p.x-=_3d_shift_move_cam*dVD;
					}
				}
			}
			else
			{
				if(kb['Y'])
				{
					if(kb['Z'])	//yz
					{
						if(kb[VK_UP])	shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, VZ, Zoffset, dVD), _3d.cam.p.z+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN])	shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, VZ, Zoffset, -dVD), _3d.cam.p.z-=_3d_shift_move_cam*dVD;
						if(kb[VK_RIGHT])shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, VY, Yoffset, dVD), _3d.cam.p.y+=_3d_shift_move_cam*dVD;
						if(kb[VK_LEFT])	shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, VY, Yoffset, -dVD), _3d.cam.p.y-=_3d_shift_move_cam*dVD;
					}
					else		//y
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, VY, Yoffset, dVD), _3d.cam.p.y+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, VY, Yoffset, -dVD), _3d.cam.p.y-=_3d_shift_move_cam*dVD;
					}
				}
				else
				{
					if(kb['Z'])	//z
					{
						if(kb[VK_UP]||kb[VK_RIGHT])	shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, VZ, Zoffset, dVD), _3d.cam.p.x+=_3d_shift_move_cam*dVD;
						if(kb[VK_DOWN]||kb[VK_LEFT])shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, VZ, Zoffset, -dVD), _3d.cam.p.x-=_3d_shift_move_cam*dVD;
					}
					else
					{
						if(kb[VK_UP])	_3d.cam.turnUp();
						if(kb[VK_DOWN])	_3d.cam.turnDown();
						if(kb[VK_RIGHT])_3d.cam.turnRight();
						if(kb[VK_LEFT])	_3d.cam.turnLeft();
					}
				}
			}
			if(kb[VK_ADD]||kb[VK_RETURN]||kb[VK_OEM_PLUS])
			{
				if(kb[VK_MENU])//alt+
				{
					if(_3d_zoom_move_cam)//zoom in
						DX/=1.1, _3d.cam.p.x=VX+(_3d.cam.p.x-VX)/1.1, _3d.cam.p.y=VY+(_3d.cam.p.y-VY)/1.1, _3d.cam.p.z=VZ+(_3d.cam.p.z-VZ)/1.1, _3d.cam.dcam/=1.1;
					else//zoom out
						DX*=1.1;
					function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);//
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);//
					shiftNDRupdate(ZshiftPoint, DX/Zplaces, ZsamplePos, VZ);//
					toSolve=true, shiftOnly=0;
				}
				else if(kb['X'])//x+ stretch (zoom out (compress), stretch y, z)
				{
					if(_3d_stretch_move_cam)
					{
						double VX0=VX, VY0=VY, VZ0=VZ;
						DX/=1.1;//zoom out
						function1();
						shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
						shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						shiftNDRupdate(ZshiftPoint, DX/Zplaces, ZsamplePos, VZ);
						_3d.cam.p.x=VX+(_3d.cam.p.x-VX0)/1.1, _3d.cam.p.y=VY+(_3d.cam.p.y-VY0)/1.1, _3d.cam.p.z=VZ+(_3d.cam.p.z-VZ0)/1.1, _3d.cam.dcam/=1.1;

						VY0=VY;//stretch y
						YshiftPoint/=1.1;
						AR_Y/=1.1, function1();
						shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						_3d.cam.p.y+=VY-VY0;
						
						VZ0=VZ;//stretch z
						ZshiftPoint/=1.1;
						AR_Z/=1.1, function1();
						shiftNDRupdate(ZshiftPoint, DX/Zplaces, ZsamplePos, VZ);
						_3d.cam.p.z+=VZ-VZ0;
					}
					else
					{
						DX/=1.1, AR_Y/=1.1, AR_Z/=1.1, function1();
						_3d.cam.p.x/=1.1, _3d.cam.p.y/=1.1, _3d.cam.p.z/=1.1, _3d.cam.dcam/=1.1;
						shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					}
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Y'])//y+ stretch
				{
					double VY0=VY;
					YshiftPoint*=1.1;//move cube
					AR_Y*=1.1, function1();
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					if(_3d_stretch_move_cam)
						_3d.cam.p.y+=VY-VY0;
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Z'])//z+ stretch
				{
					double VZ0=VZ;
					ZshiftPoint*=1.1;//move cube
					AR_Z*=1.1, function1();
					shiftNDRupdate(ZshiftPoint, DX/Zplaces, ZsamplePos, VZ);
					if(_3d_stretch_move_cam)
						_3d.cam.p.z+=VZ-VZ0;
					toSolve=true, shiftOnly=0;
				}
				else if(!(kb[VK_CONTROL]||kb[VK_SHIFT]))
					_3d.cam.zoomIn();
			}
			if(kb[VK_SUBTRACT]||kb[VK_BACK]||kb[VK_OEM_MINUS])
			{
				if(kb[VK_MENU])//alt-
				{
					if(_3d_zoom_move_cam)//zoom out
						DX*=1.1, _3d.cam.p.x=VX+(_3d.cam.p.x-VX)*1.1, _3d.cam.p.y=VY+(_3d.cam.p.y-VY)*1.1, _3d.cam.p.z=VZ+(_3d.cam.p.z-VZ)*1.1, _3d.cam.dcam*=1.1;
					else//zoom in
						DX/=1.1;
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);//
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);//
					shiftNDRupdate(ZshiftPoint, DX/Zplaces, ZsamplePos, VZ);//
					toSolve=true, shiftOnly=0;
				}
				else if(kb['X'])//x- compress (zoom in (stretch), compress y z)
				{
					if(_3d_stretch_move_cam)
					{
						double VX0=VX, VY0=VY, VZ0=VZ;
						DX*=1.1;//zoom in
						function1();
						shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
						shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						shiftNDRupdate(ZshiftPoint, DX/Zplaces, ZsamplePos, VZ);
						_3d.cam.p.x=VX+(_3d.cam.p.x-VX0)*1.1, _3d.cam.p.y=VY+(_3d.cam.p.y-VY0)*1.1, _3d.cam.p.z=VZ+(_3d.cam.p.z-VZ0)*1.1, _3d.cam.dcam*=1.1;
					
						VY0=VY;//compress y
						YshiftPoint*=1.1;
						AR_Y*=1.1, function1();
						shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
						_3d.cam.p.y+=VY-VY0;
					
						VZ0=VZ;//compress z
						ZshiftPoint*=1.1;
						AR_Z*=1.1, function1();
						shiftNDRupdate(ZshiftPoint, DX/Zplaces, ZsamplePos, VZ);
						_3d.cam.p.z+=VZ-VZ0;
					}
					else
					{
						DX*=1.1, AR_Y*=1.1, AR_Z*=1.1, function1();
						_3d.cam.p.x*=1.1, _3d.cam.p.y*=1.1, _3d.cam.p.z*=1.1, _3d.cam.dcam*=1.1;
						shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					}
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Y'])//y- compress
				{
					double VY0=VY;
					YshiftPoint/=1.1;//move cube
					AR_Y/=1.1, function1();
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					if(_3d_stretch_move_cam)
						_3d.cam.p.y+=VY-VY0;
					toSolve=true, shiftOnly=0;
				}
				else if(kb['Z'])//z- compress
				{
					double VZ0=VZ;
					ZshiftPoint/=1.1;
					AR_Z/=1.1, function1();
					shiftNDRupdate(ZshiftPoint, DX/Zplaces, ZsamplePos, VZ);
					if(_3d_stretch_move_cam)
						_3d.cam.p.z+=VZ-VZ0;
					toSolve=true, shiftOnly=0;
				}
				else if(!(kb[VK_CONTROL]||kb[VK_SHIFT]))
					_3d.cam.zoomOut();
			}
			a_draw();
			if(!time_variance&&!kp)
				KillTimer(ghWnd, 0), timer=false;
		}
		int inputLButtonDown(int lParam)
		{
			if(!drag)
			{
				if(!shift)
				{
					ShowCursor(0);
					GetCursorPos(&mouseP0);
					SetCursorPos(centerP.x, centerP.y);
					SetCapture(ghWnd);
				}
				drag=1;
			}
			return 0;
		}
		int inputMouseMove(int lParam)
		{
			if(!m_bypass)
			{
				auto &VX=xs.VX, &DX=xs.DX, &VY=ys.VX, &DY=ys.DX, &VZ=zs.VX, &DZ=zs.DX;
				int draw=0;
				int dmx=((short*)&lParam)[0]-w/2, dmy=h/2-((short*)&lParam)[1];
				if(kb['X'])
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//xyz	mx my mw
						{
							double VX0=VX, VY0=VY;
							shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, VX, Xoffset, dmx*DX/w), _3d.cam.p.x+=(VX-VX0)*_3d_shift_move_cam;
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y,	YsamplePos, VY, Yoffset, dmy*DX/w), _3d.cam.p.y+=(VY-VY0)*_3d_shift_move_cam;
						}
						else		//xy	mx my
						{
							double VX0=VX, VY0=VY;
							shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, VX, Xoffset, dmx*DX/w), _3d.cam.p.x+=(VX-VX0)*_3d_shift_move_cam;
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y,	YsamplePos, VY, Yoffset, dmy*DX/w), _3d.cam.p.y+=(VY-VY0)*_3d_shift_move_cam;
						}
						draw=1;
					}
					else
					{
						if(kb['Z'])	//xz	mx my
						{
							double VX0=VX, VZ0=VZ;
							shiftNDR(XshiftPoint, solver.Xsample,		XsamplePos, VX, Xoffset, dmx*DX/w), _3d.cam.p.x+=(VX-VX0)*_3d_shift_move_cam;
							shiftNDR(ZshiftPoint, solver.Zsample*AR_Z,	ZsamplePos, VZ, Zoffset, dmy*DX/w), _3d.cam.p.x+=(VZ-VZ0)*_3d_shift_move_cam;
						}
						else		//x		mx
						{
							double VX0=VX;
							shiftNDR(XshiftPoint, solver.Xsample, XsamplePos, VX, Xoffset, dmx*DX/w), _3d.cam.p.x+=(VX-VX0)*_3d_shift_move_cam;
						}
						draw=1;
					}
				}
				else
				{
					if(kb['Y'])
					{
						if(kb['Z'])	//yz	mx my
						{
							double VY0=VY, VZ0=VZ;
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, VY, Yoffset, dmx*DX/w), _3d.cam.p.y+=(VY-VY0)*_3d_shift_move_cam;
							shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, VZ, Zoffset, dmy*DX/w), _3d.cam.p.z+=(VZ-VZ0)*_3d_shift_move_cam;
						}
						else		//y		mx
						{
							double VY0=VY;
							shiftNDR(YshiftPoint, solver.Ysample*AR_Y, YsamplePos, VY, Yoffset, dmx*DX/w), _3d.cam.p.y+=(VY-VY0)*_3d_shift_move_cam;
						}
						draw=1;
					}
					else
					{
						if(kb['Z'])	//z		my
						{
							double VZ0=VZ;
							shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, VZ, Zoffset, dmy), _3d.cam.p.z+=(VZ-VZ0)*_3d_shift_move_cam;
							draw=1;
						}
						else if(drag)
						{
							_3d.cam.turnMouse(lParam);
							draw=1;
						}
					}
				}
				if(draw)
				{
					SetCursorPos(centerP.x, centerP.y);
					if(!time_variance&&!timer)
						a_draw();
				}
			}
			m_bypass=!m_bypass;
			return 0;
		}
		void inputLButtonUp(int lParam)
		{
			if(drag)
			{
				if(!shift)
				{
					ReleaseCapture();
					SetCursorPos(mouseP0.x, mouseP0.y);
					ShowCursor(1);
				}
				drag=0;
			}
		}
		int inputMouseWheel(int wParam)
		{
			auto &VX=xs.VX, &DX=xs.DX, &VY=ys.VX, &DY=ys.DX, &VZ=zs.VX, &DZ=zs.DX;
			bool mw_forward=((short*)&wParam)[1]>0;
			if(kb['X']&&kb['Y']&&kb['Z'])
				shiftNDR(ZshiftPoint, solver.Zsample*AR_Z, ZsamplePos, VZ, Zoffset, (mw_forward-!mw_forward)*DX/100);
			else if(kb[VK_MENU])//alt wheel
			{
				double zoom_signed=double(mw_forward)/1.1+!mw_forward*1.1;
				double VX0=VX, VY0=VY, VZ0=VZ;
				DX*=zoom_signed;
				function1();
				shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);//
				shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);//
				shiftNDRupdate(ZshiftPoint, DX/Zplaces, ZsamplePos, VZ);//
				if(_3d_zoom_move_cam)
				{
					_3d.cam.p.x=VX+(_3d.cam.p.x-VX0)*zoom_signed;
					_3d.cam.p.y=VY+(_3d.cam.p.y-VY0)*zoom_signed;
					_3d.cam.p.z=VZ+(_3d.cam.p.z-VZ0)*zoom_signed;
					_3d.cam.dcam*=zoom_signed;
				}
				toSolve=true, shiftOnly=0;
			}
			else if(kb['X'])//x wheel
			{
				double zoom_signed=double(mw_forward)/1.1+!mw_forward*1.1;
				if(_3d_stretch_move_cam)
				{
					double VX0=VX, VY0=VY;
					DX*=zoom_signed;
					function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					_3d.cam.p.x=VX+(_3d.cam.p.x-VX0)*zoom_signed, _3d.cam.p.y=VY+(_3d.cam.p.y-VY0)*zoom_signed, _3d.cam.p.z=VZ+(_3d.cam.p.z-VZ)*zoom_signed, _3d.cam.dcam*=zoom_signed;

					VY0=VY;//stretch y
					AR_Y*=zoom_signed,	YshiftPoint*=zoom_signed;
					function1();
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					_3d.cam.p.y+=VY-VY0;


					double VZ0=VZ;//stretch y
					AR_Z*=zoom_signed,	ZshiftPoint*=zoom_signed;
					function1();
					shiftNDRupdate(ZshiftPoint, DX/Zplaces, ZsamplePos, VZ);
					_3d.cam.p.z+=VZ-VZ0;
				}
				else
				{
						 if(mw_forward)	DX/=1.1, AR_Y/=1.1, AR_Z/=1.1, _3d.cam.p.x/=1.1, _3d.cam.p.y/=1.1, _3d.cam.p.z/=1.1, _3d.cam.dcam/=1.1;
					else				DX*=1.1, AR_Y*=1.1, AR_Z*=1.1, _3d.cam.p.x*=1.1, _3d.cam.p.y*=1.1, _3d.cam.p.z*=1.1, _3d.cam.dcam*=1.1;
					function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
				}
				toSolve=true, shiftOnly=0;
			}
			else if(kb['Y'])//y wheel
			{
				double VY0=VY;
					 if(mw_forward)	AR_Y*=1.1,	YshiftPoint*=1.1;
				else				AR_Y/=1.1,	YshiftPoint/=1.1;
				function1();
				shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
				_3d.cam.p.y+=(VY-VY0)*_3d_stretch_move_cam;
				toSolve=true, shiftOnly=0;
			}
			else if(kb['Z'])//z wheel
			{
				double VZ0=VZ;
					 if(mw_forward)	AR_Z*=1.1,	ZshiftPoint*=1.1;
				else				AR_Z/=1.1,	ZshiftPoint/=1.1;
				function1();
				shiftNDRupdate(ZshiftPoint, DX/Zplaces, ZsamplePos, VZ);
				_3d.cam.p.z+=(VZ-VZ0)*_3d_stretch_move_cam;
				toSolve=true, shiftOnly=0;
			}
			else if(kb[VK_CONTROL])//ctrl wheel: change speed
			{
					 if(mw_forward)	_3d.cam.faster();
				else				_3d.cam.slower();
			}
			else if(kb[VK_SHIFT])//shift wheel: change resolution
			{
				if(usingOpenGL==MODE_CL_GL_INTEROP)
					cl_setsizes(MODE_C3D, &Xplaces, &Yplaces, &Zplaces, mw_forward-!mw_forward), toSolve=true, shiftOnly=0;
				else if(mw_forward)
				{
					if(Xplaces<512)
						Zplaces=Yplaces=Xplaces+=1<<max_simd_method, toSolve=true, shiftOnly=0;
				}
				else if(Xplaces>1<<max_simd_method)
					Zplaces=Yplaces=Xplaces-=1<<max_simd_method, toSolve=true, shiftOnly=0;
			}
			else//wheel
			{
					 if(mw_forward)	_3d.cam.zoomIn();
				else				_3d.cam.zoomOut();
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		int inputKeyDown(int wParam, int lParam)
		{
			auto &VX=xs.VX, &DX=xs.DX, &VY=ys.VX, &DY=ys.DX, &VZ=zs.VX, &DZ=zs.DX;
			switch(wParam)
			{
			case 'W':case 'A':case 'S':case 'D':case VK_UP:case VK_DOWN:case VK_LEFT:case VK_RIGHT:case 'T':case 'G':
				if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case VK_ADD:case VK_OEM_PLUS:case VK_RETURN:
				if(kb[VK_CONTROL])
					_3d.cam.faster();
				else if(kb[VK_SHIFT])//increase resolution
				{
					if(usingOpenGL==MODE_CL_GL_INTEROP)
						cl_setsizes(MODE_C3D, &Xplaces, &Yplaces, &Zplaces, 1), toSolve=true, shiftOnly=0;
					else if(Xplaces<512)
						Zplaces=Yplaces=Xplaces+=1<<max_simd_method, toSolve=true, shiftOnly=0;
					break;
				}
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case VK_SUBTRACT:case VK_OEM_MINUS:case VK_BACK:
				if(kb[VK_CONTROL])
					_3d.cam.slower();
				else if(kb[VK_SHIFT])//decrease resolution
				{
					if(usingOpenGL==MODE_CL_GL_INTEROP)
						cl_setsizes(MODE_C3D, &Xplaces, &Yplaces, &Zplaces, -1), toSolve=true, shiftOnly=0;
					else if(Xplaces>1<<max_simd_method)
						Zplaces=Yplaces=Xplaces-=1<<max_simd_method, toSolve=true, shiftOnly=0;
					break;
				}
				else if(!(lParam&1<<30))
				{
					if(!kb[wParam])
						++kp;
					if(!time_variance&&!timer)
						SetTimer(ghWnd, 0, 10, 0), timer=true;
				}
				return 0;
			case 'X':case 'Y':case 'Z':
				if(!(lParam&1<<30)&&!shift)
				{
					if(!drag)
					{
						GetCursorPos(&mouseP0);
						ShowCursor(0);
						SetCursorPos(centerP.x, centerP.y);
						SetCapture(ghWnd);
					}
					shift=1;
				}
				return 0;
			case VK_OEM_3://'`' grave accent
				if(contourOn)//was on
				{
					if(kb[VK_CONTROL])
					{
						//contour+surface
						//contour only
						//flat contour
						//flat+surface
						if(contourFlat)
						{
							if(contourOnly)
								contourOnly=false;//3: surface appears
							else
								contourFlat=false;//4: pops up
						}
						else
						{
							if(contourOnly)
								contourFlat=true;//2: gets flat
							else
								contourOnly=true;//1: surface disappears
						}
					}
					else
						contourOn=false, contourOnly=false, contourFlat=false;
				}
				else//contour was off
				{
					contourOn=true;
					if(!toSolve&&usingOpenGL!=MODE_CL_GL_INTEROP)
					{
						Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
						Rlines.clear(), Ilines.clear(), Jlines.clear(), Klines.clear();
						doContour(cursorEx);
					}
				}
				break;
			case 'F':
				//if(contourOn)
					contourWireframe=!contourWireframe;
				break;
			case '0':case VK_NUMPAD0:
				if(operations.size())
					toSolve=true, shiftOnly=0;
				operations.clear();
				break;
			case '1':case VK_NUMPAD1:
			case '2':case VK_NUMPAD2:
			case '3':case VK_NUMPAD3:
			case '4':case VK_NUMPAD4:
			case '5':case VK_NUMPAD5:
			case '6':case VK_NUMPAD6:
			case '7':case VK_NUMPAD7:
			case '8':case VK_NUMPAD8:
				{
					auto op=&Color_3D::differentiate_xyz;
					switch(wParam)
					{
					case '1':case VK_NUMPAD1:
							 if(kb['X']){		 if(kb['Y']){		 if(kb['Z'])operations.push_back( 1), op=&Color_3D::differentiate_xyz;
																else			operations.push_back( 5), op=&Color_3D::differentiate_xy;}
											else			{		 if(kb['Z'])operations.push_back( 7), op=&Color_3D::differentiate_xz;
																else			operations.push_back( 2), op=&Color_3D::differentiate_x;}}
						else			{		 if(kb['Y']){		 if(kb['Z'])operations.push_back( 6), op=&Color_3D::differentiate_yz;
																else			operations.push_back( 3), op=&Color_3D::differentiate_y;}
											else			{		 if(kb['Z'])operations.push_back( 4), op=&Color_3D::differentiate_z;
																else			operations.push_back( 1), op=&Color_3D::differentiate_xyz;}}
						break;
					case '2':case VK_NUMPAD2:
							 if(kb['X']){		 if(kb['Y']){		 if(kb['Z'])operations.push_back( 8), op=&Color_3D::integrate_xyz;
																else			operations.push_back(12), op=&Color_3D::integrate_xy;}
											else			{		 if(kb['Z'])operations.push_back(14), op=&Color_3D::integrate_xz;
																else			operations.push_back( 9), op=&Color_3D::integrate_x;}}
						else			{		 if(kb['Y']){		 if(kb['Z'])operations.push_back(13), op=&Color_3D::integrate_yz;
																else			operations.push_back(10), op=&Color_3D::integrate_y;}
											else			{		 if(kb['Z'])operations.push_back(11), op=&Color_3D::integrate_z;
																else			operations.push_back( 8), op=&Color_3D::integrate_xyz;}}
						break;
					case '3':case VK_NUMPAD3:	operations.push_back(15), op=&Color_3D::discreteFourrierTransform;			break;
					case '4':case VK_NUMPAD4:	operations.push_back(16), op=&Color_3D::inverseDiscreteFourrierTransform;	break;
					case '5':case VK_NUMPAD5:
							 if(kb['X']){		 if(kb['Y']){		 if(kb['Z'])operations.push_back(17), op=&Color_3D::lowPassFilter_xyz;
																else			operations.push_back(21), op=&Color_3D::lowPassFilter_xy;}
											else			{		 if(kb['Z'])operations.push_back(23), op=&Color_3D::lowPassFilter_xz;
																else			operations.push_back(18), op=&Color_3D::lowPassFilter_x;}}
						else			{		 if(kb['Y']){		 if(kb['Z'])operations.push_back(22), op=&Color_3D::lowPassFilter_yz;
																else			operations.push_back(19), op=&Color_3D::lowPassFilter_y;}
											else			{		 if(kb['Z'])operations.push_back(20), op=&Color_3D::lowPassFilter_z;
																else			operations.push_back(17), op=&Color_3D::lowPassFilter_xyz;}}
						break;
					case '6':case VK_NUMPAD6:
							 if(kb['X']){		 if(kb['Y']){		 if(kb['Z'])operations.push_back(24), op=&Color_3D::highPassFilter_xyz;
																else			operations.push_back(28), op=&Color_3D::highPassFilter_xy;}
											else			{		 if(kb['Z'])operations.push_back(30), op=&Color_3D::highPassFilter_xz;
																else			operations.push_back(25), op=&Color_3D::highPassFilter_x;}}
						else			{		 if(kb['Y']){		 if(kb['Z'])operations.push_back(29), op=&Color_3D::highPassFilter_yz;
																else			operations.push_back(26), op=&Color_3D::highPassFilter_y;}
											else			{		 if(kb['Z'])operations.push_back(27), op=&Color_3D::highPassFilter_z;
																else			operations.push_back(24), op=&Color_3D::highPassFilter_xyz;}}
						break;
					}
					if(!toSolve)
					{
						Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
						Rlines.clear(), Ilines.clear(), Jlines.clear(), Klines.clear();
						(this->*op)(expr[cursorEx].n[expr[cursorEx].resultTerm]);
						if(contourOn)
							doContour(cursorEx);
					}
				}
				break;
			case 'C':
				clearScreen=!clearScreen;
				break;
			case 'E':
				{
					double r=20/DX;

					XshiftPoint*=r, YshiftPoint*=r, ZshiftPoint*=r;
					_3d.cam.p.x*=r, _3d.cam.p.y*=r, _3d.cam.p.z*=r, _3d.cam.dcam*=r;
					xs.reset_scale(), ys.reset_scale(), zs.reset_scale(), AR_Y=1, AR_Z=1, function1();
					shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
					shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
					shiftNDRupdate(ZshiftPoint, DX/Zplaces, ZsamplePos, VZ);
					toSolve=true, shiftOnly=0;
				}
				break;
			case 'R':
			//	_3d.lsw_transparency_multiply=!_3d.lsw_transparency_multiply;//
				_3d.cam.dcam=.04, _3d.cam.tanfov=1;
				if(!kb[VK_CONTROL])
					xs.reset_scale(), ys.reset_scale(), zs.reset_scale(), AR_Y=1, AR_Z=1, function1(), Xplaces=Yplaces=Zplaces=8;//4 12	//Xplaces multiple of 4
				
				XshiftPoint=YshiftPoint=ZshiftPoint=0;
				shiftNDRupdate(XshiftPoint, DX/Xplaces, XsamplePos, VX);
				shiftNDRupdate(YshiftPoint, DX/Yplaces, YsamplePos, VY);
				shiftNDRupdate(ZshiftPoint, DX/Zplaces, ZsamplePos, VZ);
				xs.reset_position(), ys.reset_position(), zs.reset_position();
				toSolve=true, shiftOnly=0;
				if(kb['X'])
					_3d.teleport_degrees(20, 0, 0, 180, 0, 1);
				else if(kb['Y'])
					_3d.teleport_degrees(0, 20, 0, 270, 0, 1);
				else if(kb['Z'])
					_3d.teleport_degrees(0, 0, 20, 90, 270, 1);
				else
					_3d.teleport_degrees(20, 20, 20, 225, 324.7356103172454, 1);
				break;
			case VK_F6://change camera settings
				if(!(lParam&1<<30))
				{
					kb_VK_F6_msg=true;
					if(!_3d_stretch_move_cam&!_3d_shift_move_cam&!_3d_zoom_move_cam)
						_3d_stretch_move_cam=true;
					else if(!_3d_shift_move_cam&!_3d_zoom_move_cam)
						_3d_shift_move_cam=true;
					else if(!_3d_zoom_move_cam)
						_3d_zoom_move_cam=true;
					else
						_3d_stretch_move_cam=_3d_shift_move_cam=_3d_zoom_move_cam=false;
				}
				break;
			default:
				if(lParam&1<<30)
					return 0;
				break;
			}
			if(!time_variance&&!timer)
				a_draw();
			return 0;
		}
		void draw()
		{
			static GPUBuffer gl_buf;
		//	static unsigned gl_vertex_buf=0, gl_idx_buf=0;
			prof_add("entry");
			if(usingOpenGL)
				gl_enabledepthtest();
			auto &VX=xs.VX, &DX=xs.DX, &VY=ys.VX, &DY=ys.DX, &VZ=zs.VX, &DZ=zs.DX;
			DY=DX/AR_Y, DZ=DX/AR_Z;
			auto &ex=expr[cursorEx];
			{
				bool changed=false;
				if(toSolve)
				{
					if(usingOpenGL==MODE_CL_GL_INTEROP)
					{
						if(!paused)
							solver.synchronize();

						//generate_glcl_buffer(gl_buf.VBO);
						//generate_glcl_buffer(gl_buf.EBO);

						cl_setsizes(MODE_C3D, &Xplaces, &Yplaces, &Zplaces);
						xs.set_Xplaces(Xplaces), ys.set_Xplaces(Yplaces), zs.set_Xplaces(Zplaces);
						XsamplePos=std::floor(XshiftPoint/solver.Xsample);
						YsamplePos=std::floor(YshiftPoint/solver.Ysample);
						ZsamplePos=std::floor(ZshiftPoint/solver.Zsample);
						ModeParameters mp=
						{
							MODE_C3D, 1,
							(unsigned)Xplaces, (unsigned)Yplaces, (unsigned)Zplaces,//ndr dimensions
							xs.Xstart, xs.Xsample,
							ys.Xstart, ys.Xsample,
							zs.Xstart, zs.Xsample,
							nullptr, nullptr,
						};
						cl_solve(ex, mp, solver.T, &gl_buf);
					}
					else if(!operations.size()&&shiftOnly==1&&abs(Xoffset)<Xplaces&&abs(Yoffset)<Yplaces&&abs(Zoffset)<Zplaces)
					{
						solver.partial_bounds(VX, DX, VY/AR_Y, DY, VZ/AR_Z, DZ, Xoffset, Yoffset, Zoffset);
						solver.synchronize();
						prof_add("prep");
						(solver.*(ex.nITD?&Solve_3D::full:solver.partial))(ex);
						prof_add("partial solve");
					}
					else
					{
						auto old_time_variance=time_variance;
						time_variance=false;
						labels.clear();
					//	Xplaces=Yplaces=Zplaces=
					//		50//2//4//8//10//50
					//		;
						xs.set_Xplaces(Xplaces), ys.set_Xplaces(Yplaces), zs.set_Xplaces(Zplaces);
						solver.full_resize(VX, DX, VY/AR_Y, DY, VZ/AR_Z, DZ, Xplaces, Yplaces, Zplaces);
						XsamplePos=std::floor(XshiftPoint/solver.Xsample);
						YsamplePos=std::floor(YshiftPoint/solver.Ysample);
						ZsamplePos=std::floor(ZshiftPoint/solver.Zsample);
						time_variance|=ex.nITD;
						labels.fill(cursorEx);
						if(!paused)
							solver.synchronize();
						prof_add("prep");
						solver.full(ex);
						prof_add("solve");
						doOperations(ex.n[ex.resultTerm]);
						if(time_variance)
						{
							if(!paused)
								SetTimer(ghWnd, 0, 10, 0);
						}
						else if(old_time_variance&&!timer)
							KillTimer(ghWnd, 0);
					}
					toSolve=false, shiftOnly=2, Xoffset=Yoffset=Zoffset=0;
					changed=true;
				}
				else if(time_variance)
				{
					if(!paused)
						solver.synchronize();
					solver.full(ex);
					doOperations(ex.n[ex.resultTerm]);
					changed=true;
				}
				if(changed&&usingOpenGL!=MODE_CL_GL_INTEROP)
				{
					solver.updateRGB(ex);
					if(contourOn)
					{
						Rcontours.clear(), Icontours.clear(), Jcontours.clear(), Kcontours.clear();
						Rlines.clear(), Ilines.clear(), Jlines.clear(), Klines.clear();
						doContour(cursorEx);
						prof_sum("gen contour", 2);
					}
				}
			}
			
			clear_depth_buffer();
			if(usingOpenGL)
				GL2_3D::begin();
		//	_3d.newFrame();
			if(!clearScreen)
				_3dMode_DrawGridNAxes(_3d, xs, ys, zs, AR_Y, AR_Z);
			prof_add("grid");
			if(usingOpenGL==MODE_CL_GL_INTEROP)
			{
				vec3 lightpos=_3d.cam.p;
				if(contourWireframe)
					glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
				GL2_L3D::draw_buffer(_3d.cam, gl_buf, vec3(), lightpos, ex.getColor());
				if(contourWireframe)
					glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
				//if(!debug_info.size())
				//	draw_contour_debuggrid(0x40FF00FF);
#if 1
				if(contourOn)
				{
					_3d.lineColor=0x400080FF;//orange normals
					for(int k=0;k<(int)debug_vertices.size();k+=6)
					{
						dvec3 p1(debug_vertices[k], debug_vertices[k+1], debug_vertices[k+2]);
						_3d.line(p1, p1+dvec3(debug_vertices[k+3], debug_vertices[k+4], debug_vertices[k+5]));
					}
				}
				if(debug_info.size())
				{
					double
						Xstart=xs.Xstart, Xsample=xs.Xsample,
						Ystart=ys.Xstart, Ysample=ys.Xsample,
						Zstart=zs.Xstart, Zsample=zs.Xsample;
					const int edgecolors[]=
					{
						0x40FF0000,
						0x4000FF00,
						0x400000FF,
						0x40FF00FF,
					};
					for(int k=0;k<(int)debug_info.size();++k)
					{
						auto &dik=debug_info[k];
						double
							x1=Xstart+dik.kx*Xsample, x2=x1+Xsample,
							y1=Ystart+dik.ky*Ysample, y2=y1+Ysample,
							z1=Zstart+dik.kz*Zsample, z2=z1+Zsample;
						dvec3 p1(x1, y1, z1);
						_3d.lineColor=0x40FFFF00;//cyan origin
					//	_3d.lineColor=0x40FF00FF;
						_3d.line(p1, dvec3(x2, y1, z1));
						_3d.line(p1, dvec3(x1, y2, z1));
						_3d.line(p1, dvec3(x1, y1, z2));
						int ke7=dik.ke*7;
						dvec3
							a1(debug_edges[ke7  ]*Xsample*0.5, debug_edges[ke7+1]*Ysample*0.5, debug_edges[ke7+2]*Zsample*0.5),
							a2(debug_edges[ke7+3]*Xsample*0.5, debug_edges[ke7+4]*Ysample*0.5, debug_edges[ke7+5]*Zsample*0.5);
						_3d.lineColor=edgecolors[debug_edges[ke7+6]];
					//	_3d.lineColor=0x40FF0000;//blue edges
						_3d.line(p1+a1, p1+a2);
						_3d.label(dik.x, dik.y, dik.z, "(%d,%d,%d,%d)", dik.kx, dik.ky, dik.kz, dik.ke);//
					//	_3d.label(dik.x, dik.y, dik.z, "%d:%f", dik.kv, dik.r);//
						break;//
					}
				}
#endif
#if 0//DEBUG
				if(contourOn)//label vertices
				{
					for(int k=0;k+5<(int)debug_vertices.size();k+=6)
						_3d.label(debug_vertices[k], debug_vertices[k+1], debug_vertices[k+2], "V%d", k/6);
				}
				else//label triangles
				{
					for(int k=0;k<(int)debug_indices.size();k+=3)
					{
						int ki=debug_indices[k]*6;
						vec3 p1(debug_vertices[ki], debug_vertices[ki+1], debug_vertices[ki+2]);
						ki=debug_indices[k+1]*6;
						vec3 p2(debug_vertices[ki], debug_vertices[ki+1], debug_vertices[ki+2]);
						ki=debug_indices[k+2]*6;
						vec3 p3(debug_vertices[ki], debug_vertices[ki+1], debug_vertices[ki+2]);
						vec3 av=(p1+p2+p3)*(1.f/3);
						_3d.label(av.x, av.y, av.z, "T%d", k/3);
					}
				}
#endif
			}
			else
			{
				if(!contourOnly)//draw the points
				{
					unsigned v=0;
					switch(ex.resultMathSet)
					{
					case 'R':case 'c':
						for(int k=0;k<Zplaces;++k)
							for(int k2=0;k2<Yplaces;++k2)
								for(int k3=0;k3<Xplaces;++k3, ++v)
									point_3D_2x2(_3d.cam, dvec3(xs.ifn_x(k3), ys.ifn_x(k2), zs.ifn_x(k)), solver.ndr_rgb[v]);
								//	_3d.point(xs.ifn_x(k3), ys.ifn_x(k2), zs.ifn_x(k), solver.ndr_rgb[v]);
						break;
					case 'h':
						for(int k=0;k<Zplaces;++k)
							for(int k2=0;k2<Yplaces;++k2)
								for(int k3=0;k3<Xplaces;++k3, ++v)
									point_3D_2x2(_3d.cam, dvec3(xs.ifn_x(k3), ys.ifn_x(k2), zs.ifn_x(k)), solver.ndr_rgb[v], solver.ndr_rgb_i[v], solver.ndr_rgb_j[v], solver.ndr_rgb_k[v]);
								//	_3d.point(xs.ifn_x(k3), ys.ifn_x(k2), zs.ifn_x(k), solver.ndr_rgb[v], solver.ndr_rgb_i[v], solver.ndr_rgb_j[v], solver.ndr_rgb_k[v]);
						break;
					}
					prof_add("points");
					if(!contourOn)//draw the cross-sections
					{
						int txsize=Xplaces*Yplaces;
						double
							X1=xs.ifn_x(-0.5), X2=xs.ifn_x(Xplaces-0.5),
							Y1=ys.ifn_x(-0.5), Y2=ys.ifn_x(Yplaces-0.5);
						if(usingOpenGL)
						{
							for(int kz=0;kz<Zplaces;++kz)
							{
								float z=(float)zs.ifn_x(kz);
								GL2_3D::push_square((float)X1, (float)X2, (float)Y1, (float)Y2, z, solver.ndr_rgb+txsize*kz, Xplaces, Yplaces);//red & blue should be swapped
							}
						}
						else
						{
							dvec3 p1(X1, Y1, 0), p2(X2, Y1, 0), p3(X2, Y2, 0), p4(X1, Y2, 0);
							vec2 t1(0, 0), t2((float)Xplaces, 0), t3((float)Xplaces, (float)Yplaces), t4(0, (float)Yplaces);
						//	vec2 t1(0, 0), t2((float)Xplaces-1, 0), t3((float)Xplaces-1, (float)Yplaces-1), t4(0, (float)Yplaces-1);
							mat2 m1, m2;
							_3d.transform(p1, p2, p3, t1, t2, t3, m1);
							_3d.transform(p3, p4, p1, t3, t4, t1, m2);
							for(int kz=0;kz<Zplaces;++kz)
							{
								p1.z=p2.z=p3.z=p4.z=zs.ifn_x(kz);
								render_textured_transparent(_3d.cam, p1, p2, p3, solver.ndr_rgb+txsize*kz, Xplaces, Yplaces, t1, m1);
								render_textured_transparent(_3d.cam, p3, p4, p1, solver.ndr_rgb+txsize*kz, Xplaces, Yplaces, t3, m2);
							}
						}

					//	float
					//		X1=(float)xs.ifn_x(-0.5), X2=(float)xs.ifn_x(Xplaces-0.5),
					//		Y1=(float)ys.ifn_x(-0.5), Y2=(float)ys.ifn_x(Yplaces-0.5);
					//		//X1=(float)xs.ifn_x(0), X2=(float)xs.ifn_x(Xplaces-1),
					//		//Y1=(float)ys.ifn_x(0), Y2=(float)ys.ifn_x(Yplaces-1);
					//	vec3 p1(X1, Y1, 0), p2(X2, Y1, 0), p3(X2, Y2, 0), p4(X1, Y2, 0);
					//	vec2 t1(0, 0), t2((float)Xplaces, 0), t3((float)Xplaces, (float)Yplaces), t4(0, (float)Yplaces);
					////	vec2 t1(0, 0), t2((float)Xplaces-1, 0), t3((float)Xplaces-1, (float)Yplaces-1), t4(0, (float)Yplaces-1);
					//	mat2 m1, m2;
					//	_3d.transform(p1, p2, p3, t1, t2, t3, m1);
					//	_3d.transform(p3, p4, p1, t3, t4, t1, m2);
					//	int txsize=Xplaces*Yplaces;
					//	for(int kz=0;kz<Zplaces;++kz)
					//	{
					//		p1.z=p2.z=p3.z=p4.z=(float)zs.ifn_x(kz);
					//		_3d.render_textured_transparent(p1, p2, p3, solver.ndr_rgb+txsize*kz, Xplaces, Yplaces, t1, m1);
					//		_3d.render_textured_transparent(p3, p4, p1, solver.ndr_rgb+txsize*kz, Xplaces, Yplaces, t3, m2);
					//	}

						//mat2 txm(1, 0, 0, 1);
						//vec2 tx1(0, 0);
						//int txsize=Xplaces*Yplaces;
						//for(int kz=0;kz<Zplaces;kz+=2)
						//{
						//	float Z=(float)zs.ifn_x(kz),
						//		X1=(float)xs.ifn_x(0), X2=(float)xs.ifn_x(Xplaces-1),
						//		Y1=(float)ys.ifn_x(0), Y2=(float)ys.ifn_x(Yplaces-1);
						//	_3d.render_textured_transparent(vec3(X1, Y1, Z), vec3(X2, Y1, Z), vec3(X2, Y2, Z), solver.ndr_rgb+txsize*kz, Xplaces, Yplaces, tx1, txm);
						//	_3d.render_textured_transparent(vec3(X2, Y2, Z), vec3(X1, Y2, Z), vec3(X1, Y1, Z), solver.ndr_rgb+txsize*kz, Xplaces, Yplaces, tx1, txm);
						//}

						//mat2 txm(1, 0, 0, 1);
						//vec2 tx1(0, 0);
						//_3d.render_textured_transparent(vec3(0, 0, 0), vec3(1, 0, 0), vec3(1, 1, 0), solver.ndr_rgb, Xplaces, Yplaces, tx1, txm);
						prof_add("planes");
					}
				}
				if(contourOn)//draw the contour
				{
				/*	int lineColor=_3d.lineColor;//DEBUG lines
					_3d.lineColor=0xFF00FF;
					for(int kz=0;kz<Zplaces-1;++kz)
					{
						for(int ky=0;ky<Yplaces-1;++ky)
						{
							for(int kx=0;kx<Xplaces-1;++kx)
							{
								double
									X_W=xs.ifn_x(kx), X_m=xs.ifn_x(kx+.5), X_E=xs.ifn_x(kx+1),
									Y_S=ys.ifn_x(ky), Y_m=ys.ifn_x(ky+.5), Y_N=ys.ifn_x(ky+1),
									Z_D=zs.ifn_x(kz), Z_m=zs.ifn_x(kz+.5), Z_U=zs.ifn_x(kz+1);
								_3d.line(X_W, Y_S, Z_D, X_E, Y_S, Z_D);//edges
								_3d.line(X_E, Y_S, Z_D, X_E, Y_N, Z_D);
								_3d.line(X_E, Y_N, Z_D, X_W, Y_N, Z_D);
								_3d.line(X_W, Y_N, Z_D, X_W, Y_S, Z_D);

								_3d.line(X_E, Y_S, Z_U, X_W, Y_S, Z_U);
								_3d.line(X_W, Y_S, Z_U, X_W, Y_N, Z_U);
								_3d.line(X_W, Y_N, Z_U, X_E, Y_N, Z_U);
								_3d.line(X_E, Y_N, Z_U, X_E, Y_S, Z_U);

								_3d.line(X_W, Y_S, Z_D, X_W, Y_S, Z_U);
								_3d.line(X_W, Y_N, Z_D, X_W, Y_N, Z_U);
								_3d.line(X_E, Y_N, Z_D, X_E, Y_N, Z_U);
								_3d.line(X_E, Y_S, Z_D, X_E, Y_S, Z_U);

								_3d.line(X_E, Y_S, Z_U, X_W, Y_N, Z_U);//face crosses
								_3d.line(X_W, Y_S, Z_U, X_E, Y_N, Z_U);//U

								_3d.line(X_E, Y_S, Z_U, X_W, Y_S, Z_D);//S
								_3d.line(X_W, Y_S, Z_U, X_E, Y_S, Z_D);

								_3d.line(X_E, Y_S, Z_U, X_E, Y_N, Z_D);//E
								_3d.line(X_E, Y_N, Z_U, X_E, Y_S, Z_D);

								_3d.line(X_E, Y_N, Z_U, X_W, Y_N, Z_D);//N
								_3d.line(X_W, Y_N, Z_U, X_E, Y_N, Z_D);

								_3d.line(X_W, Y_S, Z_U, X_W, Y_N, Z_D);//W
								_3d.line(X_W, Y_N, Z_U, X_W, Y_S, Z_D);
							
								_3d.line(X_E, Y_S, Z_D, X_W, Y_N, Z_D);//D
								_3d.line(X_W, Y_S, Z_D, X_E, Y_N, Z_D);

								_3d.line(X_E, Y_S, Z_U, X_W, Y_N, Z_D);//opposite vertices
								_3d.line(X_E, Y_N, Z_U, X_W, Y_S, Z_D);
								_3d.line(X_W, Y_N, Z_U, X_E, Y_S, Z_D);
								_3d.line(X_W, Y_S, Z_U, X_E, Y_N, Z_D);

								_3d.line(X_m, Y_m, Z_U, X_m, Y_m, Z_D);//internal
								_3d.line(X_m, Y_S, Z_m, X_m, Y_N, Z_m);
								_3d.line(X_W, Y_m, Z_m, X_E, Y_m, Z_m);
							}
						}
					}
					_3d.lineColor=lineColor;//end DEBUG lines//*/

					draw_contour(Rcontours, Rlines, rColor);
					if(ex.resultMathSet>='c')
					{
						draw_contour(Icontours, Ilines, iColor);
						if(ex.resultMathSet=='h')
						{
							draw_contour(Jcontours, Jlines, jColor);
							draw_contour(Kcontours, Klines, kColor);
						}
					}
					prof_add("contour");
					//switch(ex.resultMathSet)
					//{
					//case 'R':
					//	draw_contour(Rcontours, Rlines, rColor);
					//	break;
					//case 'c':
					//	draw_contour(Rcontours, Rlines, rColor);
					//	draw_contour(Icontours, Ilines, iColor);
					//	break;
					//case 'h':
					//	draw_contour(Rcontours, Rlines, rColor);
					//	draw_contour(Icontours, Ilines, iColor);
					//	draw_contour(Icontours, Ilines, jColor);
					//	draw_contour(Icontours, Ilines, kColor);
					//	break;
					//}
				/*	auto &ndr=ex.n[ex.resultTerm].r;		//print values at verteces (DEBUG)
					int XYplaces=Xplaces*Yplaces;
					for(int kz=0;kz<Zplaces-1;++kz)
					{
						for(int ky=0;ky<Yplaces-1;++ky)
						{
							for(int kx=0;kx<Xplaces-1;++kx)
							{
								double
									X_W=xs.ifn_x(kx), X_m=xs.ifn_x(kx+.5), X_E=xs.ifn_x(kx+1),
									Y_S=ys.ifn_x(ky), Y_m=ys.ifn_x(ky+.5), Y_N=ys.ifn_x(ky+1),
									Z_D=zs.ifn_x(kz), Z_m=zs.ifn_x(kz+.5), Z_U=zs.ifn_x(kz+1);
								int idx=Xplaces*(Yplaces*kz+ky)+kx;
								double
									V_UNW=ndr[idx+XYplaces+Xplaces],	V_UNE=ndr[idx+XYplaces+Xplaces+1],
									V_USW=ndr[idx+XYplaces],			V_USE=ndr[idx+XYplaces+1],

									V_DNW=ndr[idx+Xplaces],				V_DNE=ndr[idx+Xplaces+1],
									V_DSW=ndr[idx],						V_DSE=ndr[idx+1];
								_3d.label(X_W, Y_m, Z_m, "W: %g", (V_UNW+V_USW+V_DNW+V_DSW)*0.25);
								_3d.label(X_E, Y_m, Z_m, "E: %g", (V_UNE+V_USE+V_DNE+V_DSE)*0.25);

								_3d.label(X_m, Y_S, Z_m, "S: %g", (V_USW+V_USE+V_DSW+V_DSE)*0.25);
								_3d.label(X_m, Y_N, Z_m, "N: %g", (V_UNW+V_UNE+V_DNW+V_DNE)*0.25);
							
								_3d.label(X_m, Y_m, Z_D, "D: %g", (V_DNW+V_DSW+V_DNE+V_DSE)*0.25);
								_3d.label(X_m, Y_m, Z_U, "U: %g", (V_UNW+V_USW+V_UNE+V_USE)*0.25);
							
								_3d.label(X_m, Y_m, Z_m, "m: %g", (V_UNW+V_USW+V_DNW+V_DSW+V_UNE+V_USE+V_DNE+V_DSE)*0.125);
							}
						}
					}
					for(int kz=0;kz<Zplaces;++kz)
						for(int ky=0;ky<Yplaces;++ky)
							for(int kx=0;kx<Xplaces;++kx)
								_3d.label(xs.ifn_x(kx), ys.ifn_x(ky), zs.ifn_x(kz), "%c%c%c: %g", kz?'U':'D', ky?'N':'S', kx?'E':'W', ndr[Xplaces*(Yplaces*kz+ky)+kx]);//*/
				}
			}
			if(usingOpenGL)
			{
				GL2_3D::end();
				prof_add("send");
				GL2_3D::draw(_3d.cam);
				prof_add("draw");
			}
			if(!clearScreen)
			{
				int bkMode=getBkMode();
			//	int bkMode=GetBkMode(ghMemDC);
				_3dMode_NumberAxes(_3d, xs, ys, zs, AR_Y, AR_Z);
				_3d.arrowLabels(0, 0, 0, 1, 0, 0, labels.Xlabels);
				_3d.arrowLabels(0, 0, 0, 0, 1, 0, labels.Ylabels);
				_3d.arrowLabels(0, 0, 0, 0, 0, 1, labels.Zlabels);
				{
					int Ys=0;
					for(int kl=0, klEnd=labels.Clabels.size();kl<klEnd;++kl)
					{
						auto &label=labels.Clabels[kl];
						int linelen=sprintf_s(g_buf, "%s=%g", label.label.c_str(), label.isTime?solver.T:label.value);
						print(w-const_label_offset_X, Ys, g_buf, linelen), Ys+=16;
					//	TextOutA(ghMemDC, w-const_label_offset_X, Ys, g_buf, linelen), Ys+=16;
					}
				}
				prof_add("label axes");
				//if(operations.size())
				//{
				//	int k=0, Y=h-operations.size()*16;
				//	for(auto it=operations.begin();it!=operations.end();++it)
				//	{
				//		auto &operation=*it;
				//		char const *a=0;
				//		switch(operation)
				//		{
				//		case  1:a="%d: Differentiate XYZ";	break;
				//		case  2:a="%d: Differentiate X";	break;
				//		case  3:a="%d: Differentiate Y";	break;
				//		case  4:a="%d: Differentiate Z";	break;
				//		case  5:a="%d: Differentiate XY";	break;
				//		case  6:a="%d: Differentiate YZ";	break;
				//		case  7:a="%d: Differentiate XZ";	break;
				//		case  8:a="%d: Integrate XYZ";		break;
				//		case  9:a="%d: Integrate X";		break;
				//		case 10:a="%d: Integrate Y";		break;
				//		case 11:a="%d: Integrate Z";		break;
				//		case 12:a="%d: Integrate XY";		break;
				//		case 13:a="%d: Integrate YZ";		break;
				//		case 14:a="%d: Integrate XZ";		break;
				//		case 15:a="%d: DFT";				break;
				//		case 16:a="%d: IDFT";				break;
				//		case 17:a="%d: LPF";				break;
				//		case 18:a="%d: LPF X";				break;
				//		case 19:a="%d: LPF Y";				break;
				//		case 20:a="%d: LPF Z";				break;
				//		case 21:a="%d: LPF XY";				break;
				//		case 22:a="%d: LPF YZ";				break;
				//		case 23:a="%d: LPF XZ";				break;
				//		case 24:a="%d: HPF";				break;
				//		case 25:a="%d: HPF X";				break;
				//		case 26:a="%d: HPF Y";				break;
				//		case 27:a="%d: HPF Z";				break;
				//		case 28:a="%d: HPF XY";				break;
				//		case 29:a="%d: HPF YZ";				break;
				//		case 30:a="%d: HPF XZ";				break;
				//		}
				//		_3d.textIn2D(w-const_label_offset_X, Y, OPAQUE, a, k);
				//		++k, Y+=16;
				//	}
				//}
				prof_add("operations");//spikes
				setBkMode(bkMode);
			//	SetBkMode(ghMemDC, bkMode);
				//SetBkMode(ghMemDC, OPAQUE);//DEBUG
				//_3d.text_show();
			}
			//else
			_3d.text_show();
		//	_3d.text_dump();
			prof_add("3D text");
		//	if(!clearScreen)
			if(showBenchmark)
			{
				int bkMode=setBkMode(OPAQUE);
				int xpos=w-300, ypos=h>>1;
				GUIPrint(xpos, ypos, "%dx%dx%d", Xplaces, Yplaces, Zplaces), ypos+=16;
				if(usingOpenGL==MODE_CL_GL_INTEROP)
				{
					GUIPrint(xpos, ypos, "%d vertices, %d triangles", g_nvert, g_ntrgl), ypos+=16;
					GUIPrint(xpos, ypos, "Max trgl/cube = %d", g_max_trgl_cube), ypos+=16;
				}
				else if(contourOn)
				{
					GUIPrint(xpos, ypos, "contour: %d tetrahedra", test_contourMethod==2?5:test_contourMethod?28:48), ypos+=16;
					GUIPrint(xpos, ypos, "%d vertices, %d triangles", test_nvertices, test_ntriangles), ypos+=16;
				}
				setBkMode(bkMode);
			}
			if(kb_VK_F6_msg||kb[VK_F6])
			{
				int bkMode=setBkMode(OPAQUE);
			//	int kb_mode=SetBkMode(ghMemDC, OPAQUE);
				kb_VK_F6_msg=false;
				if(!_3d_stretch_move_cam&!_3d_shift_move_cam&!_3d_zoom_move_cam)
					GUIPrint(0, h-18*3, "move cam: [-] scale, [-] shift, [-] zoom");
				else if(!_3d_shift_move_cam&!_3d_zoom_move_cam)
					GUIPrint(0, h-18*3, "move cam: [v] scale, [-] shift, [-] zoom");
				else if(!_3d_zoom_move_cam)
					GUIPrint(0, h-18*3, "move cam: [v] scale, [v] shift, [-] zoom");
				else
					GUIPrint(0, h-18*3, "move cam: [v] scale, [v] shift, [v] zoom");
				setBkMode(bkMode);
			//	SetBkMode(ghMemDC, kb_mode);
			}
		}
		void i_draw();
		void a_draw();
	} c3d;
	const int		Color_3D::modes[]={9}, Color_3D::nmodes=sizeof(modes)>>2;
	void			Color_3D::i_draw()
	{
		if(modes::ready)
		{
			draw();
			if(showLastModeOnIdle)
				capture_window(modeRGB);
			//	std::copy(rgb, rgb+w*h, modeRGB);

			selectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
			{
				int bkMode=setBkMode(OPAQUE);
			//	int bkMode=GetBkMode(ghMemDC);
			//	SetBkMode(ghMemDC, OPAQUE);
				itb.draw();
				setBkMode(bkMode);
			//	SetBkMode(ghMemDC, bkMode);
			}
			deselectFont();
		//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	
			if(showBenchmark)
				Performance(0, h-32);//
#ifndef BUILD_1_7
			BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
#endif
		}
		else
		{
			display_texture_fullwindow(modeRGB);
		//	std::copy(modeRGB, modeRGB+w*h, rgb);
			if(showBenchmark)
				Performance(0, h-32);//
		}
	}
	void			Color_3D::a_draw()
	{
		newframe();
	//	rectangle(bpx-1, bpy-1, bw+1, bh+1);
	//	Rectangle(ghMemDC, bpx-1, bpy-1, bw+1, bh+1);

		draw();
		
		if(contextHelp)
		{
			const char *help[]=
			{
				"W/A/S/D/T/G: move",
				"arrows: turn",
				"+/-/enter/backspace/wheel: change FOV",
				"X/Y/Z arrows/mouse move: shift x/y/z",
				"X/Y/Z +/-/enter/backspace/wheel: scale x/y/z",
				"alt +/-/enter/backspace/wheel: zoom",
				"shift +/-/enter/backspace/wheel: change resolution",
				"E: reset scale",
				"R: reset scale & view",
				"C: toggle clear screen",
				"F6: change camera settings",
				"1: differentiate xyz",
				"X/Y/Z 1: differentiate x/y/z",
				"2: integrate xyz",
				"X/Y/Z 2: integrate xyz",
				"3: DFT",
				"4: Inverse DFT",
				"5: LPF",
				"X/Y/Z 5: LPF x/y/z",
				"6: HPF",
				"X/Y/Z 6: HPF x/y/z",
				"0: reset operations",
				"`: contour",
				"F3: toggle contour method",
				"F : toggle contour wireframe",//
				"Tab/Shift Tab: switch renderer",
				"Esc: back to text editor"
			};
			print_contextHelp(help, sizeof(help)>>2, 330);
		}
		if(showBenchmark&&!clearScreen)
			Performance(0, h-32);//
		show();
	//	BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
		report_error();
	}

	void (*paint)();
	void paint_0()
	{
		modes::n0d	.ready=false;
		modes::t1d	.ready=false, modes::t1d.toSolve=true, modes::t1d.shiftOnly=0;
		modes::t1d_c.ready=false;
		modes::t1d_h.ready=false, modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0;
		modes::t2d	.ready=false;
		modes::c2d	.ready=false, modes::c2d.toSolve=true, modes::c2d.shiftOnly=0;
		modes::l2d	.ready=false, modes::l2d.toSolve=true, modes::l2d.shiftOnly=0;
		modes::t2d_h.ready=false;
		modes::c3d	.ready=false;
		modes::ti1d	.ready=false;
		modes::ti2d	.ready=false;
	}
	void paint_n0d()
	{
		modes::n0d.setDimensions(0, 0, w, h);
		
		modes::t1d	.ready=false, modes::t1d.toSolve=true, modes::t1d.shiftOnly=0;
		modes::t1d_c.ready=false;
		modes::t1d_h.ready=false, modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0;
		modes::t2d	.ready=false;
		modes::c2d	.ready=false, modes::c2d.toSolve=true, modes::c2d.shiftOnly=0;
		modes::l2d	.ready=false, modes::l2d.toSolve=true, modes::l2d.shiftOnly=0;
		modes::t2d_h.ready=false;
		modes::c3d	.ready=false;
		modes::ti1d	.ready=false;
		modes::ti2d	.ready=false;
	}
	void paint_t1d()
	{
		modes::n0d.ready=false;

		modes::t1d.setDimensions(0, 0, w, h);
		
		modes::t1d_c.ready=false;
		modes::t1d_h.ready=false, modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0;
		modes::t2d	.ready=false;
		modes::c2d	.ready=false, modes::c2d.toSolve=true, modes::c2d.shiftOnly=0;
		modes::l2d	.ready=false, modes::l2d.toSolve=true, modes::l2d.shiftOnly=0;
		modes::t2d_h.ready=false;
		modes::c3d	.ready=false;
		modes::ti1d	.ready=false;
		modes::ti2d	.ready=false;
	}
	void paint_t1d_c()
	{
		modes::n0d.ready=false;
		modes::t1d.ready=false, modes::t1d.toSolve=true, modes::t1d.shiftOnly=0;

		modes::t1d_c.setDimensions(0, 0, w, h);
		
		modes::t1d_h.ready=false, modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0;
		modes::t2d	.ready=false;
		modes::c2d	.ready=false, modes::c2d.toSolve=true, modes::c2d.shiftOnly=0;
		modes::l2d	.ready=false, modes::l2d.toSolve=true, modes::l2d.shiftOnly=0;
		modes::t2d_h.ready=false;
		modes::c3d	.ready=false;
		modes::ti1d	.ready=false;
		modes::ti2d	.ready=false;
	}
	void paint_t1d_h()
	{
		modes::n0d	.ready=false;
		modes::t1d	.ready=false, modes::t1d.toSolve=true, modes::t1d.shiftOnly=0;
		modes::t1d_c.ready=false;

		modes::t1d_h.setDimensions(0, 0, w, h);
		
		modes::t2d	.ready=false;
		modes::c2d	.ready=false, modes::c2d.toSolve=true, modes::c2d.shiftOnly=0;
		modes::l2d	.ready=false, modes::l2d.toSolve=true, modes::l2d.shiftOnly=0;
		modes::t2d_h.ready=false;
		modes::c3d	.ready=false;
		modes::ti1d	.ready=false;
		modes::ti2d	.ready=false;
	}
	void paint_t2d()
	{
		modes::n0d	.ready=false;
		modes::t1d	.ready=false, modes::t1d.toSolve=true, modes::t1d.shiftOnly=0;
		modes::t1d_c.ready=false;
		modes::t1d_h.ready=false, modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0;

		modes::t2d.setDimensions(0, 0, w, h);
		
		modes::c2d	.ready=false, modes::c2d.toSolve=true, modes::c2d.shiftOnly=0;
		modes::l2d	.ready=false, modes::l2d.toSolve=true, modes::l2d.shiftOnly=0;
		modes::t2d_h.ready=false;
		modes::c3d	.ready=false;
		modes::ti1d	.ready=false;
		modes::ti2d	.ready=false;
	}
	void paint_c2d()
	{
		modes::n0d	.ready=false;
		modes::t1d	.ready=false, modes::t1d.toSolve=true, modes::t1d.shiftOnly=0;
		modes::t1d_c.ready=false;
		modes::t1d_h.ready=false, modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0;
		modes::t2d	.ready=false;

		modes::c2d.setDimensions(0, 0, w, h);
		
		modes::l2d	.ready=false, modes::l2d.toSolve=true, modes::l2d.shiftOnly=0;
		modes::t2d_h.ready=false;
		modes::c3d	.ready=false;
		modes::ti1d	.ready=false;
		modes::ti2d	.ready=false;
	}
	void paint_l2d()
	{
		modes::n0d	.ready=false;
		modes::t1d	.ready=false, modes::t1d.toSolve=true, modes::t1d.shiftOnly=0;
		modes::t1d_c.ready=false;
		modes::t1d_h.ready=false, modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0;
		modes::t2d	.ready=false;
		modes::c2d	.ready=false, modes::c2d.toSolve=true, modes::c2d.shiftOnly=0;

		modes::l2d.setDimensions(0, 0, w, h);

		modes::t2d_h.ready=false;
		modes::c3d	.ready=false;
		modes::ti1d	.ready=false;
		modes::ti2d	.ready=false;
	}
	void paint_t2d_h()
	{
		modes::n0d	.ready=false;
		modes::t1d	.ready=false, modes::t1d.toSolve=true, modes::t1d.shiftOnly=0;
		modes::t1d_c.ready=false;
		modes::t1d_h.ready=false, modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0;
		modes::t2d	.ready=false;
		modes::c2d	.ready=false, modes::c2d.toSolve=true, modes::c2d.shiftOnly=0;
		modes::l2d	.ready=false, modes::l2d.toSolve=true, modes::l2d.shiftOnly=0;

		modes::t2d_h.setDimensions(0, 0, w, h);

		modes::c3d	.ready=false;
		modes::ti1d	.ready=false;
		modes::ti2d	.ready=false;
	}
	void paint_c3d()
	{
		modes::n0d	.ready=false;
		modes::t1d	.ready=false, modes::t1d.toSolve=true, modes::t1d.shiftOnly=0;
		modes::t1d_c.ready=false;
		modes::t1d_h.ready=false, modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0;
		modes::t2d	.ready=false;
		modes::c2d	.ready=false, modes::c2d.toSolve=true, modes::c2d.shiftOnly=0;
		modes::l2d	.ready=false, modes::l2d.toSolve=true, modes::l2d.shiftOnly=0;
		modes::t2d_h.ready=false;

		modes::c3d.setDimensions(0, 0, w, h);
		
		modes::ti1d.ready=false;
		modes::ti2d.ready=false;
	}
	void paint_ti1d()
	{
		modes::n0d	.ready=false;
		modes::t1d	.ready=false, modes::t1d.toSolve=true, modes::t1d.shiftOnly=0;
		modes::t1d_c.ready=false;
		modes::t1d_h.ready=false, modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0;
		modes::t2d	.ready=false;
		modes::c2d	.ready=false, modes::c2d.toSolve=true, modes::c2d.shiftOnly=0;
		modes::l2d	.ready=false, modes::l2d.toSolve=true, modes::l2d.shiftOnly=0;
		modes::t2d_h.ready=false;
		modes::c3d	.ready=false;

		modes::ti1d.setDimensions(0, 0, w, h);

		modes::ti2d.ready=false;
	}
	void paint_ti2d()
	{
		modes::n0d	.ready=false;
		modes::t1d	.ready=false, modes::t1d.toSolve=true, modes::t1d.shiftOnly=0;
		modes::t1d_c.ready=false;
		modes::t1d_h.ready=false, modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0;
		modes::t2d	.ready=false;
		modes::c2d	.ready=false, modes::c2d.toSolve=true, modes::c2d.shiftOnly=0;
		modes::l2d	.ready=false, modes::l2d.toSolve=true, modes::l2d.shiftOnly=0;
		modes::t2d_h.ready=false;
		modes::c3d	.ready=false;
		modes::ti1d	.ready=false;

		modes::ti2d.setDimensions(0, 0, w, h);
	}
}
int inactiveLMBDown=0;
int copy_text_with_n0d_results(int wParam)//friend InputTextBox
{
	if(itb.cursor!=itb.selcur)
	{
		auto &text=itb.text;
		auto &textlen=itb.textlen;
		int selStart=itb.cursor<itb.selcur?itb.cursor:itb.selcur, selEnd=itb.cursor>itb.selcur?itb.cursor:itb.selcur;
		int nBounds=bounds.size();
		int startBound=0, startEx=0;
		for(int k=0, bound=0, e=0;;++k)//seek to selStart
		{
			if(bound<nBounds&&k==bounds[bound].first)
			{
				e+=bound<nBounds&&bounds[bound].second=='e';
				++bound;
			}
			if(k==selStart)
			{
				startBound=bound, startEx=e;
				break;
			}
		}
		int maxlen=0;
		for(int k=selStart, bound=startBound, e=startEx, linelen=0;;++k)//find text width
		{
			if(k>selStart&&bound<nBounds&&k==bounds[bound].first)//the bound is over
			{
				if(bound<nBounds&&bounds[bound].second=='e'&&expr[e].rmode[0]==1&&maxlen<linelen)//
					maxlen=linelen;//
				e+=bound<nBounds&&bounds[bound].second=='e';
				++bound;
			}
			if(k>=selEnd)
			{
				if(bound<nBounds&&bounds[bound].second=='e'&&expr[e].rmode[0]==1&&maxlen<linelen)
					maxlen=linelen;
				break;
			}
			if(text[k]=='\r')
			{
				if(bound<nBounds&&bounds[bound].second=='e'&&expr[e].rmode[0]==1&&maxlen<linelen)
					maxlen=linelen;
				linelen=0;
				if(text[k+1]=='\n')
					++k;
			}
			else
				++linelen;
		}
		int tabsize=8;
		int offset=maxlen-maxlen%tabsize+tabsize;
		std::string str(text+selStart, text+selEnd);
		for(int k=selStart, k2=0, linelen=0, oldlinelen=0, bound=startBound, e=startEx;;++k, ++k2)//print text with results to string
		{
			if(k==selEnd)
			{
				if(bound<nBounds&&bounds[bound].second=='e')
				{
					auto &ex=expr[e];
					if(ex.rmode[0]==1)//n0d
					{
						int nTabs=(offset-linelen)/tabsize+1;
						int buf_off=0;
						ex.nresult.print(g_buf, buf_off, ex.resultMathSet, modes::n0d.base);
					//	ex.data[ex.resultTerm].print(g_buf, buf_off, ex.resultMathSet, modes::n0d.base);
						str.insert(k2, std::string(clamp_positive(nTabs), '\t')+g_buf);
					}
				}
				break;
			}
			if(bound<nBounds&&k==bounds[bound].first&&bounds[bound].second=='e')
			{
				auto &ex=expr[e];
				if(ex.rmode[0]==1)//n0d
				{
					char &ch=text[bounds[bound].first-1];
					int k2_rewind=(ch=='\n'||ch=='\r')*(1+(ch=='\n'&&(bounds[bound].first-2<0||text[bounds[bound].first-2]=='\r')));
					k2-=k2_rewind;
					if(k2_rewind)
						linelen=oldlinelen;
					int nTabs=(offset-linelen)/tabsize+1;
					int buf_off=0;
					ex.nresult.print(g_buf, buf_off, ex.resultMathSet, modes::n0d.base);
				//	ex.data[ex.resultTerm].print(g_buf, buf_off, ex.resultMathSet, modes::n0d.base);
					str.insert(k2, std::string(nTabs, '\t')+g_buf);
					k2+=k2_rewind;
					if(k2_rewind)
						linelen=1;
					k2+=nTabs+buf_off;
				}
			}
			if(text[k]=='\r')
			{
				oldlinelen=linelen;
				linelen=0;
				if(text[k+1]=='\n')
					++k, ++k2;
			}
			++linelen;
			if(bound<nBounds&&k==bounds[bound].first)
			{
				e+=bound<nBounds&&bounds[bound].second=='e';
				++bound;
			}
		}
		copy_to_clipboard(str.c_str(), str.size());
		if(wParam=='X')
		{
			itb.removeText(selStart, selEnd);
			return 2;
		}
	}
	return 0;
}

#ifdef BUILD_1_7
int var_menu=0, var_menu_drag=0, var_menu_drag_pui=0, var_menu_idx=0;
int vui_height=18*6;
//int vui_height=18+20+18+10;//36
double g_scale=0.1;
char g_scale_type='I';
struct LinearScale
{
	bool uninitialized;
	double scale, sample,//scale=v/DV, sample=DX/x=1/scale
		VX, DX;
	double step, substep;
	int prec;//precision
	LinearScale():uninitialized(true), scale(20), sample(1/scale), VX(0){}
	void set_scale(double scale){this->scale=scale, sample=1/scale;}
	void mul_scale(double mul){scale*=mul, sample/=mul;}
	void div_scale(double mul){scale/=mul, sample*=mul;}
	double scale_fn(double x){return scale*(x-(VX-DX*0.5));}//R -> screen
	double scale_ifn(double x){return VX-DX*0.5+x/scale;}//screen -> R
	void update_scale(int screen_length)
	{
		sample=1/scale;
		DX=screen_length/scale;//scale=v/DV, DV=v/scale, v=DV*scale
	//	VX=c;
	//	double R=100*DV/v;
		double R=50/scale;//50px -> R

		int p=floor_log10(R);
		step=_10pow(p), prec=clamp_positive(-p);
		//double t2=floor_log10(R);
		//step=exp(t2*G2::_ln10), prec=(int)clamp_positive_ll(-t2);

		switch(int(R/step))//most significant digit
		{
		case 1:step*=1, substep=0.2*step;break;
		case 2:step*=2, substep=0.5*step;break;
		case 3:step*=2, substep=0.5*step;break;
		case 4:step*=2, substep=0.5*step;break;
		case 5:step*=5, substep=0.2*step;break;
		case 6:step*=5, substep=0.2*step;break;
		case 7:step*=5, substep=0.2*step;break;
		case 8:step*=5, substep=0.2*step;break;
		case 9:step*=5, substep=0.2*step;break;
		default:step*=6, substep=0.2*step;break;
	//	default:step*=1;break;
		}
	}
	double substart(){return ceil((VX-DX*0.5)/substep)*substep;}
	double subend(){return ceil((VX+DX*0.5)/substep)*substep;}
	double start()
	{
		return ceil((VX-DX*0.5)/step)*step;
	//	return floor(scale_ifn(-screen_length*0.5)/step)*step;
	//	return floor(screen_length/scale
	}
	double end()
	{
		return ceil((VX+DX*0.5)/step)*step;
	//	return floor(scale_ifn(screen_length*0.5)/step)*step;
	}
	double next(double x){return x+step;}
};
struct LogScale
{
	bool uninitialized;
	bool linearstep_on;//switch to linear step (when zoomed-in)
	double Xscale, Xsample,//power = log10(R) = px/scale = px*sample,		R=10^(log10(Xstart)+x*Xsample)
		VX;
	double Xstep, logXstep, Xstart, Xend, logXstart, logXend, _1_logDX;	//for conversion
	double linearstep, temp_linstep, temp_linstep2;						//for axis labeling
	LogScale():uninitialized(true), Xscale(20), Xsample(1/Xscale), VX(1){}
	void set_scale(double Xscale){this->Xscale=Xscale, Xsample=1/Xscale;}
	void mul_scale(double mul){Xscale*=mul, Xsample/=mul;}
	void div_scale(double div){Xscale/=div, Xsample*=div;}
	void update_scale(int screen_size)
	{
		Xsample=1/Xscale;
		double logVX=log10(VX);
		logXstart=logVX-screen_size*0.5*Xsample, logXend=logVX+screen_size*0.5*Xsample;
		Xstart=exp(logXstart*G2::_ln10), Xend=exp(logXend*G2::_ln10);//ifn: screen -> R
		_1_logDX=1/(logXend-logXstart);

		const int tick_size=100;//50
		int p=(int)floor(log10(Xend/Xstart)*tick_size/screen_size);//how many divisions are there in 100px?
		if(p>3)
			p+=2, p-=p%3;
		Xstep=_10pow(p);
		if(linearstep_on=Xstep<2)//smallest integer greater than one, multiples of 2 are too far apart on screen
		{
			Xstep=10;

			int subtick_size=150;//50 100
			double R=exp((logXstart+subtick_size*Xsample)*G2::_ln10)-Xstart;//150px from left -> R, do not simplify
			linearstep=_10pow(floor_log10(R));

			const int multiplier[]={1, 1, 2, 2, 2, 5, 5, 5, 5, 5};
			int msd=int(R/linearstep);//most significant digit
		//	linearstep*=multiplier[minimum(clamp_positive(msd), 9)];
			linearstep*=multiplier[msd];
		}
		logXstep=log10(Xstep);
	}
	double scale_fn(double x)//R -> screen
	{
		return (log10(x)-logXstart)*_1_logDX;
	}
	double scale_lfn(double x)//logR -> screen
	{
		return (x-logXstart)*_1_logDX;
	}
	double scale_ifn(double x)//screen[0,1] -> R
	{
		return exp((logXstart+(logXend-logXstart)*x)*G2::_ln10);
	}
	double start(){return floor(logXstart/logXstep)*logXstep;}//ceil
	double end(){return ceil(logXend/logXstep)*logXstep;}
	double next(double x){return x+logXstep;}

	double start_linstep()
	{
		temp_linstep2=temp_linstep=linearstep;
		return floor(Xstart/temp_linstep)*temp_linstep;
	}
	double end_linstep(){return Xend;}
	double next_linstep(double x, int screen_size, bool &r)
	{
		x+=temp_linstep;
		double logx=log10(x);
		if(r=abs(logx-std::round(logx))<1e-10)//logx is a round number
			temp_linstep=x;
		return x;
	}
	double subnext_linstep(double x, int screen_size, bool &r)
	{
		x+=temp_linstep2;
		double logx=log10(x);
		if(r=abs(logx-std::round(logx))<1e-10)//logx is a round number
			temp_linstep2=temp_linstep;
		return x;
	}

	double pow10(double x){return exp(x*G2::_ln10);}
};
struct AtanScale
{
	bool uninitialized;
	double scale, sample, VX;
	std::vector<double> bestVal;
	std::vector<int> prec,//precision
		bvs;//best value on screen
	AtanScale():uninitialized(true), scale(0.1), sample(1/scale), VX(0){}
	void set_scale(double scale){this->scale=scale, sample=1/scale;}
	void mul_scale(double mul){scale*=mul, sample/=mul;}
	void div_scale(double mul){scale/=mul, sample*=mul;}
	void insert_bv(double bv, int kv)
	{
		bestVal.insert(bestVal.begin()+kv, bv);
		int p=(int)clamp_positive_ll(-floor(log10(abs(bv))));
		prec.insert(prec.begin()+kv, p);
	}
	double subscale_step(int kv)
	{
		double const epsilon=1e-10;
		double diff=abs(bestVal[kv+1]-bestVal[kv]);
		if(diff>1e4)
			return diff*0.2;
		double p=1, xp=0;
		if(diff<1)
		{
			for(;;p*=10)
			{
				xp=diff*p;
				double tail=xp-floor(xp);
				if(abs(tail)<epsilon)
					break;
				if(abs(tail-1)<epsilon)
				{
					xp=ceil(xp);
					break;
				}
			}
		}
		else if(diff>1)
		{
			for(;;p/=10)
			{
				xp=diff*p;
				if((int)xp%100)
					break;
			}
		}
		else//diff=1
			return 0.2;
		int x=int(xp), csr_x=(int)ceil(sqrt(xp));
		int step=1, oldstep=step;
		for(int k=2;k<csr_x;)
		{
			if(!(x%k))//k is a factor
			{
				x/=k;
				if(k==5)
				{
					oldstep=step;
					step*=k;
				}
				if(step>csr_x)
				{
					step=oldstep;
					break;
				}
			}
			else
				++k;
		}
		if(x==5)
		{
			oldstep=step;
			step*=x;
		}
		if(step>csr_x)
			step=oldstep;
		return step/p;
	}
	void update_scale(int screen_length)
	{
		sample=1/scale;
		bestVal.clear(), prec.clear();
		double const two=2, five=5;
		double x0=0, xs0=scale_fn(x0);
		insert_bv(x0, 0);

		double step=50./screen_length, divider;
		if(step>=0.499999)//length too small
			return;
		divider=five;
		{
			int k=0;
			for(;k<300;++k)
			{
				double ds=scale_fn(divider+VX);
				if(abs(ds-0.5)<step)
					break;
				divider/=k&1?two:five;
			}
			for(;k<600;++k)
			{
				double ds=scale_fn(divider+VX);
				if(abs(ds-0.5)>step)
					break;
				divider*=k&1?five:two;
			}
		}
		for(;xs0+step<1;)
		{
			double x_raw=scale_ifn(xs0+step);
			double x=floor(x_raw/divider)*divider;
			int k=0;
			bool goodval=true;
			for(double mul=1;x<=x0;mul/=k&1?five:two, ++k)
				x=floor(x_raw/mul)*mul, goodval=false;
			if(goodval)
				insert_bv(x, bestVal.size());
			x0=x;
			xs0=scale_fn(x0);
		//	xs0+=step;
		}
		x0=0, xs0=scale_fn(x0);
		for(;xs0-step>0;)
		{
			double x_raw=scale_ifn(xs0-step);
			double x=ceil(x_raw/divider)*divider;
			int k=0;
			bool goodval=true;
			for(double mul=1;x>=x0;mul/=k&1?five:two, ++k)
				x=ceil(x_raw/mul)*mul, goodval=false;
			if(goodval)
				insert_bv(x, 0);
			x0=x;
			xs0=scale_fn(x0);
		//	xs0+=step;
		}
	}
	double scale_fn(double x)//R -> [0, 1]
	{
		return atan(scale*(x-VX))*G2::_1_pi+0.5;
	}
	double scale_ifn(double x){return VX+tan((x-0.5)*G2::_pi)/scale;}//[0, 1] -> R
};
enum ButtonType
{
	B_MISS,
	B_CONST, B_TIME, B_SPACE_X, B_SPACE_Y, B_SPACE_Z,
	B_SCALE,
	B_SLIDER, B_INC, B_DEC
};
struct Button
{
	short x1, x2, y1, y2;
	Button():x1(0), x2(0), y1(0), y2(0){}
	Button(short x1, short x2, short y1, short y2):x1(x1), x2(x2), y1(y1), y2(y2){}
	void set(short x1, short x2, short y1, short y2){this->x1=x1, this->x2=x2, this->y1=y1, this->y2=y2;}
	bool click(short mx, short my){return mx>=x1&&mx<x2&&my>=y1&&my<y2;}
	bool click(int lParam){short mx=((short*)&lParam)[0], my=((short*)&lParam)[1]; return click(mx, my);}
};
struct ParamUI
{
	int var, comp;
	char scale_type, param_type;
	LinearScale is;
	LogScale ls;
	AtanScale ts;
	Button b_space_x, b_space_y, b_space_z, b_time, b_const,
		b_scale,
		b_slider, b_inc, b_dec;
	ParamUI(int var, int comp, char scale_type, char param_type):var(var), comp(comp), scale_type(scale_type), param_type(param_type){}
	void setLinearScale(double scale, double VX){is.set_scale(scale), is.VX=VX;}
	void setLogScale(double scale, double VX){ls.set_scale(scale), ls.VX=VX<=0?1:VX;}
	void setAtanScale(double scale, double VX){ts.set_scale(scale), ts.VX=VX;}
};
std::vector<ParamUI> puis;
void print_varType(ParamUI &pui, char varType, int x, int y)
{
	const char *varTypeMsg[]={"space x", "space y", "space z", "time", "constant"};
	const char *varTypes="xyztc";
	int bg_white=0xFFFFFF, bg_select=0xFFFF96;
	auto buttons=&pui.b_space_x;
	rectangle(x-1, y-1, x+80, y+5*18);
//	Rectangle(ghMemDC, x-1, y-1, x+80, y+5*18);
	for(int k=0;k<5;++k)
	{
		if(varType==varTypes[k])
			setBkColor(bg_select);
		//	SetBkColor(ghMemDC, bg_select);
		int y2=y+k*18;
		GUIPrint(x, y2, varTypeMsg[k]);
		buttons[k].set(x-1, x+80, y2, y2+18);
		if(varType==varTypes[k])
			setBkColor(bg_white);
		//	SetBkColor(ghMemDC, bg_white);
	}
}
inline void draw_line(int x1, int y1, int x2, int y2){line(x1, y1, x2, y2);}
void extract_range(int rmode, Variable const &var, int c, double &varStart, double &varEnd)
{
	using namespace modes;
	switch(rmode)
	{
	case 0:break;//no expression	unreachable
	case 1://n0d
		switch((&var.varTypeR)[c])
		{
		case 't':varStart=varEnd=n0d.solver.T;break;
		case 'c':varStart=varEnd=(&var.val.r)[c];break;
		}
		break;
	case 10://ti1d
		switch((&var.varTypeR)[c])
		{
		case 'x':varStart=ti1d.xs.Xstart, varEnd=ti1d.xs.Xend;break;
		case 't':varStart=varEnd=ti1d.solver.T;break;
		case 'c':varStart=varEnd=(&var.val.r)[c];break;
		}
		break;
	case 2://t1d
		switch((&var.varTypeR)[c])
		{
		case 'x':varStart=t1d.xs.Xstart, varEnd=t1d.xs.Xend;break;
		case 't':varStart=varEnd=t1d.solver.T;break;
		case 'c':varStart=varEnd=(&var.val.r)[c];break;
		}
		break;
	case 3://t1d_c
		switch((&var.varTypeR)[c])
		{
		case 'x':varStart=t1d_c.xs.Xstart, varEnd=t1d_c.xs.Xend;break;
		case 't':varStart=varEnd=t1d_c.solver.T;break;
		case 'c':varStart=varEnd=(&var.val.r)[c];break;
		}
		break;
	case 4://t1d_h
		switch((&var.varTypeR)[c])
		{
		case 'x':varStart=t1d_h.xs.Xstart, varEnd=t1d_h.xs.Xend;break;
		case 't':varStart=varEnd=t1d_h.solver.T;break;
		case 'c':varStart=varEnd=(&var.val.r)[c];break;
		}
		break;
	case 11://ti2d
		switch((&var.varTypeR)[c])
		{
		case 'x':varStart=ti2d.xs.Xstart, varEnd=ti2d.xs.Xend;break;
		case 'y':varStart=ti2d.ys_Ystart, varEnd=ti2d.ys.Xend;break;
		case 't':varStart=varEnd=ti2d.solver.T;break;
		case 'c':varStart=varEnd=(&var.val.r)[c];break;
		}
		break;
	case 5://t2d
		switch((&var.varTypeR)[c])
		{
		case 'x':varStart=t2d.xs.Xstart, varEnd=t2d.xs.Xend;break;
		case 'y':varStart=t2d.ys_Ystart, varEnd=t2d.ys.Xend;break;
		case 't':varStart=varEnd=t2d.solver.T;break;
		case 'c':varStart=varEnd=(&var.val.r)[c];break;
		}
		break;
	case 6://c2d
		switch((&var.varTypeR)[c])
		{
		case 'x':varStart=c2d.xs.Xstart, varEnd=c2d.xs.Xend;break;
		case 'y':varStart=c2d.ys_Ystart, varEnd=c2d.ys.Xend;break;
		case 't':varStart=varEnd=c2d.solver.T;break;
		case 'c':varStart=varEnd=(&var.val.r)[c];break;
		}
		break;
	case 7://l2d
		switch((&var.varTypeR)[c])
		{
		case 'x':varStart=l2d.xs.Xstart, varEnd=l2d.xs.Xend;break;
		case 'y':varStart=l2d.ys_Ystart, varEnd=l2d.ys.Xend;break;
		case 't':varStart=varEnd=l2d.solver.T;break;
		case 'c':varStart=varEnd=(&var.val.r)[c];break;
		}
		break;
	case 8://t2d_h
		switch((&var.varTypeR)[c])
		{
		case 'x':varStart=t2d_h.xs.Xstart, varEnd=t2d_h.xs.Xend;break;
		case 'y':varStart=t2d_h.ys_Ystart, varEnd=t2d_h.ys.Xend;break;
		case 't':varStart=varEnd=t2d_h.solver.T;break;
		case 'c':varStart=varEnd=(&var.val.r)[c];break;
		}
		break;
	case 9://c3d
		switch((&var.varTypeR)[c])
		{
		case 'x':varStart=c3d.xs.Xstart, varEnd=c3d.xs.Xend;break;
		case 'y':varStart=c3d.ys_Ystart, varEnd=c3d.ys.Xend;break;
		case 'z':varStart=c3d.zs_Zstart, varEnd=c3d.zs.Xend;break;
		case 't':varStart=varEnd=c3d.solver.T;break;
		case 'c':varStart=varEnd=(&var.val.r)[c];break;
		}
		break;
	}
}
void increment_parameter(ParamUI &pui)
{
	auto &ex=expr[cursorEx];
	auto &var=ex.variables[pui.var];
	auto &varType=(&var.varTypeR)[pui.comp];
	using namespace modes;
	mode->toSolve=true;
	switch(ex.rmode[0])
	{
	case 0:break;//no expression	unreachable
	case 1://n0d
		switch(varType)
		{
		case 't':++n0d.solver.T;break;
		case 'c':++(&var.val.r)[pui.comp];break;
		}
		break;
	case 10://ti1d
		switch(varType)
		{
		case 'x':ti1d.xs.ppVX();break;
		//case 'x':++ti1d.xs.VX;break;
		case 't':++ti1d.solver.T;break;
		case 'c':++(&var.val.r)[pui.comp];break;
		}
		break;
	case 2://t1d
		switch(varType)
		{
		case 'x':t1d.xs.ppVX();break;
		case 't':++t1d.solver.T;break;
		case 'c':++(&var.val.r)[pui.comp];break;//
		}
		break;
	case 3://t1d_c
		switch(varType)
		{
		case 'x':t1d_c.xs.ppVX();break;
		case 't':++t1d_c.solver.T;break;
		case 'c':++(&var.val.r)[pui.comp];break;
		}
		break;
	case 4://t1d_h
		switch(varType)
		{
		case 'x':t1d_h.xs.ppVX();break;
		case 't':++t1d_h.solver.T;break;
		case 'c':++(&var.val.r)[pui.comp];break;
		}
		break;
	case 11://ti2d
		switch(varType)
		{
		case 'x':ti2d.xs.ppVX();break;
		case 'y':ti2d.ys.ppVX();break;
		case 't':++ti2d.solver.T;break;
		case 'c':++(&var.val.r)[pui.comp];break;
		}
		break;
	case 5://t2d
		switch(varType)
		{
		case 'x':t2d.xs.ppVX();break;
		case 'y':t2d.ys.ppVX();break;
		case 't':++t2d.solver.T;break;
		case 'c':++(&var.val.r)[pui.comp];break;
		}
		break;
	case 6://c2d
		switch(varType)
		{
		case 'x':c2d.xs.ppVX();break;
		case 'y':c2d.ys.ppVX();break;
		case 't':++c2d.solver.T;break;
		case 'c':++(&var.val.r)[pui.comp];break;
		}
		break;
	case 7://l2d
		switch(varType)
		{
		case 'x':l2d.xs.ppVX();break;
		case 'y':l2d.ys.ppVX();break;
		case 't':++l2d.solver.T;break;
		case 'c':++(&var.val.r)[pui.comp];break;
		}
		break;
	case 8://t2d_h
		switch(varType)
		{
		case 'x':t2d_h.xs.ppVX();break;
		case 'y':t2d_h.ys.ppVX();break;
		case 't':++t2d_h.solver.T;break;
		case 'c':++(&var.val.r)[pui.comp];break;
		}
		break;
	case 9://c3d
		switch(varType)
		{
		case 'x':c3d.xs.ppVX();break;
		case 'y':c3d.ys.ppVX();break;
		case 'z':c3d.zs.ppVX();break;
		case 't':++c3d.solver.T;break;
		case 'c':++(&var.val.r)[pui.comp];break;
		}
		break;
	}
}
void decrement_parameter(ParamUI &pui)
{
	auto &ex=expr[cursorEx];
	auto &var=ex.variables[pui.var];
	auto &varType=(&var.varTypeR)[pui.comp];
	using namespace modes;
	mode->toSolve=true;
	switch(ex.rmode[0])
	{
	case 0:break;//no expression	unreachable
	case 1://n0d
		switch(varType)
		{
		case 't':--n0d.solver.T;break;
		case 'c':--(&var.val.r)[pui.comp];break;
		}
		break;
	case 10://ti1d
		switch(varType)
		{
		case 'x':ti1d.xs.mmVX();break;
		case 't':--ti1d.solver.T;break;
		case 'c':--(&var.val.r)[pui.comp];break;
		}
		break;
	case 2://t1d
		switch(varType)
		{
		case 'x':t1d.xs.mmVX();break;
		case 't':--t1d.solver.T;break;
		case 'c':--(&var.val.r)[pui.comp];break;//
		}
		break;
	case 3://t1d_c
		switch(varType)
		{
		case 'x':t1d_c.xs.mmVX();break;
		case 't':--t1d_c.solver.T;break;
		case 'c':--(&var.val.r)[pui.comp];break;
		}
		break;
	case 4://t1d_h
		switch(varType)
		{
		case 'x':t1d_h.xs.mmVX();break;
		case 't':--t1d_h.solver.T;break;
		case 'c':--(&var.val.r)[pui.comp];break;
		}
		break;
	case 11://ti2d
		switch(varType)
		{
		case 'x':ti2d.xs.mmVX();break;
		case 'y':ti2d.ys.mmVX();break;
		case 't':--ti2d.solver.T;break;
		case 'c':--(&var.val.r)[pui.comp];break;
		}
		break;
	case 5://t2d
		switch(varType)
		{
		case 'x':t2d.xs.mmVX();break;
		case 'y':t2d.ys.mmVX();break;
		case 't':--t2d.solver.T;break;
		case 'c':--(&var.val.r)[pui.comp];break;
		}
		break;
	case 6://c2d
		switch(varType)
		{
		case 'x':c2d.xs.mmVX();break;
		case 'y':c2d.ys.mmVX();break;
		case 't':--c2d.solver.T;break;
		case 'c':--(&var.val.r)[pui.comp];break;
		}
		break;
	case 7://l2d
		switch(varType)
		{
		case 'x':l2d.xs.mmVX();break;
		case 'y':l2d.ys.mmVX();break;
		case 't':--l2d.solver.T;break;
		case 'c':--(&var.val.r)[pui.comp];break;
		}
		break;
	case 8://t2d_h
		switch(varType)
		{
		case 'x':t2d_h.xs.mmVX();break;
		case 'y':t2d_h.ys.mmVX();break;
		case 't':--t2d_h.solver.T;break;
		case 'c':--(&var.val.r)[pui.comp];break;
		}
		break;
	case 9://c3d
		switch(varType)
		{
		case 'x':c3d.xs.mmVX();break;
		case 'y':c3d.ys.mmVX();break;
		case 'z':c3d.zs.mmVX();break;
		case 't':--c3d.solver.T;break;
		case 'c':--(&var.val.r)[pui.comp];break;
		}
		break;
	}
}
void set_parameter(ParamUI &pui, double value)
{
	auto &ex=expr[cursorEx];
	auto &var=ex.variables[pui.var];
	auto &varType=(&var.varTypeR)[pui.comp];
	using namespace modes;
	mode->toSolve=true;
	switch(ex.rmode[0])
	{
	case 0:break;//no expression	unreachable
	case 1://n0d
		switch(varType)
		{
		case 't':n0d.solver.T=value;break;
		case 'c':(&var.val.r)[pui.comp]=value;break;
		}
		break;
	case 10://ti1d
		switch(varType)
		{
		case 'x':ti1d.xs.setVX(value);break;
		case 't':ti1d.solver.T=value;break;
		case 'c':(&var.val.r)[pui.comp]=value;break;
		}
		break;
	case 2://t1d
		switch(varType)
		{
		case 'x':t1d.xs.setVX(value);break;
		case 't':t1d.solver.T=value;break;
		case 'c':(&var.val.r)[pui.comp]=value;break;//
		}
		break;
	case 3://t1d_c
		switch(varType)
		{
		case 'x':t1d_c.xs.setVX(value);break;
		case 't':t1d_c.solver.T=value;break;
		case 'c':(&var.val.r)[pui.comp]=value;break;
		}
		break;
	case 4://t1d_h
		switch(varType)
		{
		case 'x':t1d_h.xs.setVX(value);break;
		case 't':t1d_h.solver.T=value;break;
		case 'c':(&var.val.r)[pui.comp]=value;break;
		}
		break;
	case 11://ti2d
		switch(varType)
		{
		case 'x':ti2d.xs.setVX(value);break;
		case 'y':ti2d.ys.setVX(value);break;
		case 't':ti2d.solver.T=value;break;
		case 'c':(&var.val.r)[pui.comp]=value;break;
		}
		break;
	case 5://t2d
		switch(varType)
		{
		case 'x':t2d.xs.setVX(value);break;
		case 'y':t2d.ys.setVX(value);break;
		case 't':t2d.solver.T=value;break;
		case 'c':(&var.val.r)[pui.comp]=value;break;
		}
		break;
	case 6://c2d
		switch(varType)
		{
		case 'x':c2d.xs.setVX(value);break;
		case 'y':c2d.ys.setVX(value);break;
		case 't':c2d.solver.T=value;break;
		case 'c':(&var.val.r)[pui.comp]=value;break;
		}
		break;
	case 7://l2d
		switch(varType)
		{
		case 'x':l2d.xs.setVX(value);break;
		case 'y':l2d.ys.setVX(value);break;
		case 't':l2d.solver.T=value;break;
		case 'c':(&var.val.r)[pui.comp]=value;break;
		}
		break;
	case 8://t2d_h
		switch(varType)
		{
		case 'x':t2d_h.xs.setVX(value);break;
		case 'y':t2d_h.ys.setVX(value);break;
		case 't':t2d_h.solver.T=value;break;
		case 'c':(&var.val.r)[pui.comp]=value;break;
		}
		break;
	case 9://c3d
		switch(varType)
		{
		case 'x':c3d.xs.setVX(value);break;
		case 'y':c3d.ys.setVX(value);break;
		case 'z':c3d.zs.setVX(value);break;
		case 't':c3d.solver.T=value;break;
		case 'c':(&var.val.r)[pui.comp]=value;break;
		}
		break;
	}
}
struct DimensionInfo
{
	bool used;
	int v, c;//variable, component
	DimensionInfo():used(false), v(-1), c(-1){}
	void set(int v, int c){used=true, this->v=v, this->c=c;}
};
struct ExpressionInfo
{
	DimensionInfo x, y, z, t;
	int nC;
	ExpressionInfo():nC(0){}
	void update(Variable &var, int v, int c)
	{
		auto &varType=(&var.varTypeR)[c];
		switch(varType)
		{
		case 'x':x.set(v, c);break;
		case 'y':y.set(v, c);break;
		case 'z':z.set(v, c);break;
		case 't':t.set(v, c);break;
		case 'c':++nC;break;
		}
	}
};
void switch_parameter_type(ParamUI &pui, ButtonType hit)
{
	auto &ex=expr[cursorEx];
	auto &var=ex.variables[pui.var];
	auto &varType=(&var.varTypeR)[pui.comp];
	ExpressionInfo ei;
	int nISD=0,//number of input space dimensions
		nITD=0,//number of input time dimensions (up to 1)
		nC=0;//number of constants
	for(int v=0, vEnd=ex.variables.size();v<vEnd;++v)
	{
		auto &var2=ex.variables[v];
		ei.update(var2, v, 0);
		if(var2.mathSet>='c')
		{
			ei.update(var2, v, 1);
			if(var2.mathSet=='h')
			{
				ei.update(var2, v, 2);
				ei.update(var2, v, 3);
			}
		}
	}
	switch(hit)
	{
	case B_SPACE_X:
		if(varType=='t'||varType=='c')//change mode
		{
			if(ei.x.used)//swap varTypes
				(&ex.variables[ei.x.v].varTypeR)[ei.x.c]=varType;
			else
				++ex.nISD;
			ex.nITD&=varType!='t';
			varType='x';
			switch(ex.rmode[0])
			{
			case 0:break;//no expression - unreachable
			case 1://n0d -> t1d
				if(ex.resultLogicType)
					ex.rmode[0]=10,	modes::ti1d .toSolve=true, modes::ti1d .shiftOnly=0, modes::ti1d .solver.reset(), modes::ti1d .ready=false;
				else if(ex.resultMathSet=='R')
					ex.rmode[0]=2,	modes::t1d  .toSolve=true, modes::t1d  .shiftOnly=0, modes::t1d  .solver.reset(), modes::t1d  .ready=false;
				else if(ex.resultMathSet=='c')
					ex.rmode[0]=3,	modes::t1d_c.toSolve=true, modes::t1d_c.shiftOnly=0, modes::t1d_c.solver.reset(), modes::t1d_c.ready=false;
				else
					ex.rmode[0]=4,	modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0, modes::t1d_h.solver.reset(), modes::t1d_h.ready=false;
				break;
			case 10:				modes::ti1d .toSolve=true, modes::ti1d .shiftOnly=0, modes::ti1d .solver.reset(), modes::ti1d .ready=false;break;//stays ti1d
			case 2:					modes::t1d  .toSolve=true, modes::t1d  .shiftOnly=0, modes::t1d  .solver.reset(), modes::t1d  .ready=false;break;//stays t1d
			case 3:					modes::t1d_c.toSolve=true, modes::t1d_c.shiftOnly=0, modes::t1d_c.solver.reset(), modes::t1d_c.ready=false;break;//stays t1d_c
			case 4:					modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0, modes::t1d_h.solver.reset(), modes::t1d_h.ready=false;break;//stays t1d_h
			case 11:				modes::ti2d .toSolve=true, modes::ti2d .shiftOnly=0, modes::ti2d .solver.reset(), modes::ti2d .ready=false;break;//stays ti2d
			case 5:					modes::t2d  .toSolve=true, modes::t2d  .shiftOnly=0, modes::t2d  .solver.reset(), modes::t2d  .ready=false;break;//stays t2d
			case 6:					modes::c2d  .toSolve=true, modes::c2d  .shiftOnly=0, modes::c2d  .solver.reset(), modes::c2d  .ready=false;break;//stays c2d
			case 7:					modes::l2d  .toSolve=true, modes::l2d  .shiftOnly=0, modes::l2d  .solver.reset(), modes::l2d  .ready=false;break;//stays l2d
			case 8:					modes::t2d_h.toSolve=true, modes::t2d_h.shiftOnly=0, modes::t2d_h.solver.reset(), modes::t2d_h.ready=false;break;//stays t2d_h
			case 9:					modes::c3d  .toSolve=true, modes::c3d  .shiftOnly=0, modes::c3d  .solver.reset(), modes::c3d  .ready=false;break;//stays c3d
			}
		}
		else if(varType!='x'&&ei.x.used)
			(&ex.variables[ei.x.v].varTypeR)[ei.x.c]=varType, varType='x', modes::mode->toSolve=true;
		break;
	case B_SPACE_Y:
		if(varType=='t'||varType=='c')//change mode
		{
			if(ei.y.used)//swap varTypes
				(&ex.variables[ei.y.v].varTypeR)[ei.y.c]=varType;
			else
				++ex.nISD;
			ex.nITD&=varType!='t';
			varType='y';
			switch(ex.rmode[0])
			{
			case 0:break;//no expression - unreachable
			case 1://n0d -> t1d
				varType='x';
				if(ex.resultLogicType)
					ex.rmode[0]=10,	modes::ti1d .toSolve=true, modes::ti1d .shiftOnly=0, modes::ti1d .solver.reset(), modes::ti1d .ready=false;
				else if(ex.resultMathSet=='R')
					ex.rmode[0]=2,	modes::t1d  .toSolve=true, modes::t1d  .shiftOnly=0, modes::t1d  .solver.reset(), modes::t1d  .ready=false;
				else if(ex.resultMathSet=='c')
					ex.rmode[0]=3,	modes::t1d_c.toSolve=true, modes::t1d_c.shiftOnly=0, modes::t1d_c.solver.reset(), modes::t1d_c.ready=false;
				else
					ex.rmode[0]=4,	modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0, modes::t1d_h.solver.reset(), modes::t1d_h.ready=false;
				break;
			case 10:ex.rmode[0]=11,	modes::ti2d .toSolve=true, modes::ti2d .shiftOnly=0, modes::ti2d .solver.reset(), modes::ti2d .ready=false;break;//ti1d -> ti2d
			case 2:ex.rmode[0]=5,	modes::t2d  .toSolve=true, modes::t2d  .shiftOnly=0, modes::t2d  .solver.reset(), modes::t2d  .ready=false;break;//t1d -> t2d
			case 3:ex.rmode[0]=6,	modes::c2d  .toSolve=true, modes::c2d  .shiftOnly=0, modes::c2d  .solver.reset(), modes::c2d  .ready=false;break;//t1d_c -> c2d (or l2d?)
			case 4:ex.rmode[0]=8,	modes::t2d_h.toSolve=true, modes::t2d_h.shiftOnly=0, modes::t2d_h.solver.reset(), modes::t2d_h.ready=false;break;//t1d_h -> t2d_h
			case 11:				modes::ti2d .toSolve=true, modes::ti2d .shiftOnly=0, modes::ti2d .solver.reset(), modes::ti2d .ready=false;break;//stays ti2d
			case 5://stays t2d
				if(ex.resultLogicType)
					ex.rmode[0]=11, modes::ti2d .toSolve=true, modes::ti2d .shiftOnly=0, modes::ti2d .solver.reset(), modes::ti2d .ready=false;
				else
									modes::t2d  .toSolve=true, modes::t2d  .shiftOnly=0, modes::t2d  .solver.reset(), modes::t2d  .ready=false;break;
			case 6:					modes::c2d  .toSolve=true, modes::c2d  .shiftOnly=0, modes::c2d  .solver.reset(), modes::c2d  .ready=false;break;//stays c2d
			case 7:					modes::l2d  .toSolve=true, modes::l2d  .shiftOnly=0, modes::l2d  .solver.reset(), modes::l2d  .ready=false;break;//stays l2d
			case 8:					modes::t2d_h.toSolve=true, modes::t2d_h.shiftOnly=0, modes::t2d_h.solver.reset(), modes::t2d_h.ready=false;break;//stays t2d_h
			case 9:					modes::c3d  .toSolve=true, modes::c3d  .shiftOnly=0, modes::c3d  .solver.reset(), modes::c3d  .ready=false;break;//stays c3d
			}
		}
		else if(varType!='y'&&ei.y.used)
			(&ex.variables[ei.y.v].varTypeR)[ei.y.c]=varType, varType='y', modes::mode->toSolve=true;
		break;
	case B_SPACE_Z:
		if(varType=='t'||varType=='c')//change mode
		{
			if(ei.z.used)//swap varTypes
				(&ex.variables[ei.z.v].varTypeR)[ei.z.c]=varType;
			else
				++ex.nISD;
			ex.nITD&=varType!='t';
			varType='z';
			switch(ex.rmode[0])
			{
			case 0:break;//no expression - unreachable
			case 1://n0d -> t1d
				varType='x';
				if(ex.resultLogicType)
					ex.rmode[0]=10,	modes::ti1d .toSolve=true, modes::ti1d .shiftOnly=0, modes::ti1d .solver.reset(), modes::ti1d .ready=false;
				else if(ex.resultMathSet=='R')
					ex.rmode[0]=2,	modes::t1d  .toSolve=true, modes::t1d  .shiftOnly=0, modes::t1d  .solver.reset(), modes::t1d  .ready=false;
				else if(ex.resultMathSet=='c')
					ex.rmode[0]=3,	modes::t1d_c.toSolve=true, modes::t1d_c.shiftOnly=0, modes::t1d_c.solver.reset(), modes::t1d_c.ready=false;
				else
					ex.rmode[0]=4,	modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0, modes::t1d_h.solver.reset(), modes::t1d_h.ready=false;
				break;
			case 10:ex.rmode[0]=11, varType='y',	modes::ti2d .toSolve=true, modes::ti2d .shiftOnly=0, modes::ti2d .solver.reset(), modes::ti2d .ready=false;break;//ti1d -> ti2d
			case 2:ex.rmode[0]=5,	varType='y',	modes::t2d  .toSolve=true, modes::t2d  .shiftOnly=0, modes::t2d  .solver.reset(), modes::t2d  .ready=false;break;//t1d -> t2d
			case 3:ex.rmode[0]=6,	varType='y',	modes::c2d  .toSolve=true, modes::c2d  .shiftOnly=0, modes::c2d  .solver.reset(), modes::c2d  .ready=false;break;//t1d_c -> c2d (or l2d?)
			case 4:ex.rmode[0]=8,	varType='y',	modes::t2d_h.toSolve=true, modes::t2d_h.shiftOnly=0, modes::t2d_h.solver.reset(), modes::t2d_h.ready=false;break;//t1d_h -> t2d_h
			case 11://ti2d -> c3d
			case 5://t2d -> c3d
			case 6://c2d -> c3d
			case 7://l2d -> c3d
			case 8:ex.rmode[0]=9,					modes::c3d  .toSolve=true, modes::c3d  .shiftOnly=0, modes::c3d  .solver.reset(), modes::c3d  .ready=false;break;//t2d_h -> c3d
			case 9:									modes::c3d  .toSolve=true, modes::c3d  .shiftOnly=0, modes::c3d  .solver.reset(), modes::c3d  .ready=false;break;//stays c3d
			}
		}
		else if(varType!='z'&&ei.z.used)
			(&ex.variables[ei.z.v].varTypeR)[ei.z.c]=varType, varType='z', modes::mode->toSolve=true;
		break;
	case B_TIME:
		if(varType=='c')
		{
			if(ei.t.used)
				(&ex.variables[ei.t.v].varTypeR)[ei.t.c]=varType;
			ex.nITD=true;
			varType='t', modes::mode->toSolve=true;
		}
		else if(varType=='x'||varType=='y'||varType=='z')
		{
			if(ei.t.used)//swap varTypes
				(&ex.variables[ei.x.v].varTypeR)[ei.x.c]=varType;
			else//decrement space dimensions
			{
				if(varType=='x')
				{
					if(ei.y.used)
						(&ex.variables[ei.y.v].varTypeR)[ei.y.c]='x';
					if(ei.z.used)
						(&ex.variables[ei.z.v].varTypeR)[ei.z.c]='y';
				}
				else if(varType=='y')
				{
					if(ei.z.used)
						(&ex.variables[ei.z.v].varTypeR)[ei.z.c]='y';
				}
				--ex.nISD;
			}
			ex.nITD=true;
			varType='t';
			switch(ex.rmode[0])
			{
			case 0:break;//no expression - unreachable
			case 1:					modes::t1d  .toSolve=true, modes::t1d  .shiftOnly=0, modes::t1d  .solver.reset(), modes::t1d  .ready=false;break;//stays n0d - unreachable
			case 10://ti1d -> n0d
			case 2://t1d -> n0d
			case 3://t1d_c -> n0d
			case 4:ex.rmode[0]=1,	modes::n0d  .toSolve=true,								modes::n0d  .solver.reset(), modes::n0d  .ready=false;break;//t1d_h -> n0d
			case 11:ex.rmode[0]=10,	modes::ti1d .toSolve=true, modes::ti1d .shiftOnly=0, modes::ti1d .solver.reset(), modes::ti1d .ready=false;break;//ti2d -> ti1d
			case 5:ex.rmode[0]=2,	modes::t1d  .toSolve=true, modes::t1d  .shiftOnly=0, modes::t1d  .solver.reset(), modes::t1d  .ready=false;break;//t2d -> t1d
			case 6:ex.rmode[0]=3,	modes::t1d_c.toSolve=true, modes::t1d_c.shiftOnly=0, modes::t1d_c.solver.reset(), modes::t1d_c.ready=false;break;//c2d -> t1d_c
			case 7:ex.rmode[0]=3,	modes::t1d_c.toSolve=true, modes::t1d_c.shiftOnly=0, modes::t1d_c.solver.reset(), modes::t1d_c.ready=false;break;//l2d -> t1d_c
			case 8:ex.rmode[0]=4,	modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0, modes::t1d_h.solver.reset(), modes::t1d_h.ready=false;break;//t2d_h -> t1d_h
			case 9://c3d -> ti2d/t2d/c2d/t2d_h
				if(ex.resultLogicType)
					ex.rmode[0]=11, modes::ti2d.toSolve=true, modes::ti2d .shiftOnly=0, modes::ti2d .solver.reset(), modes::ti2d .ready=false;
				else if(ex.resultMathSet=='R')
					ex.rmode[0]=5, modes::t2d  .toSolve=true, modes::t2d  .shiftOnly=0, modes::t2d  .solver.reset(), modes::t2d  .ready=false;
				else if(ex.resultMathSet=='c')
					ex.rmode[0]=6, modes::c2d  .toSolve=true, modes::c2d  .shiftOnly=0, modes::c2d  .solver.reset(), modes::c2d  .ready=false;
				else if(ex.resultMathSet=='h')
					ex.rmode[0]=8, modes::t2d_h.toSolve=true, modes::t2d_h.shiftOnly=0, modes::t2d_h.solver.reset(), modes::t2d_h.ready=false;
				break;
			}
		}
		break;
	case B_CONST:
		if(varType=='t')
		{
			ex.nITD=false;
			varType='c', modes::mode->toSolve=true;
		}
		else if(varType=='x'||varType=='y'||varType=='z')
		{
			if(varType=='x')//decrement space dimensions
			{
				if(ei.y.used)
					(&ex.variables[ei.y.v].varTypeR)[ei.y.c]='x';
				if(ei.z.used)
					(&ex.variables[ei.z.v].varTypeR)[ei.z.c]='y';
			}
			else if(varType=='y')
			{
				if(ei.z.used)
					(&ex.variables[ei.z.v].varTypeR)[ei.z.c]='y';
			}
			--ex.nISD;
			varType='c';
			switch(ex.rmode[0])
			{
			case 0:break;//no expression - unreachable
			case 1:					modes::t1d  .toSolve=true, modes::t1d  .shiftOnly=0, modes::t1d  .solver.reset(), modes::t1d  .ready=false;break;//stays n0d - unreachable
			case 10:ex.rmode[0]=1,	modes::n0d  .toSolve=true,							modes::n0d  .solver.reset(), modes::n0d  .ready=false;break;//ti1d -> n0d
			case 2:ex.rmode[0]=1,	modes::n0d  .toSolve=true,							modes::n0d  .solver.reset(), modes::n0d  .ready=false;break;//t1d -> n0d
			case 3:ex.rmode[0]=1,	modes::n0d  .toSolve=true,							modes::n0d  .solver.reset(), modes::n0d  .ready=false;break;//t1d_c -> n0d
			case 4:ex.rmode[0]=1,	modes::n0d  .toSolve=true,							modes::n0d  .solver.reset(), modes::n0d  .ready=false;break;//t1d_h -> n0d
			case 11:ex.rmode[0]=10,	modes::ti1d .toSolve=true, modes::ti1d .shiftOnly=0, modes::ti1d .solver.reset(), modes::ti1d .ready=false;break;//ti2d -> ti1d
			case 5:ex.rmode[0]=2,	modes::t1d  .toSolve=true, modes::t1d  .shiftOnly=0, modes::t1d  .solver.reset(), modes::t1d  .ready=false;break;//t2d -> t1d
			case 6:ex.rmode[0]=3,	modes::t1d_c.toSolve=true, modes::t1d_c.shiftOnly=0, modes::t1d_c.solver.reset(), modes::t1d_c.ready=false;break;//c2d -> t1d_c
			case 7:ex.rmode[0]=3,	modes::t1d_c.toSolve=true, modes::t1d_c.shiftOnly=0, modes::t1d_c.solver.reset(), modes::t1d_c.ready=false;break;//l2d -> t1d_c
			case 8:ex.rmode[0]=4,	modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0, modes::t1d_h.solver.reset(), modes::t1d_h.ready=false;break;//t2d_h -> t1d_h
			case 9://c3d -> t2d/c2d/t2d_h
				if(ex.resultLogicType)
					ex.rmode[0]=11, modes::ti2d.toSolve=true, modes::ti2d .shiftOnly=0, modes::ti2d .solver.reset(), modes::ti2d .ready=false;
				else if(ex.resultMathSet=='R')
					ex.rmode[0]=5, modes::t2d  .toSolve=true, modes::t2d  .shiftOnly=0, modes::t2d  .solver.reset(), modes::t2d  .ready=false;
				else if(ex.resultMathSet=='c')
					ex.rmode[0]=6, modes::c2d  .toSolve=true, modes::c2d  .shiftOnly=0, modes::c2d  .solver.reset(), modes::c2d  .ready=false;
				else if(ex.resultMathSet=='h')
					ex.rmode[0]=8, modes::t2d_h.toSolve=true, modes::t2d_h.shiftOnly=0, modes::t2d_h.solver.reset(), modes::t2d_h.ready=false;
				break;
			}
		}
		break;
	}
}
void get_var_ui_sizes(int &uiStart, int &Sstart, int &Send)
{
	uiStart=w>>2, Sstart=uiStart+50, Send=w-110;
}
void draw_var_ui(Expression &ex, int kv, int component, int kp, bool start_anew, int y)
{
	int bkMode=setBkMode(OPAQUE);
//	int bg_mode=GetBkMode(ghMemDC);
//	SetBkMode(ghMemDC, OPAQUE);
	auto &var=ex.variables[kv];
	auto &varType=(&var.varTypeR)[component];
	if(start_anew)
		puis.push_back(ParamUI(kv, component, 'I', varType));
	auto &pui=puis[kp];
	int uiStart, Sstart, Send;
	get_var_ui_sizes(uiStart, Sstart, Send);
	{
		short yl=y-9;
		if(var.mathSet=='R')
			GUIPrint(uiStart, yl, var.name.c_str());
		else if(var.mathSet=='c')
		{
			if(component==0)
				GUIPrint(uiStart, yl, "Re(%s)", var.name.c_str());
			else
				GUIPrint(uiStart, yl, "Im(%s)", var.name.c_str());
		}
		else
			switch(component)
			{
			case 0:GUIPrint(uiStart, yl, "R(%s)", var.name.c_str());break;
			case 1:GUIPrint(uiStart, yl, "I(%s)", var.name.c_str());break;
			case 2:GUIPrint(uiStart, yl, "J(%s)", var.name.c_str());break;
			case 3:GUIPrint(uiStart, yl, "K(%s)", var.name.c_str());break;
			}
	}
//	int uiStart=w>>2, Sstart=uiStart+50, Send=w-110;
	print_varType(pui, varType, Send+10, y-18*2);
	{
		short bx=uiStart-21, by=y;
		rectangle(bx-10, by-10, bx+11, by+11);
	//	Rectangle(ghMemDC, bx-10, by-10, bx+11, by+11);
		draw_line(bx-5, by, bx+6, by), draw_line(bx, by-5, bx, by+6);
		pui.b_inc.set(bx-10, bx+11, by-10, by+11);
	}
	{
		short bx=uiStart-21*3, by=y;
		rectangle(bx-10, by-10, bx+11, by+11);
	//	Rectangle(ghMemDC, bx-10, by-10, bx+11, by+11);
		draw_line(bx-5, by, bx+6, by);
		pui.b_dec.set(bx-10, bx+11, by-10, by+11);
	}
	if(Sstart<Send)
	{
		{
			short x1=Send-80-1, x2=Send, y1=y+25-1, y2=y+25+18;
		//	short x1=Send+10-1, x2=Send+90, y1=y+18-1, y2=y+18*2;
			pui.b_scale.set(x1, x2, y1, y2);
		//	if(pui.b_scale.click(oldMouse))
				rectangle(x1, y1, x2, y2);
			//	Rectangle(ghMemDC, x1, y1, x2, y2);
			if(pui.scale_type=='I')
				GUIPrint(x1+1, y1+1, "linear scale");
			else if(pui.scale_type=='L')
				GUIPrint(x1+1, y1+1, "log scale");
			else if(pui.scale_type=='T')
				GUIPrint(x1+1, y1+1, "atan scale");
		}
		pui.b_slider.set(Sstart, Send, y-10, y+10);
	//	pui.b_slider.set('l', Sstart, Send, y-10, y+10);
		draw_line(Sstart, y, Send, y);
		draw_line(Sstart, y-10, Sstart, y+10), draw_line(Send, y-10, Send, y+10);
		double varStart=0, varEnd=0;
		extract_range(ex.rmode[0], var, component, varStart, varEnd);
		int Slength=Send-Sstart;

		if(pui.scale_type=='I')//linear scale
		{
			auto &s=pui.is;
			if(start_anew||s.uninitialized)
				s.uninitialized=false, pui.setLinearScale(g_scale*100, 0.5*(varStart+varEnd));
			s.update_scale(Slength);
			double step_2=s.step*0.5;
			for(double bv=s.start(), bvEnd=s.end();bv<=bvEnd;bv=s.next(bv))
			{
				int x=Sstart+(int)s.scale_fn(bv);
				if(x>=Send)
					break;
				draw_line(x, y-7, x, y+7);
				if(bv>-step_2&&bv<step_2)
					GUIPrint(x, y-28, "0");
				else
					GUIPrint(x, y-28, "%g", bv);
			}
			for(double bv=s.substart(), bvEnd=s.subend();bv<=bvEnd;bv+=s.substep)
			{
				int x2=Sstart+(int)s.scale_fn(bv);
				if(x2>=Send)
					break;
				draw_line(x2, y-4, x2, y+4);
			}
			if(varType=='c'||varType=='t')
			{
				int v=Sstart+int(s.scale_fn(varStart));
				if(v<Sstart)
				{
					v=Sstart;
					GUIPrint(v, y+11, "%g...", varStart);
				}
				else if(v>=Send)
				{
					v=Send;
					GUIPrint(v, y+11, "...%g", varStart);
				}
				else
					GUIPrint(v, y+11, "%g", varStart);
				draw_line(v-10, y-10, v-10, y+10);
				draw_line(v+10, y-10, v+10, y+10);
				draw_line(v-10, y-10, v+10, y-10);
				draw_line(v-10, y+10, v+10, y+10);
				draw_line(v, y-10, v, y);
			}
			else
			{
				int Rstart=Sstart+int(s.scale_fn(varStart)),
					Rend=Sstart+int(s.scale_fn(varEnd)),
					Rav=(Rstart+Rend)>>1;
				if(Rstart>=Send)
					GUIPrint(Send, y+11, "...%g", 0.5*(varStart+varEnd));
				else if(Rend<=Sstart)
					GUIPrint(Sstart, y+11, "%g...", 0.5*(varStart+varEnd));
				else
				{
					bool start_oob=false, end_oob=false;
					if(Rstart<Sstart)
						Rstart=Sstart, start_oob=true;
					if(Rend>Send)
						Rend=Send, end_oob=true;
					draw_line(Rstart, y-10, Rstart, y+10);
					draw_line(Rend, y-10, Rend, y+10);
					draw_line(Rstart, y-10, Rend, y-10);
					draw_line(Rstart, y+10, Rend, y+10);
					if(Rav>=Sstart&&Rav<Send)
						draw_line(Rav, y-10, Rav, y);
					if(start_oob)
						GUIPrint(Rstart, y+11, "%g...", varStart);
					else
						GUIPrint(Rstart, y+11, "%g", varStart);
					if(end_oob)
						GUIPrint(Rend, y+11, "...%g", varEnd);
					else
						GUIPrint(Rend, y+11, "%g", varEnd);
				}
			}
		}
		else if(pui.scale_type=='L')//log scale
		{
			auto &s=pui.ls;
			if(start_anew||s.uninitialized)
				s.uninitialized=false, pui.setLogScale(g_scale*1000, 0.5*(varStart+varEnd));
			s.update_scale(Slength);
			if(s.linearstep_on)
			{
				bool r=false;
				int k=0;
				for(double v=s.start_linstep(), vEnd=s.end_linstep();v<=vEnd;v=s.next_linstep(v, Slength, r), ++k)
				{
					if(v>0)
					{
						int x=Sstart+int(s.scale_fn(v)*Slength);
						if(x>Send)
							break;
						if(x>=Sstart)
							draw_line(x, y-7, x, y+7);
						if(r)//round power
						{
							k=-1;
							int flv=floor_log10(v);
							int elevation=64;//5
							if(x>=Sstart)
								switch(flv)
								{
								case -1:
									GUIPrint(x, y-28-elevation, "0.1");
									break;
								case 0:
									GUIPrint(x, y-28-elevation, "1");
									break;
								case 1:
									GUIPrint(x, y-28-elevation, "10");
									break;
								default:
									GUIPrint(x, y-28-elevation, "1e%d", flv);
									break;
								}
							for(double v2=s.subnext_linstep(v, Slength, r);v2<=vEnd;v2=s.subnext_linstep(v2, Slength, r))
							{
								if(r)
									break;
								int x=Sstart+int(s.scale_fn(v2)*Slength);
								if(x>=Send)
									break;
								if(x>=Sstart)
									draw_line(x, y-3, x, y+3);
							}
							s.temp_linstep2=s.temp_linstep;
						}
						else if(x>=Sstart)
							GUIPrint(x, y-28-16*(k%4), "%g", v);
					}
				}
			}
			else if(std::round(s.Xstep)==10)//linsubstep
			{
				for(double bv=s.start(), bvEnd=s.end();bv<=bvEnd;bv=s.next(bv))
				{
					int x=Sstart+int(s.scale_lfn(bv)*Slength);
				//	int x=Sstart+int((bv-s.logVstart)*Slength/(s.logVend-s.logVstart));
					if(x>=Send)
						break;
					if(x>=Sstart)
					{
						draw_line(x, y-7, x, y+7);
						GUIPrint(x, y-28, "%g", s.pow10(bv));
					}
					for(double bv0=exp(bv*G2::_ln10), bv2=bv0, bv2End=exp(s.next(bv)*G2::_ln10);bv2<bv2End;bv2+=bv0)
					{
						int x2=Sstart+int(s.scale_fn(bv2)*Slength);
						if(x2>=Sstart&&x2<=Send)
							draw_line(x2, y-4, x2, y+4);
					}
				}
			}
			else//log step & substep
			{
				for(double bv=s.start(), bvEnd=s.end();bv<=bvEnd;)
				{
					int x=Sstart+int(s.scale_lfn(bv)*Slength);
				//	int x=Sstart+int((bv-s.logVstart)*Slength/(s.logVend-s.logVstart));
					if(x>=Send)
						break;
					if(x>=Sstart)
					{
						draw_line(x, y-7, x, y+7);
						GUIPrint(x, y-28, "%g", s.pow10(bv));
					}
					double bv0=bv;
					bv=s.next(bv);
					for(double v2=bv0+1;v2<bv;++v2)//draw all powers of 10
					{
						int x2=Sstart+int(s.scale_lfn(v2)*Slength);
						if(x2>=Sstart&&x2<=Send)
							draw_line(x2, y-3, x2, y+3);
					}
				}
			}
			if(varType=='c'||varType=='t')
			{
				int v=Sstart+int(s.scale_fn(varStart)*Slength);
				bool oob_left=false, oob_right=false;
				if(v<Sstart)
					v=Sstart, oob_left=true;
				if(v>Send)
					v=Send, oob_right=true;
				draw_line(v-10, y-10, v-10, y+10);
				draw_line(v+10, y-10, v+10, y+10);
				draw_line(v-10, y-10, v+10, y-10);
				draw_line(v-10, y+10, v+10, y+10);
				draw_line(v, y-10, v, y);
				if(oob_left)
					GUIPrint(v, y+11, "%g...", varStart);
				else if(oob_right)
					GUIPrint(v, y+11, "...%g", varStart);
				else
					GUIPrint(v, y+11, "%g", varStart);
			}
			else
			{
				int Rstart=Sstart+int(s.scale_fn(varStart)*Slength),//0x800002dd<0
					Rend=Sstart+int(s.scale_fn(varEnd)*Slength),
					Rav=Sstart+int(s.scale_fn(0.5*(varStart+varEnd))*Slength);
				if(Rstart>=Send)
					GUIPrint(Send, y+11, "...%g", 0.5*(varStart+varEnd));
				else if(Rend<=Sstart)
					GUIPrint(Sstart, y+11, "%g...", 0.5*(varStart+varEnd));
				else
				{
					bool start_oob=false, end_oob=false;
					if(Rstart<Sstart)
						Rstart=Sstart, start_oob=true;
					if(Rend>Send)
						Rend=Send, end_oob=true;
					draw_line(Rstart, y-10, Rstart, y+10);
					draw_line(Rend, y-10, Rend, y+10);
					draw_line(Rstart, y-10, Rend, y-10);
					draw_line(Rstart, y+10, Rend, y+10);
					if(Rav>=Sstart&&Rav<Send)
						draw_line(Rav, y-10, Rav, y);
					if(start_oob)
						GUIPrint(Rstart, y+11, "%g...", varStart);
					else
						GUIPrint(Rstart, y+11, "%g", varStart);
					if(end_oob)
						GUIPrint(Rend, y+11, "...%g", varEnd);
					else
						GUIPrint(Rend, y+11, "%g", varEnd);
				}
			}
		}
		else if(pui.scale_type=='T')//atan scale
		{
			auto &s=pui.ts;
			if(start_anew||s.uninitialized)
				s.uninitialized=false, pui.setAtanScale(g_scale, 0.5*(varStart+varEnd));
			s.update_scale(Slength);
			for(int kv=0, kvEnd=s.bestVal.size();kv<kvEnd;++kv)
			{
				auto &bv=s.bestVal[kv];
				int x=Sstart+int(s.scale_fn(bv)*Slength);
			//	int x=Sstart+int((atan(s.scale*bv-s.c)*G2::_1_pi+0.5)*Slength);
				draw_line(x, y-7, x, y+7);
				GUIPrint(x, y-28, "%g", bv);
				if(kv+1<kvEnd)
				{
					auto &bv2=s.bestVal[kv+1];
					double step=s.subscale_step(kv);
					for(double X2=bv+step;X2<bv2;X2+=step)
					{
						int x2=Sstart+int(s.scale_fn(X2)*Slength);
					//	draw_line(x2, y-5, x2, y+5);
						draw_line(x2, y-4, x2, y+4);
					}
				}
			}
			if(varType=='c'||varType=='t')
			{
				int v=Sstart+int(s.scale_fn(varStart)*Slength);
			//	int v=Sstart+int((atan(s.scale*varStart-s.c)*G2::_1_pi+0.5)*Slength);
				draw_line(v-10, y-10, v-10, y+10);
				draw_line(v+10, y-10, v+10, y+10);
				draw_line(v-10, y-10, v+10, y-10);
				draw_line(v-10, y+10, v+10, y+10);
				draw_line(v, y-10, v, y);
				GUIPrint(v, y+11, "%g", varStart);
			}
			else
			{
				int Rstart=Sstart+int(s.scale_fn(varStart)*Slength),
					Rend=Sstart+int(s.scale_fn(varEnd)*Slength),
					Rav=Sstart+int(s.scale_fn(0.5*(varStart+varEnd))*Slength);
			//	int Rstart=Sstart+int((atan(s.scale*varStart-s.c)*G2::_1_pi+0.5)*Slength),
			//		Rend=Sstart+int((atan(s.scale*varEnd-s.c)*G2::_1_pi+0.5)*Slength);
				draw_line(Rav, y-10, Rav, y);
				draw_line(Rstart, y-10, Rstart, y+10);
				draw_line(Rend, y-10, Rend, y+10);
				draw_line(Rstart, y-10, Rend, y-10);
				draw_line(Rstart, y+10, Rend, y+10);
				GUIPrint(Rstart, y+11, "%g", varStart);
				GUIPrint(Rend, y+11, "%g", varEnd);
			}
		}
	}
	setBkMode(bkMode);
//	SetBkMode(ghMemDC, bg_mode);
}
void var_ui_drag(short mx, short my)
{
	auto &pui=puis[var_menu_drag_pui];
	int uiStart, Sstart, Send;
	get_var_ui_sizes(uiStart, Sstart, Send);
	int Slength=Send-Sstart;
	double value=0;

	double varStart, varEnd;
	auto &ex=expr[cursorEx];
	auto &var=ex.variables[pui.var];
	auto &varType=(&var.varTypeR)[pui.comp];
	extract_range(ex.rmode[0], var, pui.comp, varStart, varEnd);
	switch(pui.scale_type)
	{
	case 'I':
		{
			auto &s=pui.is;
			value=s.VX+(mx-(Sstart+Slength/2))*s.sample;
		}
		break;
	case 'L':
		{
			auto &s=pui.ls;
			value=exp((s.logXstart+(s.logXend-s.logXstart)*double(mx-Sstart)/Slength)*G2::_ln10);
		}
		break;
	case 'T':
		{
			auto &s=pui.ts;
			value=s.scale_ifn(double(mx-Sstart)/Slength);
		}
		break;
	}
	set_parameter(pui, value);
}
void var_ui_lbuttonDown()
{
	short mx=((short*)&oldMouse)[0], my=((short*)&oldMouse)[1];
	ButtonType hit=B_MISS;//1: scale, 2: param, 3: slider
	int k=0;
	for(int kEnd=puis.size();k<kEnd;++k)
	{
		auto &pui=puis[k];
		if(pui.b_space_x.click(mx, my))
		{
			hit=B_SPACE_X;
			break;
		}
		if(pui.b_space_y.click(mx, my))
		{
			hit=B_SPACE_Y;
			break;
		}
		if(pui.b_space_z.click(mx, my))
		{
			hit=B_SPACE_Z;
			break;
		}
		if(pui.b_time.click(mx, my))
		{
			hit=B_TIME;
			break;
		}
		if(pui.b_const.click(mx, my))
		{
			hit=B_CONST;
			break;
		}
		if(pui.b_scale.click(mx, my))
		{
			hit=B_SCALE;
			break;
		}
		if(pui.b_slider.click(mx, my))
		{
			hit=B_SLIDER;
			break;
		}
		if(pui.b_inc.click(mx, my))
		{
			hit=B_INC;
			break;
		}
		if(pui.b_dec.click(mx, my))
		{
			hit=B_DEC;
			break;
		}
	}
	if(hit!=B_MISS)
	{
		auto &pui=puis[k];
		switch(hit)
		{
		case B_SCALE:
			switch(pui.scale_type)
			{
			case 'I':pui.scale_type='L';break;
			case 'L':pui.scale_type='T';break;
			case 'T':pui.scale_type='I';break;
			}
			break;
		case B_SPACE_X:
		case B_SPACE_Y:
		case B_SPACE_Z:
		case B_TIME:
		case B_CONST:
	//	case B_PARAM:
			switch_parameter_type(pui, hit);
			break;
		case B_SLIDER:
			var_menu_drag=1, var_menu_drag_pui=k;
			var_ui_drag(mx, my);
			break;
		case B_INC:
			increment_parameter(pui);
			break;
		case B_DEC:
			decrement_parameter(pui);
			break;
		}
		render();
	}
}
void var_ui_drag(int lParam)
{
	short mx=((short*)&lParam)[0], my=((short*)&lParam)[1];
	var_ui_drag(mx, my);
	render();
}
void var_ui_scroll(int wParam)
{
	bool mw_forward=((short*)&wParam)[1]>0;
	short mx=((short*)&oldMouse)[0], my=((short*)&oldMouse)[1];
	int k=0;
	bool hit=false;
	if(puis.size()==1)
		hit=true;
	else
		for(int kEnd=puis.size();k<kEnd;++k)
		{
			if(my>h-vui_height*(k+1))
			{
				hit=true;
				break;
			}
		}
	if(hit)
	{
		int uiStart, Sstart, Send;
		get_var_ui_sizes(uiStart, Sstart, Send);
		int Slength=Send-Sstart;

		auto &pui=puis[k];
		switch(pui.scale_type)
		{
		case 'I':
			if(kb[VK_CONTROL])//scroll
			{
				double ammount=0.2*(pui.is.scale_ifn(Slength)-pui.is.scale_ifn(0));
					 if(mw_forward)	pui.is.VX+=ammount;
				else				pui.is.VX-=ammount;
			}
			else//zoom
			{
				auto &s=pui.is;
				double dx=(mx-(Sstart+Slength/2))*s.sample;
					 if(mw_forward)	s.mul_scale(1.1), s.VX+=dx*(1-1/1.1);
				else				s.div_scale(1.1), s.VX+=dx*(1-1.1);
			}
			break;
		case 'L':
			if(kb[VK_CONTROL])//scroll
			{
				double ammount=pow((pui.ls.scale_ifn(1)/pui.ls.scale_ifn(0)), 0.2);
					 if(mw_forward)	pui.ls.VX*=ammount;
				else				pui.ls.VX/=ammount;
			}
			else//zoom
			{
				auto &s=pui.ls;
				double zoomCenter=s.Xstart*pow(s.Xend/s.Xstart, double(mx-Sstart)/Slength);
				if(mw_forward)
					s.mul_scale(1.1), s.VX=zoomCenter*pow(s.VX/zoomCenter, 1/1.1);
				else
					s.div_scale(1.1), s.VX=zoomCenter*pow(s.VX/zoomCenter, 1.1);
				if(s.VX<=0)
					s.VX=1;
			}
			break;
		case 'T':
			if(kb[VK_CONTROL])//scroll
			{
				double ammount=0.2*(pui.ts.scale_ifn(0.75)-pui.ts.scale_ifn(0.25));
					 if(mw_forward)	pui.ts.VX+=ammount;
				else				pui.ts.VX-=ammount;
			}
			else//zoom
			{
				auto &s=pui.ts;
				double dx=tan((double(mx-(Sstart+Slength/2))/Slength)*G2::_pi)/s.scale;
					 if(mw_forward)	s.mul_scale(1.1), s.VX+=dx*(1-1/1.1);
				else				s.div_scale(1.1), s.VX+=dx*(1-1.1);
			}
			break;
		}
		render();
	}
}
HWND ghWndEditBox=0;
WNDPROC gPrevEditProc=0;
unsigned gkpui=0;
long		__stdcall SubClassProc(HWND__ *hWnd, unsigned message, unsigned wParam, long lParam)
{
	switch(message)
	{
	case WM_KEYDOWN:
		switch(wParam)
		{
		case VK_ESCAPE:
			DestroyWindow(ghWndEditBox);
			break;
		case VK_RETURN:
			if(gkpui<puis.size())
			{
				int length=GetWindowTextA(ghWndEditBox, g_buf, g_buf_size);
				if(!length)
				{
					int err=GetLastError();
					err=err;
				}
				else
				{
					double value=atof(g_buf);
					set_parameter(puis[gkpui], value);
				}
			}
			DestroyWindow(ghWndEditBox);
			break;
		}
		break;
	}
	return CallWindowProc(gPrevEditProc, hWnd, message, wParam, lParam);
}
void var_ui_keyDown(int wParam, int lParam)
{
	bool hit=
		(wParam==VK_ADD)|(wParam==VK_OEM_PLUS)|
		(wParam==VK_SUBTRACT)|(wParam==VK_OEM_MINUS)|
		(wParam=='0')|(wParam==VK_NUMPAD0)|
		(wParam==VK_RETURN)|(wParam==VK_SPACE)|
		(wParam=='S');
	if(hit)
	{
		int param=-1;
		for(int k='1', k2=VK_NUMPAD1;k<':';++k)
		{
			if(kb[k]||kb[k2])
			{
				param=k-'1';
				break;
			}
		}
		if(param!=-1&&param<(int)puis.size())
		{
			auto &pui=puis[param];
			switch(wParam)
			{
			case VK_ADD:case VK_OEM_PLUS://increment Nth parameter
				increment_parameter(pui);
				break;
			case VK_SUBTRACT:case VK_OEM_MINUS://decrement Nth parameter
				decrement_parameter(pui);
				break;
			case '0':case VK_NUMPAD0://reset Nth parameter
				set_parameter(pui, 0);
				break;
			case VK_RETURN://textbox for Nth parameter
				{
					gkpui=param;
					short X0=w>>1, Y0=h>>1;
					short ww=200, wh=18, wx1=X0-(ww>>1), wy1=Y0-(wh>>1);
				//	short bw=50, bh=25, bx1=X0+(ww>>1)+50, by1=Y0-(bh>>1);

					HMODULE hInstance=GetModuleHandleA(0);
					ghWndEditBox=CreateWindowExA(WS_EX_CLIENTEDGE, "COMBOBOX", "", CBS_DROPDOWN|CBS_HASSTRINGS|WS_CHILD|WS_OVERLAPPED|WS_VISIBLE, wx1, wy1, ww, wh, ghWnd, 0, hInstance, 0);
				//	ghWndEditBox=CreateWindowExA(WS_EX_CLIENTEDGE, "EDIT", "", WS_CHILD|WS_OVERLAPPED|WS_VISIBLE|ES_CENTER, wx1, wy1, ww, wh, ghWnd, 0, hInstance, 0);//no messages
					HWND hWndEdit=GetWindow(ghWndEditBox, GW_CHILD);
					gPrevEditProc=(WNDPROC)SetWindowLongA(hWndEdit, GWL_WNDPROC, (long)SubClassProc);
					SetFocus(ghWndEditBox);
				}
				break;
			case VK_SPACE://select type of Nth parameter
				{
					auto &ex=expr[cursorEx];
					auto &var=ex.variables[pui.var];
					auto &varType=(&var.varTypeR)[pui.comp];
					switch(varType)
					{
					case 'x':
					case 'y':
					case 'z':
						switch_parameter_type(pui, B_TIME);
						break;
					case 't':
						switch_parameter_type(pui, B_CONST);
						break;
					case 'c':
						switch_parameter_type(pui, B_SPACE_X);
						break;
					}
				}
				break;
			case 'S'://select scale type for Nth parameter
				switch(pui.scale_type)
				{
				case 'I':pui.scale_type='L';break;
				case 'L':pui.scale_type='T';break;
				case 'T':pui.scale_type='I';break;
				}
				break;
			}
			render();
		}
	}
}
#endif

static const char	  // 0				   1				   2				   3				   4				   5				   6				   7				   8				   9				   10				   11				   12
					  // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7
					  //                                                                 s ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ del
	isAlphanumeric	[]="\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\1\1\1\1\1\1\1\1\1\0\0\0\0\0\0\0\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\0\0\0\0\1\0\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\0\0\0\0\0",
	isLetter		[]="\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\0\0\0\0\1\0\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\0\0\0\0\0",
	isHexadecimal	[]="\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\1\1\1\1\1\1\1\1\1\0\0\0\0\0\0\0\1\1\1\1\1\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\1\1\1\1\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
const char	*keywords[]=
{
#define	TOKEN(STRING, LABEL)	STRING
#include"g2_keywords.h"
#undef	TOKEN
};
enum		ConstantLabels
{
#define	TOKEN(STRING, LABEL)	LABEL
#include"g2_keywords2.h"
#undef	TOKEN
};
const char	*kw2[]=
{
#define	TOKEN(STRING, LABEL)	STRING
#include"g2_keywords2.h"
#undef	TOKEN
};
inline char	tolower(char c)
{
	return c+(('a'-'A')&-((c>='A')&(c<='Z')));
}
int			strcmp_advance_ci(const char *s1, const char *label, int *advance)//returns zero if label matches
{
	if(advance)
	{
		*advance=0;
		for(;*s1&&*label&&tolower(*s1)==tolower(*label);++s1, ++label, ++*advance);
	}
	else
		for(;*s1&&*label&&tolower(*s1)==tolower(*label);++s1, ++label);
	return *label!=0;
//	return (*s1>*label)-(*s1<*label);
}
int			strcmp_advance(const char *s1, const char *label, int *advance)//returns zero if label matches
{
	if(advance)
	{
		*advance=0;
		for(;*s1&&*label&&*s1==*label;++s1, ++label, ++*advance);
	}
	else
		for(;*s1&&*label&&*s1==*label;++s1, ++label);
	return *label!=0;
//	return (*s1>*label)-(*s1<*label);
}
inline int	match_kw(const char *text, const char *kw, int exprBound, int *advance)
{
	int condition=!strcmp_advance_ci(text, kw, advance)&&(exprBound||!isAlphanumeric[text[*advance]]);
	return condition;
}
inline int	match_uf(const char *text, const char *kw, int *advance)//case-sensitive
{
	int condition=!(strcmp_advance(text, kw, advance)||isAlphanumeric[text[*advance]]);
	//int condition=!strcmp_advance(text, kw, advance)&&!isAlphanumeric[text[*advance]];
	return condition;
}
long		__stdcall WndProc(HWND__ *hWnd, unsigned message, unsigned wParam, long lParam)
{
	switch(message)
	{
	case WM_PAINT:
		GetClientRect(hWnd, &R);
		if(h!=R.bottom-R.top||w!=R.right-R.left)
		{
			h=R.bottom-R.top, w=R.right-R.left, centerP.x=w/2, centerP.y=h/2, X0=w>>1, Y0=h>>1;
			ClientToScreen(hWnd, &centerP);
			resize_2D();
			//DeleteObject((HBITMAP)SelectObject(ghMemDC, ghBitmap));
			//BITMAPINFO bmpInfo={{sizeof(BITMAPINFOHEADER), w, -h, 1, 32, BI_RGB, 0, 0, 0, 0, 0}};
			//ghBitmap=(HBITMAP)SelectObject(ghMemDC, CreateDIBSection(0, &bmpInfo, DIB_RGB_COLORS, (void**)&rgb, 0, 0));
			modeRGB=(int*)realloc(modeRGB, w*h*sizeof(int));
			memset(modeRGB, 0xFF, w*h*sizeof(int));
			if(modes::active)
				modes::mode->messagePaint(0, 0, w, h);
			else
			{
				itb.setDimensions(0, 0, w, h);
				if(modes::paint)
					modes::paint();
				render();
			}
		}
		else
		{
			if(modes::active)
				modes::mode->a_draw();
			else
				render();
		}
		break;
	case WM_EXITSIZEMOVE:
		centerP.x=w/2, centerP.y=h/2;
		ClientToScreen(ghWnd, &centerP);
		return 0;
	case WM_ACTIVATE:
		switch(wParam)
		{
		case WA_ACTIVE:
		case WA_CLICKACTIVE:
			caps_lock=char(GetKeyState(VK_CAPITAL)), num_lock=char(GetKeyState(VK_NUMLOCK));
			for(int k=0;k<256;++k)
				kb[k]=(GetKeyState(k)&0x8000)!=0;
			kb[VK_LBUTTON]=0;
			if(modes::ready)
				modes::mode->appActivate();
			break;
		case WA_INACTIVE:
			if(modes::ready)
				modes::mode->appDeactivate();
			else if(inactiveLMBDown)
			{
				ReleaseCapture();
				itb.inputLButtonUp();
				inactiveLMBDown=0;
			}
			break;
		}
		break;
	case WM_TIMER:
		if(modes::active)
			modes::mode->messageTimer();
		else
			render();
		return 0;
	case WM_LBUTTONDOWN:
	case WM_LBUTTONDBLCLK:
		kb[VK_LBUTTON]=1;
		if(modes::active)
			modes::mode->inputLButtonDown(lParam);
		else if(var_menu)
			var_ui_lbuttonDown();
		else
		{
			SetCapture(hWnd), inactiveLMBDown=1;
			if(itb.inputLButtonDown(lParam))
				render();
		}
		oldMouse=lParam;
		return 0;
	case WM_LBUTTONUP:
		if(kb[VK_LBUTTON])//double click title bar crash
		{
			kb[VK_LBUTTON]=0;
			if(inactiveLMBDown)
			{
				ReleaseCapture();
				itb.inputLButtonUp();
				inactiveLMBDown=0;
			}
			else if(modes::mode)
				modes::mode->inputLButtonUp(lParam);
		}
		var_menu_drag=0;
		return 0;
	case WM_RBUTTONDOWN:
	case WM_RBUTTONDBLCLK:
#ifdef BUILD_1_7
		if(!modes::active)
		{
			auto &ex=expr[cursorEx];
			if(bounds[cursorB].second=='e'&&(ex.rmode[0]!=1||ex.nISD+ex.nITD))
			{
				puis.clear();
				var_menu=!var_menu;
				render();
			}
		}
#endif
		break;
	case WM_RBUTTONUP:
		break;
	case WM_MOUSELEAVE:
		break;
	case WM_MOUSEMOVE:
		if(modes::active)
			modes::mode->inputMouseMove(lParam);
#ifdef BUILD_1_7
		else if(var_menu_drag)
			var_ui_drag(lParam);
#endif
		else
		{
			if(itb.inputMouseMove(lParam))
				render();
		}
		oldMouse=lParam;
		return 0;
	case WM_MOUSEWHEEL:
		if(modes::active)
			modes::mode->inputMouseWheel(wParam);
#ifdef BUILD_1_7
		else if(var_menu)
			var_ui_scroll(wParam);
#endif
		else
		{
			int draw=0;
			if(kb[VK_CONTROL])
			{
				double A=changeFont(wParam);
			//	double A=font.change(wParam);
				if(A!=1)
				{
					itb.changeFont(A);
					draw|=1;
				}
			}
			else
				draw|=itb.inputMouseWheel(wParam);
			if(draw)
				render();
		}
		return 0;
	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
		switch(wParam)//global commands
		{
		case VK_ESCAPE:
			if(modes::active)
			{
				modes::active=false, modes::mode->exit();
				itb.setDimensions(0, 0, w, h);
				if(kb[VK_LBUTTON])
					inactiveLMBDown=1, itb.switchToWithMouseOn(oldMouse);
				render();
				return 0;
			}
			else if(modes::ready)
			{
				if(kb[VK_LBUTTON])
					inactiveLMBDown=0, itb.inputLButtonUp();
				modes::active=true, modes::mode->enter();
			}
			break;
		case VK_TAB://switch between {software, OpenGL, OpenCL-OpenGL interoperation}
			if(modes::active)
			{
				char decrement=kb[VK_SHIFT];
				decrement-=!decrement;
				char old_gmode=usingOpenGL;
				usingOpenGL=(usingOpenGL+N_GRAPHICS_MODES-decrement)%N_GRAPHICS_MODES;
				switch(old_gmode)//1) finish
				{
				case MODE_SOFTWARE:
					gBitmap.finish();
					finish();
					break;
				case MODE_CL_GL_INTEROP:
					cl_terminate();
				case MODE_OPENGL:
					if(usingOpenGL==MODE_SOFTWARE)
						gl_finish();
					break;
				}
				switch(usingOpenGL)//2) start
				{
				case MODE_SOFTWARE:
					initiate();
					gBitmap.set(w, h);
					gBitmap.use();
					break;
				case MODE_OPENGL:
					if(old_gmode!=MODE_CL_GL_INTEROP)
						gl_initiate(ghDC, w, h);
					break;
				case MODE_CL_GL_INTEROP:
					if(old_gmode!=MODE_OPENGL)
						gl_initiate(ghDC, w, h);
					cl_initiate();
					break;
				}
				//if(usingOpenGL==MODE_CL_GL_INTEROP)
				//	cl_initiate();						//2nd time: INVALID CONTEXT
				//else if(usingOpenGL)//turn on OpenGL
				//{
				//	gBitmap.finish();
				//	finish();
				//	gl_initiate(ghDC, w, h);
				//}
				//else//turn off OpenGL
				//{
				//	cl_terminate();
				//	gl_finish();
				//	initiate();
				//	gBitmap.set(w, h);
				//	gBitmap.use();
				//}
				if(modes::mode)
					modes::mode->toSolve=true;
			}
			break;
		case VK_F1://toggle context help
			contextHelp=!contextHelp;
			if(!modes::active)
				render();
			break;
		case VK_F2:
			if(!modes::active&&expr[cursorEx].rmode[0])
			{
				puis.clear();
				var_menu=!var_menu;
				render();
			}
			break;
		case VK_F3://test: toggle contour method
			test_contourMethod=(test_contourMethod+1)%3;
			modes::c3d.toSolve=true, modes::c3d.shiftOnly=0;
			render();
			break;
		case VK_F4:
			if(kb[VK_MENU])//alt F4 quit
			{
				PostQuitMessage(0);
				return 0;
			}
			else//version
			{
				char date[]=__DATE__, time[]=__TIME__, space[]=" ";
				char *next_token=nullptr, *month=strtok_s(date, space, &next_token), *day=strtok_s(nullptr, space, &next_token), *year=strtok_s(nullptr, space, &next_token);
				const char *months[]={"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
				const int nmonths=12;
				int m=0;
				for(int k=0;k<nmonths;++k)
				{
					if(!strcmp(month, months[k]))
					{
						m=k+1;
						break;
					}
				}
				const char *build=
#ifdef _DEBUG
					"Debug";
#else
					"Release";
#endif
				int length=sprintf_s(g_buf, g_buf_size,
					"Grapher 2\n"
					"Version:\t%.2lf-CL %d\n", g2_version.g2*0.01, (int)g2_version.cl_comp);
				if(m)
					length+=sprintf_s(g_buf+length, g_buf_size-length, "Build:\t%s-%02d-%s%s %s", year, m, strlen(day)==1?"0":"", day, time);
				else
					length+=sprintf_s(g_buf+length, g_buf_size-length, "Build:\t%s %s", date, time);
				length+=sprintf_s(g_buf+length, g_buf_size-length, " (%s)", build);
			//	if(m)
			//		sprintf_s(g_buf, g_buf_size, "Grapher 2\nVersion: G2 %.2lf, CL %d\nBuild %s-%02d-%s %s (%s)", g2_version.g2*0.01, (int)g2_version.cl_comp, year, m, day, time, a);
			//	else
			//		sprintf_s(g_buf, g_buf_size, "Grapher 2\nVersion: G2 %d, CL %d\nBuild %s %s (%s)", g2_version.g2*0.01, (int)g2_version.cl_comp, date, time, a);
				MessageBoxA(ghWnd, g_buf, "About", MB_OK);
			}
			break;
	//	case VK_F6://3D mode move cam
		case VK_F7://show benchmark, ctrl+F7: toggle SIMD
			if(kb[VK_CONTROL])
			{
				if(supported_simd_arch>=ARCH_AVX)
				{
					switch(simd_method)
					{
					case 0:simd_method=1;break;
					case 1:simd_method=2;break;
					case 2:simd_method=0;break;
					default:simd_method=0;break;
					}
				}
				else if(supported_simd_arch>=ARCH_SSE3)
				{
					switch(simd_method)
					{
					case 0:simd_method=1;break;
					case 1:simd_method=0;break;
					default:simd_method=0;break;
					}
				}
			}
			else if(kb[VK_MENU])
				all_to_clipboard();
			else
				showBenchmark=!showBenchmark;
			if(modes::mode)
				modes::mode->toSolve=true, modes::mode->ready=false;
			if(modes::active)
				modes::mode->a_draw();
			else
				render();
			break;
		case VK_F8://toggle 2d drag convention
			_2d_drag_graph_not_window=!_2d_drag_graph_not_window;
			break;
		case VK_F9://l2d shift is not dangerous
			_dangerous_code=!_dangerous_code;
			break;
		case VK_F10://last mode vs blank on idle
			showLastModeOnIdle=!showLastModeOnIdle;
			break;
		case VK_F11://fullscreen
			if(fullscreen)//exit fullscreen
			{
				SetWindowLongA(hWnd, GWL_STYLE, WS_CAPTION|WS_SYSMENU|WS_THICKFRAME|WS_MINIMIZEBOX|WS_MAXIMIZEBOX|WS_CLIPCHILDREN);
				SetWindowPos(hWnd, HWND_TOP, oldWindowSize.left, oldWindowSize.top, oldWindowSize.right-oldWindowSize.left, oldWindowSize.bottom-oldWindowSize.top, SWP_SHOWWINDOW);
			}
			else//enter fullscreen
			{
				GetWindowRect(ghWnd, &oldWindowSize);
				SetWindowLongA(hWnd, GWL_STYLE, WS_OVERLAPPED);
				SetWindowPos(hWnd, HWND_TOP, 0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN), SWP_SHOWWINDOW);
			}
			fullscreen=!fullscreen;
			break;
		case VK_CAPITAL:
			caps_lock=!caps_lock;
			return 0;
		case VK_NUMLOCK:
			num_lock=!num_lock;
			return 0;
		case VK_ADD:case VK_OEM_PLUS:
			if(!modes::active&&kb[VK_CONTROL])
			{
				double A=largerFont();
			//	double A=font.larger();
				if(A!=1)
				{
					itb.changeFont(A);
					render();
				}
				return 0;
			}
			break;
		case VK_SUBTRACT:case VK_OEM_MINUS:
			if(!modes::active&&kb[VK_CONTROL])
			{
				double A=smallerFont();
			//	double A=font.smaller();
				if(A!=1)
				{
					itb.changeFont(A);
					render();
				}
				return 0;
			}
			break;
		case '0':case VK_NUMPAD0:
			if(!modes::active&&kb[VK_CONTROL])
			{
				double A=setFont(3);
			//	double A=font.assign(3);
				if(A!=1)
				{
					itb.changeFont(A);
					render();
				}
				return 0;
			}
			break;
		}
		if(modes::active)
		{
			modes::mode->inputKeyDown(wParam, lParam);
			kb[wParam]=1;
		}
		else if(var_menu)
		{
			var_ui_keyDown(wParam, lParam);
			kb[wParam]=1;
		}
		else
		{
			kb[wParam]=1;
			int action=0;
			if(modes::nExpr[1]&&kb[VK_CONTROL]&&kb[VK_SHIFT]&&(wParam=='C'||wParam=='X'))
		//	if(modes::nExpr[1]&&kb[VK_CONTROL]&&!kb[VK_SHIFT]&&(wParam=='C'||wParam=='X'))
				action=copy_text_with_n0d_results(wParam);
			else
				action=itb.inputKeyDown(wParam, lParam);

			if(exprRemoveEnd<exprInsertEnd)
				expr.insert(expr.begin()+exprRemoveEnd, exprInsertEnd-exprRemoveEnd, Expression());
			else if(exprRemoveEnd>exprInsertEnd)
				expr.erase(expr.begin()+exprInsertEnd, expr.begin()+exprRemoveEnd);
			if(functionRemoveEnd<functionInsertEnd)
				userFunctionDefinitions.insert(userFunctionDefinitions.begin()+functionRemoveEnd, functionInsertEnd-functionRemoveEnd, Expression());
			else if(functionRemoveEnd>functionInsertEnd)
				userFunctionDefinitions.erase(userFunctionDefinitions.begin()+functionInsertEnd, userFunctionDefinitions.begin()+functionRemoveEnd);
		//	if(boundRemoveEnd<boundInsertEnd)
		//		expr.insert(expr.begin()+boundRemoveEnd, boundInsertEnd-boundRemoveEnd, Expression());
		//	else if(boundRemoveEnd>boundInsertEnd)
		//		expr.erase(expr.begin()+boundInsertEnd, expr.begin()+boundRemoveEnd);
		//	if(action==2&&(exprChangeStart<exprInsertEnd||functionChangeStart<functionInsertEnd))
			if(action==2&&boundChangeStart<boundInsertEnd)//new expressions/functions were inserted
			{
				itb.text=(char*)realloc(itb.text, (itb.textlen+1+10)*sizeof(char));
				memset(&itb.text[itb.textlen+1], ' ', 10*sizeof(char));
				auto text=itb.text;
				bool prec_changed=false;

				int kStart=boundChangeStart==0?0:bounds[boundChangeStart-1].first;
				int comment=0;//next comment
/*nobreak?*/	for(;comment!=allComments.size()&&allComments[comment].first<kStart;++comment);
				int lineNo=lineChangeStart=itb.getLineNo(0, 0, kStart);

				std::vector<UFVariableName> ufVarNames;
				std::stack<char> scopeLevel;//'{', 'f' for, '(' for(, ')' for()
				int forHeaderPLevel=0;//no alibi
			//	int forHeaderPLevel;
			//	int scopeLevel=0;
				
				user_trigered_seed();
				int e=exprChangeStart, function=functionChangeStart;
				for(int bound=boundChangeStart;bound<boundInsertEnd;++bound)//bound loop
			//	for(int bound=boundChangeStart, e=exprChangeStart, function=functionChangeStart;bound<boundInsertEnd;++bound)
				{
					int kStart=bound?bounds[bound-1].first:0, kEnd=bounds[bound].first;
					bool exprBound=bounds[bound].second=='e';
					int old_rmode;
					Expression *it;
					if(exprBound)
					{
						it=&expr[e];
						old_rmode=it->rmode[0];
						it->free();
						puis.clear();
					}
					else//user-defined function
					{
						it=&userFunctionDefinitions[function];
						*it=Expression();
					//	scopeLevel=0;
						ufVarNames.clear();

						//parse function header		correct header syntax checked by profiler
						bool unnamed=true;
						BoundCounter k(kStart, comment, itb.textlen);
						char match_oob=0;
#define					OOB_BIT		(match_oob&1)
#define					MATCH_BIT	(match_oob>>1)
						skip_whitespace(text, k, itb.textlen);//function header lexer
						int start=k.idx;
						match_oob=skip_identifier_ifmatch(text, k, itb.textlen);
						int end=k.idx;
						k.skip_comments(itb.textlen);//skip_identifier_ifmatch doesn't skip comments
						if(MATCH_BIT)
						{
							it->name_id=userFunctionNames.addName(text, start, end)->name_id;
							unnamed=false;
						}
						//TODO: else log error quiet (no messagebox)
						skip_whitespace(text, k, itb.textlen);
						match_oob=skip_char_ifmatch(text, k, itb.textlen, '(');
						//TODO: !match: quiet error
						char arg_separators[]="),";
						for(char notfirsttime=false;;notfirsttime=true)
						{
							if(skip_whitespace(text, k, itb.textlen))
								break;//unreachable

							char c_matched=0;
							arg_separators[1]=','&-notfirsttime;
							match_oob=skip_char_ifmatch(text, k, itb.textlen, arg_separators, &c_matched);//look for ',' or ')'
							char match=MATCH_BIT;
							if(match&&c_matched==')'||k.idx<itb.textlen&&text[k.idx]=='{')//end of function header
								break;
							//TODO: notfirsttime&&!match: quiet error

							if(skip_whitespace(text, k, itb.textlen))
								break;//unreachable

							int start1=k.idx;
							match_oob=skip_identifier_ifmatch(text, k, itb.textlen);//can be optional mathset indicator or obligatory argname
							int end1=k.idx;
							k.skip_comments(itb.textlen);

							if(skip_whitespace(text, k, itb.textlen))
								break;//unreachable

							int start2=k.idx;
							match_oob=skip_identifier_ifmatch(text, k, itb.textlen);
							int end2=k.idx;
							k.skip_comments(itb.textlen);
							if(MATCH_BIT)//mathset indicator & argname
							{
								char mathSet='R';
								switch(text[start1])
								{
								case 'r':case 'R':mathSet='R';break;
								case 'c':case 'C':mathSet='c';break;
								case 'h':case 'H':
								case 'q':case 'Q':mathSet='h';break;
								}
								ufVarNames.push_back(UFVariableName(text+start2, end2-start2, 0, it->data.size()));
								it->insertFVar(mathSet, ufVarNames.rbegin()->name);
								++it->nArgs;
							}
							else//just argname
							{
								ufVarNames.push_back(UFVariableName(text+start1, end1-start1, 0, it->data.size()));
								it->insertFVar('R', ufVarNames.rbegin()->name);
								++it->nArgs;
							}
						}
						skip_whitespace(text, k, itb.textlen);//k should now point at '{'
						kStart=k.idx;
#undef					OOB_BIT
#undef					MATCH_BIT
						comment=k.kc;
#if 0
						enum
						{
							HPS_LOOKING_FOR_FUNC_NAME='f',
							HPS_READING_ARG_NAMES='a',
							HPS_ARG_MATHSET='s',
						};
						char state=HPS_LOOKING_FOR_FUNC_NAME, mathSet='R';//'f' looking for function name, 'a' reading arg names, 's' arg mathSet specifier
						int i=-1, f=-1;
						for(int k=kStart, kcEnd=comment!=allComments.size()?allComments[comment].first:kEnd;k<kEnd;++k)//function header lexer
						{
							if(k>=kcEnd)//skip comments
							{
								lineNo=itb.getLineNo(allComments[comment].first, lineNo, allComments[comment].second);
								k=allComments[comment].second-1;
								++comment;
								kcEnd=comment!=allComments.size()?allComments[comment].first:itb.textlen;
								continue;
							}
							if(isLetter[text[k]])
							{
								for(int k2=(i=k)+1;;++k2)
								{
									if(!isAlphanumeric[text[k2]])
									{
										if(state==HPS_LOOKING_FOR_FUNC_NAME)
										{
											it->name_id=userFunctionNames.addName(text, i, k2)->name_id;
											unnamed=false;
										}
										else if(state==HPS_READING_ARG_NAMES||state==HPS_ARG_MATHSET)
										{
											f=k2;
											if(state!=HPS_ARG_MATHSET&&k2-i==1&&(text[i]=='r'||text[i]=='R'||text[i]=='c'||text[i]=='C'||text[i]=='h'||text[i]=='H'||text[i]=='q'||text[i]=='Q'))
											{
												switch(text[i])
												{
												case 'r':case 'R':mathSet='R';break;
												case 'c':case 'C':mathSet='c';break;
												case 'h':case 'H':
												case 'q':case 'Q':mathSet='h';break;
												}
												state=HPS_ARG_MATHSET;
											}
											else
											{
												ufVarNames.push_back(UFVariableName(text+i, f-i, 0, it->data.size()));
												it->insertFVar(mathSet, ufVarNames.rbegin()->name);
											//	it->insertData(mathSet, Value());
												++it->nArgs;
												state=HPS_READING_ARG_NAMES, mathSet='R';
											}
										}
										k=k2-1;
										break;
									}
								}
							}
							else if(text[k]=='(')
								state=HPS_READING_ARG_NAMES;
							else if(text[k]==',')
							{
								if(state==HPS_READING_ARG_NAMES)
									continue;
								else if(state==HPS_ARG_MATHSET)//not a specifier but a variable
								{
									ufVarNames.push_back(UFVariableName(text+i, f-i, 0, it->data.size()));
									it->insertFVar(mathSet, ufVarNames.rbegin()->name);
								//	it->insertData(mathSet, 0);
									continue;
								}
								else if(state==HPS_LOOKING_FOR_FUNC_NAME)//unreachable
									break;
							}
							else if(text[k]==')')//header end
							{
								for(++k;text[k]!='{';++k)
								{
									bool newline=text[k]=='\r';
									lineNo+=newline||text[k]=='\n', k+=newline&&text[k+1]=='\n';//robust
								}
								kStart=k;//definition lexing starts with { or CRASH
							//	kStart=k+1;
								break;
							}
							else if(text[k]=='{')//header end
							{
								kStart=k;
								break;
							}
							else if(text[k]!=' '&&text[k]!='\t')//unreachable
								break;
						}//function header lexer
#endif
						if(unnamed)
							it->name_id=-1;
					}//end else
					it->lineNo=lineNo, it->boundNo=bound;
					bool notForLoopHeaderScope=true;
					for(int k=kStart, kcEnd=comment!=allComments.size()?allComments[comment].first:kEnd;k<kEnd;++k)//lexer loop
					{
						if(k>=kcEnd)//skip comments
						{
							lineNo=itb.getLineNo(allComments[comment].first, lineNo, allComments[comment].second);
							k=allComments[comment].second-1;
							++comment;
							kcEnd=comment!=allComments.size()?allComments[comment].first:itb.textlen;
							continue;
						}
						{//user function call
							NameTreeNode* node=nullptr;
							int nameEnd;
							if(exprBound)
								node=userFunctionNames.matchName_free(text, k, kEnd, nameEnd);
							else//user function bound, get token call identifier
							{
								if((k-1<0||!isAlphanumeric[text[k-1]])&&isLetter[text[k]])
								{
									for(int f=k+1;f<=kEnd;++f)
									{
										if(!isAlphanumeric[text[f]])
										{
											node=userFunctionNames.matchName(text, k, f, nameEnd);
											break;
										}
									}
								}
							}
							if(node)
							{
								bool match=false;
								for(int d=0, dEnd=userFunctionDefinitions.size();d<dEnd;++d)
								{
									auto &definition=userFunctionDefinitions[d];
									if(definition.m.size()&&definition.m.rbegin()->pos>k)
										break;
									if(definition.name_id==node->name_id)
									{
										match=true;
										break;
									}
								}
								if(match)
								{
									it->insertMap(k, nameEnd-k, G2::M_USER_FUNCTION, node->name_id);
									k=nameEnd-1;
									continue;
								}
								else
									userFunctionNames.removeName(text, k, nameEnd);
							}
						}
						using namespace G2;
#if 1
#define	MATCH_KW(KEYWORD)				if(				match_kw(text+k+1, keywords	[KEYWORD]+1,	exprBound,	&advance)){it->insertMap	(k, sizeof(keywords	[KEYWORD]),			KEYWORD); k+=advance; continue;}
#define	MATCH_KW_ALT(ALT, KEYWORD)		if(				match_kw(text+k+1, ALT+1,					exprBound,	&advance)){it->insertMap	(k, sizeof(ALT),						KEYWORD); k+=advance; continue;}
#define	MATCH_CONST(KEYWORD, CONSTANT)	if(				match_kw(text+k+1, kw2		[KEYWORD]+1,	exprBound,	&advance)){it->insertMapData(k, sizeof(kw2		[KEYWORD]), 'R',	CONSTANT); k+=advance; continue;}
#define MATCH_UF(KEYWORD)				if(!exprBound&&	match_uf(text+k+1, keywords	[KEYWORD]+1,				&advance)){it->insertMap	(k, sizeof(keywords	[KEYWORD]),			KEYWORD); k+=advance; continue;}
						int advance=0;
						switch(text[k])
						{
						case '(':
							if(!exprBound)
							{
								auto &scope=scopeLevel.top();
								if(scope=='f')
									scope='(', forHeaderPLevel=1;
								else if(scope=='(')
									++forHeaderPLevel;
							}
							it->insertMap(k, 1, M_LPR);
							continue;
						case ')':
							if(!exprBound)
							{
								auto &scope=scopeLevel.top();
								if(scope=='(')
								{
									--forHeaderPLevel;
									if(!forHeaderPLevel)
										scope=')';
								}
							}
							it->insertMap(k, 1, M_RPR);
							continue;
						case '{':
							if(!exprBound)
							{
								if(!scopeLevel.size()||scopeLevel.top()=='{')
									scopeLevel.push('{');
								else
									scopeLevel.top()='{';
								it->insertMap(k, 1, M_LBRACE);
								continue;
							}
							continue;//exprBound
						case '}':
							if(!exprBound)
							{
								scopeLevel.pop();
								for(;scopeLevel.size()&&scopeLevel.top()==')';)
									scopeLevel.pop();
								if(ufVarNames.size())
								{
									int level=scopeLevel.size();
									for(int n=ufVarNames.size()-1;;--n)
									{
										if(n<0||ufVarNames[n].scopeLevel<=level)
										{
											ufVarNames.erase(ufVarNames.begin()+n+1, ufVarNames.end());
											break;
										}
									}
								}
								it->insertMap(k, 1, M_RBRACE);
								continue;
							}
							continue;//exprBound
						case ',':
							it->insertMap(k, 1, M_COMMA);
							continue;
						case ';':
							if(!exprBound)
							{
								auto &scope=scopeLevel.top();
								if(scope==')'||scope=='f')
								{
									scopeLevel.pop();
									for(;scopeLevel.size()&&scopeLevel.top()==')';)
										scopeLevel.pop();
									if(ufVarNames.size())
									{
										int level=scopeLevel.size();
										for(int n=ufVarNames.size()-1;;--n)
										{
											if(n<0||ufVarNames[n].scopeLevel<=level)
											{
												ufVarNames.erase(ufVarNames.begin()+n+1, ufVarNames.end());
												break;
											}
										}
									}
								}
								it->insertMap(k, 1, M_SEMICOLON);
								continue;
							}
							continue;//exprBound
						//	break;
						case '0'://hex/oct
							if((text[k+1]=='x'||text[k+1]=='X')&&(isHexadecimal[text[k+2]]||text[k+2]=='.'))//hexadecimal
							{
								bool number=false;
								for(int k2=k+2;k2<=itb.textlen;++k2)
								{
									if(isHexadecimal[text[k2]])
										number=true;
									else if(text[k2]!='.'&&(!commasInNumbers||text[k2]!=','))
									{
										if(number&&(exprBound||!isAlphanumeric[text[k2]]))
										{
											bool E_notation=(text[k2]=='p'||text[k2]=='P'||text[k2]=='e'||text[k2]=='E')//p notation	c99, java5
												&&(isHexadecimal[text[k2+1]]||text[k2+1]=='.'
													||(text[k2+1]=='+'||text[k2+1]=='-')&&(isHexadecimal[text[k2+2]]||text[k2+2]=='.'));
											if(!E_notation)
												for(;text[k2-1]==',';--k2);

											int bin_prec=(k2-(k+2))<<2;
											if(bin_prec>MP::bin_prec)
												MP::set_prec(bin_prec, 2), prec_changed=true;
											char temp=text[k2];
											text[k2]='\0';
											MP::Real val(text+k+2, MP::bin_prec, 16);
											text[k2]=temp;
											if(E_notation)
											{
												int sign=text[k2+1]=='-'?-1:1;
												bool number=false;
												for(int k3=k2+1+(text[k2+1]=='+'||text[k2+1]=='-'), k4=k3;k4<=itb.textlen;++k4)
												{
													if(isHexadecimal[text[k4]])
														number=true;
													else if(text[k4]!='.')
													{
														if(number)
														{
															double p=1;
															for(int k5=k3;k5<k4;++k5)
															{
																if(text[k5]=='.')
																{
																	for(int k6=k5+1;k6<k4;++k6)
																		if(text[k6]!='.')
																			p/=10;
																		//	p/=16;
																	break;
																}
															}
															double val2=0;
															for(int k5=k4-1;k5>=k3;--k5)
															{
																if(text[k5]!='.')
																{
																	switch(text[k5])
																	{
																	case '0':						break;
																	case '1':			val2+=   p;	break;
																	case '2':			val2+= 2*p;	break;
																	case '3':			val2+= 3*p;	break;
																	case '4':			val2+= 4*p;	break;
																	case '5':			val2+= 5*p;	break;
																	case '6':			val2+= 6*p;	break;
																	case '7':			val2+= 7*p;	break;
																	case '8':			val2+= 8*p;	break;
																	case '9':			val2+= 9*p;	break;
																	//case 'a':case 'A':	val2+=10*p;	break;
																	//case 'b':case 'B':	val2+=11*p;	break;
																	//case 'c':case 'C':	val2+=12*p;	break;
																	//case 'd':case 'D':	val2+=13*p;	break;
																	//case 'e':case 'E':	val2+=14*p;	break;
																	//case 'f':case 'F':	val2+=15*p;	break;
																	default:						continue;
																	}
																	p*=10;
																//	p*=16;
																}
															}
														//	const double logBase=G2::_ln2;//power of 2		c99
															val*=pow(MP::Real(2), MP::Real(sign*val2));
														//	val*=std::exp(sign*val2*logBase);
															k2=k4;
														}
														break;
													}
												}
											}
											it->insertMapData(k, k2-k, val);
										//	it->insertMapData(k, k2-k, 'R', val);
										//	it->insertMapData('R', val);
										//	it->insertData('R', val);
											k=k2-1;
										}
										break;
									}
								}
								continue;
							}
							else if(text[k+1]>='0'&&text[k+1]<='7')
							{
								for(int k2=k+2;k2<=itb.textlen;++k2)
								{
									//if(text[k2]=='8'||text[k2]=='9')//default to decimal
									//	break;
									if((text[k2]<'0'||text[k2]>'7')&&text[k2]!='.'&&(!commasInNumbers||text[k2]!=','))//octal
									{
										if(exprBound||!isAlphanumeric[text[k2]])
										{
											bool E_notation=(text[k2]=='e'||text[k2]=='E'||text[k2]=='p'||text[k2]=='P')
												&&(text[k2+1]>='0'&&text[k2+1]<='9'||text[k2+1]=='.'
													||(text[k2+1]=='+'||text[k2+1]=='-')&&(text[k2+2]>='0'&&text[k2+2]<='9'||text[k2+2]=='.'));
												//&&(text[k2+1]>='0'&&text[k2+1]<='7'||text[k2+1]=='.'
												//	||(text[k2+1]=='+'||text[k2+1]=='-')&&(text[k2+2]>='0'&&text[k2+2]<='7'||text[k2+2]=='.'));
											if(!E_notation)
												for(;text[k2-1]==',';--k2);

											int bin_prec=(k2-(k+1))*3;
											if(bin_prec>MP::bin_prec)
												MP::set_prec(bin_prec, 2), prec_changed=true;
											char temp=text[k2];
											text[k2]='\0';
											MP::Real val(text+k+1, MP::bin_prec, 8);
											text[k2]=temp;
											//double p=1;
											//for(int k4=k+1;k4<k2;++k4)
											//{
											//	if(text[k4]=='.')
											//	{
											//		for(int k5=k4+1;k5<k2;++k5)
											//			if(text[k5]>='0'&&text[k5]<='7')
											//				p/=8;
											//		break;
											//	}
											//}
											//double val=0;
											//for(int k4=k2-1;k4>=k+1;--k4)
											//	if(text[k4]>='0'&&text[k4]<='7')
											//		val+=(text[k4]-'0')*p, p*=8;
											if(E_notation)
											{
												int sign=text[k2+1]=='-'?-1:1;
											//	int sign=text[k2+1]=='-'?-1:1;
												bool number=false;
												for(int k3=k2+1+(text[k2+1]=='+'||text[k2+1]=='-'), k4=k3;k4<=itb.textlen;++k4)
												{
													if(text[k4]>='0'&&text[k4]<='9')
												//	if(text[k4]>='0'&&text[k4]<='7')
														number=true;
													else if(text[k4]!='.')
													{
														if(number)
														{
															double p=1;
															for(int k5=k3;k5<k4;++k5)
															{
																if(text[k5]=='.')
																{
																	for(int k6=k5+1;k6<k4;++k6)
																		if(text[k6]!='.')
																			p/=10;
																		//	p/=8;
																	break;
																}
															}
															double val2=0;
															for(int k5=k4-1;k5>=k3;--k5)
																if(text[k5]!='.')
																	val2+=(text[k5]-'0')*p, p*=10;
																//	val2+=(text[k5]-'0')*p, p*=8;
														//	const double logBase=G2::_ln2;
														//	const double logBase=std::log(8.);
															val*=pow(MP::Real(2), MP::Real(sign*val2));
														//	val*=std::exp(sign*val2*logBase);
															k2=k4;
														}
														break;
													}
												}
											}
											it->insertMapData(k, k2-k, val);
										//	it->insertMapData(k, k2-k, 'R', val);
										//	it->insertMapData('R', val);
										//	it->insertData('R', val);
											k=k2-1;
										}
										break;
									}
								}
								continue;
							}
						case '1':case '2':case '3':case '4':case '5':case '6':case '7':case '8':case '9':case '.'://decimal
							{
								bool number=false;
								for(int k2=k;k2<=itb.textlen;++k2)//k: number start, k2: mantissa end
								{
									if(text[k2]>='0'&&text[k2]<='9')
										number=true;
									else if(text[k2]!='.'&&(!commasInNumbers||text[k2]!=','))
									{
										if(number&&(exprBound||!isAlphanumeric[text[k2]]))
										{
											bool E_notation=(text[k2]=='e'||text[k2]=='E')
												&&(text[k2+1]>='0'&&text[k2+1]<='9'||text[k2+1]=='.'
													||(text[k2+1]=='+'||text[k2+1]=='-')&&(text[k2+2]>='0'&&text[k2+2]<='9'||text[k2+2]=='.'));
											if(!E_notation)
												for(;text[k2-1]==',';--k2);

											const double ln10_ln2=G2::_ln10/G2::_ln2;
											int bin_prec=int((k2-(k+2)+2)*ln10_ln2);//+2 reserve digits
											if(bin_prec>MP::bin_prec)
												MP::set_prec(bin_prec, 2), prec_changed=true;
											char temp=text[k2];
											text[k2]='\0';
											MP::Real val(text+k, MP::bin_prec, 10);
											text[k2]=temp;
											//double p=1;
											//for(int k4=k;k4<k2;++k4)
											//{
											//	if(text[k4]=='.')
											//	{
											//		for(int k5=k4+1;k5<k2;++k5)
											//			if(text[k5]>='0'&&text[k5]<='9')
											//				p/=10;
											//		break;
											//	}
											//}
											//double val=0;
											//for(int k4=k2-1;k4>=k;--k4)
											//	if(text[k4]>='0'&&text[k4]<='9')
											//		val+=(text[k4]-'0')*p, p*=10;
											if(E_notation)
											{
												int sign=text[k2+1]=='-'?-1:1;
												number=false;
												for(int k3=k2+1+(text[k2+1]=='+'||text[k2+1]=='-'), k4=k3;k4<=itb.textlen;++k4)//k3: exp start, k4: exp end
												{
													if(text[k4]>='0'&&text[k4]<='9')
														number=true;
													else if(text[k4]!='.')
													{
														if(number)
														{
															double p=1;
															for(int k5=k3;k5<k4;++k5)
															{
																if(text[k5]=='.')
																{
																	for(int k6=k5+1;k6<k4;++k6)
																		if(text[k6]!='.')
																			p/=10;
																	break;
																}
															}
															double val2=0;
															for(int k5=k4-1;k5>=k3;--k5)
																if(text[k5]!='.')
																	val2+=(text[k5]-'0')*p, p*=10;
															val*=pow(MP::Real(10), MP::Real(sign*val2));
														//	const double logBase=G2::_ln10;
														//	val*=std::exp(sign*val2*logBase);
															k2=k4;
														}
														break;
													}
												}
											}
											it->decimals.push_back(Expression::IdxStr(it->data.size(), std::string(text+k, text+k2)));
											it->insertMapData(k, k2-k, val);
										//	it->insertMapData(k, k2-k, 'R', val);
										//	it->insertMapData('R', val);
										//	it->insertData('R', val);
											k=k2-1;
										}
										break;
									}
								}
							}
							continue;
						case '_':
								 MATCH_CONST(L_ATM, _atm)
							else MATCH_CONST(L_BBR, _bbr)
							else MATCH_CONST(L_C, _c)
							else MATCH_CONST(L_ELE, _ele)
							else if(match_kw(text+k+1, kw2[L_E]+1, exprBound, &advance))
							{
								it->insertMapEuler(k, sizeof(kw2[L_E]));
								k+=advance;
								continue;
							}
							else MATCH_CONST(L_g, _g)
							else MATCH_CONST(L_G, _G)
							else MATCH_CONST(L_H, _h)
							else MATCH_CONST(L_MAG, _mag)
							else MATCH_CONST(L_ME, _Me)
							else MATCH_CONST(L_me, _me)
							else MATCH_CONST(L_MN, _mn)
							else MATCH_CONST(L_MP, _mp)
							else MATCH_CONST(L_MS, _Ms)
							else MATCH_CONST(L_NA, _Na)
							else MATCH_CONST(L_PHI, _phi)
							else MATCH_CONST(L_PI, _pi)
							else MATCH_CONST(L_Q, _q)
							else MATCH_CONST(L_RAND, (double)rand()/RAND_MAX)
							else MATCH_CONST(L_R, _R)
							break;
						case 'i':
							if(!exprBound&&match_uf(text+k+1, keywords[M_IF]+1, &advance))
							{
								it->insertMap(k, sizeof(keywords[M_IF]), M_IF);
								k+=advance;
								continue;
							}
							else MATCH_KW(M_IMAG)
							else MATCH_CONST(L_IND, _qnan)
							else MATCH_CONST(L_INF, _HUGE)
							else MATCH_KW(M_INVMOD)
							else MATCH_KW(M_INVSQRT)
							else MATCH_KW(M_ISPRIME)
							else if(match_kw(text+k+1, kw2[L_I]+1, exprBound, &advance))
							{
								it->insertMapData(k, sizeof(kw2[L_I]), 'c', 0, 1);
								k+=advance;
								continue;
							}
							break;
						case 'I':
								 MATCH_KW(M_IMAG)
							else MATCH_CONST(L_IND, _qnan)
							else MATCH_CONST(L_INF, _HUGE)
							else MATCH_KW(M_INVMOD)
							else MATCH_KW(M_INVSQRT)
							else MATCH_KW(M_ISPRIME)
							else if(match_kw(text+k+1, kw2[L_I]+1, exprBound, &advance))
							{
								it->insertMapData(k, sizeof(kw2[L_I]), 'c', 0, 1);
								k+=advance;
								continue;
							}
							break;
						case 'j':
							if(exprBound||!isAlphanumeric[text[k+1]])
							{
								it->insertMapData(k, 1, 'h', 0, 0, 1);
								continue;
							}
							break;
						case 'J':
							MATCH_KW(M_BESSEL_J)
							break;
						case 'k':
							if(exprBound||!isAlphanumeric[text[k+1]])
							{
								it->insertMapData(k, 1, 'h', 0, 0, 0, 1);
								continue;
							}
							break;
						case 'x':
							if(exprBound)
							{
								it->insertRVar(k, 1, &text[k], 's');
								continue;
							}
							break;
						case 'y':
							if(exprBound)
							{
								it->insertRVar(k, 1, &text[k], 's');
								continue;
							}
							break;
						case 'Y':
							MATCH_KW(M_BESSEL_Y)
							break;
						case 'z':
								 MATCH_KW(M_ZETA)
							else if(exprBound)
							{
								it->insertRVar(k, 1, &text[k], 's');
								continue;
							}
							break;
						case 'Z':
								 MATCH_KW(M_ZETA)
							else if(exprBound)
							{
								it->insertCVar(k, 1, &text[k]);
								continue;
							}
							break;
						case '\'':
							if(exprBound)
							{
								bool hit=false;
								for(int k2=k+1;k2<=itb.textlen;++k2)
								{
									if(!isAlphanumeric[text[k2]])
									{
										it->insertRVar(k+1, k2-(k+1), &text[k+1], 's');
									//	it->insertRVar(&text[k+1], k2-(k+1), 's');
										k=text[k2]=='\''?k2:k2-1;
										hit=true;
										break;
									}
								}
								if(hit)
									continue;
							}
							break;
						case 'Q':
							if(exprBound)
							{
								it->insertHVar(k, 1, &text[k]);
								continue;
							}
							break;
						case '+':
								 MATCH_UF(M_ASSIGN_PLUS)//uf
							else MATCH_UF(M_INCREMENT)//uf
							else MATCH_KW(M_PLUS)
							break;
						case '-':
								 MATCH_UF(M_ASSIGN_MINUS)//uf
							else MATCH_UF(M_DECREMENT)//uf
							else MATCH_KW(M_MINUS)
							break;
						case '*':
								 MATCH_KW(M_POWER_REAL)
							else MATCH_UF(M_ASSIGN_MULTIPLY)//uf
							else MATCH_KW(M_MULTIPLY)
							break;
						case '/':
								 MATCH_UF(M_ASSIGN_DIVIDE)//uf
							else MATCH_KW(M_DIVIDE)
							break;
						case '%':
								 MATCH_UF(M_ASSIGN_MOD)//uf
							else MATCH_KW(M_MODULO_PERCENT)
							break;
						case '@':
							MATCH_KW(M_LOGIC_DIVIDES);
							break;
						case '^':
								 MATCH_KW(M_PENTATE)
							else MATCH_KW(M_TETRATE)
							else MATCH_KW(M_BITWISE_XNOR)
							else MATCH_KW(M_POWER)
							break;
						case '!':
								 MATCH_KW(M_LOGIC_NOT_EQUAL)
							else MATCH_KW(M_FACTORIAL_LOGIC_NOT)
							break;
						case '~':
								 MATCH_KW(M_BITWISE_NAND)
							else MATCH_KW(M_BITWISE_XNOR)
							else MATCH_KW(M_BITWISE_NOR)
							else MATCH_KW(M_BITWISE_NOT)
							break;
						case '&':
								 MATCH_KW(M_LOGIC_AND)
							else MATCH_KW(M_BITWISE_NOR)
							else MATCH_KW(M_ASSIGN_AND)
							else MATCH_KW(M_BITWISE_AND)
							break;
						case '#':
								 MATCH_KW(M_LOGIC_XOR)
							else MATCH_KW(M_BITWISE_XNOR)
							else MATCH_KW(M_ASSIGN_XOR)
							else MATCH_KW(M_BITWISE_XOR)
							break;
						case '|':
								 MATCH_KW(M_LOGIC_OR)
							else MATCH_KW(M_BITWISE_NAND)
							else MATCH_KW(M_ASSIGN_OR)
							else MATCH_KW(M_VERTICAL_BAR)
							break;
						case '<':
								 MATCH_KW(M_ASSIGN_LEFT)
							else MATCH_KW(M_BITWISE_SHIFT_LEFT)
							else MATCH_KW(M_LOGIC_LESS_EQUAL)
							else MATCH_KW(M_LOGIC_LESS)
							break;
						case '>':
								 MATCH_KW(M_ASSIGN_RIGHT)
							else MATCH_KW(M_BITWISE_SHIFT_RIGHT)
							else MATCH_KW(M_LOGIC_GREATER_EQUAL)
							else MATCH_KW(M_LOGIC_GREATER)
							break;
						case '=':
								 MATCH_KW(M_ASSIGN_RIGHT)
							else MATCH_KW(M_BITWISE_SHIFT_RIGHT)
							else MATCH_KW(M_LOGIC_GREATER_EQUAL)
							else MATCH_KW(M_LOGIC_GREATER)
							break;
						case '?':
								 MATCH_KW(M_CONDITION_ZERO)
							else MATCH_KW(M_QUESTION_MARK)
							break;
						case ':':
							MATCH_KW(M_COLON)
							break;
						case 'a':case 'A':
								 MATCH_KW(M_ABS)
							else MATCH_KW_ALT("ach", M_ACOSH)
							else MATCH_KW_ALT("acosecd", M_ACSCD)
							else MATCH_KW_ALT("acosech", M_ACSCH)
							else MATCH_KW_ALT("acosec", M_ACSC)
							else MATCH_KW(M_ACOSD)
							else MATCH_KW(M_ACOSH)
							else MATCH_KW(M_ACOS)
							else MATCH_KW(M_ACOTD)
							else MATCH_KW(M_ACOTH)
							else MATCH_KW(M_ACOT)
							else MATCH_KW(M_ACSCH)
							else MATCH_KW(M_ACSC)
							else MATCH_KW(M_ARG)
							else MATCH_KW(M_ASECH)
							else MATCH_KW(M_ASEC)
							else MATCH_KW_ALT("ash", M_ASEC)
							else MATCH_KW(M_ASIND)
							else MATCH_KW(M_ASINH)
							else MATCH_KW(M_ASIN)
							else MATCH_KW(M_ATAND)
							else MATCH_KW(M_ATANH)
							else MATCH_KW(M_ATAN)
							else MATCH_KW_ALT("ath", M_ATANH)
							else MATCH_KW(M_AV)
							break;
						case 'b':
								 MATCH_KW_ALT("bessel", M_BESSEL_J)
							else MATCH_KW(M_BETA)
							else MATCH_UF(M_BREAK)
							else if(text[k+1]=='0'||text[k+1]=='1'||text[k+1]=='.')//binary
							{
								bool number=false;
								for(int k2=k+1;k2<=itb.textlen;++k2)
								{
									if(text[k2]>='2'&&text[k2]<='9')//default to decimal
										break;
									if(text[k2]=='0'||text[k2]=='1')
										number=true;
									else if(text[k2]!='.'&&(!commasInNumbers||text[k2]!=','))
									{
										if(number&&(exprBound||!isAlphanumeric[text[k+3]]))
										{
											bool E_notation=(text[k2]=='e'||text[k2]=='E'||text[k2]=='p'||text[k2]=='P')
												&&(text[k2+1]>='0'&&text[k2+1]<='1'||text[k2+1]=='.'
													||(text[k2+1]=='+'||text[k2+1]=='-')&&(text[k2+2]>='0'&&text[k2+2]<='1'||text[k2+2]=='.'));
											if(!E_notation)
												for(;text[k2-1]==',';--k2);

											int bin_prec=k2-(k+2);
											if(bin_prec>MP::bin_prec)
												MP::set_prec(bin_prec, 2), prec_changed=true;
											char temp=text[k2];
											text[k2]='\0';
											MP::Real val(text+k+1, MP::bin_prec, 2);
											text[k2]=temp;
											//double p=1;
											//for(int k4=k+1;k4<k2;++k4)
											//{
											//	if(text[k4]=='.')
											//	{
											//		for(int k5=k4+1;k5<k2;++k5)
											//			if(text[k5]>='0'&&text[k5]<='1')
											//				p/=2;
											//		break;
											//	}
											//}
											//double val=0;
											//for(int k4=k2-1;k4>=k+1;--k4)
											//	if(text[k4]>='0'&&text[k4]<='1')
											//		val+=(text[k4]-'0')*p, p*=2;
											if(E_notation)
											{
												int sign=text[k2+1]=='-'?-1:1;
												number=false;
												for(int k3=k2+1+(text[k2+1]=='+'||text[k2+1]=='-'), k4=k3;k4<=itb.textlen;++k4)
												{
													if(text[k4]>='0'&&text[k4]<='9')
												//	if(text[k4]>='0'&&text[k4]<='1')
														number=true;
													else if(text[k4]!='.')
													{
														if(number)
														{
															double p=1;
															for(int k5=k3;k5<k4;++k5)
															{
																if(text[k5]=='.')
																{
																	for(int k6=k5+1;k6<k4;++k6)
																		if(text[k6]!='.')
																			p/=10;
																		//	p/=2;
																	break;
																}
															}
															double val2=0;
															for(int k5=k4-1;k5>=k3;--k5)
																if(text[k5]!='.')
																	val2+=(text[k5]-'0')*p, p*=10;
																//	val2+=(text[k5]-'0')*p, p*=2;
															val*=pow(MP::Real(2), MP::Real(sign*val2));
															//const double logBase=G2::_ln2;
															//val*=std::exp(sign*val2*logBase);
															k2=k4;
														}
														break;
													}
												}
											}
											it->insertMapData(k, k2-k, val);
										//	it->insertMapData(k, k2-k, 'R', val);
										//	it->insertMapData('R', val);
										//	it->insertData('R', val);
											k=k2-1;
										}
										break;
									}
								}
								continue;
							}
							break;
						case 'B':
								 MATCH_KW_ALT("bessel", M_BESSEL_J)
							else MATCH_KW(M_BETA)
							else MATCH_UF(M_BREAK)
							else if(text[k+1]=='0'||text[k+1]=='1'||text[k+1]=='.')//binary
							{
								bool number=false;
								for(int k2=k+1;k2<=itb.textlen;++k2)
								{
									if(text[k2]>='2'&&text[k2]<='9')//default to decimal
										break;
									if(text[k2]=='0'||text[k2]=='1')
										number=true;
									else if(text[k2]!='.'&&(!commasInNumbers||text[k2]!=','))
									{
										if(number&&(exprBound||!isAlphanumeric[text[k+3]]))
										{
											bool E_notation=(text[k2]=='e'||text[k2]=='E'||text[k2]=='p'||text[k2]=='P')
												&&(text[k2+1]>='0'&&text[k2+1]<='1'||text[k2+1]=='.'
													||(text[k2+1]=='+'||text[k2+1]=='-')&&(text[k2+2]>='0'&&text[k2+2]<='1'||text[k2+2]=='.'));
											if(!E_notation)
												for(;text[k2-1]==',';--k2);

											int bin_prec=k2-(k+2);
											if(bin_prec>MP::bin_prec)
												MP::set_prec(bin_prec, 2), prec_changed=true;
											char temp=text[k2];
											text[k2]='\0';
											MP::Real val(text+k+1, MP::bin_prec, 2);
											text[k2]=temp;
											//double p=1;
											//for(int k4=k+1;k4<k2;++k4)
											//{
											//	if(text[k4]=='.')
											//	{
											//		for(int k5=k4+1;k5<k2;++k5)
											//			if(text[k5]>='0'&&text[k5]<='1')
											//				p/=2;
											//		break;
											//	}
											//}
											//double val=0;
											//for(int k4=k2-1;k4>=k+1;--k4)
											//	if(text[k4]>='0'&&text[k4]<='1')
											//		val+=(text[k4]-'0')*p, p*=2;
											if(E_notation)
											{
												int sign=text[k2+1]=='-'?-1:1;
												number=false;
												for(int k3=k2+1+(text[k2+1]=='+'||text[k2+1]=='-'), k4=k3;k4<=itb.textlen;++k4)
												{
													if(text[k4]>='0'&&text[k4]<='9')
												//	if(text[k4]>='0'&&text[k4]<='1')
														number=true;
													else if(text[k4]!='.')
													{
														if(number)
														{
															double p=1;
															for(int k5=k3;k5<k4;++k5)
															{
																if(text[k5]=='.')
																{
																	for(int k6=k5+1;k6<k4;++k6)
																		if(text[k6]!='.')
																			p/=10;
																		//	p/=2;
																	break;
																}
															}
															double val2=0;
															for(int k5=k4-1;k5>=k3;--k5)
																if(text[k5]!='.')
																	val2+=(text[k5]-'0')*p, p*=10;
																//	val2+=(text[k5]-'0')*p, p*=2;
															val*=pow(MP::Real(2), MP::Real(sign*val2));
															//const double logBase=G2::_ln2;
															//val*=std::exp(sign*val2*logBase);
															k2=k4;
														}
														break;
													}
												}
											}
											it->insertMapData(k, k2-k, val);
										//	it->insertMapData(k, k2-k, 'R', val);
										//	it->insertMapData('R', val);
										//	it->insertData('R', val);
											k=k2-1;
										}
										break;
									}
								}
								continue;
							}
							break;
						case 'c':
								 MATCH_KW(M_CARTESIAN)
							else MATCH_KW(M_CBRT)
							else MATCH_KW(M_CEIL)
							else MATCH_KW_ALT("ch", M_COSH)
							else MATCH_KW(M_CLAMP)
							else MATCH_KW(M_COMBINATION)
							else MATCH_UF(M_CONTINUE)//uf
							else MATCH_KW(M_CONJUGATE)
							else MATCH_KW_ALT("cosc", M_CSC)
							else MATCH_KW_ALT("cosech", M_CSCH)
							else MATCH_KW_ALT("cosec", M_CSC)
							else MATCH_KW(M_COSD)
							else MATCH_KW(M_COSH)
							else MATCH_KW(M_COS)
							else MATCH_KW(M_COTD)
							else MATCH_KW(M_COTH)
							else MATCH_KW(M_COT)
							else MATCH_KW(M_CSCD)
							else MATCH_KW(M_CSCH)
							else MATCH_KW(M_CSC)
							break;
						case 'C':
								 MATCH_KW(M_CARTESIAN)
							else MATCH_KW(M_CBRT)
							else MATCH_KW(M_CEIL)
							else MATCH_KW_ALT("ch", M_COSH)
							else MATCH_KW(M_CLAMP)
							else MATCH_KW(M_COMBINATION)
							else MATCH_KW(M_CONJUGATE)
							else MATCH_KW_ALT("cosc", M_CSC)
							else MATCH_KW_ALT("cosech", M_CSCH)
							else MATCH_KW_ALT("cosec", M_CSC)
							else MATCH_KW(M_COSD)
							else MATCH_KW(M_COSH)
							else MATCH_KW(M_COS)
							else MATCH_KW(M_COTD)
							else MATCH_KW(M_COTH)
							else MATCH_KW(M_COT)
							else MATCH_KW(M_CSCD)
							else MATCH_KW(M_CSCH)
							else MATCH_KW(M_CSC)
							break;
						case 'd':
							MATCH_UF(M_DO)
							break;
						case 'e':
								 MATCH_UF(M_ELSE)
							else MATCH_KW(M_ERF)
							else MATCH_KW(M_EXP)
							else if(exprBound||!isAlphanumeric[text[k+1]])
							{
								it->insertMapEuler(k, 1);
								continue;
							}
							break;
						case 'E':
								 MATCH_KW(M_ERF)
							else MATCH_KW(M_EXP)
							else if(exprBound||!isAlphanumeric[text[k+1]])
							{
								it->insertMapEuler(k, 1);
								continue;
							}
							break;
						case 'f':
								 MATCH_KW(M_FIB)
							else MATCH_CONST(L_FALSE, 0)
							else MATCH_KW(M_FLOOR)
							else if(!exprBound&&match_uf(text+k+1, keywords[M_FOR]+1, &advance))//uf
							{
								auto &scope=scopeLevel.top();
								if(scope=='{'||scope==')')
									scopeLevel.push('f');
								it->insertMap(k, 3, M_FOR);
								k+=2;
								continue;
							}
							else MATCH_KW(M_FRAC)
							break;
						case 'F':
								 MATCH_KW(M_FIB)
							else MATCH_KW(M_FLOOR)
							else MATCH_KW(M_FRAC)
							break;
						case 'g':case 'G':
								 MATCH_KW(M_GAMMA)
							else MATCH_KW(M_GAUSS)
							else MATCH_KW(M_GCD)
							break;
						case 'h':case 'H':
								 MATCH_KW(M_HANKEL1)
							else MATCH_KW(M_HYPOT)
							break;
						case 'l':case 'L':
								 MATCH_KW(M_LNGAMMA)
							else MATCH_KW(M_LN)
							else MATCH_KW(M_LOG)
							break;
						case 'm':case 'M':
								 MATCH_KW_ALT("mag", M_ABS)
							else MATCH_KW(M_MANDELBROT)
							else MATCH_KW(M_MIN)
							break;
						case 'n':case 'N':
								 MATCH_CONST(L_NAN, _qnan)
							else MATCH_KW(M_BESSEL_Y)
							else MATCH_KW(M_NORM)
							break;
						case 'p':case 'P':
								 MATCH_KW(M_PERMUTATION)
							else if(match_kw(text+k+1, kw2[L_PI]+2,	exprBound, &advance))
							{
								it->insertMapPi(k, 2);
								k+=advance;
								continue;
							}
							else MATCH_KW(M_NORM)
							break;
						case 'r':
								 MATCH_KW(M_RAND)
							else MATCH_KW(M_RECT)
							else MATCH_UF(M_RETURN)//uf
							else MATCH_KW(M_REAL)
							else MATCH_KW(M_ROUND)
							break;
						case 'R':
								 MATCH_KW(M_RAND)
							else MATCH_KW(M_RECT)
							else MATCH_KW(M_REAL)
							else MATCH_KW(M_ROUND)
							break;
						case 's':case 'S':
								 MATCH_KW(M_SAW)
							else MATCH_KW(M_SECD)
							else MATCH_KW(M_SECH)
							else MATCH_KW(M_SEC)
							else MATCH_KW(M_SGN)
							else MATCH_KW_ALT("sh", M_SINH)
							else MATCH_KW(M_SINC)
							else MATCH_KW(M_SIND)
							else MATCH_KW(M_SINHC)
							else MATCH_KW(M_SINH)
							else MATCH_KW(M_SIN)
							else MATCH_KW(M_SQRT)
							else MATCH_KW(M_SQWV)
							else MATCH_KW(M_SQ)
							else MATCH_KW(M_STEP)
							break;
						case 't':case 'T':
								 MATCH_KW(M_TANC)
								 MATCH_KW(M_TAND)
							else MATCH_KW(M_TANH)
							else MATCH_KW(M_TAN)
							else MATCH_KW(M_TENT)
							else MATCH_KW_ALT("th", M_TANH)
							else MATCH_KW(M_TOTIENT)
							else MATCH_KW(M_TENT)
							else MATCH_CONST(L_TRUE, 1)
							else MATCH_KW(M_TRWV)
							else if(exprBound)
							{
								it->insertRVar(k, 1, &text[k], 't');
								continue;
							}
							break;
						case 'w':
								 MATCH_KW_ALT("weber", M_BESSEL_Y)
							else MATCH_UF(M_WHILE)
							break;
						case 'W':
								 MATCH_KW_ALT("weber", M_BESSEL_Y)
							else if(exprBound)
							{
								it->insertCVar(k, 5, &text[k]);
								continue;
							}
							break;
						case '\r':
							k+=text[k+1]=='\n';
							++lineNo;
							continue;
						case '\n'://robust	unix/mac
							++lineNo;
							continue;
						}
#endif
					}//end lexer loop
					it->endLineNo=lineNo-((bound==0?0:bounds[bound-1].first)<kEnd&&text[kEnd-1]=='\n');
					if(exprBound)
					{
						auto &map=it->m;
						if(map.size())
						{
							using namespace G2;
							{
								int min=0, end=0;
								for(unsigned k=0;k<map.size();++k)
								{
									if(map[k]._0==M_LPR)
										++end;
									else if(map[k]._0==M_RPR)
									{
										--end;
										if(min>end)
											min=end;
									}
								}
								if(min<0)
								{
									int pos=map[0].pos;
									int inc=-min;
									map.resize(map.size()+inc);
									for(int k=map.size()-1;k>=inc;--k)
										map[k]=map[k-inc];
									for(int k=0;k<inc;++k)
										map[k]=::Map(pos, 0, M_LPR);
									//	map[k]=::Map(M_LPR);
								}
								if(end-min>0)
								{
									int pos=map.rbegin()->pos+map.rbegin()->len;
									int inc=end-min;
									map.resize(map.size()+inc);
									for(unsigned k=map.size()-inc;k<map.size();++k)
										map[k]=::Map(pos, 0, M_RPR);
									//	map[k]=::Map(M_RPR);
								}
							}
						}
						if(map.size())
						{
							Compile::compile_expression_global(*it);
						//	expression_to_clipboard(*it, true);//MP instructions
						//	expression_to_clipboard(*it);//
							it->resultLogicType=Compile::expressionResultLogicType();
							if(it->resultLogicType>=2&&it->i.rbegin()->has_nonreal_args())
								it->resultLogicType=1;
							if(!it->n.size())//no expression
								it->rmode[0]=0;
							else
							{
								it->resultMathSet=Compile::predictedMathSet;
								switch(it->nISD)
								{
								case 0://numeric 0d
									{
										it->rmode[0]=1;
										modes::n0d.toSolve=true, modes::n0d.solver.reset();
										auto &n=it->n[it->resultTerm];
										n.r.push_back(it->data[it->resultTerm].r.toDouble());
										if(it->resultMathSet>='c')
										{
											n.i.push_back(it->data[it->resultTerm].i.toDouble());
											if(it->resultMathSet=='h')
											{
												n.j.push_back(it->data[it->resultTerm].j.toDouble());
												n.k.push_back(it->data[it->resultTerm].k.toDouble());
											}
										}
										it->setColor_random();
									}
									break;
								case 1:
									if(it->i.size()&&it->resultLogicType)//transverse implicit 1d	//bool expr
									{
										it->rmode[0]=10;
										modes::ti1d.toSolve=true, modes::ti1d.shiftOnly=0, modes::ti1d.solver.reset();
										modes::ti1d.ready=false;
										it->setColor_random();
									}
									else
									{
										switch(Compile::predictedMathSet)
										{
										case 'R'://transverse 1d
											it->rmode[0]=2;
											modes::t1d.toSolve=true, modes::t1d.shiftOnly=0, modes::t1d.solver.reset();
											modes::t1d.ready=false;
											it->setColor_random();
											break;
										case 'c'://transverse 1d complex
											it->rmode[0]=3;
											modes::t1d_c.toSolve=true, modes::t1d_c.shiftOnly=0, modes::t1d_c.solver.reset();
											modes::t1d_c.ready=false;
											it->setColor_random();
											break;
										case 'h'://transverse 1d quaternion
											it->rmode[0]=4;
											it->rmode.push_back(0);
											modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0, modes::t1d_h.solver.reset();
											modes::t1d_h.ready=false;
											it->setColor_black();
											break;
										}
									}
									break;
								case 2:
									if(it->i.size()&&it->resultLogicType)//transverse implicit 2d
									{
										it->rmode[0]=11;
										modes::ti2d.toSolve=true, modes::ti2d.shiftOnly=0, modes::ti2d.solver.reset();
										modes::ti2d.ready=false;
										it->setColor_random();
									}
									else
									{
										switch(Compile::predictedMathSet)
										{
										case 'R'://transverse 2d
											it->rmode[0]=5;
											modes::t2d.toSolve=true, modes::t2d.shiftOnly=0, modes::t2d.solver.reset();
											modes::t2d.ready=false;
											it->setColor_random();
											break;
										case 'c':
											if(it->nZ==1)//longitudinal 2d
											{
												it->rmode[0]=7;
												modes::l2d.toSolve=true, modes::l2d.shiftOnly=0, modes::l2d.solver.reset();
												modes::l2d.ready=false;
												it->setColor_random();
											}
											else//color 2d
											{
												it->rmode[0]=6;
												it->rmode.push_back(0);
												modes::c2d.toSolve=true, modes::c2d.shiftOnly=0, modes::c2d.solver.reset();
												modes::c2d.ready=false;
												it->setColor_black();
											}
											break;
										case 'h'://transverse 2d quaternion
											it->rmode[0]=8;
											it->rmode.push_back(0);
											modes::t2d_h.toSolve=true, modes::t2d_h.shiftOnly=0, modes::t2d_h.solver.reset();
											modes::t2d_h.ready=false;
											it->setColor_black();
											break;
										}
									}
									break;
								case 3://color 3d
#if 0
									if(it->i.size()&&it->resultLogicType)
									{
										it->rmode[0]=9;
										it->rmode.push_back(0);
										modes::c3d.toSolve=true, modes::c3d.shiftOnly=0, modes::c3d.solver.reset();
										modes::c3d.ready=false;
										it->setColor_black();
									}
									else
#endif
									{
										it->rmode[0]=9;
										it->rmode.push_back(0);
										modes::c3d.toSolve=true, modes::c3d.shiftOnly=0, modes::c3d.solver.reset();
										modes::c3d.ready=false;
										it->setColor_random();//
									//	it->setColor_black();
									}
									break;
								}
							}
						}
						switch(old_rmode)//all modes showing multiple expressions except n0d
						{
						case  2:modes::t1d	.exprRemoved|=it->rmode[0]!=old_rmode;	break;
						case  3:modes::t1d_c.exprRemoved|=it->rmode[0]!=old_rmode;	break;
						case  5:modes::t2d	.exprRemoved|=it->rmode[0]!=old_rmode;	break;
						case  7:modes::l2d	.exprRemoved|=it->rmode[0]!=old_rmode;	break;
						case 10:modes::ti1d	.exprRemoved|=it->rmode[0]!=old_rmode;	break;
						case 11:modes::ti2d	.exprRemoved|=it->rmode[0]!=old_rmode;	break;
						}
						++e;
					}
					else//user function
					{
					//	map_to_clipboard(it->m);//
						Compile::compile_function(*it);
						it->resultMathSet=Compile::predictedMathSet;
					//	expression_to_clipboard(*it, true);//MP instructions
					//	expression_to_clipboard(*it);//
						++function;
					}
				}//end bound loop
				std::fill(modes::nExpr.begin(), modes::nExpr.end(), 0);
				for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)
				{
					auto &ex=expr[ke];
					++modes::nExpr[ex.rmode[0]];
				}
				if(modes::nExpr[1]&&prec_changed)//there are n0d expressions & precision changed
					modes::n0d.reassign_constants();

				int lineChange=lineInsertEnd-lineRemoveEnd;
				for(int b=boundInsertEnd, bEnd=bounds.size();b<bEnd;++b)
				{
					auto &bound=bounds[b];
					if(bound.second=='e')
						expr[e].lineNo+=lineChange, expr[e].endLineNo+=lineChange, ++e;
					else if(bound.second=='f')
						userFunctionDefinitions[function].lineNo+=lineChange, userFunctionDefinitions[function].endLineNo+=lineChange, ++function;
				}

				itb.text=(char*)realloc(itb.text, (itb.textlen+1)*sizeof(char));
				lineChangeStart=lineRemoveEnd=lineInsertEnd=0;
				boundChangeStart=boundRemoveEnd=boundInsertEnd=0;
				exprChangeStart=exprRemoveEnd=exprInsertEnd=0;
				functionChangeStart=functionRemoveEnd=functionInsertEnd=0;
			}
			if(action)
				render();
		}
	//	set_window_title("CTRL=%d, SHIFT=%d, C=%d", (int)kb[VK_CONTROL], (int)kb[VK_SHIFT], (int)kb['C']);//
		if(message==WM_SYSKEYDOWN)
			break;
		return 0;
	case WM_KEYUP:
	case WM_SYSKEYUP:
		if(modes::active)
			modes::mode->inputKeyUp(wParam);
		kb[wParam]=0;
	//	set_window_title("CTRL=%d, SHIFT=%d, C=%d", (int)kb[VK_CONTROL], (int)kb[VK_SHIFT], (int)kb['C']);//
		return 0;
	case WM_CLOSE:PostQuitMessage(0);
		return 0;
	}
	return DefWindowProcA(hWnd, message, wParam, lParam);
}
//#include"g2_resources.h"//
//#include"g2_file.h"//
int			__stdcall WinMain(HINSTANCE hInstance, HINSTANCE, char*, int nCmdShow)
{
	ghInstance=hInstance;
	
	//	int common_size=0;
	//	const char *rc_common=loadresource(IDR_CL_COMMON, TEXTFILE, common_size);
	//	std::string common(rc_common, rc_common+common_size);//

	//anything depending on G2::_pi is initialized here
	modes::t1d_c._3d.set(4, 4, 4, 225*G2::_pi/180, 324.7356103172454*G2::_pi/180, 1);
	modes::t2d	._3d.set(4, 4, 4, 225*G2::_pi/180, 324.7356103172454*G2::_pi/180, 1);
	modes::t2d_h._3d.set(4, 4, 4, 225*G2::_pi/180, 324.7356103172454*G2::_pi/180, 1);
	modes::c3d	._3d.set(20, 20, 20, 225*G2::_pi/180, 324.7356103172454*G2::_pi/180, 1);
#if DEFAULT_PREC!=53
	MP::set_prec(MP::bin_prec, 2);
#endif

	tagWNDCLASSEXA wndClassEx={sizeof(tagWNDCLASSEXA), CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS, WndProc, 0, 0, hInstance, LoadIconA(0, (char*)0x00007F00), LoadCursorA(0, (char*)0x00007F00), nullptr, 0, "New format", 0};
	//tagWNDCLASSEXA wndClassEx={sizeof(tagWNDCLASSEXA), CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS, WndProc, 0, 0, hInstance, LoadIconA(0, (char*)0x00007F00), LoadCursorA(0, (char*)0x00007F00), (HBRUSH__*)(COLOR_WINDOW+1), 0, "New format", 0};
	RegisterClassExA(&wndClassEx);
	ghWnd=CreateWindowExA(0, wndClassEx.lpszClassName, "", WS_CAPTION|WS_SYSMENU|WS_THICKFRAME|WS_MINIMIZEBOX|WS_MAXIMIZEBOX|WS_CLIPCHILDREN, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, 0, 0, hInstance, 0);
	{//check for CPU features
		int registers[4]={0};
		cpuid(registers, 0);//function IDs
		unsigned max_eax=registers[0];
		if(max_eax>=1)
		{
			cpuid(registers, 1);
			unsigned ecx=registers[2], edx=registers[3];
			bool has_fpu		=(edx&(1<< 0))!=0;
			bool has_mmx		=(edx&(1<<23))!=0;
			bool has_sse		=(edx&(1<<25))!=0;
			bool has_sse2		=(edx&(1<<26))!=0;
			bool has_sse3		=(ecx&(1<< 0))!=0;
			bool has_ssse3		=(ecx&(1<< 9))!=0;
			bool has_sse4_1		=(ecx&(1<<19))!=0;
#ifndef		__GCC_SUCKS__
			SSE4_1=has_sse4_1;
#endif
			bool has_sse4_2		=(ecx&(1<<20))!=0;
			bool has_pclmulqdq	=(ecx&(1<< 1))!=0;
			bool has_avx		=(ecx&(1<<28))!=0;
#ifdef AVX_H
			avx_supported=has_avx;
#endif
			bool has_aes_ni		=(ecx&(1<<25))!=0;
			supported_simd_arch=has_mmx+has_sse+has_sse2+has_sse3+has_ssse3+has_sse4_1+has_sse4_2+has_avx;
			if(max_eax>=7)//extract x86 extended flags
			{
				cpuidex(registers, 7, 0);
				unsigned ebx=registers[1];
				bool has_avx2=(ebx&(1<<5))!=0;
				supported_simd_arch+=has_avx2;
			}
#ifdef AVX_H
			if(avx_supported)
				avx_initialize();
#endif
			max_simd_method=simd_method=(supported_simd_arch>=ARCH_SSE3S)
#ifdef AVX_H
				+(supported_simd_arch>=ARCH_AVX)
#endif
				;
		//	vectorsize=1+(supported_simd_arch>=ARCH_SSE3S)+((supported_simd_arch>=ARCH_AVX)<<1);
			char a[64];
			const int rsize=sizeof(registers);
			cpuid(registers, 0x80000002), memcpy(a, registers, rsize);
			cpuid(registers, 0x80000003), memcpy(a+16, registers, rsize);
			cpuid(registers, 0x80000004), memcpy(a+32, registers, rsize);
			CPUBrand.assign(a, 48);
		}
	}
	{//command args: [-h <height>] [-w <width>] [-benchmark]
		int width=0, height=0;
		bool set_width=false, set_height=false;
		char *cmd=GetCommandLineA();
		auto readint=[](char *a, int &k, int &value)->bool
		{
			for(int k2=k;;++k2)
			{
				if(a[k2]<'0'||a[k2]>'9')
				{
					if(k2>k)
					{
						value=0;
						for(int k3=k2-1, p=1;k3>=k;--k3, p*=10)
							value+=p*(a[k3]-'0');
						k=k2-1;
						return true;
					}
					break;
				}
			}
			return false;
		};
		for(int k=0;cmd[k];++k)
		{
			if(cmd[k]=='.'&&cmd[k+1]=='e'&&cmd[k+2]=='x'&&cmd[k+3]=='e')
			{
				for(k+=4;cmd[k];++k)
				{
					if(cmd[k]=='-')
					{
						if(cmd[k+1]=='b'&&cmd[k+2]=='e'&&cmd[k+3]=='n'&&cmd[k+4]=='c'&&cmd[k+5]=='h'&&cmd[k+6]=='m'&&cmd[k+7]=='a'&&cmd[k+8]=='r'&&cmd[k+9]=='k')
							showBenchmark=true, k+=9;
						else if(cmd[k+1]=='h')
						{
							for(k+=2;cmd[k];++k)
							{
								if(cmd[k]!=' ')
								{
									set_height=readint(cmd, k, height);//client height
									break;
								}
							}
						}
						else if(cmd[k+1]=='w')
						{
							for(k+=2;cmd[k];++k)
							{
								if(cmd[k]!=' ')
								{
									set_width=readint(cmd, k, width);//client width
									break;
								}
							}
						}
					}
				}
				break;
			}
		}
		if(set_width||set_height)
		{
			RECT window, client, area;
			GetWindowRect(ghWnd, &window);//window (client+border) position in screen & dimensions
			GetClientRect(ghWnd, &client);//client (inner) dimensions
			SystemParametersInfoA(SPI_GETWORKAREA, 0, &area, 0);
			int wleft, wwidth, wtop, wheight;//new window position & dimensions
			int w0width=window.right-window.left;
			int w0height=window.bottom-window.top;
			if(set_width)
			{
				wwidth=width+w0width-(client.right-client.left);
				if(wwidth>area.right)//if new size is larger than screen, clip to screen
					wleft=0, wwidth=area.right;
				else if(wwidth<w0width)//if new size is smaller than original size, align right/bottom
					wleft=window.right-wwidth;
				else//if new size >= original size, same position
					wleft=window.left;
			}
			else
				wleft=window.left, wwidth=w0width;
			if(set_height)
			{
				wheight=height+w0height-(client.bottom-client.top);
				if(wheight>area.bottom)
					wtop=0, wheight=area.bottom;
				else if(wheight<w0height)
					wtop=window.bottom-wheight;
				else
					wtop=window.top;
			}
			else
				wtop=window.top, wheight=w0height;
			SetWindowPos(ghWnd, HWND_TOP, wleft, wtop, wwidth, wheight, 0);
		}
	}
	ShowWindow(ghWnd, nCmdShow);
	tagMSG msg;
	
		Performance();//

		GetClientRect(ghWnd, &R);
		h=R.bottom-R.top, w=R.right-R.left, centerP.x=w/2, centerP.y=h/2;
		ClientToScreen(ghWnd, &centerP);
		ghDC=GetDC(ghWnd);
		initiate();
	//	ghDC=GetDC(ghWnd), ghMemDC=CreateCompatibleDC(ghDC);
		gBitmap.set(w, h);
		gBitmap.use();
		//tagBITMAPINFO bmpInfo={{sizeof(tagBITMAPINFOHEADER), w, -h, 1, 32, BI_RGB, 0, 0, 0, 0, 0}};
		//ghBitmap=(HBITMAP__*)SelectObject(ghMemDC, CreateDIBSection(0, &bmpInfo, DIB_RGB_COLORS, (void**)&rgb, 0, 0));
		modeRGB=(int*)realloc(modeRGB, w*h*sizeof(int));
	//	font.createFonts();
		itb.setDimensions(0, 0, w, h);

	while(GetMessageA(&msg, 0, 0, 0)>0)TranslateMessage(&msg), DispatchMessageA(&msg);

		gBitmap.drop(), gBitmap.finish();
		finish();
		ReleaseDC(ghWnd, ghDC);
	//	DeleteObject(SelectObject(ghMemDC, ghBitmap)), DeleteDC(ghMemDC), ReleaseDC(ghWnd, ghDC);

	return msg.wParam;
}
void		render()
{
		newframe();
	//	memset(rgb, 0xFF, w*h*sizeof(int));
	
	int inputTextBkMode=OPAQUE;
	if(expr.size()||userFunctionDefinitions.size())//
	{
		static bool toResume=false;

		cursorB=0, cursorEx=0;
		for(int bEnd=bounds.size()-1;cursorB<bEnd&&bounds[cursorB].first<=itb.cursor;++cursorB)
			cursorEx+=bounds[cursorB].second=='e';

		if(bounds[cursorB].second=='e')//exression bound
	//	if(bounds[cursorB].second&1)//expression or clear
		{
			auto &ex=expr[cursorEx];
			switch(ex.rmode[0])//current mode
			{
			case 0://no expression
				modes::ready=false;
				if(showLastModeOnIdle)
				{
					if(modes::mode&&!modes::mode->paused)
						modes::mode->pause();
				}
				else
					modes::mode=nullptr, modes::paint=modes::paint_0;
				std::fill(modes::nExpr.begin(), modes::nExpr.end(), 0);//crappy code
				for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)
				{
					auto &ex=expr[ke];
					++modes::nExpr[ex.rmode[0]];
				}
				break;
			case 1://numeric 0d
				modes::ready=true;
				modes::mode=&modes::n0d, modes::paint=modes::paint_n0d;
				modes::n0d.toPrint=true;
				break;
			case 2://transverse 1d
				modes::ready=true;
				modes::mode=&modes::t1d, modes::paint=modes::paint_t1d;
				break;
			case 3://transverse 1d complex
				modes::ready=true;
				modes::mode=&modes::t1d_c, modes::paint=modes::paint_t1d_c;
				if(modes::mode!=modes::old_mode)
					modes::t1d.ready=false;
				break;
			case 4://transverse 1d quaternion
				modes::ready=true;
				modes::mode=&modes::t1d_h, modes::paint=modes::paint_t1d_h;
				if(cursorEx!=prevCursorEx||!ex.n[ex.resultTerm].r.size())
					modes::t1d_h.toSolve=true, modes::t1d_h.shiftOnly=0;
				break;
			case 5://transverse 2d
				modes::ready=true;
				modes::mode=&modes::t2d, modes::paint=modes::paint_t2d;
				break;
			case 6://color 2d
				modes::ready=true;
				modes::mode=&modes::c2d, modes::paint=modes::paint_c2d;
				if(cursorEx!=prevCursorEx||!ex.n[ex.resultTerm].r.size())
					modes::c2d.toSolve=true, modes::c2d.shiftOnly=0;
				break;
			case 7://longitudinal 2d
				modes::ready=true;
				modes::mode=&modes::l2d, modes::paint=modes::paint_l2d;
				break;
			case 8://transverse 2d quaternion
				modes::ready=true;
				modes::mode=&modes::t2d_h, modes::paint=modes::paint_t2d_h;
				if(cursorEx!=prevCursorEx||usingOpenGL!=MODE_CL_GL_INTEROP&&!ex.n[ex.resultTerm].r.size())
					modes::t2d_h.toSolve=true, modes::t2d_h.shiftOnly=0;
				break;
			case 9://color 3d
				modes::ready=true;
				modes::mode=&modes::c3d, modes::paint=modes::paint_c3d;
				if(cursorEx!=prevCursorEx||usingOpenGL!=MODE_CL_GL_INTEROP&&!ex.n[ex.resultTerm].r.size())
					modes::c3d.toSolve=true, modes::c3d.shiftOnly=0;
				break;
			case 10://transverse implicit 1d
				modes::ready=true;
				modes::mode=&modes::ti1d, modes::paint=modes::paint_ti1d;
				break;
			case 11://transverse implicit 2d
				modes::ready=true;
				modes::mode=&modes::ti2d, modes::paint=modes::paint_ti2d;
				break;
			}
		}
		else//cursor in user function
		{
			modes::ready=false;
			if(showLastModeOnIdle)
			{
				if(modes::mode&&!modes::mode->paused)
					modes::mode->pause();
			}
			else
				modes::mode=nullptr, modes::paint=modes::paint_0;
			std::fill(modes::nExpr.begin(), modes::nExpr.end(), 0);//crappy code
			for(int ke=0, keEnd=expr.size();ke<keEnd;++ke)
			{
				auto &ex=expr[ke];
				++modes::nExpr[ex.rmode[0]];
			}
		}
		if(modes::mode!=modes::old_mode)
		{
			if(modes::old_mode)
			{
				if(modes::mode&&(modes::mode->bw!=modes::old_mode->bw||modes::mode->bh!=modes::old_mode->bh))//up, esc, resize, esc, down CRASH
					modes::mode->setDimensions(0, 0, w, h);//
				modes::old_mode->pause();
			}
			if(modes::mode)
				modes::mode->resume();
			modes::old_mode=modes::mode;//
		}
		if(modes::ready)
		{
			if(modes::mode->paused)
				modes::mode->resume();
			if(!modes::mode->ready)
				modes::mode->setDimensions(0, 0, w, h);
			modes::mode->i_draw();
		}
		else if(showLastModeOnIdle&&modes::mode!=nullptr)//
			modes::mode->i_draw();//
		prevCursorEx=cursorEx;
#ifdef BUILD_1_7
		if(bounds[cursorB].second&1&&var_menu)
		{
			auto &ex=expr[cursorEx];
			bool start_anew=!puis.size()||cursorEx!=var_menu_idx;
			if(var_menu_idx!=cursorEx)
				puis.clear(), var_menu_idx=cursorEx;
			if(ex.nx+ex.nZ+ex.nQ)
			{
				dim_screen();
				//switch(simd_method)
				//{
				//case 0://ia32
				//	for(int k=0, kEnd=w*h;k<kEnd;++k)
				//	{
				//		auto p=(unsigned char*)(rgb+k);
				//		rgb[k]=~rgb[k];
				//		p[0]>>=1, p[1]>>=1, p[2]>>=1;
				//		rgb[k]=~rgb[k];
				//	}
				//	break;
				//case 1://sse2
				//	lighten_sse2(rgb, w*h);
				//	break;
				//case 2://avx2 required, won't compile on VS2010
				//	lighten_sse2(rgb, w*h);
				//	break;
				//}
				int vui_h_2=vui_height>>1;
				for(int kv=0, kp=0, kvEnd=ex.variables.size();kv<kvEnd;++kv, ++kp)
				{
					auto &var=ex.variables[kv];
					int y=h-(vui_h_2+kp*vui_height);
					draw_var_ui(ex, kv, 0, kp, start_anew, y);
					if(var.mathSet>='c')
					{
						++kp, y=h-(vui_h_2+kp*vui_height);
						draw_var_ui(ex, kv, 1, kp, start_anew, y);
						if(var.mathSet=='h')
						{
							++kp, y=h-(vui_h_2+kp*vui_height);
							draw_var_ui(ex, kv, 2, kp, start_anew, y);
							++kp, y=h-(vui_h_2+kp*vui_height);
							draw_var_ui(ex, kv, 3, kp, start_anew, y);
						}
					}
				}
			}
		}
#endif
	}
	if(!modes::ready)
	{
		selectFont();
	//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
		{
			int bkMode=setBkMode(inputTextBkMode);//TRANSPARENT
		//	int bkMode=GetBkMode(ghMemDC);
		//	SetBkMode(ghMemDC, inputTextBkMode);//TRANSPARENT
			itb.draw();
			setBkMode(bkMode);
		//	SetBkMode(ghMemDC, bkMode);
		}
		deselectFont();
	//	font.hFont=(HFONT__*)SelectObject(ghMemDC, font.hFont);
	
#ifndef BUILD_1_7
		BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
#endif
	}
	if(contextHelp)
	{
		if(var_menu)
		{
			const char *help[]=
			{
				"number +/-: increment/decrement Nth parameter",
				"    (starting from 1)",
				"number 0: reset Nth parameter",
				"number enter: enter value for Nth parameter",
				"number space: select type of Nth parameter",
				"number S: select scale type for Nth parameter",
				"wheel: zoom",
				"Ctrl wheel: scroll",
				"F2/right click: close parameter menu"
			};
			print_contextHelp(help, sizeof(help)>>2, 315);
		}
		else
		{
			const char *help[]=
			{
				"Esc: interactive mode",
				"F1: context help",
				"F2/right click: parameter menu",
				"F7: toggle benchmark",
				"Ctrl F7: switch SIMD method",
				"Alt F7: copy debug info to clipboard",
				"F10: toggle show last mode on idle",
				"F11: fullscreen",
				"Ctrl +/-/wheel: change font size",
				"Ctrl 0: reset font size",
				"Ctrl up/down: scroll",
				"Ctrl C/X: copy/cut text",
				"Ctrl Shift C/X: copy/cut text with results",
				"Ctrl V: paste text",
				"F4: About Grapher 2"
			};
			print_contextHelp(help, sizeof(help)>>2, 256);
		}
	}
#ifdef BUILD_1_7
	show();
//	BitBlt(ghDC, 0, 0, w, h, ghMemDC, 0, 0, SRCCOPY);
	report_error();
#endif
}